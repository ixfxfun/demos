{"version":3,"file":"visual.js","names":["canvasElementContextOrQuery: CanvasContextQuery","ctxOrCanvasEl: CanvasContextQuery","canvasBounds?: Rects.Rect","pathsToDraw: Paths.Path[] | readonly Paths.Path[]","opts?: DrawingOpts","lineToDraw: Lines.Line | Lines.Line[]","rectsToDraw: Rects.Rect | Rects.Rect[] | Rects.RectPositioned | Rects.RectPositioned[]","opts?: RectOpts","bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier","pointsToDraw: Points.Point[]","opts?: DrawingOpts & Partial<ConnectedPointsOptions>","dotPosition: Points.Point | Points.Point[]","opts?: DotOpts","circlesToDraw: Circles.CirclePositioned | Circles.CirclePositioned[]","opts: DrawingOpts","circle","arcsToDraw: Arcs.ArcPositioned | Arcs.ArcPositioned[]","lines: string[]","opts: DrawingOpts & {\n        anchor: Points.Point;\n        anchorPadding?: number;\n        bounds?: Rects.RectPositioned;\n      }","applyOpts","ctx: CanvasRenderingContext2D","arcs: Arcs.ArcPositioned | readonly Arcs.ArcPositioned[]","arc: Arcs.ArcPositioned","arc","arcsArray: Arcs.ArcPositioned[]","strokeStyle: string | CanvasGradient | CanvasPattern | undefined","fillStyle: string | CanvasGradient | CanvasPattern | undefined","lineWidth: number | undefined","lineJoin: CanvasLineJoin | undefined","lineCap: CanvasLineCap | undefined","stk?: IStackImmutable<StackOp>","circlesToDraw: Circles.CirclePositioned | readonly Circles.CirclePositioned[]","c: Circles.CirclePositioned","pathsToDraw: readonly Paths.Path[] | Paths.Path","opts: { readonly strokeStyle?: string; readonly debug?: boolean }","path: Paths.Path","pts: readonly Points.Point[]","opts: Partial<ConnectedPointsOptions>","opts: { readonly fillStyle?: string }","labels?: readonly string[]","pos: Points.Point | (Points.Point | Circles.CirclePositioned)[] | Circles.CirclePositioned","pos","bezierToDraw: Beziers.CubicBezier","bezierToDraw: Beziers.QuadraticBezier","toDraw: Lines.Line | readonly Lines.Line[]","opts: LineOpts & DrawingOpts","d: Lines.Line","toDraw: Rects.Rect | Rects.Rect[] | Rects.RectPositioned | Rects.RectPositioned[]","opts: RectOpts","d: Rects.RectPositioned | Rects.Rect","lines: readonly string[]","opts: DrawingOpts & {\n    readonly anchor: Points.Point;\n    readonly align?: `top` | `center`\n    readonly anchorPadding?: number;\n    readonly bounds?: Rects.RectPositioned;\n  }","line","withOpacity","value: T","fn: (opacityScalar: number, value: T) => number","fromHexString","hexString: string","fromLibrary","fromCssAbsolute","value: string","options: ParsingOptions<HslAbsolute>","fromCssScalar","toScalar","toCssString","hsl: Hsl","toAbsolute","hsl: C.HSL","parsingOptions: ParsingOptions<HslAbsolute>","guard","generateScalar","absoluteHslOrVariable: string | number | Angle","colour: string","withOpacity","value: T","fn: (opacityScalar: number, value: T) => number","fromHexString","hexString: string","fromLibrary","srgbTansparent: Rgb8Bit","value: string","options: ParsingOptions<Rgb8Bit>","toCssString","rgb: Rgb","guard","rgb: C.RGB","toScalar","image: ImageData","fn: Grids.GridCellAccessor<Rgb8Bit>","cell: Grids.GridCell","fn: Grids.GridCellSetter<Rgb>","value: Rgb","col: Rgb8Bit[]","domQueryOrEl: Readonly<string | HTMLCanvasElement | undefined | null>","opts: Partial<CanvasHelperOptions>","#scaler","#scalerSize","#init","#logicalSize","reason?: string","#disposed","#resizer","#ctx","#drawHelper","#getContext","logicalSize: Rect","#handleEvents","resizerOptions: ElementSizerOptions<HTMLCanvasElement>","event: PointerEvent","colour?: string","#viewport","grid","elem: SVGElement","opts: DrawingOpts","parent: SVGElement","type: string","queryOrExisting?: string | V","suffix?: string","existing:SVGElement|HTMLElement|null","v: any","colour: any","convert","colour: string","destination: 'hex' | 'hsl' | 'oklab' | 'oklch' | 'srgb' | `rgb`","guard","colour: Colour","colourish: any","c: Colour | undefined","elem: SVGElement","opts: StrokeOpts","elem: SVGCircleElement","circle: CirclePositioned","opts?: CircleDrawingOpts","circle","parent: SVGElement","queryOrExisting?: string | SVGCircleElement","elOrQuery: HTMLElement | string","options: Opts","event: PointerEvent","el","fallbacks?: ReadonlyArray<string>","#store","#aliases","#elementBase","el: Element","key: string","colour: string","from: string","to: string","fallback?: string","#lastFallback","index: number","rand: RandomSource","multiplyOpacity","colourish: string","amount: number","colourish: Colourish","fn: (scalarOpacity: number) => number","result: Colour | undefined","guard","lch: OkLch","lch: C.LCH","parsingOptions: ParsingOptions<OkLchAbsolute>","hexString: string","oklchTransparent: OkLchAbsolute","value: string","options: ParsingOptions<OkLchAbsolute>","absoluteHslOrVariable: string | number | Angle","sourceVideoEl: HTMLVideoElement","opts: FramesOpts","c: CanvasRenderingContext2D | null","opts: CaptureOpts","worker: Worker | undefined","pixels: ImageData | undefined","opts: ManualCaptureOpts","capture","c: CanvasRenderingContext2D | undefined | null","c","c: ManualCapturer"],"sources":["../packages/visual/src/drawing.ts","../packages/visual/src/colour/hsl.ts","../packages/visual/src/colour/css-colours.ts","../packages/visual/src/colour/srgb.ts","../packages/visual/src/image-data-grid.ts","../packages/visual/src/canvas-helper.ts","../packages/visual/src/svg/apply.ts","../packages/visual/src/svg/create.ts","../packages/visual/src/colour/types.ts","../packages/visual/src/colour/conversion.ts","../packages/visual/src/svg/stroke.ts","../packages/visual/src/svg/elements.ts","../packages/visual/src/pointer-visualise.ts","../packages/visual/src/named-colour-palette.ts","../packages/visual/src/colour/generate.ts","../packages/visual/src/colour/math.ts","../packages/visual/src/colour/oklch.ts","../packages/visual/src/colour/index.ts","../packages/visual/src/video.ts","../packages/visual/src/index.ts"],"sourcesContent":["import { arrayTest, resultThrow } from '@ixfx/guards';\nimport { Colour } from '@ixfx/visual';\nimport { resolveEl } from '@ixfx/dom';\n//import type { IStackImmutable } from '@ixfx/collections';\nimport { StackImmutable, type IStackImmutable } from '@ixfx/collections/stack';\nimport { Beziers, Lines, Points, Rects, Triangles, type Arcs, type Circles, type Ellipses, type Paths } from '@ixfx/geometry';\nimport { quantiseEvery } from '@ixfx/numbers';\n\n// import type { Point } from '../geometry/point/PointType.js';\n// import type { Line } from '../geometry/line/LineType.js';\n// import type { CirclePositioned } from '../geometry/circle/CircleType.js';\n// import type { Rect, RectPositioned } from '../geometry/rect/index.js';\n// import type { Path } from '../geometry/path/PathType.js';\n// import type { Triangle } from '../geometry/triangle/TriangleType.js';\n\n// import { Empty as RectsEmpty } from '../geometry/rect/Empty.js';\n// import { corners as RectsCorners } from '../geometry/rect/Corners.js';\n// import { isLine } from '../geometry/line/Guard.js';\n// import { quantiseEvery } from '../numbers/Quantise.js';\n\nconst PIPI = Math.PI * 2;\n\nexport type CanvasContextQuery =\n  | null\n  | string\n  | CanvasRenderingContext2D\n  | HTMLCanvasElement;\n\n/**\n * Gets a 2d drawing context from canvas element or query, or throws an error\n * @param canvasElementContextOrQuery Canvas element reference or DOM query\n * @returns Drawing context.\n */\nexport const getContext = (\n  canvasElementContextOrQuery: CanvasContextQuery\n): CanvasRenderingContext2D => {\n  if (canvasElementContextOrQuery === null) {\n    throw new Error(\n      `canvasElCtxOrQuery null. Must be a 2d drawing context or Canvas element`\n    );\n  }\n  if (canvasElementContextOrQuery === undefined) {\n    throw new Error(\n      `canvasElCtxOrQuery undefined. Must be a 2d drawing context or Canvas element`\n    );\n  }\n\n  const ctx =\n    canvasElementContextOrQuery instanceof CanvasRenderingContext2D\n      ? canvasElementContextOrQuery\n      : canvasElementContextOrQuery instanceof HTMLCanvasElement\n        ? canvasElementContextOrQuery.getContext(`2d`)\n\n        : typeof canvasElementContextOrQuery === `string`\n          ? resolveEl<HTMLCanvasElement>(canvasElementContextOrQuery).getContext(`2d`)\n          : canvasElementContextOrQuery;\n  if (ctx === null) throw new Error(`Could not create 2d context for canvas`);\n  return ctx;\n};\n\nexport type DrawingHelper = ReturnType<typeof makeHelper>\n/**\n * Makes a helper object that wraps together a bunch of drawing functions that all use the same drawing context\n * @param ctxOrCanvasEl Drawing context or canvs element reference\n * @param canvasBounds Bounds of drawing (optional). Used for limiting `textBlock`\n * @returns\n */\nexport const makeHelper = (\n  ctxOrCanvasEl: CanvasContextQuery,\n  canvasBounds?: Rects.Rect\n) => {\n  const ctx = getContext(ctxOrCanvasEl);\n  return {\n    ctx,\n    paths(pathsToDraw: Paths.Path[] | readonly Paths.Path[], opts?: DrawingOpts): void {\n      paths(ctx, pathsToDraw, opts);\n    },\n    line(lineToDraw: Lines.Line | Lines.Line[], opts?: DrawingOpts): void {\n      line(ctx, lineToDraw, opts);\n    },\n    rect(\n      rectsToDraw: Rects.Rect | Rects.Rect[] | Rects.RectPositioned | Rects.RectPositioned[],\n      opts?: RectOpts\n    ): void {\n      rect(ctx, rectsToDraw, opts);\n    },\n    bezier(\n      bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier,\n      opts?: DrawingOpts\n    ): void {\n      bezier(ctx, bezierToDraw, opts);\n    },\n    connectedPoints(\n      pointsToDraw: Points.Point[],\n      opts?: DrawingOpts & Partial<ConnectedPointsOptions>\n    ): void {\n      connectedPoints(ctx, pointsToDraw, opts);\n    },\n    pointLabels(pointsToDraw: Points.Point[], opts?: DrawingOpts): void {\n      pointLabels(ctx, pointsToDraw, opts);\n    },\n    dot(\n      dotPosition: Points.Point | Points.Point[],\n      opts?: DotOpts\n    ): void {\n      dot(ctx, dotPosition, opts);\n    },\n    circle(\n      circlesToDraw: Circles.CirclePositioned | Circles.CirclePositioned[],\n      opts: DrawingOpts\n    ): void {\n      circle(ctx, circlesToDraw, opts);\n    },\n    arc(\n      arcsToDraw: Arcs.ArcPositioned | Arcs.ArcPositioned[],\n      opts: DrawingOpts\n    ): void {\n      arc(ctx, arcsToDraw, opts);\n    },\n    textBlock(\n      lines: string[],\n      opts: DrawingOpts & {\n        anchor: Points.Point;\n        anchorPadding?: number;\n        bounds?: Rects.RectPositioned;\n      }\n    ): void {\n      if (opts.bounds === undefined && canvasBounds !== undefined) {\n        opts = { ...opts, bounds: { ...canvasBounds, x: 0, y: 0 } };\n      }\n      textBlock(ctx, lines, opts);\n    },\n  };\n};\n\n/**\n * Drawing options\n */\nexport type DrawingOpts = {\n  /**\n   * Stroke style\n   */\n  readonly strokeStyle?: string;\n  /**\n   * Fill style\n   */\n  readonly fillStyle?: string;\n  /**\n   * If true, diagnostic helpers will be drawn\n   */\n  readonly debug?: boolean;\n};\n\nexport type LineOpts = {\n  readonly lineWidth?: number;\n  readonly lineCap?: CanvasLineCap;\n  readonly lineJoin?: CanvasLineJoin;\n};\n\n/**\n * Creates a drawing op to apply provided options\n * @param opts Drawing options that apply\n * @returns Stack\n */\nconst optsOp = (opts: DrawingOpts): StackOp =>\n  coloringOp(opts.strokeStyle, opts.fillStyle);\n\n/**\n * Applies drawing options to `ctx`, returning a {@link DrawingStack}\n * @param ctx Context\n * @param opts Options\n * @returns\n */\nconst applyOpts = (\n  ctx: CanvasRenderingContext2D,\n  opts: DrawingOpts = {},\n  ...additionalOps: readonly StackOp[]\n): DrawingStack => {\n  if (ctx === undefined) throw new Error(`ctx undefined`);\n\n  // Create a drawing stack, pushing an op generated from drawing options\n  const stack = drawingStack(ctx).push(optsOp(opts), ...additionalOps);\n\n  // Apply stack to context\n  stack.apply();\n  return stack;\n};\n\n/**\n * Draws one or more arcs.\n * @param ctx\n * @param arcs\n * @param opts\n */\nexport const arc = (\n  ctx: CanvasRenderingContext2D,\n  arcs: Arcs.ArcPositioned | readonly Arcs.ArcPositioned[],\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (arc: Arcs.ArcPositioned) => {\n    ctx.beginPath();\n    ctx.arc(arc.x, arc.y, arc.radius, arc.startRadian, arc.endRadian);\n    ctx.stroke();\n  };\n\n  const arcsArray: Arcs.ArcPositioned[] = Array.isArray(arcs) ? arcs : [ arcs ];\n  for (const arc of arcsArray) {\n    draw(arc);\n  }\n\n};\n\n/**\n * A drawing stack operation\n */\nexport type StackOp = (ctx: CanvasRenderingContext2D) => void;\n\n/**\n * A drawing stack (immutable)\n */\nexport type DrawingStack = {\n  /**\n   * Push a new drawing op\n   * @param ops Operation to add\n   * @returns stack with added op\n   */\n  push(...ops: readonly StackOp[]): DrawingStack;\n  /**\n   * Pops an operatiomn\n   * @returns Drawing stack with item popped\n   */\n  pop(): DrawingStack;\n  /**\n   * Applies drawing stack\n   */\n  apply(): DrawingStack;\n};\n\n/**\n * Colouring drawing op. Applies `fillStyle` and `strokeStyle`\n * @param strokeStyle\n * @param fillStyle\n * @returns\n */\nconst coloringOp = (\n  strokeStyle: string | CanvasGradient | CanvasPattern | undefined,\n  fillStyle: string | CanvasGradient | CanvasPattern | undefined\n): StackOp => {\n  const apply = (ctx: CanvasRenderingContext2D) => {\n    if (fillStyle) ctx.fillStyle = fillStyle;\n    if (strokeStyle) ctx.strokeStyle = strokeStyle;\n  };\n  return apply;\n};\n\nconst lineOp = (\n  lineWidth: number | undefined,\n  lineJoin: CanvasLineJoin | undefined,\n  lineCap: CanvasLineCap | undefined\n): StackOp => {\n  const apply = (ctx: CanvasRenderingContext2D) => {\n    if (lineWidth) ctx.lineWidth = lineWidth;\n    if (lineJoin) ctx.lineJoin = lineJoin;\n    if (lineCap) ctx.lineCap = lineCap;\n  };\n  return apply;\n};\n\n/**\n * Creates and returns an immutable drawing stack for a context\n * @param ctx Context\n * @param stk Initial stack operations\n * @returns\n */\nexport const drawingStack = (\n  ctx: CanvasRenderingContext2D,\n  stk?: IStackImmutable<StackOp>\n): DrawingStack => {\n  stk ??= new StackImmutable<StackOp>();\n\n  const push = (...ops: StackOp[]): DrawingStack => {\n    stk ??= new StackImmutable<StackOp>();\n    const s = stk.push(...ops);\n    for (const o of ops) o(ctx);\n    return drawingStack(ctx, s);\n  };\n\n  const pop = (): DrawingStack => {\n    const s = stk?.pop();\n    return drawingStack(ctx, s);\n  };\n\n  const apply = (): DrawingStack => {\n    if (stk === undefined) return drawingStack(ctx);\n    for (const op of stk.data) op(ctx);\n    return drawingStack(ctx, stk);\n  };\n\n  return { push, pop, apply };\n};\n\n/**\n * Draws a curved line through a set of points\n * @param ctx \n * @param points \n * @param opts \n */\nexport const lineThroughPoints = (\n  ctx: CanvasRenderingContext2D,\n  points: readonly Points.Point[],\n  opts?: DrawingOpts\n): void => {\n  applyOpts(ctx, opts);\n\n  // https://stackoverflow.com/questions/7054272/how-to-draw-smooth-curve-through-n-points-using-javascript-html5-canvas\n  ctx.moveTo(points[ 0 ].x, points[ 0 ].y);\n\n  for (const [ index, p ] of points.entries()) {\n    if (index + 2 >= points.length) continue;\n    const pNext = points[ index + 1 ];\n    const mid = {\n      x: (p.x + pNext.x) / 2,\n      y: (p.y + pNext.y) / 2,\n    };\n    const cpX1 = (mid.x + p.x) / 2;\n    const cpX2 = (mid.x + pNext.x) / 2;\n    ctx.quadraticCurveTo(cpX1, pNext.y, mid.x, mid.y);\n    ctx.quadraticCurveTo(cpX2, pNext.y, pNext.x, pNext.y);\n  }\n};\n\n/**\n * Draws one or more circles. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n *\n * ```js\n * // Draw a circle with radius of 10 at 0,0\n * circle(ctx, {radius:10});\n *\n * // Draw a circle of radius 10 at 100,100\n * circle(ctx, {radius: 10, x: 100, y: 100});\n *\n * // Draw two blue outlined circles\n * circle(ctx, [ {radius: 5}, {radius: 10} ], {strokeStyle:`blue`});\n * ```\n * @param ctx Drawing context\n * @param circlesToDraw Circle(s) to draw\n * @param opts Drawing options\n */\nexport const circle = (\n  ctx: CanvasRenderingContext2D,\n  circlesToDraw: Circles.CirclePositioned | readonly Circles.CirclePositioned[],\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (c: Circles.CirclePositioned) => {\n    ctx.beginPath();\n    ctx.arc(c.x, c.y, c.radius, 0, PIPI);\n    if (opts.strokeStyle) ctx.stroke();\n    if (opts.fillStyle) ctx.fill();\n  };\n\n  if (Array.isArray(circlesToDraw)) {\n    for (const c of circlesToDraw) draw(c as Circles.CirclePositioned);\n  } else {\n    draw(circlesToDraw as Circles.CirclePositioned);\n  }\n};\n\n/**\n * Draws one or more ellipses. Will draw outline/fill depending on\n * whether `strokeStyle` or `fillStyle` params are present in the drawing options.\n * @param ctx\n * @param ellipsesToDraw\n * @param opts\n */\nexport const ellipse = (\n  ctx: CanvasRenderingContext2D,\n  ellipsesToDraw:\n    | Ellipses.EllipsePositioned\n    | readonly Ellipses.EllipsePositioned[],\n  opts: DrawingOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (ellipse: Ellipses.EllipsePositioned) => {\n    ctx.beginPath();\n    const rotation = ellipse.rotation ?? 0;\n    const startAngle = ellipse.startAngle ?? 0;\n    const endAngle = ellipse.endAngle ?? PIPI;\n    ctx.ellipse(ellipse.x, ellipse.y, ellipse.radiusX, ellipse.radiusY, rotation, startAngle, endAngle);\n    if (opts.strokeStyle) ctx.stroke();\n    if (opts.fillStyle) ctx.fill();\n  };\n\n  const ellipsesArray = Array.isArray(ellipsesToDraw) ? ellipsesToDraw : [ ellipsesToDraw ];\n  for (const ellipse of ellipsesArray) {\n    draw(ellipse);\n  }\n};\n\n/**\n * Draws one or more paths.\n * supported paths are quadratic beziers and lines.\n * @param ctx\n * @param pathsToDraw\n * @param opts\n */\nexport const paths = (\n  ctx: CanvasRenderingContext2D,\n  pathsToDraw: readonly Paths.Path[] | Paths.Path,\n  opts: { readonly strokeStyle?: string; readonly debug?: boolean } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (path: Paths.Path) => {\n    // Call appropriate drawing function depending on the type of path\n    if (Beziers.isQuadraticBezier(path)) quadraticBezier(ctx, path, opts);\n    else if (Lines.isLine(path)) line(ctx, path, opts);\n    else throw new Error(`Unknown path type ${ JSON.stringify(path) }`);\n  };\n\n  if (Array.isArray(pathsToDraw)) {\n    for (const p of pathsToDraw) draw(p);\n  } else {\n    draw(pathsToDraw as Paths.Path);\n  }\n};\n\nexport type ConnectedPointsOptions = {\n  readonly lineWidth: number\n  readonly loop: boolean\n  readonly fillStyle: string\n  readonly strokeStyle: string\n}\n/**\n * Draws a line between all the given points.\n * If a fillStyle is specified, it will be filled.\n *\n * See also:\n * * {@link line}: Draw one or more lines\n *\n * @param ctx\n * @param pts\n */\nexport const connectedPoints = (\n  ctx: CanvasRenderingContext2D,\n  pts: readonly Points.Point[],\n  opts: Partial<ConnectedPointsOptions> = {}\n) => {\n  const shouldLoop = opts.loop ?? false;\n\n  resultThrow(arrayTest(pts, `pts`));\n\n  if (pts.length === 0) return;\n\n  // Throw an error if any point is invalid\n  for (const [ index, pt ] of pts.entries()) Points.guard(pt, `Index ${ index }`);\n\n  applyOpts(ctx, opts);\n\n  // Draw points\n  if (opts.lineWidth) ctx.lineWidth = opts.lineWidth;\n  ctx.beginPath();\n  ctx.moveTo(pts[ 0 ].x, pts[ 0 ].y);\n  for (const pt of pts) ctx.lineTo(pt.x, pt.y);\n\n  if (shouldLoop) ctx.lineTo(pts[ 0 ].x, pts[ 0 ].y);\n\n  // if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n  if (\n    opts.strokeStyle ||\n    (opts.strokeStyle === undefined && opts.fillStyle === undefined)\n  ) {\n    ctx.stroke();\n  }\n  if (opts.fillStyle) {\n    ctx.fill();\n  }\n};\n\n/**\n * Draws labels for a set of points\n * @param ctx\n * @param pts Points to draw\n * @param opts\n * @param labels Labels for points\n */\nexport const pointLabels = (\n  ctx: CanvasRenderingContext2D,\n  pts: readonly Points.Point[],\n  opts: { readonly fillStyle?: string } = {},\n  labels?: readonly string[]\n) => {\n  if (pts.length === 0) return;\n\n  // Throw an error if any point is invalid\n  for (const [ index, pt ] of pts.entries()) Points.guard(pt, `Index ${ index }`);\n\n  applyOpts(ctx, opts);\n\n  for (const [ index, pt ] of pts.entries()) {\n    const label =\n      labels !== undefined && index < labels.length ? labels[ index ] : index.toString();\n    ctx.fillText(label.toString(), pt.x, pt.y);\n  }\n};\n\n/**\n * Returns `point` with the canvas's translation matrix applied\n * @param ctx\n * @param point\n * @returns\n */\nexport const translatePoint = (\n  ctx: CanvasRenderingContext2D,\n  point: Points.Point\n): Points.Point => {\n  const m = ctx.getTransform();\n  return {\n    x: point.x * m.a + point.y * m.c + m.e,\n    y: point.x * m.b + point.y * m.d + m.f,\n  };\n};\n\n/**\n * Creates a new HTML IMG element with a snapshot of the\n * canvas. Element will need to be inserted into the document.\n *\n * ```\n * const myCanvas = document.getElementById('someCanvas');\n * const el = copyToImg(myCanvas);\n * document.getElementById('images').appendChild(el);\n * ```\n * @param canvasEl\n * @returns\n */\nexport const copyToImg = (canvasEl: HTMLCanvasElement): HTMLImageElement => {\n  const img = document.createElement(`img`);\n  img.src = canvasEl.toDataURL(`image/jpeg`);\n  return img;\n};\n\nexport type DotOpts = DrawingOpts & {\n  readonly radius?: number;\n  readonly stroke?: boolean;\n  readonly filled?: boolean;\n  readonly strokeWidth?: number;\n}\n\n/**\n * Draws filled circle(s) at provided point(s)\n * @param ctx\n * @param pos\n * @param opts\n */\nexport const dot = (\n  ctx: CanvasRenderingContext2D,\n  pos: Points.Point | (Points.Point | Circles.CirclePositioned)[] | Circles.CirclePositioned,\n  opts?: DotOpts\n) => {\n  opts ??= {};\n  const radius = opts.radius ?? 10;\n  const positions = Array.isArray(pos) ? pos : [ pos ];\n  const stroke = opts.stroke ? opts.stroke : opts.strokeStyle !== undefined;\n  let filled = opts.filled ? opts.filled : opts.fillStyle !== undefined;\n  if (!stroke && !filled) filled = true;\n\n  applyOpts(ctx, opts);\n\n  for (const pos of positions) {\n    ctx.beginPath();\n    if (`radius` in pos) {\n      ctx.arc(pos.x, pos.y, pos.radius, 0, 2 * Math.PI);\n    } else {\n      ctx.arc(pos.x, pos.y, radius, 0, 2 * Math.PI);\n    }\n    if (filled) {\n      ctx.fill();\n    }\n    if (stroke) {\n      ctx.stroke();\n    }\n  }\n\n  // const makePath = () => {\n  //   ctx.beginPath();\n\n  //   // x&y for arc is the center of circle\n  //   if (Array.isArray(pos)) {\n  //     for (const p of pos) {\n  //       ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n  //     }\n  //   } else {\n  //     const p = pos as Point;\n  //     ctx.arc(p.x, p.y, radius, 0, 2 * Math.PI);\n  //   }\n  // }\n  // makePath();\n  // if (opts.filled || !opts.stroke) {\n  //   ctx.fill();\n  // }\n  // if (opts.stroke) {\n  //   if (opts.strokeWidth) ctx.lineWidth = opts.strokeWidth;\n  //   //makePath();\n  //   ctx.stroke();\n  // }\n};\n\n/**\n * Draws a cubic or quadratic bezier\n * @param ctx\n * @param bezierToDraw\n * @param opts\n */\nexport const bezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.QuadraticBezier | Beziers.CubicBezier,\n  opts?: DrawingOpts\n) => {\n  if (Beziers.isQuadraticBezier(bezierToDraw)) {\n    quadraticBezier(ctx, bezierToDraw, opts);\n  } else if (Beziers.isCubicBezier(bezierToDraw)) {\n    cubicBezier(ctx, bezierToDraw, opts);\n  }\n};\n\nconst cubicBezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.CubicBezier,\n  opts: DrawingOpts = {}\n) => {\n  let stack = applyOpts(ctx, opts);\n\n  const { a, b, cubic1, cubic2 } = bezierToDraw;\n  const isDebug = opts.debug ?? false;\n\n  if (isDebug) {\n    /*\n     * const ss = ctx.strokeStyle;\n     * ctx.strokeStyle = ss;\n     */\n  }\n  ctx.beginPath();\n  ctx.moveTo(a.x, a.y);\n  ctx.bezierCurveTo(cubic1.x, cubic1.y, cubic2.x, cubic2.y, b.x, b.y);\n  ctx.stroke();\n\n  if (isDebug) {\n    stack = stack.push(\n      optsOp({\n        ...opts,\n        strokeStyle: Colour.multiplyOpacity(opts.strokeStyle ?? `silver`, 0.6),\n        fillStyle: Colour.multiplyOpacity(opts.fillStyle ?? `yellow`, 0.4),\n      })\n    );\n\n    stack.apply();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(cubic1.x, cubic1.y);\n    ctx.stroke();\n    ctx.moveTo(b.x, b.y);\n    ctx.lineTo(cubic2.x, cubic2.y);\n    ctx.stroke();\n\n    ctx.fillText(`a`, a.x + 5, a.y);\n    ctx.fillText(`b`, b.x + 5, b.y);\n    ctx.fillText(`c1`, cubic1.x + 5, cubic1.y);\n    ctx.fillText(`c2`, cubic2.x + 5, cubic2.y);\n\n    dot(ctx, cubic1, { radius: 3 });\n    dot(ctx, cubic2, { radius: 3 });\n    dot(ctx, a, { radius: 3 });\n    dot(ctx, b, { radius: 3 });\n    stack = stack.pop();\n    stack.apply();\n  }\n};\n\nconst quadraticBezier = (\n  ctx: CanvasRenderingContext2D,\n  bezierToDraw: Beziers.QuadraticBezier,\n  opts: DrawingOpts = {}\n) => {\n  const { a, b, quadratic } = bezierToDraw;\n  const isDebug = opts.debug ?? false;\n  let stack = applyOpts(ctx, opts);\n\n  ctx.beginPath();\n  ctx.moveTo(a.x, a.y);\n  ctx.quadraticCurveTo(quadratic.x, quadratic.y, b.x, b.y);\n  ctx.stroke();\n\n  if (isDebug) {\n    /*\n     * const fs = ctx.fillStyle;\n     * const ss = ctx.strokeStyle;\n     * ctx.fillStyle = opts.strokeStyle ?? `gray`;\n     * ctx.strokeStyle = opts.strokeStyle ?? `gray`;\n     */\n    stack = stack.push(\n      optsOp({\n        ...opts,\n        strokeStyle: Colour.multiplyOpacity(opts.strokeStyle ?? `silver`, 0.6),\n        fillStyle: Colour.multiplyOpacity(opts.fillStyle ?? `yellow`, 0.4),\n      })\n    );\n    connectedPoints(ctx, [ a, quadratic, b ]);\n\n    ctx.fillText(`a`, a.x + 5, a.y);\n    ctx.fillText(`b`, b.x + 5, b.y);\n    ctx.fillText(`h`, quadratic.x + 5, quadratic.y);\n    dot(ctx, quadratic, { radius: 3 });\n    dot(ctx, a, { radius: 3 });\n    dot(ctx, b, { radius: 3 });\n    /*\n     * ctx.fillStyle = fs;\n     * ctx.strokeStyle = ss;\n     */\n    stack = stack.pop();\n    stack.apply();\n  }\n};\n\n/**\n * Draws one or more lines.\n *\n * Each line is drawn independently, ie it's not assumed lines are connected.\n *\n * See also:\n * * {@link connectedPoints}: Draw a series of connected points\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const line = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Lines.Line | readonly Lines.Line[],\n  opts: LineOpts & DrawingOpts = {}\n) => {\n  const isDebug = opts.debug ?? false;\n  const o = lineOp(opts.lineWidth, opts.lineJoin, opts.lineCap);\n  applyOpts(ctx, opts, o);\n\n  const draw = (d: Lines.Line) => {\n    const { a, b } = d;\n    ctx.beginPath();\n    ctx.moveTo(a.x, a.y);\n    ctx.lineTo(b.x, b.y);\n    if (isDebug) {\n      ctx.fillText(`a`, a.x, a.y);\n      ctx.fillText(`b`, b.x, b.y);\n      dot(ctx, a, { radius: 5, strokeStyle: `black` });\n      dot(ctx, b, { radius: 5, strokeStyle: `black` });\n    }\n    ctx.stroke();\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) draw(t as Lines.Line);\n  } else {\n    draw(toDraw as Lines.Line);\n  }\n};\n\n/**\n * Draws one or more triangles\n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const triangle = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Triangles.Triangle | readonly Triangles.Triangle[],\n  opts: DrawingOpts & { readonly filled?: boolean } = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const draw = (t: Triangles.Triangle) => {\n    connectedPoints(ctx, Triangles.corners(t), { ...opts, loop: true });\n\n    if (opts.debug) {\n      pointLabels(ctx, Triangles.corners(t), undefined, [ `a`, `b`, `c` ]);\n    }\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) {\n      draw(t);\n    }\n  } else {\n    draw(toDraw as Triangles.Triangle);\n  }\n};\n\n// export const arrowFromTip = (ctx:CanvasRenderingContext2D, tipPos: Point, tailLength:number, opts:DrawingOpts) => {\n//   if (opts.fillStyle) ctx.fillStyle = opts.fillStyle;\n//   if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n\n//   ctx.save();\n//   ctx.translate\n//   ctx.restore();\n// }\n\n\nexport type RectOpts = DrawingOpts & Readonly<Partial<{\n  stroke: boolean\n  filled: boolean\n  strokeWidth: number\n  /**\n   * If true, diagonals are drawn\n   */\n  crossed: boolean\n}>>\n\n/**\n * Draws one or more rectangles.\n * \n * @param ctx\n * @param toDraw\n * @param opts\n */\nexport const rect = (\n  ctx: CanvasRenderingContext2D,\n  toDraw: Rects.Rect | Rects.Rect[] | Rects.RectPositioned | Rects.RectPositioned[],\n  opts: RectOpts = {}\n) => {\n  applyOpts(ctx, opts);\n\n  const filled = opts.filled ?? (opts.fillStyle === undefined ? false : true);\n  const stroke = opts.stroke ?? (opts.strokeStyle === undefined ? false : true);\n  const draw = (d: Rects.RectPositioned | Rects.Rect) => {\n    const x = `x` in d ? d.x : 0;\n    const y = `y` in d ? d.y : 0;\n    if (filled) ctx.fillRect(x, y, d.width, d.height);\n    if (stroke) {\n      if (opts.strokeWidth) ctx.lineWidth = opts.strokeWidth;\n      //if (opts.strokeStyle) ctx.strokeStyle = opts.strokeStyle;\n      ctx.strokeRect(x, y, d.width, d.height);\n    }\n    if (opts.crossed) {\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(d.width, d.height);\n      ctx.stroke();\n      ctx.moveTo(0, d.height);\n      ctx.lineTo(d.width, 0);\n      ctx.stroke();\n    }\n    if (opts.debug) {\n      pointLabels(ctx, Rects.corners(d), undefined, [ `NW`, `NE`, `SE`, `SW` ]);\n    }\n  };\n\n  if (Array.isArray(toDraw)) {\n    for (const t of toDraw) {\n      draw(t);\n    }\n  } else {\n    draw(toDraw as Rects.RectPositioned);\n  }\n};\n\n/**\n * Returns the width of `text`. Rounds number up to nearest multiple if provided. If\n * text is empty or undefined, 0 is returned.\n * @param ctx\n * @param text\n * @param widthMultiple\n * @returns\n */\nexport const textWidth = (\n  ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0,\n  widthMultiple?: number\n): number => {\n  const rect = textRect(ctx, text, padding, widthMultiple);\n  return rect.width;\n};\n\nexport const textRect = (ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0, widthMultiple?: number): Rects.Rect => {\n  if (text === undefined || text === null || text.length === 0) return Rects.Empty;\n  const m = ctx.measureText(text);\n\n  const width = (widthMultiple) ? quantiseEvery(m.width, widthMultiple) + padding : m.width + padding;\n\n  return {\n    width: width,\n    height: m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding\n  }\n}\n\nexport const textHeight = (\n  ctx: CanvasRenderingContext2D,\n  text?: string | null,\n  padding = 0): number => {\n  const rect = textRect(ctx, text, padding);\n  return rect.height;\n  // if (text === undefined || text === null || text.length === 0) return 0;\n  // const m = ctx.measureText(text);\n  // return m.actualBoundingBoxAscent + m.actualBoundingBoxDescent + padding + padding;\n}\n\n\n/**\n * Draws a block of text. Each array item is considered a line.\n * @param ctx\n * @param lines\n * @param opts\n */\nexport const textBlock = (\n  ctx: CanvasRenderingContext2D,\n  lines: readonly string[],\n  opts: DrawingOpts & {\n    readonly anchor: Points.Point;\n    readonly align?: `top` | `center`\n    readonly anchorPadding?: number;\n    readonly bounds?: Rects.RectPositioned;\n  }\n) => {\n  applyOpts(ctx, opts);\n  const anchorPadding = opts.anchorPadding ?? 0;\n  const align = opts.align ?? `top`;\n  const anchor = opts.anchor;\n  const bounds = opts.bounds ?? { x: 0, y: 0, width: 1_000_000, height: 1_000_000 };\n\n  // Measure each line\n  const blocks = lines.map((l) => ctx.measureText(l));\n\n  // Get width and height\n  const widths = blocks.map((tm) => tm.width);\n  const heights = blocks.map(\n    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent + 3\n  );\n\n  // Find extremes\n  const maxWidth = Math.max(...widths);\n  const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n\n  let { x, y } = anchor;\n\n  if (anchor.x + maxWidth > bounds.width) {\n    x = bounds.width - (maxWidth + anchorPadding);\n  } else x -= anchorPadding;\n\n  if (x < bounds.x) x = bounds.x + anchorPadding;\n\n  if (anchor.y + totalHeight > bounds.height) {\n    y = bounds.height - (totalHeight + anchorPadding);\n  } else y -= anchorPadding;\n\n  if (y < bounds.y) y = bounds.y + anchorPadding;\n\n  if (align === `top`) {\n    ctx.textBaseline = `top`;\n  } else {\n    ctx.textBaseline = `middle`;\n  }\n  for (const [ index, line ] of lines.entries()) {\n    ctx.fillText(line, x, y);\n    y += heights[ index ];\n  }\n};\n\nexport type HorizAlign = `left` | `right` | `center`;\nexport type VertAlign = `top` | `center` | `bottom`;\n\n/**\n * Draws an aligned text block\n */\nexport const textBlockAligned = (\n  ctx: CanvasRenderingContext2D,\n  text: readonly string[] | string,\n  opts: DrawingOpts & {\n    readonly bounds: Rects.RectPositioned;\n    readonly horiz?: HorizAlign;\n    readonly vert?: VertAlign;\n  }\n) => {\n  const { bounds } = opts;\n  const { horiz = `left`, vert = `top` } = opts;\n\n  const lines = typeof text === `string` ? [ text ] : text;\n\n  applyOpts(ctx, opts);\n\n  ctx.save();\n  ctx.translate(bounds.x, bounds.y);\n  ctx.textAlign = `left`;\n  ctx.textBaseline = `top`;\n  const middleX = bounds.width / 2;\n  const middleY = bounds.height / 2;\n\n  // Measure each line\n  const blocks = lines.map((l) => ctx.measureText(l));\n  const heights = blocks.map(\n    (tm) => tm.actualBoundingBoxAscent + tm.actualBoundingBoxDescent\n  );\n  const totalHeight = heights.reduce((accumulator, value) => accumulator + value, 0);\n\n  let y = 0;\n  if (vert === `center`) y = middleY - totalHeight / 2;\n  else if (vert === `bottom`) {\n    y = bounds.height - totalHeight;\n  }\n\n  for (const [ index, line ] of lines.entries()) {\n    let x = 0;\n    if (horiz === `center`) x = middleX - blocks[ index ].width / 2;\n    else if (horiz === `right`) x = bounds.width - blocks[ index ].width;\n    ctx.fillText(line, x, y);\n    y += heights[ index ];\n  }\n\n  ctx.restore();\n};\n","import * as C from \"colorizr\";\nimport type { Hsl, HslAbsolute, HslScalar, ParsingOptions } from \"./types.js\";\nimport { numberInclusiveRangeTest, numberTest } from \"@ixfx/guards\";\nimport { resultThrow } from \"@ixfx/guards\";\nimport { cssDefinedHexColours } from \"./css-colours.js\";\nimport { angleConvert, angleParse, type Angle } from \"@ixfx/geometry\";\n\n/**\n * Scales the opacity value of an input HSL value\n * ```js\n * withOpacity()\n * ```\n * @param value \n * @param fn \n * @returns \n */\nexport const withOpacity = <T extends Hsl>(value: T, fn: (opacityScalar: number, value: T) => number): T => {\n  switch (value.unit) {\n    case `absolute`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 100) / 100, value) * 100\n      }\n    case `scalar`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 1), value)\n      }\n  }\n}\n\n\nconst hslTransparent = Object.freeze({\n  h: 0, s: 0, l: 0, opacity: 0, unit: `absolute`, space: `hsl`\n});\nexport const fromHexString = (hexString: string): HslAbsolute => fromLibrary(C.hex2hsl(hexString))\n\nexport const fromCssAbsolute = (value: string, options: ParsingOptions<HslAbsolute> = {}): HslAbsolute => {\n  value = value.toLowerCase();\n  if (value.startsWith(`#`)) {\n    return fromHexString(value);\n\n  }\n  if (value === `transparent`) return hslTransparent;\n  if (typeof cssDefinedHexColours[ value ] !== `undefined`) {\n    return fromHexString(cssDefinedHexColours[ value ] as string);\n  }\n\n  if (!value.startsWith(`hsl(`) && !value.startsWith(`hsla(`)) {\n    try {\n      const converted = C.convert(value, `hsl`);\n      value = converted;\n      // eslint-disable-next-line unicorn/prevent-abbreviations\n    } catch (e) {\n      if (options.fallbackString) {\n        value = options.fallbackString;\n      } else {\n        throw e;\n      }\n    }\n  }\n  const c = C.extractColorParts(value);\n  if (c.model !== `hsl`) {\n    if (options.fallbackColour) return options.fallbackColour;\n    throw new Error(`Expecting HSL colour space. Got: ${ c.model }`);\n  }\n  return fromLibrary(c as any as C.HSL, options);\n}\n\nexport const fromCssScalar = (value: string, options: ParsingOptions<HslAbsolute> = {}): HslScalar => toScalar(fromCssAbsolute(value, options));\n\n\nexport const toCssString = (hsl: Hsl): string => {\n  const abs = toAbsolute(hsl);\n  let css = `hsl(${ abs.h }deg ${ abs.s }% ${ abs.l }%`;\n  if (`opacity` in abs && abs.opacity !== undefined && abs.opacity < 100) {\n    css += ` / ${ abs.opacity }%`;\n  }\n  css += ')';\n  return css;\n}\n\nconst toLibrary = (hsl: Hsl): C.HSL => {\n  const abs = toAbsolute(hsl);\n  return {\n    h: abs.h,\n    s: abs.s,\n    l: abs.l,\n    alpha: abs.opacity,\n  }\n}\n\nconst fromLibrary = (hsl: C.HSL, parsingOptions: ParsingOptions<HslAbsolute> = {}): HslAbsolute => {\n  if (typeof hsl === `undefined` || hsl === null) {\n    if (parsingOptions.fallbackColour) return parsingOptions.fallbackColour;\n  }\n  resultThrow(\n    numberInclusiveRangeTest(hsl.h, 0, 360, `h`),\n    numberInclusiveRangeTest(hsl.s, 0, 100, `s`),\n    numberInclusiveRangeTest(hsl.l, 0, 100, `l`),\n    () => hsl.alpha !== undefined ? numberInclusiveRangeTest(hsl.alpha, 0, 100, `alpha`) : { success: true, value: hsl },\n  );\n  return {\n    h: hsl.h,\n    s: hsl.s,\n    l: hsl.l,\n    opacity: (hsl.alpha ?? 1) * 100,\n    unit: `absolute`,\n    space: `hsl`\n  }\n}\n\nexport const toAbsolute = (hsl: Hsl): HslAbsolute => {\n  guard(hsl);\n  if (hsl.unit === `absolute`) return hsl;\n  return {\n    h: hsl.h * 360,\n    s: hsl.s * 100,\n    l: hsl.l * 100,\n    opacity: (hsl.opacity ?? 1) * 100,\n    unit: `absolute`,\n    space: `hsl`\n  }\n}\n\n/**\n * Generates a {@link HslScalar} value.\n * \n * ```js\n * generateScaler(10); // 10deg, default to full saturation, half lightness and full opacity\n * \n * // Generate HSL value from radian angle and 50% saturation\n * generateScalar(`10rad`, 0.5); \n * \n * // Generate from numeric CSS variable\n * generateScalar(`--hue`);\n * ```\n * @param absoluteHslOrVariable Hue angle or CSS variable\n * @param saturation \n * @param lightness \n * @param opacity \n */\nexport const generateScalar = (absoluteHslOrVariable: string | number | Angle, saturation = 1, lightness = 0.5, opacity = 1): HslScalar => {\n\n  if (typeof absoluteHslOrVariable === `string`) {\n    if (absoluteHslOrVariable.startsWith(`--`)) {\n      absoluteHslOrVariable = getComputedStyle(document.body).getPropertyValue(absoluteHslOrVariable).trim()\n    }\n  }\n  const hue = angleParse(absoluteHslOrVariable);\n  if (saturation > 1) throw new TypeError(`Param 'saturation' must be between 0..1`);\n  if (lightness > 1) throw new TypeError(`Param 'lightness' must be between 0..1`);\n  if (opacity > 1) throw new TypeError(`Param 'opacity' must be between 0..1`);\n  const hueDeg = angleConvert(hue, `deg`).value / 360;\n  return {\n    h: hueDeg,\n    s: saturation,\n    l: lightness,\n    opacity: opacity,\n    unit: `scalar`,\n    space: `hsl`\n  }\n}\n\nexport const toScalar = (hsl: Hsl): HslScalar => {\n  guard(hsl);\n  if (hsl.unit === `scalar`) return hsl;\n  return {\n    h: hsl.h / 360,\n    s: hsl.s / 100,\n    l: hsl.l / 100,\n    opacity: (hsl.opacity ?? 1) / 100,\n    unit: `scalar`,\n    space: `hsl`\n  }\n}\n\nexport const guard = (hsl: Hsl) => {\n  const { h, s, l, opacity, space, unit } = hsl;\n  if (space !== `hsl`) throw new Error(`Space is expected to be 'hsl'. Got: ${ space }`);\n  if (unit === `absolute`) {\n    resultThrow(\n      numberTest(h, `finite`, `h`),\n      numberInclusiveRangeTest(s, 0, 100, `s`),\n      numberInclusiveRangeTest(l, 0, 100, `l`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberInclusiveRangeTest(opacity, 0, 100, `opacity`);\n        }\n      });\n  } else if (unit === `scalar`) {\n    resultThrow(\n      numberTest(h, `percentage`, `h`),\n      numberTest(s, `percentage`, `s`),\n      numberTest(l, `percentage`, `l`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberTest(opacity, `percentage`, `opacity`);\n        }\n      });\n  } else {\n    throw new Error(`Unit is expected to be 'absolute' or 'scalar'. Got: ${ unit }`);\n  }\n}\n","import * as SrgbSpace from \"./srgb.js\";\nimport * as HslSpace from './hsl.js';\nimport type { Colour } from \"./types.js\";\n\n/**\n * Converts from some kind of colour that is legal in CSS\n * into a structured Colour type.\n * \n * Handles: hex format, CSS variables, colour names\n * ```js\n * fromCssColour(`#ffffff`);\n * fromCssColour(`blue`);\n * fromCssColour(`--some-variable`);\n * fromCssColour(`hsl(50, 50%, 50%)`);\n * fromCssColour(`rgb(50, 100, 100)`);\n * ```\n * @param colour \n * @returns \n */\nexport const fromCssColour = (colour: string): Colour => {\n  if (colour.startsWith(`#`)) {\n    return SrgbSpace.fromHexString(colour);\n  }\n\n  if (typeof cssDefinedHexColours[ colour ] !== `undefined`) {\n    return SrgbSpace.fromHexString(cssDefinedHexColours[ colour ] as string);\n  }\n  if (colour.startsWith(`--`)) {\n    const fromCss = getComputedStyle(document.body).getPropertyValue(colour).trim();\n    if (fromCss.length === 0 || fromCss === null) throw new Error(`Variable missing: ${ colour }`);\n    return fromCssColour(fromCss);\n  }\n  colour = colour.toLowerCase();\n  if (colour.startsWith(`hsl(`) || colour.startsWith(`hsla(`)) {\n    return HslSpace.fromCssAbsolute(colour);\n  }\n  if (colour.startsWith(`rgb(`) || colour.startsWith(`rgba(`)) {\n    return SrgbSpace.fromCss8bit(colour);\n  }\n\n  throw new Error(`String colour is not a hex colour, CSS variable nor well-defined colour name: '${ colour }'`);\n}\n\nexport const cssDefinedHexColours = {\n  \"aliceblue\": \"#f0f8ff\",\n  \"antiquewhite\": \"#faebd7\",\n  \"aqua\": \"#00ffff\",\n  \"aquamarine\": \"#7fffd4\",\n  \"azure\": \"#f0ffff\",\n  \"beige\": \"#f5f5dc\",\n  \"bisque\": \"#ffe4c4\",\n  \"black\": \"#000000\",\n  \"blanchedalmond\": \"#ffebcd\",\n  \"blue\": \"#0000ff\",\n  \"blueviolet\": \"#8a2be2\",\n  \"brown\": \"#a52a2a\",\n  \"burlywood\": \"#deb887\",\n  \"cadetblue\": \"#5f9ea0\",\n  \"chartreuse\": \"#7fff00\",\n  \"chocolate\": \"#d2691e\",\n  \"coral\": \"#ff7f50\",\n  \"cornflowerblue\": \"#6495ed\",\n  \"cornsilk\": \"#fff8dc\",\n  \"crimson\": \"#dc143c\",\n  \"cyan\": \"#00ffff\",\n  \"darkblue\": \"#00008b\",\n  \"darkcyan\": \"#008b8b\",\n  \"darkgoldenrod\": \"#b8860b\",\n  \"darkgray\": \"#a9a9a9\",\n  \"darkgreen\": \"#006400\",\n  \"darkkhaki\": \"#bdb76b\",\n  \"darkmagenta\": \"#8b008b\",\n  \"darkolivegreen\": \"#556b2f\",\n  \"darkorange\": \"#ff8c00\",\n  \"darkorchid\": \"#9932cc\",\n  \"darkred\": \"#8b0000\",\n  \"darksalmon\": \"#e9967a\",\n  \"darkseagreen\": \"#8fbc8f\",\n  \"darkslateblue\": \"#483d8b\",\n  \"darkslategray\": \"#2f4f4f\",\n  \"darkturquoise\": \"#00ced1\",\n  \"darkviolet\": \"#9400d3\",\n  \"deeppink\": \"#ff1493\",\n  \"deepskyblue\": \"#00bfff\",\n  \"dimgray\": \"#696969\",\n  \"dodgerblue\": \"#1e90ff\",\n  \"firebrick\": \"#b22222\",\n  \"floralwhite\": \"#fffaf0\",\n  \"forestgreen\": \"#228b22\",\n  \"fuchsia\": \"#ff00ff\",\n  \"gainsboro\": \"#dcdcdc\",\n  \"ghostwhite\": \"#f8f8ff\",\n  \"gold\": \"#ffd700\",\n  \"goldenrod\": \"#daa520\",\n  \"gray\": \"#808080\",\n  \"green\": \"#008000\",\n  \"greenyellow\": \"#adff2f\",\n  \"honeydew\": \"#f0fff0\",\n  \"hotpink\": \"#ff69b4\",\n  \"indianred\": \"#cd5c5c\",\n  \"indigo\": \"#4b0082\",\n  \"ivory\": \"#fffff0\",\n  \"khaki\": \"#f0e68c\",\n  \"lavender\": \"#e6e6fa\",\n  \"lavenderblush\": \"#fff0f5\",\n  \"lawngreen\": \"#7cfc00\",\n  \"lemonchiffon\": \"#fffacd\",\n  \"lightblue\": \"#add8e6\",\n  \"lightcoral\": \"#f08080\",\n  \"lightcyan\": \"#e0ffff\",\n  \"lightgoldenrodyellow\": \"#fafad2\",\n  \"lightgray\": \"#d3d3d3\",\n  \"lightgreen\": \"#90ee90\",\n  \"lightpink\": \"#ffb6c1\",\n  \"lightsalmon\": \"#ffa07a\",\n  \"lightseagreen\": \"#20b2aa\",\n  \"lightskyblue\": \"#87cefa\",\n  \"lightslategray\": \"#778899\",\n  \"lightsteelblue\": \"#b0c4de\",\n  \"lightyellow\": \"#ffffe0\",\n  \"lime\": \"#00ff00\",\n  \"limegreen\": \"#32cd32\",\n  \"linen\": \"#faf0e6\",\n  \"magenta\": \"#ff00ff\",\n  \"maroon\": \"#800000\",\n  \"mediumaquamarine\": \"#66cdaa\",\n  \"mediumblue\": \"#0000cd\",\n  \"mediumorchid\": \"#ba55d3\",\n  \"mediumpurple\": \"#9370db\",\n  \"mediumseagreen\": \"#3cb371\",\n  \"mediumslateblue\": \"#7b68ee\",\n  \"mediumspringgreen\": \"#00fa9a\",\n  \"mediumturquoise\": \"#48d1cc\",\n  \"mediumvioletred\": \"#c71585\",\n  \"midnightblue\": \"#191970\",\n  \"mintcream\": \"#f5fffa\",\n  \"mistyrose\": \"#ffe4e1\",\n  \"moccasin\": \"#ffe4b5\",\n  \"navajowhite\": \"#ffdead\",\n  \"navy\": \"#000080\",\n  \"oldlace\": \"#fdf5e6\",\n  \"olive\": \"#808000\",\n  \"olivedrab\": \"#6b8e23\",\n  \"orange\": \"#ffa500\",\n  \"orangered\": \"#ff4500\",\n  \"orchid\": \"#da70d6\",\n  \"palegoldenrod\": \"#eee8aa\",\n  \"palegreen\": \"#98fb98\",\n  \"paleturquoise\": \"#afeeee\",\n  \"palevioletred\": \"#db7093\",\n  \"papayawhip\": \"#ffefd5\",\n  \"peachpuff\": \"#ffdab9\",\n  \"peru\": \"#cd853f\",\n  \"pink\": \"#ffc0cb\",\n  \"plum\": \"#dda0dd\",\n  \"powderblue\": \"#b0e0e6\",\n  \"purple\": \"#800080\",\n  \"rebeccapurple\": \"#663399\",\n  \"red\": \"#ff0000\",\n  \"rosybrown\": \"#bc8f8f\",\n  \"royalblue\": \"#4169e1\",\n  \"saddlebrown\": \"#8b4513\",\n  \"salmon\": \"#fa8072\",\n  \"sandybrown\": \"#f4a460\",\n  \"seagreen\": \"#2e8b57\",\n  \"seashell\": \"#fff5ee\",\n  \"sienna\": \"#a0522d\",\n  \"silver\": \"#c0c0c0\",\n  \"skyblue\": \"#87ceeb\",\n  \"slateblue\": \"#6a5acd\",\n  \"slategray\": \"#708090\",\n  \"snow\": \"#fffafa\",\n  \"springgreen\": \"#00ff7f\",\n  \"steelblue\": \"#4682b4\",\n  \"tan\": \"#d2b48c\",\n  \"teal\": \"#008080\",\n  \"thistle\": \"#d8bfd8\",\n  \"tomato\": \"#ff6347\",\n  \"turquoise\": \"#40e0d0\",\n  \"violet\": \"#ee82ee\",\n  \"wheat\": \"#f5deb3\",\n  \"white\": \"#ffffff\",\n  \"whitesmoke\": \"#f5f5f5\",\n  \"yellow\": \"#ffff00\",\n  \"yellowgreen\": \"#9acd32\",\n  \"transparent\": \"#00000000\"\n}\n","import * as C from \"colorizr\";\nimport type { ParsingOptions, Rgb, Rgb8Bit, RgbScalar } from \"./types.js\";\nimport { numberInclusiveRangeTest, numberTest } from \"@ixfx/guards\";\nimport { resultThrow } from \"@ixfx/guards\";\nimport { cssDefinedHexColours } from \"./css-colours.js\";\n\nexport const withOpacity = <T extends Rgb>(value: T, fn: (opacityScalar: number, value: T) => number): T => {\n  switch (value.unit) {\n    case `8bit`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 255) / 255, value) * 255\n      }\n    case `scalar`:\n      return {\n        ...value,\n        opacity: fn((value.opacity ?? 1), value)\n      }\n  }\n}\n\nexport const fromHexString = (hexString: string): Rgb8Bit => fromLibrary(C.hex2rgb(hexString));\nconst srgbTansparent: Rgb8Bit = Object.freeze({\n  r: 0, g: 0, b: 0, opacity: 0, unit: `8bit`, space: `srgb`\n});\n\nexport const fromCss8bit = (value: string, options: ParsingOptions<Rgb8Bit> = {}): Rgb8Bit => {\n  value = value.toLowerCase();\n  if (value.startsWith(`#`)) {\n    return fromHexString(value);\n\n  }\n  if (value === `transparent`) return srgbTansparent;\n  if (typeof cssDefinedHexColours[ value ] !== `undefined`) {\n    return fromHexString(cssDefinedHexColours[ value ] as string);\n  }\n\n  if (!value.startsWith(`rgb(`) && !value.startsWith(`rgba(`)) {\n    try {\n      const converted = C.convert(value, `rgb`);\n      value = converted;\n    } catch (error) {\n      if (options.fallbackString) {\n        value = options.fallbackString;\n      } else {\n        throw error;\n      }\n    }\n  }\n  const c = C.extractColorParts(value);\n  if (c.model !== `rgb`) throw new Error(`Expecting RGB colour space. Got: ${ c.model }`);\n  return fromLibrary(c as any as C.RGB);\n}\n\nexport const toCssString = (rgb: Rgb): string => {\n  guard(rgb);\n  switch (rgb.unit) {\n    case `8bit`:\n      if (rgb.opacity === undefined || rgb.opacity === 255) {\n        return `rgb(${ rgb.r } ${ rgb.b } ${ rgb.g })`;\n      }\n      return `rgb(${ rgb.r } ${ rgb.b } ${ rgb.g } / ${ (rgb.opacity ?? 255) / 255 })`;\n    case `scalar`:\n      if (rgb.opacity === undefined || rgb.opacity === 1) {\n        return `rgb(${ rgb.r * 100 }% ${ rgb.b * 100 }% ${ rgb.g * 100 }%)`;\n      }\n      return `rgb(${ rgb.r * 100 }% ${ rgb.b * 100 }% ${ rgb.g * 100 }% / ${ (rgb.opacity ?? 1) * 100 }%)`;\n    default:\n\n      throw new Error(`Unknown unit: ${ (rgb as any).unit }`);\n  }\n}\n\nconst toLibrary = (rgb: Rgb): C.RGB => {\n  const abs = to8bit(rgb);\n  return {\n    r: abs.r,\n    g: abs.g,\n    b: abs.b,\n    alpha: abs.opacity,\n  }\n}\n\nconst fromLibrary = (rgb: C.RGB): Rgb8Bit => {\n  return {\n    r: rgb.r,\n    g: rgb.g,\n    b: rgb.b,\n    opacity: rgb.alpha ?? 255,\n    unit: `8bit`,\n    space: `srgb`\n  }\n}\n\nexport const to8bit = (rgb: Rgb): Rgb8Bit => {\n  guard(rgb);\n  if (rgb.unit === `8bit`) return rgb;\n  return {\n    r: rgb.r * 255,\n    g: rgb.g * 255,\n    b: rgb.b * 255,\n    opacity: rgb.opacity ?? 255,\n    unit: `8bit`,\n    space: `srgb`\n  }\n}\n\nexport const toScalar = (rgb: Rgb): RgbScalar => {\n  guard(rgb);\n  if (rgb.unit === `scalar`) return rgb;\n  return {\n    r: rgb.r / 255,\n    g: rgb.g / 255,\n    b: rgb.b / 255,\n    opacity: (rgb.opacity ?? 1) / 255,\n    unit: `scalar`,\n    space: `srgb`\n  }\n}\n\nexport const guard = (rgb: Rgb) => {\n  const { r, g, b, opacity, space, unit } = rgb;\n  if (space !== `srgb`) throw new Error(`Space is expected to be 'srgb'. Got: ${ space }`);\n  if (unit === `8bit`) {\n    resultThrow(\n      numberInclusiveRangeTest(r, 0, 255, `r`),\n      numberInclusiveRangeTest(g, 0, 255, `g`),\n      numberInclusiveRangeTest(b, 0, 255, `b`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberInclusiveRangeTest(opacity, 0, 255, `opacity`);\n        }\n      }\n    );\n  } else if (unit === `scalar`) {\n    resultThrow(\n      numberTest(r, `percentage`, `r`),\n      numberTest(g, `percentage`, `g`),\n      numberTest(b, `percentage`, `b`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberTest(opacity, `percentage`, `opacity`);\n        }\n      });\n  } else {\n    throw new Error(`Unit is expected to be '8bit' or 'scalar'. Got: ${ unit }`);\n  }\n}\n\n//export const SrgbSpace = { withOpacity, toCssString, fromHexString, fromCss8bit, toLibrary, fromLibrary, guard, toScalar, to8bit };\n","import { Grids } from '@ixfx/geometry';\nimport * as SrgbSpace from './colour/srgb.js';\nimport type { Rgb, Rgb8Bit } from './colour/types.js';\n\n/**\n * Returns a {@link @ixfx/geometry/Grids.Grid} based on the provided `image`\n * @param image ImageData\n * @returns Grid\n */\nexport const grid = (image: ImageData): Grids.Grid => {\n  const g = { rows: image.width, cols: image.height };\n  return g;\n}\n\n/**\n * Returns an object that allows get/set grid semantics on the underlying `image` data.\n * Uses 8-bit sRGB values, meaning 0..255 range for red, green, blue & opacity.\n * \n * ```js\n * // Get CANVAS element, drawing context and then image data\n * const canvasEl = document.querySelector(`#my-canvas`);\n * const ctx = canvasEl.getContext(`2d`);\n * const imageData = ctx.getImageData();\n * \n * // Now that we have image data, we can wrap it:\n * const asGrid = ImageDataGrid.wrap(imageData);\n * asGrid.get({ x:10, y: 20 }); // Get pixel at 10,20\n * asGrid.set(colour, { x:10, y: 20 }); // Set pixel value\n * \n * // Display changes back on the canvas\n * ctx.putImageData(imageData, 0, 0)\n * ```\n * @param image \n * @returns \n */\nexport const wrap = (image: ImageData): Grids.GridWritable<Rgb8Bit> & Grids.GridReadable<Rgb8Bit> => {\n  return {\n    ...grid(image),\n    get: accessor(image),\n    set: setter(image)\n  }\n}\n\n/**\n * Returns a function to access pixel values by x,y\n * @param image \n * @returns \n */\nexport const accessor = (image: ImageData): Grids.GridCellAccessor<Rgb8Bit> => {\n  const g = grid(image);\n  const data = image.data;\n\n  const fn: Grids.GridCellAccessor<Rgb8Bit> = (cell: Grids.GridCell, bounds = `undefined`) => {\n    const index = Grids.indexFromCell(g, cell, bounds);\n    if (index === undefined) return;\n    const pxIndex = index * 4;\n    return {\n      r: data[ pxIndex ],\n      g: data[ pxIndex + 1 ],\n      b: data[ pxIndex + 2 ],\n      opacity: data[ pxIndex + 3 ],\n      unit: `8bit`,\n      space: `srgb`\n    };\n  };\n  return fn;\n};\n\n/**\n * Returns a function that sets pixel values\n * @param image \n * @returns \n */\nexport const setter = (image: ImageData): Grids.GridCellSetter<Rgb> => {\n  const g = grid(image);\n  const data = image.data;\n\n  const fn: Grids.GridCellSetter<Rgb> = (value: Rgb, cell: Grids.GridCell, bounds = `undefined`) => {\n    const index = Grids.indexFromCell(g, cell, bounds);\n    if (index === undefined) throw new Error(`Cell out of range. ${ cell.x },${ cell.y }`);\n    const pixel = SrgbSpace.to8bit(value);\n    const pxIndex = index * 4;\n    data[ pxIndex ] = pixel.r;\n    data[ pxIndex + 1 ] = pixel.g;\n    data[ pxIndex + 2 ] = pixel.b;\n    data[ pxIndex + 3 ] = pixel.opacity ?? 255;\n  };\n  return fn;\n}\n\n// export function* visit(image: ImageData, visitor: Grids.VisitGenerator) {\n//   const a = accessor(image);\n\n//   for (const cell of visitor) {\n//     yield a(cell, `undefined`);\n//   }\n// }\n\n/**\n * Yields pixels of an image row by row\n * @param image \n */\nexport function* byRow(image: ImageData) {\n  const a = accessor(image);\n  const g = grid(image);\n\n  const v = Grids.As.rows(g, { x: 0, y: 0 });\n  for (const row of v) {\n    const pixels = row.map(p => a(p, `undefined`));\n    yield pixels\n  }\n}\n\n/**\n * Yields pixels of an image column by column\n * @param image \n */\nexport function* byColumn(image: ImageData) {\n  const a = accessor(image);\n  const g = grid(image);\n\n  for (let x = 0; x < g.cols; x++) {\n    const col: Rgb8Bit[] = [];\n    for (let y = 0; y < g.rows; y++) {\n      const p = a({ x, y }, `undefined`);\n      if (p) col.push(p);\n    }\n    yield col;\n  }\n}","import { ElementSizer, resolveEl, type ElementResizeLogic, type ElementSizerOptions } from '@ixfx/dom';\nimport { SimpleEventEmitter } from '@ixfx/events';\nimport type { ScaleBy, ScalerCombined } from '@ixfx/geometry';\nimport type { Rect, RectPositioned } from '@ixfx/geometry/rect';\nimport { Rects, scaler } from '@ixfx/geometry';\nimport * as Drawing from './drawing.js';\nimport * as ImageDataGrid from './image-data-grid.js';\nimport { cloneFromFields } from '@ixfx/core/records';\nimport type { Grid } from '@ixfx/geometry/grid';\n\nexport type CanvasEvents = {\n  /**\n   * Fired when canvas is resized\n   */\n  resize: { size: Rect, helper: CanvasHelper, ctx: CanvasRenderingContext2D }\n\n  /**\n   * Pointerdown. \n   * \n   * Adds logicalX/Y to get logical pixel coordinate\n   */\n  pointerdown: PointerEvent & { physicalX: number, physicalY: number },\n  /**\n * Pointerup. \n * \n * Adds logicalX/Y to get logical pixel coordinate\n */\n  pointerup: PointerEvent & { physicalX: number, physicalY: number },\n  /**\n * Pointermove \n * \n * Adds logicalX/Y to get logical pixel coordinate\n */\n  pointermove: PointerEvent & { physicalX: number, physicalY: number },\n}\n\n\n/**\n * CanvasHelper options\n */\nexport type CanvasHelperOptions = Readonly<{\n  /**\n   * Automatic canvas resizing logic.\n   */\n  resizeLogic?: ElementResizeLogic\n  /**\n   * By default, the helper emits pointer events from the canvas.\n   * Set this to _true_ to disable.\n   */\n  disablePointerEvents: boolean\n  /**\n   * By default the display DPI is used for scaling.\n   * If this is set, this will override.\n   */\n  pixelZoom: number\n  /**\n   * If _true_ (default) canvas is cleared when a resize happens\n   */\n  clearOnResize: boolean\n  /**\n   * If true, it won't add any position CSS\n   */\n  skipCss: boolean;\n  coordinateScale: ScaleBy;\n  /**\n   * Callback when canvas is resized\n   * @param size \n   * @returns \n   */\n  onResize?: (ctx: CanvasRenderingContext2D, size: Rect, helper: CanvasHelper) => void\n  /**\n   * Logical width of canvas.\n   * This is used for establishing the desired aspect ratio.\n   */\n  width: number\n  /**\n   * Logical height of canvas.\n   * This is used for establishing the desired aspect ratio.\n   */\n  height: number\n  /**\n   * If set, the z-index for this canvas.\n   * By default, fullscreen canvas will be given -1\n   */\n  zIndex: number\n  /**\n   * Colour space to use. Defaults to sRGB.\n   */\n  colourSpace: PredefinedColorSpace;\n\n  /**\n   * If specified, this function be called in an animation loop.\n   * @param ctx Drawing context\n   * @param size Viewport size\n   * @param helper CanvasHelper instance\n   * @returns \n   */\n  draw?: (ctx: CanvasRenderingContext2D, size: Rect, helper: CanvasHelper) => void\n}>;\n\n\n/**\n * A wrapper for the CANVAS element that scales the canvas for high-DPI displays\n * and helps with resizing.\n * \n * ```js\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both` });\n * const { ctx, width, height } = canvas.ctx; // Get drawing context, width & height\n * ```\n * \n * Draw whenever it is resized using the 'resize' event\n * ```js\n * canvas.addEventListener(`resize`, ({ctx, size}) => {\n *  // Use ctx...  \n * });\n * ```\n * \n * Or provide a function when initialising:\n * ```js\n * const onResize = (ctx, size) => {\n *  // Do drawing\n * }\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both`, onResize });\n * ```\n * \n * Automatically draw at animation speeds:\n * ```js\n * const draw = () => {\n * }\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both`, draw });\n * ```\n */\nexport class CanvasHelper extends SimpleEventEmitter<CanvasEvents> {\n  readonly el: HTMLCanvasElement;\n  readonly opts: CanvasHelperOptions\n\n  #scaler: ScalerCombined;\n  #scalerSize: ScalerCombined;\n  #viewport: RectPositioned = Rects.EmptyPositioned;\n  #logicalSize: Rect = Rects.Empty;\n  #ctx: CanvasRenderingContext2D | undefined;\n  #drawHelper: Drawing.DrawingHelper | undefined;\n  #resizer: ElementSizer<HTMLCanvasElement> | undefined;\n  #disposed = false;\n\n  constructor(domQueryOrEl: Readonly<string | HTMLCanvasElement | undefined | null>, opts: Partial<CanvasHelperOptions> = {}) {\n    super();\n    if (!domQueryOrEl) throw new Error(`Param 'domQueryOrEl' is null or undefined`);\n    this.el = resolveEl<HTMLCanvasElement>(domQueryOrEl);\n    if (this.el.nodeName !== `CANVAS`) {\n      throw new Error(`Expected CANVAS HTML element. Got: ${ this.el.nodeName }`);\n    }\n\n    const size = this.el.getBoundingClientRect();\n    this.opts = {\n      resizeLogic: opts.resizeLogic ?? `none`,\n      disablePointerEvents: opts.disablePointerEvents ?? false,\n      pixelZoom: opts.pixelZoom ?? (window.devicePixelRatio || 1),\n      height: opts.height ?? size.height,\n      width: opts.width ?? size.width,\n      zIndex: opts.zIndex ?? -1,\n      coordinateScale: opts.coordinateScale ?? `both`,\n      onResize: opts.onResize,\n      clearOnResize: opts.clearOnResize ?? true,\n      draw: opts.draw,\n      skipCss: opts.skipCss ?? false,\n      colourSpace: `srgb`\n    }\n\n    this.#scaler = scaler(`both`);\n    this.#scalerSize = scaler(`both`, size);\n    this.#init();\n  }\n\n  getRectangle(): RectPositioned {\n    return {\n      x: 0, y: 0,\n      ...this.#logicalSize\n    }\n  }\n  dispose(reason?: string) {\n    if (this.#disposed) return;\n    this.#disposed = true;\n    if (this.#resizer) {\n      this.#resizer.dispose(`CanvasHelper disposing ${ reason }`.trim());\n      this.#resizer = undefined;\n    }\n  }\n\n  #getContext(reset = false) {\n    if (this.#ctx === undefined || reset) {\n      const ratio = this.ratio;\n      const c = this.el.getContext(`2d`);\n      if (c === null) throw new Error(`Could not create drawing context`);\n      this.#ctx = c;\n      // Reset scale\n      c.setTransform(1, 0, 0, 1, 0, 0);\n      c.scale(ratio, ratio);\n    }\n    return this.#ctx;\n  };\n\n  /**\n   * Gets the drawable area of the canvas.\n   * This accounts for scaling due to high-DPI displays etc.\n   * @returns \n   */\n  getPhysicalSize() {\n    return {\n      width: this.width * this.ratio,\n      height: this.height * this.ratio\n    }\n  }\n\n  /**\n   * Creates a drawing helper for the canvas.\n   * If one is already created it is reused.\n   */\n  getDrawHelper() {\n    if (!this.#drawHelper) {\n      this.#drawHelper = Drawing.makeHelper(this.#getContext(), {\n        width: this.width, height: this.height\n      });\n    }\n  }\n\n  setLogicalSize(logicalSize: Rect) {\n    Rects.guard(logicalSize, `logicalSize`);\n    const logicalSizeInteger = Rects.applyFields(v => Math.floor(v), logicalSize);\n    const ratio = this.opts.pixelZoom;\n\n    // Scaler for going between relative and logical units\n    this.#scaler = scaler(this.opts.coordinateScale, logicalSize);\n    this.#scalerSize = scaler(`both`, logicalSize);\n\n    // Scaled logical size for DPI\n    const pixelScaled = Rects.multiplyScalar(logicalSize, ratio);\n\n    // Canvas will actually be much larger, based on DPI\n    this.el.width = pixelScaled.width;\n    this.el.height = pixelScaled.height;\n\n    // But scaled down on screen\n    this.el.style.width = logicalSizeInteger.width.toString() + `px`;\n    this.el.style.height = logicalSizeInteger.height.toString() + `px`;\n\n    // Since dimensions have change, reset context\n    this.#getContext(true);\n\n    if (this.opts.clearOnResize) {\n      this.ctx.clearRect(0, 0, this.width, this.height);\n    }\n\n    this.#logicalSize = logicalSizeInteger;\n\n    //console.log(`setting logical size to ${ this.#logicalSize.width }x${ this.#logicalSize.height }`);\n    // Notify listeners of resize\n    const r = this.opts.onResize;\n    if (r) {\n      setTimeout(() => { r(this.ctx, this.size, this) }, 100);\n    }\n    this.fireEvent(`resize`, { ctx: this.ctx, size: this.#logicalSize, helper: this });\n  }\n\n\n  #init() {\n    //console.log(`init`, this.opts);\n\n    // If there is a 'draw' callback, set up an animation loop\n    const d = this.opts.draw;\n    if (d) {\n      const sched = () => {\n        d(this.ctx, this.#logicalSize, this);\n        requestAnimationFrame(sched);\n      }\n      setTimeout(() => { sched() }, 100);\n    }\n\n    if (!this.opts.disablePointerEvents) {\n      this.#handleEvents();\n    }\n\n    const resizeLogic = this.opts.resizeLogic ?? `none`;\n    if (resizeLogic === `none`) {\n      this.setLogicalSize({ width: this.opts.width, height: this.opts.height });\n    } else {\n      const resizerOptions: ElementSizerOptions<HTMLCanvasElement> = {\n        onSetSize: (size) => {\n          if (Rects.isEqual(this.#logicalSize, size)) return;\n          this.setLogicalSize(size);\n        },\n        naturalSize: { width: this.opts.width, height: this.opts.height },\n        stretch: this.opts.resizeLogic ?? `none`\n      };\n      this.#resizer = new ElementSizer(this.el, resizerOptions);\n    }\n\n    this.#getContext();\n  }\n\n  #handleEvents() {\n    const handlePointerEvent = (event: PointerEvent) => {\n      const { offsetX, offsetY } = event;\n      const physicalX = offsetX * this.ratio;\n      const physicalY = offsetY * this.ratio;\n      event = cloneFromFields(event);\n      const eventData = {\n        physicalX, physicalY,\n        // eslint-disable-next-line @typescript-eslint/no-misused-spread\n        ...event\n      };\n\n      switch (event.type) {\n        case `pointerup`: {\n          {\n            this.fireEvent(`pointerup`, eventData);\n            break;\n          };\n        }\n        case `pointermove`: {\n          {\n            this.fireEvent(`pointermove`, eventData);\n            break;\n          };\n        }\n        case `pointerdown`: {\n          {\n            this.fireEvent(`pointerup`, eventData);\n            break;\n          };\n        }\n      };\n    }\n\n    this.el.addEventListener(`pointermove`, handlePointerEvent);\n    this.el.addEventListener(`pointerdown`, handlePointerEvent);\n    this.el.addEventListener(`pointerup`, handlePointerEvent);\n  }\n\n  /**\n   * Clears the canvas.\n   * \n   * Shortcut for:\n   * `ctx.clearRect(0, 0, this.width, this.height)`\n   */\n  clear() {\n    if (!this.#ctx) return;\n    this.#ctx.clearRect(0, 0, this.width, this.height);\n\n  }\n\n  /**\n   * Fills the canvas with a given colour.\n   * \n   * Shortcut for:\n   * ```js\n      * ctx.fillStyle = ``;\n   * ctx.fillRect(0, 0, this.width, this.height);\n   * ```\n   * @param colour Colour\n   */\n  fill(colour?: string) {\n    if (!this.#ctx) return;\n    if (colour) this.#ctx.fillStyle = colour;\n    this.#ctx.fillRect(0, 0, this.width, this.height);\n\n  }\n  /**\n   * Gets the drawing context\n   */\n  get ctx() {\n    if (this.#ctx === undefined) throw new Error(`Context not available`);\n    return this.#getContext();\n  }\n\n  get viewport() {\n    return this.#viewport;\n  }\n\n  /**\n   * Gets the logical width of the canvas\n   * See also: {@link height}, {@link size}\n   */\n  get width() {\n    return this.#logicalSize.width;\n  }\n\n  /**\n   * Gets the logical height of the canvas\n   * See also: {@link width}, {@link size}\n   */\n  get height() {\n    return this.#logicalSize.height;\n  }\n\n  /**\n   * Gets the logical size of the canvas\n   * See also: {@link width}, {@link height}\n   */\n  get size() {\n    return this.#logicalSize;\n  }\n\n  /**\n   * Gets the current scaling ratio being used\n   * to compensate for high-DPI display\n   */\n  get ratio() {\n    return window.devicePixelRatio || 1;\n  }\n\n  /**\n   * Returns the width or height, whichever is smallest\n   */\n  get dimensionMin() {\n    return Math.min(this.width, this.height);\n  }\n\n  /**\n   * Returns the width or height, whichever is largest\n   */\n  get dimensionMax() {\n    return Math.max(this.width, this.height);\n  }\n\n\n\n  drawBounds(strokeStyle = `green`) {\n    const ctx = this.#getContext();\n    Drawing.rect(ctx,\n      { x: 0, y: 0, width: this.width, height: this.height },\n      { crossed: true, strokeStyle, strokeWidth: 1 });\n\n    Drawing.rect(ctx, this.#viewport, { crossed: true, strokeStyle: `silver`, strokeWidth: 3 })\n  }\n\n  /**\n   * Returns a Scaler that converts from absolute\n   * to relative coordinates.\n   * This is based on the canvas size.\n   * \n   * ```js\n      * // Assuming a canvas of 800x500\n   * toRelative({ x: 800, y: 600 });  // { x: 1,   y: 1 }\n   * toRelative({ x: 0, y: 0 });   // { x: 0,   y: 0 }\n   * toRelative({ x: 400, y: 300 }); // { x: 0.5, y: 0.5 }\n   * ```\n   */\n  get toRelative() {\n    return this.#scaler.rel;\n  }\n\n  /**\n   * Returns a scaler for points based on width & height\n   */\n  get toAbsoluteFixed() {\n    return this.#scalerSize.abs\n  }\n\n  /**\n   * Returns a scaler for points based on width & height\n   */\n  get toRelativeFixed() {\n    return this.#scalerSize.rel;\n  }\n\n  get logicalCenter() {\n    return {\n      x: this.#logicalSize.width / 2,\n      y: this.#logicalSize.height / 2\n    }\n  }\n\n  /**\n * Returns a Scaler that converts from relative to absolute\n * coordinates.\n * This is based on the canvas size.\n * \n * ```js\n * // Assuming a canvas of 800x600\n * toAbsolute({ x: 1, y: 1 });      // { x: 800, y: 600}\n * toAbsolute({ x: 0, y: 0 });      // { x: 0, y: 0}\n * toAbsolute({ x: 0.5, y: 0.5 });  // { x: 400, y: 300}\n * ```\n */\n  get toAbsolute() {\n    return this.#scaler.abs;\n  }\n\n  /**\n   * Gets the center coordinate of the canvas\n   */\n  get center() {\n    return { x: this.width / 2, y: this.height / 2 }\n  }\n\n  /**\n   * Gets the image data for the canvas.\n   * Uses the 'physical' canvas size. Eg. A logical size of 400x400 might be\n   * 536x536 with a high-DPI display.\n   * @returns \n   */\n  getImageData(): ImageData {\n    const size = this.getPhysicalSize();\n    const data = this.ctx.getImageData(0, 0, size.width, size.height, { colorSpace: this.opts.colourSpace });\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (data === null || data === undefined) throw new Error(`Could not get image data from context`);\n    return data;\n  }\n\n  /**\n   * Returns the canvas frame data as a writable grid.\n   * When editing, make as many edits as needed before calling\n   * `flip`, which writes buffer back to the canvas.\n   * ```js\n      * const g = helper.getWritableBuffer();\n   * // Get {r,g,b,opacity} of pixel 10,10\n   * const pixel = g.get({ x: 10, y: 10 });\n   * \n   * // Set a colour to pixel 10,10\n   * g.set({ r: 0.5, g: 1, b: 0, opacity: 0 }, { x: 10, y: 10 });\n   * \n   * // Write buffer to canvas\n   * g.flip();\n   * ```\n   * \n   * Uses 'physical' size of canvas. Eg with a high-DPI screen, this will\n   * mean a higher number of rows and columns compared to the logical size.\n   * @returns\n   */\n  getWritableBuffer() {\n    const ctx = this.ctx;\n    const data = this.getImageData();\n    const grid = ImageDataGrid.grid(data);\n    const get = ImageDataGrid.accessor(data);\n    const set = ImageDataGrid.setter(data);\n\n    const flip = () => {\n      ctx.putImageData(data, 0, 0);\n    }\n\n    return { grid, get, set, flip };\n  }\n}\n\n// export const imageDataAsGrid = (canvas: HTMLCanvasElement, colorSpace: PredefinedColorSpace = `srgb`) => {\n//   const ctx = canvas.getContext(`2d`);\n//   if (!ctx) throw new Error(`Could not create context`);\n\n//   const data = ctx.getImageData(0, 0, canvas.width, canvas.height, { colorSpace });\n//   if (!data) throw new Error(`Could not get image data from context`);\n\n//   const get = ImageDataGrid.accessor(data);\n//   const set = ImageDataGrid.setter(data);\n// }","import type { DrawingOpts } from \"./types.js\";\n\n/**\n * Applies drawing options to given SVG element.\n * Applies: fillStyle\n * @param elem Element\n * @param opts Drawing options\n */\nexport const applyOpts = (elem: SVGElement, opts: DrawingOpts) => {\n  if (opts.fillStyle) elem.setAttributeNS(null, `fill`, opts.fillStyle);\n  if (opts.opacity) {\n    elem.setAttributeNS(null, `opacity`, opts.opacity.toString());\n  }\n\n};","/**\n * Creates an element of `type` and with `id` (if specified)\n * @param type Element type, eg `circle`\n * @param id Optional id to assign to element\n * @returns Element\n */\nexport const createEl = <V extends SVGElement>(\n  type: string,\n  id?: string\n): V => {\n  const m = document.createElementNS(`http://www.w3.org/2000/svg`, type) as V;\n  if (id) {\n    m.id = id;\n  }\n  return m;\n};\n\n\n/**\n * Creates and appends a SVG element.\n *\n * ```js\n * // Create a circle\n * const circleEl = createOrResolve(parentEl, `SVGCircleElement`);\n * ```\n *\n * If `queryOrExisting` is specified, it is used as a query to find an existing element. If\n * query starts with `#`, this will be set as the element id, if created.\n *\n * ```js\n * // Creates an element with id 'myCircle' if it doesn't exist\n * const circleEl = createOrResolve(parentEl, `SVGCircleElement`, `#myCircle`);\n * ```\n * @param parent Parent element\n * @param type Type of SVG element\n * @param queryOrExisting Query, eg `#id`\n * @returns\n */\nexport const createOrResolve = <V extends SVGElement>(\n  parent: SVGElement,\n  type: string,\n  queryOrExisting?: string | V,\n  suffix?: string\n): V => {\n  let existing:SVGElement|HTMLElement|null = null;\n  if (queryOrExisting !== undefined) {\n    existing = typeof queryOrExisting === `string` ? parent.querySelector(queryOrExisting) : queryOrExisting;\n  }\n  if (existing === null) {\n    const p = document.createElementNS(`http://www.w3.org/2000/svg`, type) as V;\n    parent.append(p);\n    if (queryOrExisting && typeof queryOrExisting === `string` &&\n      queryOrExisting.startsWith(`#`)) {\n      p.id = suffix !== undefined && !queryOrExisting.endsWith(suffix) ? queryOrExisting.slice(1) + suffix : queryOrExisting.slice(1);\n    }\n    return p;\n  }\n  return existing as V;\n};","export type HslBase = {\n  /**\n   * Hue\n   */\n  h: number;\n  /**\n   * Saturation\n   */\n  s: number;\n  /**\n   * Lightness\n   */\n  l: number;\n  /**\n   * Opacity\n   */\n  opacity?: number,\n  space?: `hsl`\n}\n\nexport const isHsl = (v: any): v is Hsl => {\n  if (typeof v === `object`) {\n    if (!(`h` in v && `s` in v && `l` in v)) return false;\n    if (!(`unit` in v)) return false;\n    if (`space` in v) {\n      if (v.space !== `hsl`) return false;\n    }\n  }\n  return false;\n}\n\n/**\n * Scalar values use 0..1 for each field\n */\nexport type HslScalar = HslBase & { unit: `scalar` };\n\n/**\n * Absolute values use hue:0..360, all other fields 0..100\n */\nexport type HslAbsolute = HslBase & { unit: `absolute` };\n\n/**\n * HSL value.\n * By default assumes scalar coordinates (0..1) for each field.\n * Use 'absolute' unit for hue:0...360, all other fields on 0..100 scale.\n */\nexport type Hsl = HslScalar | HslAbsolute;\n\n/**\n * Rgb.\n * Units determine how to interperet rgb values.\n * * 'relative': 0..1 range for RGB & opacity\n * * '8bit': 0..255 range for RGB & opacity\n */\nexport type RgbBase = { r: number; g: number; b: number; opacity?: number, space?: `srgb` };\nexport type RgbScalar = RgbBase & { unit: `scalar` };\n\nexport const isRgb = (v: any): v is Rgb => {\n  if (typeof v === `object`) {\n    if (!(`r` in v && `g` in v && `b` in v)) return false;\n    if (!(`unit` in v)) return false;\n    if (`space` in v) {\n      if (v.space !== `srgb`) return false;\n    }\n  }\n  return false;\n}\n\n/**\n * If the input object has r,g&b properties, it will return a fully-\n * formed Rgb type with `unit` and `space` properties.\n * \n * If it lacks these basic three properties or they are out of range,\n *  _undefined_ is returned.\n * \n * If RGB values are less than 1 assumes unit:scalar. Otherwise unit:8bit.\n * If RGB values exceed 255, _undefined_ returned.\n * @param v \n * @returns \n */\nexport const tryParseObjectToRgb = (v: any): Rgb | undefined => {\n  if (!(`r` in v && `g` in v && `b` in v)) return;\n  if (!(`unit` in v)) {\n    if (v.r <= 1 && v.g <= 1 && v.b <= 1) {\n      v.unit = `scalar`;\n    } else if (v.r > 255 && v.g <= 255 && v.b <= 255) {\n      return; // out of range\n    } else {\n      v.unit = `8bit`;\n    }\n  }\n  if (!(`space` in v)) {\n    v.space = `srgb`;\n  }\n  return v as Rgb;\n}\n\nexport const tryParseObjectToHsl = (v: any): Hsl | undefined => {\n  if (!(`h` in v && `s` in v && `l` in v)) return;\n  if (!(`unit` in v)) {\n    if (v.r <= 1 && v.g <= 1 && v.b <= 1) {\n      v.unit = `scalar`;\n    } else if (v.s > 100 && v.l <= 100) {\n      return; // out of range\n    } else {\n      v.unit = `absolute`;\n    }\n  }\n  if (!(`space` in v)) {\n    v.space = `hsl`;\n  }\n  return v as Hsl;\n}\n/**\n * RGB in 0...255 range, including opacity.\n */\nexport type Rgb8Bit = RgbBase & { unit: `8bit` };\nexport type Rgb = RgbScalar | Rgb8Bit;\n\nexport type LchBase = {\n  /**\n   * Lightness/perceived brightnes\n   */\n  l: number,\n  /**\n   * Chroma ('amount of colour')\n   */\n  c: number,\n  /**\n   * Hue\n   */\n  h: number,\n  /**\n   * Opacity on 0..1 scale\n   */\n  opacity?: number,\n  space: `lch` | `oklch`\n}\n\nexport const isLch = (v: any): v is OkLch => {\n  if (typeof v === `object`) {\n    if (!(`l` in v && `c` in v && `h` in v)) return false;\n    if (!(`unit` in v)) return false;\n    if (`space` in v) {\n      if (v.space !== `lch` && v.space !== `oklch`) return false;\n    }\n  }\n  return false;\n}\n\nexport type OkLchBase = LchBase & { space: `oklch` }\n/**\n * Oklch colour expressed in 0..1 scalar values for LCH & opacity\n */\nexport type OkLchScalar = OkLchBase & { unit: `scalar` }\n/**\n * Oklch colour expressed with:\n * l: 0..100\n * c: 0..100\n * h: 0..360 degrees \n * opacity: 0..1\n */\nexport type OkLchAbsolute = OkLchBase & { unit: `absolute` }\nexport type OkLch = OkLchAbsolute | OkLchScalar;\n\nexport type Colour = { opacity?: number } & (Hsl | OkLch | Rgb);\n\n/**\n * A representation of colour. Eg: `blue`, `rgb(255,0,0)`, `hsl(20,100%,50%)`\n */\nexport type Colourish = Colour | string;\n\nexport const isColourish = (v: any): v is Colourish => {\n  if (typeof v === `string`) return true;\n  if (typeof v !== `object`) return false;\n  if (isHsl(v)) return true;\n  if (isLch(v)) return true;\n  if (isRgb(v)) return true;\n  return false;\n}\n\n// export type ColourRgb = {\n//   space:`rgb`\n//   coords: Rgba\n// }\n// export type ColourHsl = {\n//   space:`hsl`;\n//   coords: Hsla;\n// }\n\n// export type Colour = ColourHsl|ColourRgb;\n\n/**\n * Options for interpolation\n */\n// export type ColourInterpolationOpts = {\n//   space: Spaces,\n//   hue: `longer` | `shorter` | `increasing` | `decreasing` | `raw`\n// };\n\nexport type ParsingOptions<T> = Partial<{\n  ensureSafe: boolean\n  /**\n   * Value to use if input is invalid\n   */\n  fallbackString: string\n  /**\n   * Fallback colour to use if value cannot be parsed\n   */\n  fallbackColour: T\n}>","import * as C from \"colorizr\";\nimport { isColourish, isHsl, isRgb, tryParseObjectToHsl, tryParseObjectToRgb, type Colour, type Colourish } from \"./types.js\";\nimport * as  SrgbSpace from \"./srgb.js\";\nimport * as HslSpace from './hsl.js';\nimport { fromCssColour } from \"./css-colours.js\";\n\n\nexport const toCssColour = (colour: any): string => {\n  if (typeof colour === `string`) return colour;\n\n  if (isHsl(colour)) {\n    return HslSpace.toCssString(colour);\n  }\n  if (isRgb(colour)) {\n    return SrgbSpace.toCssString(colour);\n  }\n\n  const asRgb = tryParseObjectToRgb(colour);\n  if (asRgb) return SrgbSpace.toCssString(asRgb);\n\n  const asHsl = tryParseObjectToHsl(colour);\n  if (asHsl) return HslSpace.toCssString(asHsl);\n\n  throw new Error(`Unknown colour format: '${ JSON.stringify(colour) }'`);\n\n}\n\n\n\nexport const convert = (colour: string, destination: 'hex' | 'hsl' | 'oklab' | 'oklch' | 'srgb' | `rgb`): string => {\n  if (destination === `srgb`) destination = `rgb`;\n  return C.convert(colour, destination);\n}\n\nexport const guard = (colour: Colour) => {\n  switch (colour.space) {\n    case `hsl`:\n      HslSpace.guard(colour);\n      break;\n    case `srgb`:\n      SrgbSpace.guard(colour);\n      break;\n    default:\n      throw new Error(`Unknown colour space: '${ colour.space }'`);\n  }\n}\n\nexport const toColour = (colourish: any): Colour => {\n  if (!isColourish(colourish)) throw new Error(`Could not parse input. Expected CSS colour string or structured colour {r,g,b}, {h,s,l} etc.`);\n  let c: Colour | undefined;\n  if (typeof colourish === `string`) c = fromCssColour(colourish);\n  else c = colourish;\n  if (c === undefined) throw new Error(`Could not parse input. Expected CSS colour string or structured colour {r,g,b}, {h,s,l} etc.`);\n\n  guard(c);\n  return c;\n}\n\n/**\n * Returns a CSS-ready string\n * representation.\n * ```js\n * element.style.backgroundColor = resolveToString(`red`);\n * ```\n * \n * Tries each parameter in turn, returning the value\n * for the first that resolves. This can be useful for\n * having fallback values.\n * \n * ```js\n * // Try a CSS variable, a object property or finally fallback to red.\n * element.style.backgroundColor = toStringFirst('--some-var', opts.background, `red`);\n * ```\n * @param colours Array of colours to resolve\n * @returns \n */\nexport const toStringFirst = (...colours: (Colourish | undefined)[]): string => {\n  for (const colour of colours) {\n    if (colour === undefined) continue;\n    if (colour === null) continue;\n    try {\n      const c = toColour(colour);\n      return toCssColour(c);\n    } catch { /* empty */ }\n  }\n  return `rebeccapurple`;\n}","import type { StrokeOpts } from \"./types.js\";\n\n/**\n * Applies drawing options to given SVG element.\n * Applies: strokeStyle, strokeWidth, strokeDash, strokeLineCap\n * @param elem Element\n * @param opts\n */\nexport const applyStrokeOpts = (elem: SVGElement, opts: StrokeOpts) => {\n  if (opts.strokeStyle) elem.setAttributeNS(null, `stroke`, opts.strokeStyle);\n  if (opts.strokeWidth) {\n    elem.setAttributeNS(null, `stroke-width`, opts.strokeWidth.toString());\n  }\n  if (opts.strokeDash) elem.setAttribute(`stroke-dasharray`, opts.strokeDash);\n  if (opts.strokeLineCap) {\n    elem.setAttribute(`stroke-linecap`, opts.strokeLineCap);\n  }\n};","\n//import type { CirclePositioned } from '../../geometry/circle/CircleType.js';\n//import type { Point } from '../../geometry/point/PointType.js';\n//import type { Line } from '../../geometry/line/LineType.js';\n//import * as Lines from '../geometry/line/index.js';\nimport { Lines, Polar } from '@ixfx/geometry';\n//import * as Svg from './index.js';\nimport { toStringFirst as ColourStringFirst } from '../colour/conversion.js';\n//import { getCssVariable } from '../colour/index.js';\nimport type { CircleDrawingOpts, LineDrawingOpts, PathDrawingOpts, TextDrawingOpts, TextPathDrawingOpts } from './types.js';\nimport { applyOpts } from './apply.js';\nimport { applyStrokeOpts } from './stroke.js';\nimport { createEl, createOrResolve } from './create.js';\nimport { applyPathOpts } from './path.js';\nimport type { CirclePositioned } from '@ixfx/geometry/circle';\nimport type { Line } from '@ixfx/geometry/line';\nimport type { Point } from '@ixfx/geometry/point';\n//import type { PolarRay } from 'src/geometry/polar/Types.js';\n//import { toCartesian as polarRayToCartesian } from 'src/geometry/polar/Ray.js';\n//import {Palette} from \".\";\n\nconst numberOrPercentage = (v: number): string => {\n  if (v >= 0 && v <= 1) return `${ v * 100 }%`;\n  return v.toString();\n};\n\n/**\n * Creates and adds an SVG path element\n * @example\n * ```js\n * const paths = [\n *  `M300,200`,\n *  `a25,25 -30 0,1 50, -25 l 50,-25`\n * ]\n * const pathEl = path(paths, parentEl);\n * ```\n * @param svgOrArray Path syntax, or array of paths. Can be empty if path data will be added later\n * @param parent SVG parent element\n * @param opts Options Drawing options\n * @returns\n */\nexport const path = (\n  svgOrArray: string | readonly string[],\n  parent: SVGElement,\n  opts?: PathDrawingOpts,\n  queryOrExisting?: string | SVGPathElement\n): SVGPathElement => {\n  const elem = createOrResolve<SVGPathElement>(\n    parent,\n    `path`,\n    queryOrExisting\n  );\n  const svg =\n    typeof svgOrArray === `string` ? svgOrArray : svgOrArray.join(`\\n`);\n\n  elem.setAttributeNS(null, `d`, svg);\n  parent.append(elem);\n  return pathUpdate(elem, opts);\n};\n\nexport const pathUpdate = (\n  elem: SVGPathElement,\n  opts?: PathDrawingOpts\n) => {\n  if (opts) applyOpts(elem, opts);\n  if (opts) applyStrokeOpts(elem, opts);\n  return elem;\n};\n\n/**\n * Updates an existing `SVGCircleElement` with potentially updated circle data and drawing options\n * @param elem Element\n * @param circle Circle\n * @param opts Drawing options\n * @returns SVGCircleElement\n */\nexport const circleUpdate = (\n  elem: SVGCircleElement,\n  circle: CirclePositioned,\n  opts?: CircleDrawingOpts\n) => {\n  elem.setAttributeNS(null, `cx`, circle.x.toString());\n  elem.setAttributeNS(null, `cy`, circle.y.toString());\n  elem.setAttributeNS(null, `r`, circle.radius.toString());\n  if (opts) applyOpts(elem, opts);\n  if (opts) applyStrokeOpts(elem, opts);\n\n  return elem;\n};\n\n/**\n * Creates or reuses a `SVGCircleElement`.\n *\n * To update an existing element, use `circleUpdate`\n * @param circle\n * @param parent\n * @param opts\n * @param queryOrExisting\n * @returns\n */\nexport const circle = (\n  circle: CirclePositioned,\n  parent: SVGElement,\n  opts?: CircleDrawingOpts,\n  queryOrExisting?: string | SVGCircleElement\n): SVGCircleElement => {\n  const p = createOrResolve<SVGCircleElement>(\n    parent,\n    `circle`,\n    queryOrExisting\n  );\n  return circleUpdate(p, circle, opts);\n};\n\n/**\n * Creates or resuses a `SVGGElement` (group)\n *\n * To update an existing elemnet, use `groupUpdate`\n * @param children\n * @param parent\n * @param queryOrExisting\n * @returns\n */\nexport const group = (\n  children: readonly SVGElement[],\n  parent: SVGElement,\n  queryOrExisting?: string | SVGGElement\n): SVGGElement => {\n  const p = createOrResolve<SVGGElement>(parent, `g`, queryOrExisting);\n  return groupUpdate(p, children);\n};\n\nexport const groupUpdate = (\n  elem: SVGGElement,\n  children: readonly SVGElement[]\n) => {\n  for (const c of children) {\n    if (c.parentNode !== elem) {\n      elem.append(c);\n    }\n  }\n\n  return elem;\n};\n\n/**\n * Creates or reuses a SVGLineElement.\n *\n * @param line\n * @param parent\n * @param opts\n * @param queryOrExisting\n * @returns\n */\nexport const line = (\n  line: Line,\n  parent: SVGElement,\n  opts?: LineDrawingOpts,\n  queryOrExisting?: string | SVGLineElement\n): SVGLineElement => {\n  const lineEl = createOrResolve<SVGLineElement>(\n    parent,\n    `line`,\n    queryOrExisting\n  );\n  return lineUpdate(lineEl, line, opts);\n};\n\n/**\n * Updates a SVGLineElement instance with potentially changed line and drawing data\n * @param lineEl\n * @param line\n * @param opts\n * @returns\n */\nexport const lineUpdate = (\n  lineEl: SVGLineElement,\n  line: Line,\n  opts?: LineDrawingOpts\n) => {\n  lineEl.setAttributeNS(null, `x1`, line.a.x.toString());\n  lineEl.setAttributeNS(null, `y1`, line.a.y.toString());\n  lineEl.setAttributeNS(null, `x2`, line.b.x.toString());\n  lineEl.setAttributeNS(null, `y2`, line.b.y.toString());\n  if (opts) applyOpts(lineEl, opts);\n  if (opts) applyPathOpts(lineEl, opts);\n  if (opts) applyStrokeOpts(lineEl, opts);\n  return lineEl;\n};\n\nexport const polarRayUpdate = (lineEl: SVGLineElement, ray: Polar.PolarRay, opts?: LineDrawingOpts) => {\n  const l = Polar.Ray.toCartesian(ray);\n  lineEl.setAttributeNS(null, `x1`, l.a.x.toString());\n  lineEl.setAttributeNS(null, `y1`, l.a.y.toString());\n  lineEl.setAttributeNS(null, `x2`, l.b.x.toString());\n  lineEl.setAttributeNS(null, `y2`, l.b.y.toString());\n  if (opts) applyOpts(lineEl, opts);\n  if (opts) applyPathOpts(lineEl, opts);\n  if (opts) applyStrokeOpts(lineEl, opts);\n  return lineEl;\n}\n\n/**\n * Updates an existing SVGTextPathElement instance with text and drawing options\n * @param el\n * @param text\n * @param opts\n * @returns\n */\nexport const textPathUpdate = (\n  el: SVGTextPathElement,\n  text?: string,\n  opts?: TextPathDrawingOpts\n) => {\n  if (opts?.method) el.setAttributeNS(null, `method`, opts.method);\n  if (opts?.side) el.setAttributeNS(null, `side`, opts.side);\n  if (opts?.spacing) el.setAttributeNS(null, `spacing`, opts.spacing);\n  if (opts?.startOffset) {\n    el.setAttributeNS(null, `startOffset`, numberOrPercentage(opts.startOffset));\n  }\n  if (opts?.textLength) {\n    el.setAttributeNS(null, `textLength`, numberOrPercentage(opts.textLength));\n  }\n\n  if (text) {\n    el.textContent = text;\n  }\n  if (opts) applyOpts(el, opts);\n  if (opts) applyStrokeOpts(el, opts);\n  return el;\n};\n\n/**\n * Creates or reuses a SVGTextPathElement.\n * @param pathReference\n * @param text\n * @param parent\n * @param opts\n * @param textQueryOrExisting\n * @param pathQueryOrExisting\n * @returns\n */\nexport const textPath = (\n  pathReference: string,\n  text: string,\n  parent: SVGElement,\n  opts?: TextPathDrawingOpts,\n  textQueryOrExisting?: string | SVGTextElement,\n  pathQueryOrExisting?: string | SVGTextPathElement\n): SVGTextPathElement => {\n  const textEl = createOrResolve<SVGTextElement>(\n    parent,\n    `text`,\n    textQueryOrExisting, `-text`\n  );\n  // Update text properties, but don't pass in position or text\n  textUpdate(textEl, undefined, undefined, opts);\n\n  const p = createOrResolve<SVGTextPathElement>(\n    textEl,\n    `textPath`,\n    pathQueryOrExisting\n  );\n  p.setAttributeNS(null, `href`, pathReference);\n  return textPathUpdate(p, text, opts);\n};\n\n/**\n * Updates an existing SVGTextElement instance with position, text and drawing options\n * @param el\n * @param pos\n * @param text\n * @param opts\n * @returns\n */\nexport const textUpdate = (\n  el: SVGTextElement,\n  pos?: Point,\n  text?: string,\n  opts?: TextDrawingOpts\n) => {\n  if (pos) {\n    el.setAttributeNS(null, `x`, pos.x.toString());\n    el.setAttributeNS(null, `y`, pos.y.toString());\n  }\n  if (text) {\n    el.textContent = text;\n  }\n\n  if (opts) {\n    applyOpts(el, opts);\n    if (opts) applyStrokeOpts(el, opts);\n\n    if (opts.anchor) el.setAttributeNS(null, `text-anchor`, opts.anchor);\n    if (opts.align) el.setAttributeNS(null, `alignment-baseline`, opts.align);\n\n    const userSelect = opts.userSelect ?? true;\n\n    if (!userSelect) {\n      el.style.userSelect = `none`;\n    }\n  }\n  return el;\n};\n\n/**\n * Creates or reuses a SVGTextElement\n * @param pos Position of text\n * @param text Text\n * @param parent\n * @param opts\n * @param queryOrExisting\n * @returns\n */\nexport const text = (\n  text: string,\n  parent: SVGElement,\n  pos?: Point,\n  opts?: TextDrawingOpts,\n  queryOrExisting?: string | SVGTextElement\n): SVGTextElement => {\n  const p = createOrResolve<SVGTextElement>(\n    parent,\n    `text`,\n    queryOrExisting\n  );\n  return textUpdate(p, pos, text, opts);\n};\n\n/**\n * Creates a square grid based at a center point, with cells having `spacing` height and width.\n *\n * It fits in as many cells as it can within `width` and `height`.\n *\n * Returns a SVG group, consisting of horizontal and vertical lines\n * @param parent Parent element\n * @param center Center point of grid\n * @param spacing Width/height of cells\n * @param width How wide grid should be\n * @param height How high grid should be\n * @param opts\n */\nexport const grid = (\n  parent: SVGElement,\n  center: Point,\n  spacing: number,\n  width: number,\n  height: number,\n  opts: LineDrawingOpts = {}\n) => {\n  if (!opts.strokeStyle) {\n    opts = { ...opts, strokeStyle: ColourStringFirst(`bg-dim`, `silver`) };\n  }\n  if (!opts.strokeWidth) opts = { ...opts, strokeWidth: 1 };\n\n  const g = createEl<SVGGElement>(`g`);\n  applyOpts(g, opts);\n  applyPathOpts(g, opts);\n  applyStrokeOpts(g, opts);\n\n  // Horizontals\n  let y = 0;\n  while (y < height) {\n    const horiz = Lines.fromNumbers(0, y, width, y);\n    line(horiz, g);\n    y += spacing;\n  }\n\n  // Verticals\n  let x = 0;\n  while (x < width) {\n    const vert = Lines.fromNumbers(x, 0, x, height);\n    line(vert, g);\n    x += spacing;\n  }\n  parent.append(g);\n  return g;\n};\n","\nimport { PointsTracker } from '@ixfx/geometry/point';\nimport * as Svg from './svg/index.js';\nimport { ElementSizer, resolveEl } from '@ixfx/dom';\nexport type Opts = {\n  readonly touchRadius?: number;\n  readonly mouseRadius?: number;\n  readonly trace?: boolean;\n  readonly hue?: number;\n};\n\n/**\n * Visualises pointer events within a given element.\n *\n * ```js\n * // Show pointer events for whole document\n * pointerVis(document);\n * ```\n *\n * Note you may need to set the following CSS properties on the target element:\n *\n * ```css\n * touch-action: none;\n * user-select: none;\n * overscroll-behavior: none;\n * ```\n *\n * Options\n * * touchRadius/mouseRadius: size of circle for these kinds of pointer events\n * * trace: if true, intermediate events are captured and displayed\n * @param elOrQuery Element to monitor\n * @param options Options\n */\nexport const pointerVisualise = (\n  elOrQuery: HTMLElement | string,\n  options: Opts = {}\n) => {\n  const touchRadius = options.touchRadius ?? 45;\n  const mouseRadius = options.touchRadius ?? 20;\n  const trace = options.trace ?? false;\n  const hue = options.hue ?? 100;\n\n  const startFillStyle = `hsla(${ hue }, 100%, 10%, 10%)`;\n  let currentHue = hue;\n\n  const el = resolveEl(elOrQuery);\n  const tracker = new PointsTracker({\n    storeIntermediate: trace,\n  });\n\n\n  const svg = document.createElementNS(\n    `http://www.w3.org/2000/svg`,\n    `svg`\n  ) as any as SVGElement & HTMLElement;\n  svg.id = `pointerVis`;\n  svg.style.zIndex = `-1000`;\n  svg.style.position = `fixed`;\n  svg.style.top = `0`;\n  svg.style.left = `0`;\n  svg.style.width = `100%`;\n  svg.style.height = `100%`;\n  svg.style.boxSizing = `border-box`;\n  svg.style.border = `3px solid red`;\n  svg.style.pointerEvents = `none`;\n  svg.style.touchAction = `none`;\n\n  // const er = new ElementSizer(svg, {\n  //   containerEl:document.body,\n  //   stretch:`both`,\n  //   onSetSize(size) {\n  //     svg.setAttribute(`width`, size.width.toString());\n  //     svg.setAttribute(`height`, size.height.toString());\n  //   },\n  // })\n  const er = ElementSizer.svgViewport(svg);\n  //fullSizeElement(svg);\n  let pointerCount = 0;\n\n  const lostPointer = (event: PointerEvent) => {\n    const id = event.pointerId.toString();\n\n    tracker.delete(id);\n    currentHue = hue;\n    svg.querySelector(`#pv-start-${ id }`)?.remove();\n\n    for (let index = 0; index < pointerCount + 10; index++) {\n      svg.querySelector(`#pv-progress-${ id }-${ index }`)?.remove();\n    }\n    pointerCount = 0;\n  };\n\n  const trackPointer = async (event: PointerEvent) => {\n    const id = event.pointerId.toString();\n    const pt = { x: event.x, y: event.y };\n    const type = event.pointerType;\n    if (event.type === `pointermove` && !tracker.has(id)) {\n      return;\n    }\n    const info = (await tracker.seen(event.pointerId.toString(), { x: event.clientX, y: event.clientY }));\n\n    if (info.values.length === 1) {\n      const el = Svg.Elements.circle(\n        {\n          ...info.values[ 0 ],\n          radius: type === `touch` ? touchRadius : mouseRadius,\n        },\n        svg,\n        {\n          fillStyle: startFillStyle,\n        },\n        `#pv-start-${ id }`\n      );\n      el.style.pointerEvents = `none`;\n      el.style.touchAction = `none`;\n    }\n\n    const fillStyle = `hsla(${ currentHue }, 100%, 50%, 50%)`;\n\n    const el2 = Svg.Elements.circle(\n      { ...pt, radius: type === `touch` ? touchRadius : mouseRadius },\n      svg,\n      {\n        fillStyle,\n      },\n      `#pv-progress-${ id }-${ info.values.length }`\n    );\n    el2.style.pointerEvents = `none`;\n    el2.style.touchAction = `none`;\n    currentHue += 1;\n    pointerCount = info.values.length;\n  };\n\n  document.body.append(svg);\n\n\n  el.addEventListener(`pointerdown`, trackPointer);\n\n  el.addEventListener(`pointermove`, trackPointer);\n  el.addEventListener(`pointerup`, lostPointer);\n  el.addEventListener(`pointerleave`, lostPointer);\n  el.addEventListener(`contextmenu`, (event) => {\n    event.preventDefault();\n  });\n};\n","/**\n * Manage a set of named colours. Uses CSS variables as a fallback if colour is not added\n *\n */\nexport type NamedColourPalette = {\n  setElementBase(el: Element): void;\n  has(key: string): boolean;\n\n  /**\n   * Returns a colour by name.\n   *\n   * If the colour is not found:\n   *  1. Try to use a CSS variable `--key`, or\n   *  2. The next fallback colour is used (array cycles)\n   *\n   * @param key\n   * @param fallback\n   * @returns\n   */\n  get(key: string, fallback?: string): string;\n\n  /**\n   * Gets a colour by key, adding and returning fallback if not present\n   * @param key Key of colour\n   * @param fallback Fallback colour if key is not found\n   */\n  getOrAdd(key: string, fallback?: string): string;\n\n  /**\n   * Adds a colour with a given key\n   *\n   * @param key\n   * @param value\n   */\n  add(key: string, value: string): void;\n\n  alias(from: string, to: string): void;\n};\n\nexport const create = (fallbacks?: ReadonlyArray<string>): NamedColourPalette =>\n  new NamedColourPaletteImpl(fallbacks);\n\nclass NamedColourPaletteImpl {\n  readonly #store: Map<string, string> = new Map();\n  readonly #aliases: Map<string, string> = new Map();\n\n  readonly fallbacks: ReadonlyArray<string>;\n  #lastFallback = 0;\n\n  #elementBase: Element;\n\n  constructor(fallbacks?: ReadonlyArray<string>) {\n    if (fallbacks !== undefined) this.fallbacks = fallbacks;\n    else this.fallbacks = [ `red`, `blue`, `green`, `orange` ];\n    this.#elementBase = document.body;\n  }\n\n  setElementBase(el: Element) {\n    this.#elementBase = el;\n  }\n\n  add(key: string, colour: string) {\n    this.#store.set(key, colour);\n  }\n\n  alias(from: string, to: string) {\n    this.#aliases.set(from, to);\n  }\n\n  get(key: string, fallback?: string): string {\n    const alias = this.#aliases.get(key);\n    if (alias !== undefined) key = alias;\n\n    const c = this.#store.get(key);\n    if (c !== undefined) return c;\n\n    const variableName = `--` + key;\n    let fromCss = getComputedStyle(this.#elementBase)\n      .getPropertyValue(variableName)\n      .trim();\n\n    // Not found\n    if (fromCss === undefined || fromCss.length === 0) {\n      if (fallback !== undefined) return fallback;\n      fromCss = this.fallbacks[ this.#lastFallback ];\n      this.#lastFallback++;\n      if (this.#lastFallback === this.fallbacks.length) this.#lastFallback = 0;\n    }\n    return fromCss;\n  }\n\n  getOrAdd(key: string, fallback?: string): string {\n    if (this.has(key)) return this.get(key);\n    const c = this.get(key, fallback);\n    this.add(key, c);\n    return c;\n  }\n\n  has(key: string): boolean {\n    return this.#store.has(key);\n  }\n}\n","import { numberTest, resultThrow } from '@ixfx/guards';\nimport { type RandomSource } from '@ixfx/random';\n/**\n * Returns a full HSL colour string (eg `hsl(20,50%,75%)`) based on a index.\n * It's useful for generating perceptually different shades as the index increments.\n *\n * ```\n * el.style.backgroundColor = goldenAgeColour(10);\n * ```\n *\n * Saturation and lightness can be specified, as numeric ranges of 0-1.\n *\n * @param saturation Saturation (0-1), defaults to 0.5\n * @param lightness Lightness (0-1), defaults to 0.75\n * @param alpha Opacity (0-1), defaults to 1.0\n * @returns HSL colour string eg `hsl(20,50%,75%)`\n */\nexport const goldenAngleColour = (\n  index: number,\n  saturation = 0.5,\n  lightness = 0.75,\n  alpha = 1\n) => {\n  resultThrow(\n    numberTest(index, `positive`, `index`),\n    numberTest(saturation, `percentage`, `saturation`),\n    numberTest(lightness, `percentage`, `lightness`),\n    numberTest(alpha, `percentage`, `alpha`)\n  );\n  // Via Stackoverflow\n  const hue = index * 137.508; // use golden angle approximation\n  return alpha === 1 ? `hsl(${ hue },${ saturation * 100 }%,${ lightness * 100 }%)` : `hsl(${ hue },${ saturation * 100 }%,${ lightness * 100 }%,${ alpha * 100 }%)`;\n};\n\n/**\n * Returns a random hue component (0..359)\n * ```\n * // Generate hue\n * const h =randomHue(); // 0-359\n *\n * // Generate hue and assign as part of a HSL string\n * el.style.backgroundColor = `hsl(${randomHue(), 50%, 75%})`;\n * ```\n * @param rand\n * @returns\n */\nexport const randomHue = (rand: RandomSource = Math.random): number => {\n  const r = rand();\n  return r * 360;\n};\n","import type { Colour, Colourish, Hsl, Rgb } from './types.js';\nimport { toColour, toCssColour } from './conversion.js';\nimport * as HslSpace from './hsl.js';\nimport * as SrgbSpace from './srgb.js';\nimport { clamp } from '@ixfx/numbers';\n\nexport function multiplyOpacity(colourish: string, amount: number): string {\n  return withOpacity(colourish, o => clamp(o * amount));\n}\n\nexport function withOpacity(colourish: string, fn: (scalarOpacity: number) => number): string;\nexport function withOpacity(colourish: Hsl, fn: (scalarOpacity: number) => number): Hsl;\nexport function withOpacity(colourish: Rgb, fn: (scalarOpacity: number) => number): Rgb;\nexport function withOpacity(colourish: Colourish, fn: (scalarOpacity: number) => number): Colourish {\n  const colour = toColour(colourish);\n  let result: Colour | undefined;\n  switch (colour.space) {\n    case `hsl`:\n      result = HslSpace.withOpacity(colour, fn);\n      break;\n    case `srgb`:\n      result = SrgbSpace.withOpacity(colour, fn);\n      break;\n    default:\n      throw new Error(`Unknown space: '${ colour.space }'. Expected hsl, srgb, oklch`)\n  }\n  if (!result) throw new Error(`Is colour in correct form?`);\n  if (typeof colourish === `string`) {\n    // Convert back to string if input was a string\n    return toCssColour(result);\n  }\n  return result;\n};\n\n// export const multiplySaturation = (colour: Colourish, amt: number): string => {\n//   throwNumberTest(amt, `percentage`, `amt`);\n//   const c = structuredToColorJs(colour);\n//   c.s = (c.s ?? 0) * amt;\n//   return c.toString();\n// };","//import type { ColorConstructor } from \"./colorjs.types.js\";\nimport type { Colourish, OkLch, OkLchAbsolute, OkLchScalar, ParsingOptions } from \"./types.js\";\nimport { numberInclusiveRangeTest, numberTest, resultThrow, throwIfFailed } from \"@ixfx/guards\";\nimport * as C from \"colorizr\";\nimport { cssDefinedHexColours } from \"./css-colours.js\";\nimport { angleConvert, angleParse, type Angle } from \"@ixfx/geometry\";\n\n// const oklchGuard = (lch: OkLch) => {\n//   switch (lch.unit) {\n//     case `scalar`:\n//       throwIfFailed(\n//         numberTest(lch.l, `percentage`, `lch.l`),\n//         numberTest(lch.c, `percentage`, `lch.c`),\n//         numberTest(lch.h, `percentage`, `lch.h`),\n//         numberTest(lch.opacity, `percentage`, `lch.opacity`)\n//       );\n//       break;\n//     case `absolute`:\n//       throwIfFailed(\n//         numberTest(lch.l, `percentage`, `lch.l`),\n//         numberTest(lch.c, `percentage`, `lch.c`),\n//         numberTest(lch.opacity, `percentage`, `lch.opacity`)\n//       );\n//       break;\n//     default:\n//       // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n//       // @ts-expect-error\n//       throw new Error(`Unknown unit: ${ lch.unit }`);\n//   }\n// }\n\nexport const guard = (lch: OkLch) => {\n  const { l, c, h, opacity, space, unit } = lch;\n  if (space !== `oklch`) throw new Error(`Space is expected to be 'oklch'. Got: ${ space }`);\n  if (unit === `absolute`) {\n    resultThrow(\n      numberTest(l, `percentage`, `l`),\n      numberTest(c, `percentage`, `c`),\n      numberTest(h, `percentage`, `h`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberInclusiveRangeTest(opacity, 0, 100, `opacity`);\n        }\n      });\n  } else if (unit === `scalar`) {\n    resultThrow(\n      numberTest(l, `percentage`, `l`),\n      numberTest(c, `percentage`, `c`),\n      numberTest(h, `percentage`, `h`),\n      () => {\n        if (typeof opacity === `number`) {\n          return numberTest(opacity, `percentage`, `opacity`);\n        }\n      });\n  } else {\n    throw new Error(`Unit is expected to be 'absolute' or 'scalar'. Got: ${ unit }`);\n  }\n}\n\nconst fromLibrary = (lch: C.LCH, parsingOptions: ParsingOptions<OkLchAbsolute> = {}): OkLchAbsolute => {\n  if (typeof lch === `undefined` || lch === null) {\n    if (parsingOptions.fallbackColour) return parsingOptions.fallbackColour;\n  }\n  resultThrow(\n    numberInclusiveRangeTest(lch.l, 0, 360, `l`),\n    numberInclusiveRangeTest(lch.c, 0, 100, `c`),\n    numberInclusiveRangeTest(lch.h, 0, 100, `h`),\n    () => lch.alpha !== undefined ? numberInclusiveRangeTest(lch.alpha, 0, 100, `alpha`) : { success: true, value: lch },\n  );\n  return {\n    l: lch.l,\n    c: lch.c,\n    h: lch.h,\n    opacity: (lch.alpha ?? 1) * 100,\n    unit: `absolute`,\n    space: `oklch`\n  }\n}\nexport const fromHexString = (hexString: string): OkLchAbsolute => fromLibrary(C.hex2oklch(hexString))\nconst oklchTransparent: OkLchAbsolute = Object.freeze({\n  l: 0, c: 0, h: 0, opacity: 0, unit: `absolute`, space: `oklch`\n});\n\nexport const fromCssAbsolute = (value: string, options: ParsingOptions<OkLchAbsolute> = {}): OkLchAbsolute => {\n  value = value.toLowerCase();\n  if (value.startsWith(`#`)) {\n    return fromHexString(value);\n  }\n  if (value === `transparent`) return oklchTransparent;\n  if (typeof cssDefinedHexColours[ value ] !== `undefined`) {\n    return fromHexString(cssDefinedHexColours[ value ] as string);\n  }\n\n  if (!value.startsWith(`hsl(`) && !value.startsWith(`oklch(`)) {\n    try {\n      const converted = C.convert(value, `oklch`);\n      value = converted;\n    } catch (error) {\n      if (options.fallbackString) {\n        value = options.fallbackString;\n      } else {\n        throw error;\n      }\n    }\n  }\n  const c = C.extractColorParts(value);\n  if (c.model !== `oklch`) {\n    if (options.fallbackColour) return options.fallbackColour;\n    throw new Error(`Expecting OKLCH colour space. Got: ${ c.model }`);\n  }\n  return fromLibrary(c as any as C.LCH, options);\n}\n\nexport const fromCssScalar = (value: string, options: ParsingOptions<OkLchAbsolute> = {}): OkLchScalar => toScalar(fromCssAbsolute(value, options));\n\nexport const toScalar = (lch: OkLch): OkLchScalar => {\n  guard(lch);\n  if (lch.unit === `scalar`) return lch;\n  return {\n    l: lch.l / 360,\n    c: lch.c / 100,\n    h: lch.h / 100,\n    opacity: (lch.opacity ?? 1) / 100,\n    unit: `scalar`,\n    space: `oklch`\n  }\n}\n\nconst toLibrary = (lch: OkLch): C.LCH => {\n  const abs = toAbsolute(lch);\n  return {\n    l: abs.l,\n    c: abs.c,\n    h: abs.h,\n    alpha: abs.opacity,\n  }\n}\n// const libraryLchToScalar = (c: C.LCH): OkLchScalar => {\n//   return {\n//     l: c.h,\n//     c: c.c,\n//     h: c.h / 360,\n//     opacity: c.alpha ?? 1,\n//     unit: `scalar`,\n//     space: `oklch`\n//   }\n// }\n\nexport const toAbsolute = (lch: OkLch): OkLchAbsolute => {\n  if (lch.unit === `absolute`) return lch;\n  return {\n    space: `oklch`,\n    unit: `absolute`,\n    l: lch.l * 100,\n    c: lch.c * 100,\n    h: lch.h * 360,\n    opacity: lch.opacity\n  }\n}\n\nexport const toCssString = (lch: OkLch): string => {\n  guard(lch);\n  const { l, c, h, opacity } = lch;\n  let css = ``;\n  switch (lch.unit) {\n    case `absolute`:\n      css = `lch(${ l }% ${ c }% ${ h })`\n  }\n  if (typeof opacity !== `undefined`) {\n    css += ` / ${ opacity }`;\n  }\n  css += `)`;\n  return css;\n}\n\n// export const oklchFromCss = (css: string): OkLchScalar => {\n//   if (css.startsWith(`#`)) {\n//     libraryLchToScalar(C.hex2oklch(css));\n//   }\n//   const p = C.extractColorParts(css);\n//   return libraryToScalar(p);\n// }\n\n// const libraryToScalar = (colour: unknown): OkLchScalar => {\n//   if (C.isLCH(colour)) {\n//     return libraryLchToScalar(colour);\n//   }\n//   if (C.isRGB(colour)) {\n//     return libraryToScalar(C.rgb2oklch(colour));\n//   }\n//   if (C.isLAB(colour)) {\n//     return libraryToScalar(C.oklab2oklch(colour));\n//   }\n//   if (C.isHSL(colour)) {\n//     return libraryToScalar(C.hsl2oklch(colour));\n//   }\n//   if (C.isHex(colour)) {\n//     return libraryLchToScalar(C.hex2oklch(colour));\n//   }\n//   throw new Error(`Unexpected colour format`);\n// }\n\n// export const oklchToColorJs = (lch: OkLch): ColorConstructor => {\n//   throwNumberTest(lch.l, `percentage`, `lch.l`);\n//   throwNumberTest(lch.c, `percentage`, `lch.c`);\n//   throwNumberTest(lch.h, `percentage`, `lch.h`);\n//   throwNumberTest(lch.opacity, `percentage`, `lch.opacity`);\n//   return {\n//     alpha: lch.opacity,\n//     coords: [ lch.l, lch.c * 0.4, lch.h * 360 ],\n//     spaceId: `oklch`\n//   }\n// }\n\n// const oklchToColorJs = (oklch: OkLch) => {\n//   throwNumberTest(oklch.l, `percentage`, `oklch.l`);\n//   throwNumberTest(oklch.c, `percentage`, `oklch.c`);\n//   throwNumberTest(oklch.h, `percentage`, `oklch.h`);\n//   throwNumberTest(oklch.opacity, `percentage`, `oklch.opacity`);\n//   const coords: [ number, number, number ] = [\n//     oklch.l,\n//     oklch.c * 0.4,\n//     oklch.h * 360\n//   ]\n//   return new ColorJs.default(`oklch`, coords, oklch.opacity);\n// }\n\n// export const isOklch = (p: Colourish | undefined | null): p is OkLch => {\n//   if (typeof p === `undefined` || p === null) return false;\n//   if (typeof p !== `object`) return false;\n\n//   // Check if Colourjs\n//   //if ((p as ColorJs.ColorObject).spaceId !== undefined) return false;\n//   //if ((p as ColorJs.ColorObject).coords !== undefined) return false;\n//   if (p.space !== `oklch`) return false;\n//   if (typeof p.l === `undefined`) return false;\n//   if (typeof p.c === `undefined`) return false;\n//   if (typeof p.h === `undefined`) return false;\n//   return true;\n// }\n\nexport const generateScalar = (absoluteHslOrVariable: string | number | Angle, chroma = 1, lightness = 0.5, opacity = 1): OkLchScalar => {\n\n  if (typeof absoluteHslOrVariable === `string`) {\n    if (absoluteHslOrVariable.startsWith(`--`)) {\n      absoluteHslOrVariable = getComputedStyle(document.body).getPropertyValue(absoluteHslOrVariable).trim()\n    }\n  }\n  if (lightness > 1) throw new TypeError(`Param 'lightness' must be between 0..1`);\n  if (chroma > 1) throw new TypeError(`Param 'chroma' must be between 0..1`);\n  const hue = angleParse(absoluteHslOrVariable);\n  const hueDeg = angleConvert(hue, `deg`).value / 360;\n  if (opacity > 1) throw new TypeError(`Param 'opacity' must be between 0..1`);\n\n  return {\n    l: lightness,\n    c: chroma,\n    h: hueDeg,\n    opacity: opacity,\n    unit: `scalar`,\n    space: `oklch`\n  }\n}","export * from './conversion.js';\nexport * from './css-colours.js';\nexport * from './generate.js';\n\n//export * from './interpolate.js';\nexport * from './math.js';\n\nexport * as HslSpace from './hsl.js';\nexport * as OklchSpace from './oklch.js';\nexport * as SrgbSpace from './srgb.js';\n\nexport type * from './types.js';","import { continuously } from '@ixfx/core';\nimport { delayLoop } from '@ixfx/flow';\n\nexport type Capturer = {\n  start(): void;\n  cancel(): void;\n  readonly canvasEl: HTMLCanvasElement;\n};\n\nexport type ManualCapturer = {\n  capture(): ImageData;\n  readonly canvasEl: HTMLCanvasElement;\n  dispose(): void;\n};\n\nexport type CaptureOpts = {\n  /**\n   * Delay between reading frames.\n   * Default: 0, reading as fast as possible\n   */\n  readonly maxIntervalMs?: number;\n  /**\n   * Whether to show the created capture canvas.\n   * Default: false\n   */\n  readonly showCanvas?: boolean;\n  readonly workerScript?: string;\n  readonly onFrame?: (pixels: ImageData) => void;\n};\n\nexport type ManualCaptureOpts = {\n  /**\n   * If true, the intermediate canvas is shown\n   * The intermediate canvas is where captures from the source are put in order\n   * to get the ImageData\n   */\n  readonly showCanvas?: boolean;\n  /**\n   * If specified, this function will be called after ImageData is captured\n   * from the intermediate canvs. This allows for drawing on top of the\n   * captured image.\n   */\n  readonly postCaptureDraw?: (\n    ctx: CanvasRenderingContext2D,\n    width: number,\n    height: number\n  ) => void;\n\n  /**\n   * If specified, this is the canvas captured to\n   */\n  readonly canvasEl?: HTMLCanvasElement;\n};\n\n/**\n * Options for frames generator\n */\nexport type FramesOpts = {\n  /**\n   * Max frame rate (millis per frame), or 0 for animation speed\n   */\n  readonly maxIntervalMs?: number;\n  /**\n   * False by default, created canvas will be hidden\n   */\n  readonly showCanvas?: boolean;\n  /**\n   * If provided, this canvas will be used as the buffer rather than creating one.\n   */\n  readonly canvasEl?: HTMLCanvasElement;\n};\n\n/**\n * Generator that yields frames from a video element as [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData).\n *\n * ```js\n * import { Video } from 'https://unpkg.com/ixfx/dist/visual.js'\n *\n * const ctx = canvasEl.getContext(`2d`);\n * for await (const frame of Video.frames(videoEl)) {\n *   // TODO: Some processing of pixels\n *\n *   // Draw image on to the visible canvas\n *   ctx.putImageData(frame, 0, 0);\n * }\n * ```\n *\n * Under the hood it creates a hidden canvas where frames are drawn to. This is necessary\n * to read back pixel data. An existing canvas can be used if it is passed in as an option.\n *\n * Options:\n * * `canvasEl`: CANVAS element to use as a buffer (optional)\n * * `maxIntervalMs`: Max frame rate (0 by default, ie runs as fast as possible)\n * * `showCanvas`: Whether buffer canvas will be shown (false by default)\n * @param sourceVideoEl\n * @param opts\n */\n\nexport async function* frames(\n  sourceVideoEl: HTMLVideoElement,\n  opts: FramesOpts = {}\n): AsyncIterable<ImageData> {\n  // TODO: Ideally use OffscreenCanvas when it has wider support?\n  // TODO: When ImageBitmap has possibility to get pixels, that might also help to avoid having to write to hidden canvas\n\n  const maxIntervalMs = opts.maxIntervalMs ?? 0;\n\n  const showCanvas = opts.showCanvas ?? false;\n  let canvasEl = opts.canvasEl;\n  let w, h;\n  w = h = 0;\n\n  // Create & setup canvas\n  if (canvasEl === undefined) {\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n    canvasEl.classList.add(`ixfx-frames`);\n    if (!showCanvas) {\n      canvasEl.style.display = `none`;\n    }\n    document.body.appendChild(canvasEl);\n  }\n\n  // Update size of canvas based on video\n  const updateSize = () => {\n    if (canvasEl === undefined) return;\n    w = sourceVideoEl.videoWidth;\n    h = sourceVideoEl.videoHeight;\n    canvasEl.width = w;\n    canvasEl.height = h;\n  };\n\n  let c: CanvasRenderingContext2D | null = null;\n\n  const looper = delayLoop(maxIntervalMs);\n  for await (const _ of looper) {\n    // If we don't yet have the size of video, get it\n    if (w === 0 || h === 0) updateSize();\n\n    // If there is still no dimensions (ie stream has not started), there's nothing to do yet\n    if (w === 0 || h === 0) continue;\n\n    // Draw current frame from video element to hidden canvas\n    if (c === null) c = canvasEl.getContext(`2d`);\n    if (c === null) return;\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n\n    // Get pixels\n    const pixels = c.getImageData(0, 0, w, h);\n    yield pixels;\n  }\n}\n\n/**\n * Captures frames from a video element. It can send pixel data to a function or post to a worker script.\n *\n * @example Using a function\n * ```js\n * import {Video} from 'https://unpkg.com/ixfx/dist/visual.js'\n *\n * // Capture from a VIDEO element, handling frame data\n * // imageData is ImageData type: https://developer.mozilla.org/en-US/docs/Web/API/ImageData\n * Video.capture(sourceVideoEl, {\n *  onFrame(imageData => {\n *    // Do something with pixels...\n *  });\n * });\n * ```\n *\n * @example Using a worker\n * ```js\n * import {Video} from 'https://unpkg.com/ixfx/dist/visual.js'\n *\n * Video.capture(sourceVideoEl, {\n *  workerScript: `./frameProcessor.js`\n * });\n * ```\n *\n * In frameProcessor.js:\n * ```\n * const process = (frame) => {\n *  // ...process frame\n *\n *  // Send image back?\n *  self.postMessage({frame});\n * };\n *\n * self.addEventListener(`message`, evt => {\n *   const {pixels, width, height} = evt.data;\n *   const frame = new ImageData(new Uint8ClampedArray(pixels),\n *     width, height);\n *\n *   // Process it\n *   process(frame);\n * });\n * ```\n *\n * Options:\n * * `canvasEl`: CANVAS element to use as a buffer (optional)\n * * `maxIntervalMs`: Max frame rate (0 by default, ie runs as fast as possible)\n * * `showCanvas`: Whether buffer canvas will be shown (false by default)\n * * `workerScript`: If this specified, this URL will be loaded as a Worker, and frame data will be automatically posted to it\n *\n * Implementation: frames are captured using a animation-speed loop to a hidden canvas. From there\n * the pixel data is extracted and sent to either destination. In future the intermediate drawing to a\n * canvas could be skipped if it becomes possible to get pixel data from an ImageBitmap.\n * @param sourceVideoEl Source VIDEO element\n * @param opts\n * @returns\n */\nexport const capture = (\n  sourceVideoEl: HTMLVideoElement,\n  opts: CaptureOpts = {}\n): Capturer => {\n  const maxIntervalMs = opts.maxIntervalMs ?? 0;\n  const showCanvas = opts.showCanvas ?? false;\n  const onFrame = opts.onFrame;\n\n  // Ideally use OffscreenCanvas when it has support?\n  const w = sourceVideoEl.videoWidth;\n  const h = sourceVideoEl.videoHeight;\n\n  // Create canvas\n  const canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n  canvasEl.classList.add(`ixfx-capture`);\n\n  if (!showCanvas) {\n    canvasEl.style.display = `none`;\n  }\n  canvasEl.width = w;\n  canvasEl.height = h;\n  let c: CanvasRenderingContext2D | null = null;\n  let worker: Worker | undefined;\n  if (opts.workerScript) {\n    worker = new Worker(opts.workerScript);\n  }\n\n  // Should we get image data?\n  const getPixels = worker || onFrame;\n  if (!getPixels && !showCanvas) {\n    console.warn(\n      `Video will be captured to hidden element without any processing. Is this what you want?`\n    );\n  }\n\n  const loop = continuously(() => {\n    // Draw current frame from video element to hidden canvas\n    if (c === null) c = canvasEl.getContext(`2d`);\n    if (c === null) return;\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n    let pixels: ImageData | undefined;\n\n    if (getPixels) {\n      // ImageData necessary\n      pixels = c.getImageData(0, 0, w, h);\n    }\n\n    if (worker) {\n      // Send to worker\n      worker.postMessage(\n        {\n          pixels: pixels!.data.buffer,\n          width: w,\n          height: h,\n          channels: 4,\n        },\n        [ pixels!.data.buffer ]\n      );\n    }\n    if (onFrame) {\n      // Send to callback\n      try {\n        onFrame(pixels!);\n      } catch (e) {\n        console.error(e);\n      }\n    }\n  }, maxIntervalMs);\n\n  return {\n    start: () => { loop.start(); },\n    cancel: () => { loop.cancel(); },\n    canvasEl,\n  };\n};\n\nexport const manualCapture = (\n  sourceVideoEl: HTMLVideoElement,\n  opts: ManualCaptureOpts = {}\n): ManualCapturer => {\n  const showCanvas = opts.showCanvas ?? false;\n\n  // Ideally use OffscreenCanvas when it has support?\n  const w = sourceVideoEl.videoWidth;\n  const h = sourceVideoEl.videoHeight;\n\n  // Create canvas if necessary\n  const definedCanvasEl = opts.canvasEl !== undefined;\n  let canvasEl = opts.canvasEl;\n  if (!canvasEl) {\n    canvasEl = document.createElement(`CANVAS`) as HTMLCanvasElement;\n    canvasEl.classList.add(`ixfx-capture`);\n    document.body.append(canvasEl);\n    if (!showCanvas) canvasEl.style.display = `none`;\n  }\n\n  canvasEl.width = w;\n  canvasEl.height = h;\n\n  const capture = (): ImageData => {\n    let c: CanvasRenderingContext2D | undefined | null;\n\n    // Draw current frame from video element to canvas\n    if (!c) c = canvasEl.getContext(`2d`, { willReadFrequently: true });\n    if (!c) throw new Error(`Could not create graphics context`);\n    c.drawImage(sourceVideoEl, 0, 0, w, h);\n\n    const pixels = c.getImageData(0, 0, w, h);\n\n    (pixels as any).currentTime = sourceVideoEl.currentTime;\n\n    if (opts.postCaptureDraw) opts.postCaptureDraw(c, w, h);\n    return pixels;\n  };\n\n  const dispose = (): void => {\n    if (definedCanvasEl) return; // we didn't create it\n    try {\n      canvasEl.remove();\n    } catch (_) {\n      // no-op\n    }\n  };\n\n  const c: ManualCapturer = {\n    canvasEl,\n    capture,\n    dispose,\n  };\n  return c;\n};\n","export * from './canvas-helper.js';\nexport * from './pointer-visualise.js';\n// import * as Svg from './svg/index.js';\n// export * as Svg from './svg/index.js';\n\nimport * as NamedColourPalette from './named-colour-palette.js';\n\n\nimport * as Colour from './colour/index.js';\n\nexport * as Colour from './colour/index.js';\n\n//export type * from './types.js';\n\n//import * as SceneGraph from './SceneGraph.js';\nimport * as Video from './video.js';\n\n//export * from '../../dom/src/CanvasRegion.js';\n\n\n/**\n * Wraps [ImageData](https://developer.mozilla.org/en-US/docs/Web/API/ImageData) as an ixfx {@link @ixfx/geometry.Grid} type.\n * This is useful because it's otherwise a one-dimensional array listing each rgba in turn.\n */\nexport * as ImageDataGrid from './image-data-grid.js';\n//export * as BipolarView from '../../dom/src/plot/BipolarView.js';\n//export * as NamedColourPalette from './named-colour-palette.js';\n\n//export * as Plot2 from './Plot2.js';\n\n//export * as Plot from './plot/index.js';\n//export * as SceneGraph from './SceneGraph.js';\n//export * from './ScaleCanvas.js';\n//export * from './plot/CartesianCanvasPlot.js';\n\n\n\n/**\n * Working with video, either playback from a file or stream from a video camera.\n *\n * Overview\n * * {@link frames}: Yields frames from a video camera\n * * {@link capture}: Capture frames from a VIDEO element\n *\n * @example Importing\n * ```js\n * // If library is stored two directories up under `ixfx/`\n * import {Video} from '../../ixfx/dist/visual.js';\n * // Import from web\n * import {Video} from 'https://unpkg.com/ixfx/dist/visual.js'\n * ```\n */\nexport * as Video from './video.js';\n\ntry {\n  if (typeof window !== `undefined`) {\n    (window as any).ixfx = {\n      ...(window as any).ixfx,\n      Visuals: {\n        NamedColourPalette,\n        Colour,\n        Video,\n      },\n    };\n  }\n} catch {\n  /* no-op */\n}\n\n\n"],"mappings":"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"}