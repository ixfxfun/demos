{"version":3,"sources":["../src/iterables/index.ts","../src/iterables/Controller.ts"],"sourcesContent":["/* eslint-disable unicorn/no-array-callback-reference */\n/* eslint-disable unicorn/no-array-for-each */\n/* eslint-disable unicorn/no-array-method-this-argument */\n\nimport * as Async from '../iterables/IterableAsync.js';\nimport * as Sync from '../iterables/IterableSync.js';\nexport * as Async from '../iterables/IterableAsync.js';\nexport * as Sync from '../iterables/IterableSync.js';\nexport * from './Controller.js';\n\n/**\n * Chains use generators as a way of processing data.\n * \n * To create, {@link From}, processing operators are {@link Links}.\n * To run: {@link run}\n * \n * Utility\n * * {@link addToArray}: add values from a source to an array as they are emitted\n * * {@link asArray}: wait for source to complete, collecting results into an array\n * * {@link mergeFlat}: combine serveral sources into one, interleaving values\n * * {@link asCallback}: passes a value to a callback whenever it is emitted\n * * {@link asPromise}: Treat chain as a promise, yeidling the final result.\n * * {@link asValue}: Return the most recent value\n * * {@link syncToArray}: Wait for all sources to produce a value\n * * {@link combineLatestToArray}, {@link combineLatestToObject}: Emit values as array/oject as soon as one source changes\n */\nexport * as Chains from './chain/index.js';\nexport * from './Iterable.js';\nexport type * from './Types.js';\n\nimport { isAsyncIterable } from '../iterables/Iterable.js';\nimport * as Chains from './chain/index.js';\nimport type { Interval } from '../flow/IntervalType.js';\n\nimport { toStringDefault } from '../util/index.js';\nimport type { GenFactoryNoInput } from './chain/Types.js';\nimport type { ForEachOptions, ToArrayOptions, IteratorControllerOptions, IteratorControllerState } from './Types.js';\n\n/**\n * {@inheritDoc Chains.combineLatestToArray}\n * @param sources \n * @param options \n * @returns \n */\nexport function combineLatestToArray(sources: Array<Chains.GenOrData<any> | GenFactoryNoInput<any>>, options: Partial<Chains.CombineLatestOptions> = {}): AsyncGenerator<Array<any>> {\n  return Chains.combineLatestToArray(sources, options);\n}\n\nexport function min<V>(it: AsyncIterable<V>, gt?: (a: V, b: V) => boolean): AsyncGenerator<V>;\nexport function min<V>(it: Iterable<V>, gt?: (a: V, b: V) => boolean): Generator<V>;\n\n\n\n/**\n * Returns a stream of minimum values.\n * \n * Streaming result: works with endless iterables.\n * \n * ```js\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], (a, b) => a.v > b.v);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns Yields minimum values\n */\nexport function min<V>(it: AsyncIterable<V> | Iterable<V>, gt = (a: V, b: V) => a > b): AsyncGenerator<V> | Generator<V> {\n  return isAsyncIterable(it) ? Async.min(it, gt) : Sync.min(it, gt);\n}\n\nexport function max<V>(it: AsyncIterable<V>, gt?: (a: V, b: V) => boolean): AsyncGenerator<V>;\nexport function max<V>(it: Iterable<V>, gt?: (a: V, b: V) => boolean): Generator<V>;\n\n/**\n * Returns the maximum value of an iterable as it changes.\n * Streaming result: works with endless iterables.\n * \n * ```js\n * // Rank values by their 'v' field\n * const rank = (a,b) => a.v > b.v;\n * \n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:0,v:1}, {i:1,v:9}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns Iterable of maximum values\n */\nexport function max<V>(it: AsyncIterable<V> | Iterable<V>, gt = (a: V, b: V) => a > b): AsyncGenerator<V> | Generator<V> {\n  return isAsyncIterable(it) ? Async.max(it, gt) : Sync.max(it, gt);\n}\n\nexport function dropWhile<V>(it: AsyncIterable<V>, f: (v: V) => boolean): AsyncGenerator<V>;\nexport function dropWhile<V>(it: Iterable<V>, f: (v: V) => boolean): Generator<V>;\n\n/**\n * Drops elements that do not meet the predicate `f`.\n * Streaming result: works with endless iterables.\n * \n * ```js\n * dropWhile([1, 2, 3, 4], e => e < 3);\n * returns [3, 4]\n * ```\n * @param it\n * @param f\n */\nexport function dropWhile<V>(it: AsyncIterable<V> | Iterable<V>, f: (v: V) => boolean): AsyncGenerator<V> | Generator<V> {\n  return isAsyncIterable(it) ? Async.dropWhile(it, f) : Sync.dropWhile(it, f);\n}\n\nexport function until(it: AsyncIterable<any>, f: () => Promise<boolean> | Promise<undefined>): Promise<undefined>;\nexport function until(it: Iterable<any>, f: () => boolean | never): void;\nexport function until(it: Iterable<any>, f: () => Promise<boolean>): Promise<undefined>;\n\n/**\n* Loops over a generator until it finishes, calling `callback`.\n* Useful if you don't care about the value generator produces, just the number of loops.\n* \n* ```js\n* until(count(5), () => {\n* // do something 5 times\n* });\n* ```\n* \n* If you want the value from the generator, use a `for of` loop as usual.\n* If `callback` explicitly returns _false_, the generator is aborted.\n* \n* This does not work for infinite generators, `callback` will never be called.\n* @param it Generator to run\n* @param callback Code to call for each iteration\n*/\nexport function until(it: AsyncIterable<any> | Iterable<any>, callback: () => Promise<boolean> | never | boolean | Promise<undefined>): Promise<undefined> | undefined {\n  if (isAsyncIterable(it)) {\n    return Async.until(it, callback);\n  } else {\n    // @ts-expect-error\n    Sync.until(it, callback);\n  }\n}\n\n\nexport function chunks<V>(it: Iterable<V>, size: number): Generator<Array<V>>;\nexport function chunks<V>(it: AsyncIterable<V>, size: number): AsyncGenerator<Array<V>>;\n\n/**\n * Breaks an iterable into array chunks\n * \n * Streaming: works with infinite iterables.\n * \n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param it\n * @param size\n */\nexport function chunks<V>(it: AsyncIterable<V> | Iterable<V>, size: number): Generator<Array<V>> | AsyncGenerator<Array<V>> {\n  return isAsyncIterable(it) ? Async.chunks(it, size) : Sync.chunks(it, size);\n}\n\nexport function filter<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): AsyncGenerator<V>;\nexport function filter<V>(it: AsyncIterable<V>, f: (v: V) => boolean): Generator<V>;\n\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * \n * When using async iterables, `f` can be async as well.\n * @param it\n * @param f\n */\nexport function filter<V>(it: AsyncIterable<V> | Iterable<V>, f: (v: V) => boolean | Promise<boolean>): AsyncGenerator<V> | Generator<V> {\n  // eslint-disable-next-line unicorn/no-array-method-this-argument, unicorn/no-array-callback-reference\n  return isAsyncIterable(it) ? Async.filter(it, f) : Sync.filter(it, f as (v: V) => boolean);\n}\n\n\nexport function fill<V>(it: AsyncIterable<V>, v: V): AsyncGenerator<V>;\nexport function fill<V>(it: Iterable<V>, v: V): Generator<V>;\n\n/**\n * Yields `v` for each item within `it`.\n *\n * ```js\n * fill([1, 2, 3], 0);\n * // Yields: [0, 0, 0]\n * ```\n * \n * This is like a `map` where we return a fixed value, ignoring the input.\n * @param it\n * @param v\n */\nexport function fill<V>(it: AsyncIterable<V> | Iterable<V>, v: V): AsyncGenerator<V> | Generator<V> {\n  return isAsyncIterable(it) ? Async.fill(it, v) : Sync.fill(it, v);\n}\n\nexport function concat<V>(...its: Array<Iterable<V>>): Generator<V>;\nexport function concat<V>(...its: Array<AsyncIterable<V>>): AsyncGenerator<V>;\n\n\n/**\n * Return concatenation of iterators.\n * \n * Non-streaming: If one of the input iterables is endless, the other ones won't\n * be processed.\n * @param its\n */\nexport function concat<V>(...its: Array<Iterable<V>> | Array<AsyncIterable<V>>): AsyncGenerator<V> | Generator<V> {\n  return isAsyncIterable(its[ 0 ]) ? Async.concat(...its as Array<AsyncIterable<V>>) : Sync.concat(...its as Array<Iterable<V>>);\n}\n\nexport function find<V>(it: Array<V> | Iterable<V>, f: (v: V) => boolean): V | undefined;\nexport function find<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): Promise<V | undefined>;\n\n/**\n * Returns first item from iterable `it` that matches predicate `f`\n * ```js\n * find([1, 2, 3, 4], e => e > 2);\n * // Yields: 3\n * ```\n * \n * When using async iterables, `f` can be async as well.\n * @param it\n * @param f\n * @returns\n */\nexport function find<V>(it: Array<V> | Iterable<V> | AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): Promise<V | undefined> | V | undefined {\n  // eslint-disable-next-line unicorn/no-array-method-this-argument, unicorn/no-array-callback-reference\n  return isAsyncIterable(it) ? Async.find(it, f) : Sync.find(it, f as (v: V) => boolean);\n}\n\n/**\n * Execute function `f` for each item in iterable.\n * If `f` returns _false_, iteration stops.\n * ```js\n * forEach(iterable, v => {\n *  // do something with value\n * });\n * ```\n * \n * When using an async iterable, `fn` can also be async.\n * @param it Iterable or array\n * @param fn Function to execute\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport function forEach<T>(it: Array<T> | AsyncIterable<T> | Iterable<T>, fn: (v: T | undefined) => boolean | Promise<boolean> | void | Promise<void>, options: Partial<ForEachOptions> = {}) {\n  if (isAsyncIterable(it)) {\n    return Async.forEach(it, fn, options);\n  } else {\n    Sync.forEach(it, fn as (v: T) => boolean);\n  }\n}\n\nexport function map<V, X>(it: AsyncIterable<V>, f: (v: V) => Promise<X> | X): Generator<X>;\nexport function map<V, X>(it: Array<V> | Iterable<V>, f: (v: V) => X): Generator<X>;\n\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n * \n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\nexport function map<V, X>(it: Array<V> | AsyncIterable<V> | Iterable<V>, f: (v: V) => X | Promise<X>) {\n  return isAsyncIterable(it) ? Async.map(it, f) : Sync.map(it, f);\n}\n\nexport function fromArray<V>(array: Array<V>, interval: Interval): AsyncGenerator<V>;\nexport function fromArray<V>(array: Array<V>): Generator<V>;\n\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * \n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport function fromArray<V>(array: Array<V>, interval?: Interval): AsyncGenerator<V> | Generator<V> {\n  return interval === undefined ? Sync.fromArray(array) : Async.fromArray(array, interval);\n}\n\nexport function flatten<V>(it: AsyncIterable<Array<V> | V>): AsyncIterable<V>;\nexport function flatten<V>(it: Iterable<Array<V> | V> | Array<V>): Iterable<V>;\n\n/**\n * Returns a 'flattened' copy of array, un-nesting arrays one level.\n * Streaming: works with unlimited iterables.\n * ```js\n * flatten([1, [2, 3], [[4]]]);\n * // Yields: [1, 2, 3, [4]];\n * ```\n * @param it\n */\nexport function flatten<V>(it: Array<V> | AsyncIterable<V | Array<V>> | Iterable<V | Array<V>>): AsyncIterable<V> | Iterable<V> {\n  return isAsyncIterable(it) ? Async.flatten(it) : Sync.flatten(it);\n}\n\nexport function some<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): Promise<boolean>\nexport function some<V>(it: Iterable<V> | Array<V>, f: (v: V) => boolean): boolean\n\n/**\n * Returns true the first time `f` returns true. Useful for spotting any occurrence of\n * data, and exiting quickly\n * ```js\n * some([1, 2, 3, 4], e => e % 3 === 0);\n * // Yields: true\n * ```\n * @param it Iterable\n * @param f Filter function\n * @returns\n */\nexport function some<V>(it: AsyncIterable<V> | Iterable<V>, f: (v: V) => boolean | Promise<boolean>): boolean | Promise<boolean> {\n  return isAsyncIterable(it) ? Async.some(it, f) : Sync.some(it, f as (v: V) => boolean);\n}\n\nexport function reduce<V>(it: AsyncIterable<V>, f: (accumulator: V, current: V) => V, start: V): Promise<V>;\nexport function reduce<V>(it: Iterable<V> | Array<V>, f: (accumulator: V, current: V) => V, start: V): V;\n\n/**\n * Reduce for iterables\n * ```js\n * reduce([1, 2, 3], (acc, cur) => acc + cur, 0);\n * // Yields: 6\n * ```\n * @param it Iterable\n * @param f Function\n * @param start Start value\n * @returns\n */\nexport function reduce<V>(it: AsyncIterable<V> | Iterable<V> | Array<V>, f: (accumulator: V, current: V) => V, start: V): Promise<V> | V {\n  return isAsyncIterable(it) ? Async.reduce(it, f, start) : Sync.reduce(it, f, start);\n}\n\nexport function slice<V>(it: AsyncIterable<V>, start?: number, end?: number): AsyncGenerator<V>;\nexport function slice<V>(it: Iterable<V> | Array<V>, start?: number, end?: number): Generator<V>;\n/**\n * Returns a section from an iterable.\n * \n * 'end' is the end index, not the number of items.\n * \n * ```js\n * // Return five items from step 10\n * slice(it, 10, 15);\n * ```\n * @param it Iterable\n * @param start Start step\n * @param end Exclusive end step (or until completion)\n */\nexport function slice<V>(\n  it: Iterable<V> | AsyncIterable<V> | Array<V>,\n  start = 0,\n  end = Number.POSITIVE_INFINITY\n) {\n  return isAsyncIterable(it) ? Async.slice(it, start, end) : Sync.slice(it, end);\n}\n\nexport function unique<V>(iterable: Iterable<V> | Array<Iterable<V>>): Generator<V>;\nexport function unique<V>(iterable: AsyncIterable<V> | Array<AsyncIterable<V>>): AsyncGenerator<V>;\n\n\n/**\n * Returns unique items from an iterable or\n * array of iterables.\n *\n * ```js\n * const data = [ 'apples', 'oranges' ]\n * const data2 = [ 'oranges', 'pears' ]\n * const unique = [...unique([data,data2]];\n * // Yields: [ 'apples', 'oranges', 'pears' ]\n * ```\n *\n * Uses object reference to compare values.\n * Use {@link uniqueByValue} if this doesn't suffice.\n * @param iterable Iterable, or array of iterables\n */\nexport function unique<V>(iterable: Array<V> | AsyncIterable<V> | Iterable<V> | Array<Iterable<V>> | Array<AsyncIterable<V>>): Generator<V> | AsyncGenerator<V> {\n  if (Array.isArray(iterable)) {\n    if (iterable.length === 0) return Sync.fromArray([]);\n    return isAsyncIterable(iterable[ 0 ]) ? Async.unique(iterable as Array<AsyncIterable<V>>) : Sync.unique(iterable as Array<Iterable<V>>);\n  } else if (isAsyncIterable(iterable)) {\n    return Async.unique(iterable);\n  } else {\n    return Sync.unique(iterable);\n  }\n}\n\nexport function uniqueByValue<T>(input: Iterable<T> | Array<T>, toString: (v: T) => string, seen?: Set<string>): Generator<T>;\nexport function uniqueByValue<T>(input: AsyncIterable<T>, toString: (v: T) => string, seen?: Set<string>): AsyncGenerator<T>;\n\n/**\n * Filters the `input` iterable, only yielding unique values. Use {@link unique} to compare\n * by object reference instead.\n * \n * Streaming: Works with unbounded iterables.\n * \n * ```js\n * const d = ['a', 'b', 'c', 'b', 'd' ];\n * for (const v of uniqueByValue(d)) {\n *  // Yields: 'a', 'b', 'c', 'd'\n * // (extra 'b' is skipped)\n * }\n * ```\n * \n * By default, JSON.stringify is used to create a string representing value. These are added\n * to a Set of strings, which is how we keep track of uniqueness. If the value is already a string it is used as-is.\n * \n * This allows you to have custom logic for what determines uniqueness. Eg, using a single field\n * of an object as an identifier:\n * \n * ```js\n * const people = [\n *  { name: `Mary`, size: 20 }, { name: `Abdul`, size: 19 }, { name: `Mary`, size: 5 }\n * ]\n * for (const v of uniqueByValue(d, v=>v.name)) {\n *  // Yields: { name: `Mary`, size: 20 }, { name: `Abdul`, size: 19 }\n *  // Second 'Mary' is skipped because name is the same, even though size field is different.\n * }\n * ```\n * \n * If you want to keep track of the set of keys, or prime it with some existing data, provide a Set instance:\n * ```js\n * const unique = new Set();\n * unique.add(`b`);\n * const d = [`a`, `b`, `c`];\n * for (const v of uniqueByValue(d, toStringDefault, unique)) {\n *  // Yields: `a`, `c`\n *  // `b` is skipped because it was already in set\n * }\n * // After completion, `unique` contains `a`, `b` and `c`.\n * ```\n * \n * Creating your own Set is useful for tracking unique values across several calls to `uniqueByValue`.\n * @param input \n * @param seen \n * @param toString \n */\nexport function* uniqueByValue<T>(input: AsyncIterable<T> | Iterable<T> | Array<T>, toString: (v: T) => string = toStringDefault, seen: Set<string> = new Set<string>()): Generator<T> | AsyncGenerator<T> {\n  return isAsyncIterable(input) ? Async.uniqueByValue(input, toString, seen) : Sync.uniqueByValue(input, toString, seen);\n}\n\nexport function toArray<V>(it: AsyncIterable<V>, options?: Partial<ToArrayOptions>): Promise<Array<V>>;\nexport function toArray<V>(it: Iterable<V>, options?: Partial<ToArrayOptions>): Array<V>;\n\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a `count` or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param count Number of items to return, by default all.\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function toArray<V>(it: Iterable<V> | AsyncIterable<V>, options: Partial<ToArrayOptions> = {}): Array<V> | Promise<Array<V>> {\n  return isAsyncIterable(it) ? Async.toArray(it, options) : Sync.toArray(it, options);\n}\n\nexport function every<V>(it: Iterable<V> | Array<V>, f: (v: V) => boolean): boolean\nexport function every<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): Promise<boolean>\n\n/**\n * Returns _true_ if `f` returns _true_ for\n * every item in iterable.\n * \n * Streaming: If an infinite iterable is used, function will never return value.\n * @param it\n * @param f\n * @returns\n */\nexport function every<V>(it: Iterable<V> | Array<V> | AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): Promise<boolean> | boolean {\n  return isAsyncIterable(it) ? Async.every(it, f) : Sync.every(it, f as (v: V) => boolean);\n}\n\nexport function equals<V>(it1: AsyncIterable<V>, it2: AsyncIterable<V>, equality?: (a: V, b: V) => boolean): Promise<boolean>\nexport function equals<V>(it1: IterableIterator<V>, it2: IterableIterator<V>, equality?: (a: V, b: V) => boolean): boolean\n\n/**\n * Returns _true_ if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport function equals<V>(it1: AsyncIterable<V> | IterableIterator<V>, it2: AsyncIterable<V> | IterableIterator<V>, equality?: (a: V, b: V) => boolean) {\n  const as = isAsyncIterable(it1) && isAsyncIterable(it2);\n  return as ? Async.equals(it1, it2, equality) : Sync.equals(it1 as IterableIterator<V>, it2 as IterableIterator<V>, equality);\n}\n\nexport function zip<V>(...its: ReadonlyArray<AsyncIterable<V>>): Generator<Array<V>>;\nexport function zip<V>(...its: ReadonlyArray<Iterable<V>>): Generator<V>;\n\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport function zip<V>(...its: ReadonlyArray<AsyncIterable<V>> | ReadonlyArray<Iterable<V>>) {\n  if (its.length === 0) return Sync.fromArray([]);\n  return isAsyncIterable(its[ 0 ]) ? Async.zip(...its as ReadonlyArray<AsyncIterable<V>>) : Sync.zip(...its as ReadonlyArray<Iterable<V>>);\n}\n\nexport function fromIterable<V>(iterable: Iterable<V>): Generator<V>\nexport function fromIterable<V>(iterable: AsyncIterable<V> | Iterable<V>, interval: Interval): AsyncGenerator<V>\n\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport function fromIterable<V>(iterable: Iterable<V> | AsyncIterable<V>, interval?: Interval): AsyncGenerator<V> | Generator<V> {\n  if (isAsyncIterable(iterable) || interval !== undefined) return Async.fromIterable(iterable, interval);\n  return Sync.fromIterable(iterable);\n}\n\n/**\n * Access `callback` as an iterable:\n * ```js\n * const fn = () => Math.random();\n * for (const v of fromFunction(fn)) {\n *  // Generate infinite random numbers\n * }\n * ```\n * \n * Use {@link fromFunctionAwaited} to await `callback`.\n * @param callback Function that generates a value\n */\nexport function* fromFunction<T>(callback: () => T) {\n  while (true) {\n    const v = callback();\n    yield v;\n  }\n}\n\n/**\n * Access awaited `callback` as an iterable:\n * ```js\n * const fn = () => Math.random();\n * for await (const v of fromFunctionAwaited(fn)) {\n *  // Generate infinite random numbers\n * }\n * ```\n * \n * `callback` can be async, result is awaited.\n * This requires the use of `for await`.\n * Use {@link fromFunction} otherwise;\n * @param callback \n */\nexport async function* fromFunctionAwaited<T>(callback: () => Promise<T> | T) {\n  while (true) {\n    const v = await callback();\n    yield v;\n  }\n}\n\n\n/**\n * Calls `callback` whenever the generator produces a value.\n * \n * When using `asCallback`, call it with `await` to let generator \n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n * \n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input \n * @param callback \n */\nexport function asCallback<V>(input: AsyncIterable<V> | Iterable<V>, callback: (v: V) => unknown, onDone?: () => void) {\n  if (isAsyncIterable(input)) {\n    return Async.asCallback(input, callback);\n  } else {\n    return Sync.asCallback(input, callback);\n  }\n}\n\n","import { continuously } from \"../flow/Continuously.js\"\nimport { intervalToMs } from \"../flow/IntervalType.js\"\nimport type { IteratorControllerOptions, IteratorControllerState } from \"./Types.js\"\n\nexport type IteratorController = {\n  get state(): IteratorControllerState\n  /**\n   * Starts 'playback' of the iterator.\n   * If already started, this does nothing.\n   * If paused, continues playback.\n   * Use {@link restart} if you want to start with a reset.\n   * @returns \n   */\n  start: () => void\n  /**\n   * Starts or restarts 'playback' of the iterator.\n   * @returns \n   */\n  restart: () => void\n  /**\n   * Pauses 'playback' of the iterator.\n   * If already paused, does nothing.\n   * Use {@link start} to resume.\n   * @returns \n   */\n  pause: () => void\n  /**\n   * Cancels the running timer. This will\n   * stop playback, and next time {@link start}\n   * is called, it will be from the beginning.\n   * @returns \n   */\n  cancel: () => void\n}\n\n/**\n * Retrieve values from an iterator, passing them to a callback.\n * Allows iterator to be started, paused, or restarted and an optional delay between reading items from iterator.\n * @param options \n * @returns \n */\nexport const iteratorController = <T>(options: IteratorControllerOptions<T>): IteratorController => {\n  const delayMs = intervalToMs(options.delay, 10);\n  let gen: AsyncGenerator<T> | IterableIterator<T> | undefined;\n  const onValue = options.onValue;\n  let state: IteratorControllerState = `stopped`;\n\n  let loop = continuously(async () => {\n    if (gen) {\n      const r = await gen.next();\n      if (r.done) {\n        state = `stopped`;\n        return false;\n      }\n      const r2 = onValue(r.value);\n      if (typeof r2 === `boolean`) {\n        if (!r2) {\n          state = `stopped`;\n        }\n        return r2;\n\n      }\n      return true;\n    } else {\n      state = `stopped`\n      return false;\n    }\n  }, delayMs);\n\n  const cancel = () => {\n    if (state === `stopped`) return;\n    gen = undefined;\n    loop.cancel();\n    state = `stopped`;\n  }\n\n  const pause = () => {\n    if (state === `paused`) return;\n    loop.cancel();\n    state = `paused`;\n  }\n\n  const start = () => {\n    if (state === `running`) return;\n    if (!gen) {\n      remake();\n    }\n    state = `running`;\n    loop.start();\n  }\n\n  const remake = () => {\n    if (options.iterator) {\n      gen = options.iterator();\n    } else {\n      throw new Error(`No source iterator`);\n    }\n  }\n  const restart = () => {\n    remake();\n    start();\n  }\n\n  return {\n    start, cancel, restart, pause,\n    get state() {\n      return state\n    }\n  }\n}"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,oBAAAA;AAAA,EAAA,cAAAC;AAAA,EAAA,4BAAAC;AAAA,EAAA,cAAAC;AAAA,EAAA,iBAAAC;AAAA,EAAA,cAAAC;AAAA,EAAA,aAAAC;AAAA,EAAA,YAAAC;AAAA,EAAA,cAAAC;AAAA,EAAA,YAAAC;AAAA,EAAA,eAAAC;AAAA,EAAA,eAAAC;AAAA,EAAA,iBAAAC;AAAA,EAAA;AAAA;AAAA;AAAA,sBAAAC;AAAA,EAAA;AAAA;AAAA;AAAA,aAAAC;AAAA,EAAA,WAAAC;AAAA,EAAA,WAAAC;AAAA,EAAA,cAAAC;AAAA,EAAA,aAAAC;AAAA,EAAA,YAAAC;AAAA,EAAA,eAAAC;AAAA,EAAA,cAAAC;AAAA,EAAA,qBAAAC;AAAA,EAAA,aAAAC;AAAA,EAAA,WAAAC;AAAA;;;ACyCO,IAAM,qBAAqB,CAAI,YAA8D;AAClG,QAAM,UAAU,aAAa,QAAQ,OAAO,EAAE;AAC9C,MAAI;AACJ,QAAM,UAAU,QAAQ;AACxB,MAAI,QAAiC;AAErC,MAAI,OAAO,aAAa,YAAY;AAClC,QAAI,KAAK;AACP,YAAM,IAAI,MAAM,IAAI,KAAK;AACzB,UAAI,EAAE,MAAM;AACV,gBAAQ;AACR,eAAO;AAAA,MACT;AACA,YAAM,KAAK,QAAQ,EAAE,KAAK;AAC1B,UAAI,OAAO,OAAO,WAAW;AAC3B,YAAI,CAAC,IAAI;AACP,kBAAQ;AAAA,QACV;AACA,eAAO;AAAA,MAET;AACA,aAAO;AAAA,IACT,OAAO;AACL,cAAQ;AACR,aAAO;AAAA,IACT;AAAA,EACF,GAAG,OAAO;AAEV,QAAM,SAAS,MAAM;AACnB,QAAI,UAAU,UAAW;AACzB,UAAM;AACN,SAAK,OAAO;AACZ,YAAQ;AAAA,EACV;AAEA,QAAM,QAAQ,MAAM;AAClB,QAAI,UAAU,SAAU;AACxB,SAAK,OAAO;AACZ,YAAQ;AAAA,EACV;AAEA,QAAM,QAAQ,MAAM;AAClB,QAAI,UAAU,UAAW;AACzB,QAAI,CAAC,KAAK;AACR,aAAO;AAAA,IACT;AACA,YAAQ;AACR,SAAK,MAAM;AAAA,EACb;AAEA,QAAM,SAAS,MAAM;AACnB,QAAI,QAAQ,UAAU;AACpB,YAAM,QAAQ,SAAS;AAAA,IACzB,OAAO;AACL,YAAM,IAAI,MAAM,oBAAoB;AAAA,IACtC;AAAA,EACF;AACA,QAAM,UAAU,MAAM;AACpB,WAAO;AACP,UAAM;AAAA,EACR;AAEA,SAAO;AAAA,IACL;AAAA,IAAO;AAAA,IAAQ;AAAA,IAAS;AAAA,IACxB,IAAI,QAAQ;AACV,aAAO;AAAA,IACT;AAAA,EACF;AACF;;;ADjEO,SAASC,sBAAqB,SAAgE,UAAgD,CAAC,GAA+B;AACnL,SAAc,qBAAqB,SAAS,OAAO;AACrD;AAwBO,SAASC,KAAO,IAAoC,KAAK,CAAC,GAAM,MAAS,IAAI,GAAqC;AACvH,SAAO,gBAAgB,EAAE,IAAUA,KAAI,IAAI,EAAE,IAAS,IAAI,IAAI,EAAE;AAClE;AAwBO,SAASC,KAAO,IAAoC,KAAK,CAAC,GAAM,MAAS,IAAI,GAAqC;AACvH,SAAO,gBAAgB,EAAE,IAAUA,KAAI,IAAI,EAAE,IAAS,IAAI,IAAI,EAAE;AAClE;AAgBO,SAASC,WAAa,IAAoC,GAAwD;AACvH,SAAO,gBAAgB,EAAE,IAAUA,WAAU,IAAI,CAAC,IAAS,UAAU,IAAI,CAAC;AAC5E;AAuBO,SAASC,OAAM,IAAwC,UAAyG;AACrK,MAAI,gBAAgB,EAAE,GAAG;AACvB,WAAaA,OAAM,IAAI,QAAQ;AAAA,EACjC,OAAO;AAEL,IAAK,MAAM,IAAI,QAAQ;AAAA,EACzB;AACF;AAkBO,SAASC,QAAU,IAAoC,MAA8D;AAC1H,SAAO,gBAAgB,EAAE,IAAUA,QAAO,IAAI,IAAI,IAAS,OAAO,IAAI,IAAI;AAC5E;AAiBO,SAASC,QAAU,IAAoC,GAA2E;AAEvI,SAAO,gBAAgB,EAAE,IAAUA,QAAO,IAAI,CAAC,IAAS,OAAO,IAAI,CAAsB;AAC3F;AAkBO,SAASC,MAAQ,IAAoC,GAAwC;AAClG,SAAO,gBAAgB,EAAE,IAAUA,MAAK,IAAI,CAAC,IAAS,KAAK,IAAI,CAAC;AAClE;AAaO,SAASC,WAAa,KAAqF;AAChH,SAAO,gBAAgB,IAAK,CAAE,CAAC,IAAUA,QAAO,GAAG,GAA8B,IAAS,OAAO,GAAG,GAAyB;AAC/H;AAiBO,SAASC,MAAQ,IAA+C,GAAiF;AAEtJ,SAAO,gBAAgB,EAAE,IAAUA,MAAK,IAAI,CAAC,IAAS,KAAK,IAAI,CAAsB;AACvF;AAgBO,SAASC,SAAW,IAA+C,IAA6E,UAAmC,CAAC,GAAG;AAC5L,MAAI,gBAAgB,EAAE,GAAG;AACvB,WAAaA,SAAQ,IAAI,IAAI,OAAO;AAAA,EACtC,OAAO;AACL,IAAK,QAAQ,IAAI,EAAuB;AAAA,EAC1C;AACF;AAqBO,SAASC,KAAU,IAA+C,GAA6B;AACpG,SAAO,gBAAgB,EAAE,IAAUA,KAAI,IAAI,CAAC,IAAS,IAAI,IAAI,CAAC;AAChE;AAaO,SAASC,WAAa,OAAiB,UAAuD;AACnG,SAAO,aAAa,SAAiB,UAAU,KAAK,IAAUA,WAAU,OAAO,QAAQ;AACzF;AAcO,SAASC,SAAW,IAAqG;AAC9H,SAAO,gBAAgB,EAAE,IAAUA,SAAQ,EAAE,IAAS,QAAQ,EAAE;AAClE;AAgBO,SAASC,MAAQ,IAAoC,GAAqE;AAC/H,SAAO,gBAAgB,EAAE,IAAUA,MAAK,IAAI,CAAC,IAAS,KAAK,IAAI,CAAsB;AACvF;AAgBO,SAASC,QAAU,IAA+C,GAAsC,OAA0B;AACvI,SAAO,gBAAgB,EAAE,IAAUA,QAAO,IAAI,GAAG,KAAK,IAAS,OAAO,IAAI,GAAG,KAAK;AACpF;AAiBO,SAASC,OACd,IACA,QAAQ,GACR,MAAM,OAAO,mBACb;AACA,SAAO,gBAAgB,EAAE,IAAUA,OAAM,IAAI,OAAO,GAAG,IAAS,MAAM,IAAI,GAAG;AAC/E;AAqBO,SAASC,QAAU,UAAsI;AAC9J,MAAI,MAAM,QAAQ,QAAQ,GAAG;AAC3B,QAAI,SAAS,WAAW,EAAG,QAAY,UAAU,CAAC,CAAC;AACnD,WAAO,gBAAgB,SAAU,CAAE,CAAC,IAAUA,QAAO,QAAmC,IAAS,OAAO,QAA8B;AAAA,EACxI,WAAW,gBAAgB,QAAQ,GAAG;AACpC,WAAaA,QAAO,QAAQ;AAAA,EAC9B,OAAO;AACL,WAAY,OAAO,QAAQ;AAAA,EAC7B;AACF;AAoDO,UAAUC,eAAiB,OAAkD,WAA6B,iBAAiB,OAAoB,oBAAI,IAAY,GAAqC;AACzM,SAAO,gBAAgB,KAAK,IAAUA,eAAc,OAAO,UAAU,IAAI,IAAS,cAAc,OAAO,UAAU,IAAI;AACvH;AAoBO,SAASC,SAAW,IAAoC,UAAmC,CAAC,GAAiC;AAClI,SAAO,gBAAgB,EAAE,IAAUA,SAAQ,IAAI,OAAO,IAAS,QAAQ,IAAI,OAAO;AACpF;AAcO,SAASC,OAAS,IAA+C,GAAqE;AAC3I,SAAO,gBAAgB,EAAE,IAAUA,OAAM,IAAI,CAAC,IAAS,MAAM,IAAI,CAAsB;AACzF;AAcO,SAASC,QAAU,KAA6C,KAA6C,UAAoC;AACtJ,QAAM,KAAK,gBAAgB,GAAG,KAAK,gBAAgB,GAAG;AACtD,SAAO,KAAWA,QAAO,KAAK,KAAK,QAAQ,IAAS,OAAO,KAA4B,KAA4B,QAAQ;AAC7H;AAeO,SAASC,QAAU,KAAmE;AAC3F,MAAI,IAAI,WAAW,EAAG,QAAY,UAAU,CAAC,CAAC;AAC9C,SAAO,gBAAgB,IAAK,CAAE,CAAC,IAAUA,KAAI,GAAG,GAAsC,IAAS,IAAI,GAAG,GAAiC;AACzI;AAYO,SAASC,cAAgB,UAA0C,UAAuD;AAC/H,MAAI,gBAAgB,QAAQ,KAAK,aAAa,OAAW,QAAaA,cAAa,UAAU,QAAQ;AACrG,SAAY,aAAa,QAAQ;AACnC;AAcO,UAAU,aAAgB,UAAmB;AAClD,SAAO,MAAM;AACX,UAAM,IAAI,SAAS;AACnB,UAAM;AAAA,EACR;AACF;AAgBA,gBAAuB,oBAAuB,UAAgC;AAC5E,SAAO,MAAM;AACX,UAAM,IAAI,MAAM,SAAS;AACzB,UAAM;AAAA,EACR;AACF;AAyBO,SAASC,YAAc,OAAuC,UAA6B,QAAqB;AACrH,MAAI,gBAAgB,KAAK,GAAG;AAC1B,WAAaA,YAAW,OAAO,QAAQ;AAAA,EACzC,OAAO;AACL,WAAY,WAAW,OAAO,QAAQ;AAAA,EACxC;AACF;","names":["asCallback","chunks","combineLatestToArray","concat","dropWhile","equals","every","fill","filter","find","flatten","forEach","fromArray","fromIterable","map","max","min","reduce","slice","some","toArray","unique","uniqueByValue","until","zip","combineLatestToArray","min","max","dropWhile","until","chunks","filter","fill","concat","find","forEach","map","fromArray","flatten","some","reduce","slice","unique","uniqueByValue","toArray","every","equals","zip","fromIterable","asCallback"]}