{"version":3,"file":"index.js","names":[],"sources":["../../core/dist/src/trackers/index.js","../../core/dist/src/correlate.js","../../core/dist/src/filters.js","../../core/dist/src/is-equal-test.js","../../core/dist/src/platform.js","../../core/dist/src/util/zip.js","../../core/dist/src/resolve-fields.js"],"sourcesContent":["export {};\n","const orderScore = (a, b) => {\n    if (a.score > b.score)\n        return -1;\n    else if (a.score < b.score)\n        return 1;\n    return 0;\n};\n/**\n * Attempts to align prior data with new data, based on a provided similarity function.\n *\n * See also `alignById` for a version which encloses parameters.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const newData = [\n *  { id:`2`, x:101, y:200 }\n * ]\n * const aligned = Correlate.align(fn, lastdata, newData, opts);\n *\n * // Result:\n * [\n *  { id:`1`, x:101, y:200 }\n * ]\n * ```\n * @param similarityFunction Function to compute similarity\n * @param lastData Old data\n * @param newData New data\n * @param options Options\n * @returns\n */\nexport const align = (similarityFunction, lastData, newData, options = {}) => {\n    const matchThreshold = options.matchThreshold ?? 0;\n    const debug = options.debug ?? false;\n    const results = new Map();\n    const newThings = [];\n    const lastMap = new Map();\n    lastData?.forEach((d, index) => {\n        if (typeof d === `undefined`) {\n            throw new Error(`'lastData' contains undefined (index: ${index.toString()})`);\n        }\n        lastMap.set(d.id, d);\n    });\n    for (const newD of newData) { //let index = 0; index < newData.length; index++) {\n        //const newD = newData[ index ];\n        if (!lastData || lastData.length === 0) {\n            // No last data to compare to\n            if (debug)\n                console.debug(`Correlate.align() new id: ${newD.id}`);\n            newThings.push(newD);\n            continue;\n        }\n        // Which of the old data does the new data match up to best?\n        const scoredLastValues = Array.from(lastMap.values()).map((last) => ({\n            id: (last).id,\n            score: last === null ? -1 : similarityFunction(last, newD),\n            last,\n        }));\n        if (scoredLastValues.length === 0) {\n            if (debug) {\n                console.debug(`Correlate.align() no valid last values id: ${newD.id}`);\n            }\n            newThings.push(newD);\n            continue;\n        }\n        scoredLastValues.sort(orderScore);\n        // Top-ranked match is pretty low, must be something new\n        const top = scoredLastValues[0];\n        if (top.score < matchThreshold) {\n            if (debug) {\n                console.debug(`Correlate.align() new item does not reach threshold. Top score: ${top.score.toString()} id: ${newD.id}`);\n            }\n            newThings.push(newD);\n            continue;\n        }\n        // TODO: If there are close options to pick, need a pluggable\n        // function to determine which is the winner.\n        //    console.log(`updating prior ${top.score}. top: ${top.id} newD: ${newD.id}`);\n        // The new item is considered the same as top ranked\n        if (debug && top.id !== newD.id) {\n            console.log(`Correlate.align() Remapped ${newD.id} -> ${top.id} (score: ${top.score.toString()})`);\n        }\n        results.set(top.id, { ...newD, id: top.id });\n        // Remove that old one from the list\n        lastMap.delete(top.id);\n    }\n    newThings.forEach((t) => results.set(t.id, t));\n    return Array.from(results.values());\n};\n/**\n * Returns a function that attempts to align a series of data by its id.\n * See also {@link align} for a version with no internal storage.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const aligner = Correlate.alignById(fn, opts);\n *\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const aligned = aligner(lastData);\n *\n * ```\n * @param fn Function to compute similarity\n * @param options Options\n * @returns\n */\nexport const alignById = (fn, options = {}) => {\n    let lastData = [];\n    const compute = (newData) => {\n        lastData = align(fn, lastData, newData, options);\n        return [...lastData];\n    };\n    return compute;\n};\n","/**\n * Returns `v` if `predicate` returns _true_,\n * alternatively returning `skipValue`.\n *\n * ```js\n * // Return true if value is less than 10\n * const p = v => v < 10;\n *\n * filterValue(5, p, 0);   // 5\n * filterValue(20, p, 0);  // 0\n * ```\n * @param v Value to test\n * @param predicate Predicate\n * @param skipValue Value to return if predicate returns false\n * @returns Input value if predicate is _true_, or `skipValue` if not.\n */\nexport const filterValue = (v, predicate, skipValue) => {\n    if (predicate(v))\n        return v;\n    return skipValue;\n};\n","import { toStringAbbreviate } from \"./text.js\";\n/**\n * Wraps the `eq` function, tracing the input data result\n * ```js\n * // Init trace\n * const traceEq = isEqualTrace(isEqualValueDefault);\n * // Use it in some function that takes IsEqual<T>\n * compare(a, b, eq);\n * ```\n * @param eq\n * @returns\n */\nexport const isEqualTrace = (eq) => {\n    return (a, b) => {\n        const result = eq(a, b);\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        console.log(`isEqualTrace eq: ${result} a: ${toStringAbbreviate(a)} b: ${toStringAbbreviate(b)}`);\n        return result;\n    };\n};\n","/**\n * Returns _true_ if it seems like the code is running on iOS (iPad/iPhone)\n * @returns\n */\nexport const runningiOS = () => [\n    `iPad Simulator`,\n    `iPhone Simulator`,\n    `iPod Simulator`,\n    `iPad`,\n    `iPhone`,\n    `iPod`,\n].includes(navigator.platform) ||\n    // iPad on iOS 13 detection\n    (navigator.userAgent.includes(`Mac`) && `ontouchend` in document);\n","export const zip = (...arrays) => {\n    if (arrays.some((a) => !Array.isArray(a))) {\n        throw new Error(`All parameters must be an array`);\n    }\n    const lengths = arrays.map((a) => a.length);\n    const returnValue = [];\n    const length = lengths[0];\n    for (let index = 0; index < length; index++) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        returnValue.push(arrays.map((a) => a[index]));\n    }\n    return returnValue;\n};\n","import { resolve, resolveSync } from \"@ixfx/core\";\nimport { zip } from \"./util/zip.js\";\n/**\n * Returns a copy of `object`, with the same properties. For each property\n * that has a basic value (string, number, boolean, object), the value is set\n * for the return object. If the property is a function or generator, its value\n * is used instead. Async functions and generators are also usable.\n *\n * Use {@link resolveFieldsSync} for a synchronous version.\n *\n * Not recursive.\n *\n * In the below example, the function for the property `random` is invoked.\n * ```js\n * const state = {\n *  length: 10,\n *  random: () => Math.random();\n * }\n * const x = resolveFields(state);\n * // { length: 10, random: 0.1235 }\n * ```\n *\n * It also works with generators. Probably best with those that are infinite.\n *\n * ```js\n * import { count } from './numbers.js';\n *\n * const state = {\n *  length: 10,\n *  index: count(2) // Generator that yields: 0, 1 and then ends\n * }\n * resolveFields(state); // { length: 10, index: 0 }\n * resolveFields(state); // { length: 10, index: 1 }\n * // Generator finishes after counting twice:\n * resolveFields(state); // { length: 10, index: undefined }\n * ```\n * @param object\n * @returns\n */\nexport async function resolveFields(object) {\n    const resolvers = [];\n    const keys = [];\n    for (const entry of Object.entries(object)) {\n        const resolvable = entry[1];\n        resolvers.push(resolve(resolvable));\n        keys.push(entry[0]);\n    }\n    const results = await Promise.all(resolvers);\n    const entries = zip(keys, results);\n    return Object.fromEntries(entries);\n}\n/**\n * 'Resolves' all the fields of `object` in a synchronous manner.\n * Uses {@link resolveSync} under-the-hood\n * @param object\n * @returns\n */\nexport function resolveFieldsSync(object) {\n    const entries = [];\n    for (const entry of Object.entries(object)) {\n        const resolvable = entry[1];\n        const value = resolveSync(resolvable);\n        entries.push([entry[0], value]);\n    }\n    return Object.fromEntries(entries);\n}\n/**\n * Returns a function that resolves `object`.\n *\n * Use {@link resolveFields} to resolve an object directly.\n * @param object\n * @returns\n */\n// export function resolverFields<V extends object>(object: V) {\n//   return () => resolveFields(object);\n// }\n"],"mappings":"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"}