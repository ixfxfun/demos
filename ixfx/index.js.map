{"version":3,"file":"index.js","names":["toArray","value: unknown","value: unknown","range: StringGuardRange","array","array","toStringDefault","isEqualDefault","isEqualValueDefault","isEqualDefault","toStringDefault","set","array","add","isEqualDefault","isContentsTheSame","array","isEqualValueDefault","filter","array","isEqualDefault","array","groupBy","array","isEqualDefault","contains","unique","toStringDefault","insertAt","array","isEqualDefault","array","shuffle","array","remove","array","total","zip","elapsedSince","elapsedInterval","elapsedInfinity","isReactive","rx: object","hasLast","rx:  object","resolve","r: ResolveToValue<V>","resolveSync","r: ResolveToValueSync<V>","resolveWithFallbackSync","p: ResolveToValueSync<T>","fallback: ResolveFallbackOpts<T>","sleep","optsOrMillis: SleepOpts<V>","resolve","toStringDefault","itemToMakeStringFor: V","isEqualValueDefault","a: T","b: T","array: readonly V[] | V[]","equality?: IsEqual<V>","array","isEqualValueDefault","unique","arrays:\n    | V[][]\n    | V[]\n    | readonly V[]\n    | readonly (readonly V[])[]","toStringDefault","t: V[]","data: readonly V[] | V[]","index: number","dataToShuffle: readonly V[]","rand: () => number","array","data: readonly V[] | V[]","index: number","zip","returnValue: any[]","piPi","interpolate","pos1: number","pos2?: number | Partial<BasicInterpolateOptions>","pos3?: number | Partial<BasicInterpolateOptions>","pos4?: Partial<BasicInterpolateOptions>","amountProcess: undefined | ((v: number) => number)","limits: BasicInterpolateOptions[ 'limits' ]","amount: number","_amt: number","_a: number","_b: number","o: Partial<BasicInterpolateOptions>","a: number","b: number","aValue: number","bValue: number","interpolateAngle","aRadians: number","bRadians: number","options?: Partial<BasicInterpolateOptions>","piPi","p: unknown","toCartesian: ToCartesian","a: Coord | number","b?: Point | number","c?: Point","EmptyPoint","distance: number","angleRadians: number","origin: Point","distance","pt: Point","a: Point","b: Point","interpolate","amount: number","a: Point","b: Point","pt: Point | Point3d","what: `both` | `x` | `y` | `z`","point: Point","pipeline","pt: Point","maxOrOptions: (number | RandomOptions)","max","min","origin: Point","width: number","height: number","rect: RectPositioned | Rect","edge: `right` | `bottom` | `left` | `top`","start: Point","end: Point","q: QuadraticBezier | CubicBezier","BezierLibrary","amount: number","handle: Point","cubicOrQuadratic: CubicBezier | QuadraticBezier","cubic1: Point","cubic2: Point","cubic: CubicBezier","cubic","t: number","_: Point","_point: Point","_intersectionThreshold: number","quadraticBezier: QuadraticBezier","quadratic","v: any","opts: QueueOpts<V>","queue: ReadonlyArray<V>","toAdd: ReadonlyArray<V>","opts: QueueOpts<V>","data: readonly V[]","index: number","result: readonly V[]","attemptedToAdd: readonly V[]","removed: readonly V[]","finalData: readonly V[]","predicate: (item: V) => boolean","it: AsyncIterableIterator<V> | IterableIterator<V>","options: SleepOpts<any>","value: IteratorResult<V> | undefined","map: ReadonlyMap<K, V>","data: ArrayKeys<K, V>","data: ObjectKeys<K, V>","key: K","value: V","immutable","dataOrMap?: ReadonlyMap<K, V> | EitherKey<K, V>","key: K","value: V","id: string","g: DirectedGraph","graph: DirectedGraph","vertex: string | Vertex","outIdOrVertex: string | Vertex","graph","vertex: Vertex","from: string","to: string","weight?: number","to","edge: Edge","options: ConnectOptions","edges: Edge[]","weight","idOrVertex: string | Vertex","count","elapsed","getErrorMessage","object","apply","average","total","min","array","max","clamp","min","max","min","max","round","relative","scale","clamp","min","max","wrap","piPi","interpolate","interpolatorStepped","interpolateAngle","piPi","#store","average","count","smoothingFactor","scale","scaler","total","min","max","count","min","max","array","property: string","selectors: QueryOrElements","value?: any","elements: Array<HTMLElement>","set","v: any","#id","#handlers","handler: Dispatch<V>","options: { once?: boolean }","#counter","wrap: Wrap<V>","wrap","id: string","value: V","callback: TimeoutSyncCallback | TimeoutAsyncCallback","interval: Interval","timer: ReturnType<typeof setTimeout>","state: HasCompletionRunStates","altInterval: Interval","args: unknown[]","resolve","produce: ResolveToValue<T> | ArrayLike<T>","opts: RepeatDelayOpts","count","elapsed","duration: Interval","opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean }","t: ModulationTimer | undefined","totalTicks: number","total: number","options: Partial<RelativeTimerOpts>","total","value: number","amt: number","frequency: number","options: Partial<TimerOpts>","fn: ((v: number) => number)","timer: CompletionTimer","elapsed","toClone: MachineState<V>","stateMachine: Machine<V> | Transitions | TransitionsStrict","initialState?: StateNames<V>","state: StateNames<V>","smOrTransitions: Machine<V> | Transitions | TransitionsStrict","sm: MachineState<V>","targets:\n    | StateTarget<V>\n    | readonly StateTargetStrict<V>[]\n    | StateTargetStrict<V>","target: string | undefined | null | object","d: Transitions","state: MachineState<V>","to","toState: StateNames<V>","m: V","opts: StateMachineWithEventsOptions<V>","#debug","#sm","#smInitial","v: boolean","#isDone","#isDoneNeedsFiring","#setIsDone","#changedAt","newState: StateNames<V>","#sm","event","#holdingInitial","#timer","#timeSource","#holding","#disposed","elapsed","relative","#triggered","adsr","max","iterator","ticks","elapsed","bpm","min","max","clamp","elapsed","elapsed","pow","gaussianA","gaussian","sqrt","pow","cos","pi","sin","bounceOut","quintIn","quintOut","arch","smoothstep","smootherstep","sineIn","sineOut","quadIn","quadOut","sineInOut","quadInOut","cubicIn","cubicOut","quartIn","quartOut","expoIn","expoOut","quintInOut","expoInOut","circIn","circOut","backIn","backOut","circInOut","backInOut","elasticIn","elasticOut","bounceIn","bell","elasticInOut","bounceInOut","max","time","relative","ticks","easingsMap","get","cacheEasings","Named","guard","mass","pipeline","distance","piPi","interpolate","piPi","abs","relative","distance","to","invert","hasLast","isReactive","manual","run","iterator","isEmpty","stream","stream","stream","field","event","noop","set","field","value","event","field","debounce","elapsed","elapsed","pow","t: number","x: number","easingsMap: Map<string, ((v: number) => number)> | undefined","easingName: EasingName","Named","interpolate","pos1: number","pos2?: number | Partial<InterpolateOptions>","pos3?: number | Partial<InterpolateOptions>","pos4?: Partial<InterpolateOptions>","amountProcess: undefined | ((v: number) => number)","limits: InterpolateOptions[ 'limits' ]","amount: number","_amt: number","_a: number","_b: number","o: Partial<InterpolateOptions>","a: number","b: number","aValue: number","bValue: number","interpolate","max","value: number | number[]","min","sum","average","total","tally","countArrayItems: boolean","rank","r: RankFunction<In>","options: Partial<RankOptions>","best: In | undefined","value: In","sum","rank","annotate","event","stream","init","event","elapsed","repeat","process","resolve","resolve","wrap","source","array","set","filter","count","insertAt","set","count","remove","add","count","elapsed","stream","stream","set","target","init","set","rank","resolve","transform","toStringDefault","object","continuously","interval","chunk","isEqualDefault","isEqualValueDefault","isEqualContextString","isEqualDefault","intervalToMs","set","object","throwResult","resolve"],"sources":["../../packages/arrays/dist/src/array-cycle.js","../../packages/guards/src/function.ts","../../packages/guards/src/string.ts","../../packages/arrays/dist/src/at-wrap.js","../../packages/arrays/dist/src/chunks.js","../../packages/arrays/dist/src/util/to-string.js","../../packages/arrays/dist/src/util/is-equal.js","../../packages/arrays/dist/src/contains.js","../../packages/arrays/dist/src/ensure-length.js","../../packages/arrays/dist/src/equality.js","../../packages/arrays/dist/src/filter.js","../../packages/arrays/dist/src/flatten.js","../../packages/arrays/dist/src/frequency.js","../../packages/arrays/dist/src/group-by.js","../../packages/arrays/dist/src/unique.js","../../packages/arrays/dist/src/insert-at.js","../../packages/arrays/dist/src/interleave.js","../../packages/arrays/dist/src/intersection.js","../../packages/arrays/dist/src/merge-by-key.js","../../packages/arrays/dist/src/pairwise.js","../../packages/arrays/dist/src/random.js","../../packages/arrays/dist/src/remove.js","../../packages/arrays/dist/src/sample.js","../../packages/arrays/dist/src/sort.js","../../packages/arrays/dist/src/until.js","../../packages/arrays/dist/src/zip.js","../../packages/arrays/dist/src/index.js","../../packages/core/src/elapsed.ts","../../packages/core/src/reactive-core.ts","../../packages/core/src/resolve-core.ts","../../packages/core/src/sleep.ts","../../packages/arrays/src/util/to-string.ts","../../packages/arrays/src/util/is-equal.ts","../../packages/arrays/src/equality.ts","../../packages/arrays/src/unique.ts","../../packages/arrays/src/insert-at.ts","../../packages/arrays/src/random.ts","../../packages/arrays/src/remove.ts","../../packages/arrays/src/zip.ts","../../packages/numbers/src/pi-pi.ts","../../packages/numbers/src/interpolate.ts","../../packages/geometry/src/polar/guard.ts","../../packages/geometry/src/polar/conversions.ts","../../packages/geometry/src/point/abs.ts","../../packages/geometry/src/point/compare.ts","../../packages/geometry/src/point/interpolate.ts","../../packages/geometry/src/point/invert.ts","../../packages/geometry/src/point/pipeline.ts","../../packages/random/src/float-source.ts","../../packages/geometry/src/rect/from-top-left.ts","../../packages/geometry/src/rect/edges.ts","../../packages/geometry/src/bezier/index.ts","../../packages/iterables/src/guard.ts","../../packages/collections/src/queue/queue-fns.ts","../../packages/collections/src/queue/queue-mutable.ts","../../packages/iterables/src/async.ts","../../packages/collections/src/map/map-immutable-fns.ts","../../packages/collections/src/map/map.ts","../../packages/collections/src/graph/directed-graph.ts","../../packages/debug/dist/src/util.js","../../packages/debug/dist/src/logger.js","../../packages/debug/dist/src/fps-counter.js","../../packages/debug/dist/src/index.js","../../packages/numbers/dist/src/apply-to-values.js","../../packages/numbers/dist/src/numeric-arrays.js","../../packages/numbers/dist/src/average-weighted.js","../../packages/numbers/dist/src/clamp.js","../../packages/numbers/dist/src/difference.js","../../packages/numbers/dist/src/guard.js","../../packages/numbers/dist/src/filter.js","../../packages/numbers/dist/src/flip.js","../../packages/numbers/dist/src/round.js","../../packages/numbers/dist/src/is-approx.js","../../packages/numbers/dist/src/bipolar.js","../../packages/numbers/dist/src/wrap.js","../../packages/numbers/dist/src/pi-pi.js","../../packages/numbers/dist/src/interpolate.js","../../packages/numbers/dist/src/linear-space.js","../../packages/numbers/dist/src/util/queue-mutable.js","../../packages/numbers/dist/src/moving-average.js","../../packages/numbers/dist/src/scale.js","../../packages/numbers/dist/src/number-array-compute.js","../../packages/numbers/dist/src/normalise.js","../../packages/numbers/dist/src/proportion.js","../../packages/numbers/dist/src/quantise.js","../../packages/numbers/dist/src/softmax.js","../src/numbers.ts","../../packages/dom/src/set-property.ts","../../packages/flow/src/dispatch-list.ts","../../packages/flow/src/timeout.ts","../../packages/flow/src/repeat.ts","../../packages/flow/src/timer.ts","../../packages/modulation/dist/src/envelope/Types.js","../../packages/flow/src/state-machine/state-machine.ts","../../packages/flow/src/state-machine/with-events.ts","../../packages/modulation/dist/src/envelope/AdsrBase.js","../../packages/modulation/dist/src/envelope/Adsr.js","../../packages/modulation/dist/src/envelope/index.js","../../packages/modulation/dist/src/source/ticks.js","../../packages/modulation/dist/src/source/time.js","../../packages/modulation/dist/src/source/per-second.js","../../packages/modulation/dist/src/source/index.js","../../packages/modulation/dist/src/cubic-bezier.js","../../packages/modulation/dist/src/drift.js","../../packages/modulation/dist/src/gaussian.js","../../packages/modulation/dist/src/easing/easings-named.js","../../packages/modulation/dist/src/easing/line.js","../../packages/modulation/dist/src/modulator-timed.js","../../packages/modulation/dist/src/easing/index.js","../../packages/modulation/dist/src/forces.js","../../packages/modulation/dist/src/util/pi-pi.js","../../packages/modulation/dist/src/interpolate.js","../../packages/modulation/dist/src/jitter.js","../../packages/modulation/dist/src/mix.js","../../packages/modulation/dist/src/no-op.js","../../packages/modulation/dist/src/oscillator.js","../../packages/modulation/dist/src/ping-pong.js","../../packages/modulation/dist/src/spring.js","../../packages/modulation/dist/src/timing-source-factory.js","../../packages/modulation/dist/src/waveforms.js","../../packages/modulation/dist/src/weighted-average.js","../../packages/modulation/dist/src/weighted-random.js","../src/modulation.ts","../../packages/rx/dist/src/util.js","../../packages/rx/dist/src/from/function.js","../../packages/rx/dist/src/from/iterator.js","../../packages/rx/dist/src/resolve-source.js","../../packages/rx/dist/src/cache.js","../../packages/rx/dist/src/init-stream.js","../../packages/rx/dist/src/sinks/dom.js","../../packages/rx/dist/src/to-readable.js","../../packages/rx/dist/src/ops/annotate.js","../../packages/rx/dist/src/ops/chunk.js","../../packages/rx/dist/src/ops/transform.js","../../packages/rx/dist/src/ops/clone-from-fields.js","../../packages/rx/dist/src/ops/combine-latest-to-array.js","../../packages/rx/dist/src/from/object.js","../../packages/rx/dist/src/ops/combine-latest-to-object.js","../../packages/rx/dist/src/ops/compute-with-previous.js","../../packages/rx/dist/src/reactives/debounce.js","../../packages/rx/dist/src/ops/debounce.js","../../packages/rx/dist/src/ops/elapsed.js","../../packages/rx/dist/src/ops/field.js","../../packages/rx/dist/src/ops/filter.js","../../packages/modulation/src/gaussian.ts","../../packages/modulation/src/easing/easings-named.ts","../../packages/modulation/src/easing/index.ts","../../packages/modulation/src/interpolate.ts","../../packages/rx/dist/src/ops/interpolate.js","../../packages/process/src/basic.ts","../../packages/rx/dist/src/ops/math.js","../../packages/rx/dist/src/ops/pipe.js","../../packages/rx/dist/src/ops/single-from-array.js","../../packages/rx/dist/src/ops/split.js","../../packages/rx/dist/src/ops/switcher.js","../../packages/rx/dist/src/ops/sync-to-array.js","../../packages/rx/dist/src/ops/sync-to-object.js","../../packages/rx/dist/src/ops/tap.js","../../packages/rx/dist/src/ops/throttle.js","../../packages/rx/dist/src/ops/timeout-value.js","../../packages/rx/dist/src/ops/timeout-ping.js","../../packages/rx/dist/src/ops/value-to-ping.js","../../packages/rx/dist/src/ops/with-value.js","../../packages/rx/dist/src/graph.js","../../packages/rx/dist/src/types.js","../../packages/rx/dist/src/to-array.js","../../packages/rx/dist/src/to-generator.js","../../packages/rx/dist/src/wrap.js","../../packages/rx/dist/src/from/array.js","../../packages/rx/dist/src/from/array-object.js","../../packages/rx/dist/src/from/boolean.js","../../packages/rx/dist/src/from/count.js","../../packages/rx/dist/src/from/derived.js","../../packages/rx/dist/src/from/event.js","../../packages/rx/dist/src/from/merged.js","../../packages/rx/dist/src/from/number.js","../../packages/rx/dist/src/from/object-proxy.js","../../packages/rx/dist/src/from/observable.js","../../packages/rx/dist/src/from/string.js","../../packages/rx/dist/src/from/index.js","../../packages/rx/dist/src/index.js","../src/rx.ts","../../packages/core/dist/src/to-string.js","../../packages/core/dist/src/comparers.js","../../packages/core/dist/src/count.js","../../packages/core/dist/src/continuously.js","../../packages/core/dist/src/correlate.js","../../packages/core/dist/src/default-keyer.js","../../packages/core/dist/src/elapsed.js","../../packages/core/dist/src/filters.js","../../packages/core/dist/src/text.js","../../packages/core/dist/src/is-equal-test.js","../../packages/core/dist/src/is-equal.js","../../packages/core/dist/src/is-integer.js","../../packages/core/dist/src/is-primitive.js","../../packages/core/dist/src/iterable-compare-values-shallow.js","../../packages/core/dist/src/key-value.js","../../packages/core/dist/src/util/round.js","../../packages/core/dist/src/interval-type.js","../../packages/core/dist/src/track-unique.js","../../packages/core/dist/src/platform.js","../../packages/core/dist/src/promise-from-event.js","../../packages/core/dist/src/reactive-core.js","../../packages/core/dist/src/resolve-core.js","../../packages/core/dist/src/util/zip.js","../../packages/core/dist/src/resolve-fields.js","../../packages/core/dist/src/results.js","../../packages/core/dist/src/sleep.js"],"sourcesContent":["/**\n * Cycle through the contents of an array. By default starts at index 0.\n * ```js\n * const c = arrayCycle([`apples`, `oranges`, `pears`]);\n * c.current; // `apples`\n * c.next();  // `oranges`\n * c.next();  // `pears`\n * c.next();  // `apples`\n * c.prev();  // `pears`\n * ```\n *\n * You can select an item by index or value:\n * ```\n * c.select(1); // `oranges`\n * c.select(`pears`); // `pears`\n * ```\n *\n * Other features:\n * ```js\n * c.current;   // Current value\n * c.toArray(); // Copy of array being cycled over\n * ```\n *\n * Additional info:\n * * Selecting by value uses === semantics.\n * * Works with a copy of input array\n * @param options Array to cycle over\n * @returns\n */\nexport const cycle = (options) => {\n    const opts = [...options];\n    let index = 0;\n    const next = () => {\n        index++;\n        if (index === opts.length)\n            index = 0;\n        return value();\n    };\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const prev = () => {\n        index--;\n        if (index === -1)\n            index = opts.length - 1;\n        return value();\n    };\n    const value = () => {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return opts.at(index);\n    };\n    const select = (indexOrValue) => {\n        if (typeof indexOrValue === `number`) {\n            index = indexOrValue;\n        }\n        else {\n            const found = opts.indexOf(indexOrValue);\n            if (found === -1)\n                throw new Error(`Could not find value`);\n            index = found;\n        }\n    };\n    const toArray = () => [...opts];\n    return { toArray, next, prev, get current() { return value(); }, select };\n};\n","import type { GuardResult } from \"./types.js\";\n\nexport const isFunction = (object: unknown): object is (...args: Array<any>) => any => object instanceof Function;\n\nexport const functionTest = (value: unknown, parameterName = `?`): GuardResult => {\n  if (value === undefined) return [ false, `Param '${ parameterName }' is undefined. Expected: function.` ];\n  if (value === null) return [ false, `Param '${ parameterName }' is null. Expected: function.` ];\n  if (typeof value !== `function`) return [ false, `Param '${ parameterName }' is type '${ typeof value }'. Expected: function` ];\n  return [ true ];\n}\n\nexport const throwFunctionTest = (value: unknown, parameterName = `?`) => {\n  const [ ok, msg ] = functionTest(value, parameterName);\n  if (ok) return;\n  throw new TypeError(msg);\n}","import type { GuardResult } from \"./types.js\";\nimport { throwFromResult } from \"./throw-from-result.js\";\n\nexport type StringGuardRange = `` | `non-empty`\n\n/**\n * Throws an error if parameter is not an string\n * @param value\n * @param parameterName\n */\nexport const stringTest = (value: unknown, range: StringGuardRange = ``, parameterName = `?`): GuardResult => {\n  if (typeof value !== `string`) return [ false, `Param '${ parameterName } is not type string. Got: ${ typeof value }` ];\n  switch (range) {\n    case `non-empty`:\n      if (value.length === 0) return [ false, `Param '${ parameterName } is empty` ];\n      break;\n  }\n  return [ true ];\n};\n\nexport const throwStringTest = (value: unknown, range: StringGuardRange = ``, parameterName = `?`) => {\n  throwFromResult(stringTest(value, range, parameterName));\n}\n\n","import { throwNumberTest } from \"@ixfx/guards\";\nexport const atWrap = (array, index) => {\n    throwNumberTest(index, ``, `index`);\n    if (!Array.isArray(array))\n        throw new Error(`Param 'array' is not an array`);\n    index = index % array.length;\n    return array.at(index);\n};\n","/**\n * Return `arr` broken up into chunks of `size`\n *\n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param array\n * @param size\n * @returns\n */\nexport function chunks(array, size) {\n    // https://surma.github.io/underdash/\n    const output = [];\n    for (let index = 0; index < array.length; index += size) {\n        output.push(array.slice(index, index + size));\n    }\n    return output;\n}\n","/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = (itemToMakeStringFor) => typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);\n","import { toStringDefault } from \"./to-string.js\";\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n *\n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor\n * @returns\n */\n// export const toStringOrdered = (itemToMakeStringFor: unknown) => {\n//   if (typeof itemToMakeStringFor === `string`) return itemToMakeStringFor;\n//   const allKeys = new Set<string>();\n//   JSON.stringify(itemToMakeStringFor, (key: string, value: unknown) => (allKeys.add(key), value));\n//   return JSON.stringify(itemToMakeStringFor, [ ...allKeys ].sort());\n// }\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = (a, b) => a === b;\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n *\n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n *\n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n *\n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = (a, b) => {\n    // ✔ UNIT TESTED\n    if (a === b)\n        return true; // Object references are the same, or string values are the same\n    return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n *\n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n *\n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n *\n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a\n * @param b\n * @param fieldComparer\n * @returns\n */\nexport const isEqualValuePartial = (a, b, fieldComparer) => {\n    if (typeof a !== `object`)\n        throw new Error(`Param 'a' expected to be object`);\n    if (typeof b !== `object`)\n        throw new Error(`Param 'b' expected to be object`);\n    if (Object.is(a, b))\n        return true;\n    const comparer = fieldComparer ?? isEqualValuePartial;\n    for (const entryB of Object.entries(b)) {\n        const valueOnAKeyFromB = a[entryB[0]];\n        const valueB = entryB[1];\n        if (typeof valueOnAKeyFromB === `object` && typeof valueB === `object`) {\n            if (!comparer(valueOnAKeyFromB, valueB)) {\n                return false;\n            }\n        }\n        else {\n            if (valueOnAKeyFromB !== valueB) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n *\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n *\n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n * @typeParam T - Type of objects being compared\n */\n// export const isEqualValueIgnoreOrder = <T>(a: T, b: T): boolean => {\n//   // ✔ UNIT TESTED\n//   if (a === b) return true; // Object references are the same, or string values are the same\n//   return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n// };\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value\n * @returns\n */\nexport const isEmptyEntries = (value) => [...Object.entries(value)].length === 0;\n/**\n * Returns _true_ if `a` and `b are equal based on their JSON representations.\n * `path` is ignored.\n * @param a\n * @param b\n * @param path\n * @returns\n */\nexport const isEqualContextString = (a, b, _path) => {\n    return JSON.stringify(a) === JSON.stringify(b);\n};\n","import { isEqualDefault } from \"./util/is-equal.js\";\nimport { toStringDefault } from \"./util/to-string.js\";\n/**\n * Returns _true_ if contents of `needles` is contained by `haystack`.\n * ```js\n * const a = ['apples','oranges','pears','mandarins'];\n * const b = ['pears', 'apples'];\n * contains(a, b); // True\n *\n * const c = ['pears', 'bananas'];\n * contains(a, b); // False ('bananas' does not exist in a)\n * ```\n * @param haystack\n * @param needles\n * @param eq\n */\nexport const contains = (haystack, needles, eq = (isEqualDefault)) => {\n    if (!Array.isArray(haystack)) {\n        throw new TypeError(`Expects haystack parameter to be an array`);\n    }\n    if (!Array.isArray(needles)) {\n        throw new TypeError(`Expects needles parameter to be an array`);\n    }\n    for (const needle of needles) {\n        let found = false;\n        for (const element of haystack) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            if (eq(needle, element)) {\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            return false;\n        }\n    }\n    return true;\n};\n/**\n * Returns _true_ if array contains duplicate values.\n *\n * ```js\n * containsDuplicateValues(['a','b','a']); // True\n * containsDuplicateValues([\n *  { name: 'Apple' },\n *  { name: 'Apple' }\n * ]); // True\n * ```\n *\n * Uses JSON.toString() by default to compare values.\n *\n * See also:\n * * {@link containsDuplicateInstances}: Compare based on reference, rather than value\n * * {@link unique} Get unique set of values in an array\n * @param array Array to examine\n * @param keyFunction Function to generate key string for object, uses JSON.stringify by default.\n * @returns\n */\nexport const containsDuplicateValues = (data, keyFunction = (toStringDefault)) => {\n    if (typeof data !== `object`)\n        throw new Error(`Param 'data' is expected to be an Iterable. Got type: ${typeof data}`);\n    const set = new Set();\n    for (const v of data) {\n        const string_ = keyFunction(v);\n        if (set.has(string_))\n            return true;\n        set.add(string_);\n    }\n    return false;\n};\n/**\n * Returns _true_ if array contains duplicate instances based on `===` equality checking\n * Use {@link containsDuplicateValues} if you'd rather compare by value.\n * @param array\n * @returns\n */\nexport const containsDuplicateInstances = (array) => {\n    if (!Array.isArray(array))\n        throw new Error(`Parameter needs to be an array`);\n    for (let index = 0; index < array.length; index++) {\n        for (let x = 0; x < array.length; x++) {\n            if (index === x)\n                continue;\n            if (array[index] === array[x])\n                return true;\n        }\n    }\n    return false;\n};\n","/**\n * Returns a copy of `data` with specified length.\n * If the input array is too long, it is truncated.\n *\n * If the input array is too short, it will be expanded based on the `expand` strategy:\n *  - 'undefined': fill with `undefined`\n *  - 'repeat': repeat array elements, starting from position 0\n *  - 'first': repeat with first element from `data`\n *  - 'last': repeat with last element from `data`\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * Arrays.ensureLength([1,2,3], 2); // [1,2]\n * Arrays.ensureLength([1,2,3], 5, `undefined`); // [1,2,3,undefined,undefined]\n * Arrays.ensureLength([1,2,3], 5, `repeat`);    // [1,2,3,1,2]\n * Arrays.ensureLength([1,2,3], 5, `first`);     // [1,2,3,1,1]\n * Arrays.ensureLength([1,2,3], 5, `last`);      // [1,2,3,3,3]\n * ```\n * @param data Input array to expand\n * @param length Desired length\n * @param expand Expand strategy\n * @typeParam V Type of array\n */\nexport const ensureLength = (data, length, expand = `undefined`) => {\n    // Unit tested\n    if (data === undefined)\n        throw new Error(`Data undefined`);\n    if (!Array.isArray(data))\n        throw new Error(`data is not an array`);\n    if (data.length === length)\n        return [...data];\n    if (data.length > length) {\n        return data.slice(0, length);\n    }\n    const d = [...data];\n    const add = length - d.length;\n    //eslint-disable-next-line functional/no-let\n    for (let index = 0; index < add; index++) {\n        //eslint-disable-next-line functional/immutable-data\n        switch (expand) {\n            case `undefined`: {\n                // @ts-expect-error\n                d.push(undefined);\n                break;\n            }\n            case `repeat`: {\n                d.push(data[index % data.length]);\n                break;\n            }\n            case `first`: {\n                d.push(data[0]);\n                break;\n            }\n            case `last`: {\n                // @ts-expect-error\n                d.push(data.at(-1));\n                break;\n            }\n            // No default\n        }\n    }\n    return d;\n};\n","import { isEqualDefault, isEqualValueDefault } from \"./util/is-equal.js\";\nimport { guardArray } from \"@ixfx/guards\";\n/**\n * Returns _true_ if the two arrays have the same items at same indexes.\n *\n * Returns _false_ if arrays are of different length.\n * By default uses === semantics for equality checking.\n *\n * ```js\n * isEqual([ 1, 2, 3], [ 1, 2, 3 ]); // true\n * isEqual([ 1, 2, 3], [ 3, 2, 1 ]); // false\n * ```\n *\n * Compare by value\n * ```js\n * isEqual(a, b, isEqualValueDefault);\n * ```\n *\n * Custom compare, eg based on `name` field:\n * ```js\n * isEqual(a, b, (compareA, compareB) => compareA.name === compareB.name);\n * ```\n * @param arrayA\n * @param arrayB\n * @param equality Function to compare values\n */\nexport const isEqual = (arrayA, arrayB, equality = (isEqualDefault)) => {\n    // TODO: 'eq' function could be a key-generating function too\n    guardArray(arrayA, `arrayA`);\n    guardArray(arrayB, `arrayB`);\n    if (arrayA.length !== arrayB.length)\n        return false;\n    for (let indexA = 0; indexA < arrayA.length; indexA++) {\n        if (!(equality(arrayA[indexA], arrayB[indexA])))\n            return false;\n    }\n    return true;\n};\n/**\n * Returns _true_ if all values in the array are the same\n *\n * Uses value-based equality checking by default.\n *\n * @example Uses default equality function:\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const a1 = [ 10, 10, 10 ];\n * Arrays.isContentsTheSame(a1); // True\n *\n * const a2 = [ { name:`Jane` }, { name:`John` } ];\n * Arrays.isContentsTheSame(a2); // True, even though object references are different\n * ```\n *\n * If we want to compare by value for objects that aren't readily\n * converted to JSON, you need to provide a function:\n *\n * ```js\n * Arrays.isContentsTheSame(someArray, (a, b) => {\n *  return (a.eventType === b.eventType);\n * });\n * ```\n *\n * Returns _true_ if `array` is empty.\n * @param array Array\n * @param equality Equality checker. Uses string-conversion checking by default\n * @returns\n */\nexport const isContentsTheSame = (array, equality) => {\n    // TODO: 'equality' function could be a key-generating function too\n    if (!Array.isArray(array))\n        throw new Error(`Param 'array' is not an array.`);\n    if (array.length === 0)\n        return true;\n    const eq = equality ?? isEqualValueDefault;\n    const a = array[0];\n    const r = array.some((v) => !eq(a, v));\n    if (r)\n        return false;\n    return true;\n};\n","import { isEqualDefault } from \"./util/is-equal.js\";\nimport { guardArray, guardIndex } from \"@ixfx/guards\";\nexport const withoutUndefined = (data) => {\n    return data.filter(v => v !== undefined);\n};\n/**\n * Returns two separate arrays of everything that `filter` returns _true_,\n * and everything it returns _false_ on. The in-built Array.filter() in\n * constrast only returns things that `filter` returns _true_ for.\n *\n * ```js\n * const [ matching, nonMatching ] = filterAB(data, v => v.enabled);\n * // `matching` is a list of items from `data` where .enabled is true\n * // `nonMatching` is a list of items from `data` where .enabled is false\n * ```\n * @param data Array of data to filter\n * @param filter Function which returns _true_ to add items to the A list, or _false_ for items to add to the B list\n * @returns Array of two elements. The first is items that match `filter`, the second is items that do not.\n */\nexport const filterAB = (data, filter) => {\n    const a = [];\n    const b = [];\n    for (const datum of data) {\n        //eslint-disable-next-line functional/immutable-data\n        if (filter(datum))\n            a.push(datum);\n        //eslint-disable-next-line functional/immutable-data\n        else\n            b.push(datum);\n    }\n    return [a, b];\n};\n/**\n * Yields elements from `array` that match a given `predicate`, and moreover are between\n * the given `startIndex` (inclusive) and `endIndex` (exclusive).\n *\n * While this can be done with in the in-built `array.filter` function, it will\n * needlessly iterate through the whole array. It also avoids another alternative\n * of slicing the array before using `filter`.\n *\n * ```js\n * import { filterBetween } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Return 'registered' people between and including array indexes 5-10\n * const filtered = [...filterBetween(people, person => person.registered, 5, 10)];\n * ```\n * @param array Array to filter\n * @param predicate Filter function\n * @param startIndex Start index (defaults to 0)\n * @param endIndex End index (by default runs until end)\n */\nexport function* filterBetween(array, predicate, startIndex, endIndex) {\n    guardArray(array);\n    if (typeof startIndex === `undefined`)\n        startIndex = 0;\n    if (typeof endIndex === `undefined`)\n        endIndex = array.length; //- 1;\n    guardIndex(array, startIndex, `startIndex`);\n    guardIndex(array, endIndex - 1, `endIndex`);\n    //const t: Array<V> = [];\n    //eslint-disable-next-line functional/no-let\n    for (let index = startIndex; index < endIndex; index++) {\n        //eslint-disable-next-line functional/immutable-data\n        if (predicate(array[index], index, array))\n            yield array[index]; //t.push(array[ index ]);\n    }\n    //return t;\n}\n;\n/**\n * Returns an array with value(s) omitted. If value is not found, result will be a copy of input.\n * Value checking is completed via the provided `comparer` function.\n * By default checking whether `a === b`. To compare based on value, use the `isEqualValueDefault` comparer.\n *\n * @example\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [100, 20, 40];\n * const filtered = Arrays.without(data, 20); // [100, 40]\n * ```\n *\n * @example Using value-based comparison\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [{name: `Alice`}, {name:`Sam`}];\n *\n * // This wouldn't work as expected, because the default comparer uses instance,\n * // not value:\n * Arrays.without(data, {name: `Alice`});\n *\n * // So instead we can use a value comparer:\n * Arrays.without(data, {name:`Alice`}, isEqualValueDefault);\n * ```\n *\n * @example Use a function\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [{name: `Alice`}, {name:`Sam`}];\n * Arrays.without(data, {name:`ALICE`}, (a, b) => {\n *  return (a.name.toLowerCase() === b.name.toLowerCase());\n * });\n * ```\n *\n * Consider {@link remove} to remove an item by index.\n *\n * @typeParam V - Type of array items\n * @param sourceArray Source array\n * @param toRemove Value(s) to remove\n * @param comparer Comparison function. If not provided `Util.isEqualDefault` is used, which compares using `===`\n * @return Copy of array without value.\n */\nexport const without = (\n//eslint-disable-next-line functional/prefer-readonly-type\nsourceArray, toRemove, comparer = isEqualDefault) => {\n    if (Array.isArray(toRemove)) {\n        const returnArray = [];\n        for (const source of sourceArray) {\n            if (!toRemove.some(v => comparer(source, v))) {\n                returnArray.push(source);\n            }\n        }\n        return returnArray;\n    }\n    else {\n        return sourceArray.filter((v) => !comparer(v, toRemove));\n    }\n};\n","/**\n * Returns a 'flattened' copy of array, un-nesting arrays one level\n * ```js\n * flatten([1, [2, 3], [[4]] ]);\n * // Yields: [ 1, 2, 3, [4]];\n * ```\n * @param array\n * @returns\n */\nexport const flatten = (array) => [...array].flat();\n","/**\n * Computes the frequency of values by a grouping function.\n * ```js\n * const data = [1,2,3,4,5,6,7,8,9,10];\n * // Returns 'odd' or 'even' for an input value\n *\n * const groupBy = v => v % 2 === 0 ? `even`:`odd`;\n *\n * const data = frequencyByGroup(groupBy, data);\n * // Yields map with:\n * //  key: 'even', value: 5\n * //  key: 'odd', value: 5\n * @param groupBy\n * @param data\n * @returns\n */\nexport const frequencyByGroup = (groupBy, data) => {\n    if (!Array.isArray(data))\n        throw new TypeError(`Param 'array' is expected to be an array. Got type: '${typeof data}'`);\n    const store = new Map();\n    for (const value of data) {\n        const group = groupBy(value);\n        if (typeof group !== `string` && typeof group !== `number`) {\n            throw new TypeError(`groupBy function is expected to return type string or number. Got type: '${typeof group}' for value: '${value}'`);\n        }\n        let groupValue = store.get(group);\n        groupValue ??= 0;\n        groupValue++;\n        store.set(group, groupValue);\n    }\n    return store;\n};\n","/**\n * Groups data by a function `grouper`, returning data as a map with string\n * keys and array values. Multiple values can be assigned to the same group.\n *\n * `grouper` must yield a string designated group for a given item.\n *\n * @example\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [\n *  { age: 39, city: `London` },\n *  { age: 14, city: `Copenhagen` },\n *  { age: 23, city: `Stockholm` },\n *  { age: 56, city: `London` }\n * ];\n *\n * // Whatever the function returns will be the designated group\n * // for an item\n * const map = Arrays.groupBy(data, item => item.city);\n * ```\n *\n * This yields a Map with keys London, Stockholm and Copenhagen, and the corresponding values.\n *\n * ```\n * London: [{ age: 39, city: `London` }, { age: 56, city: `London` }]\n * Stockhom: [{ age: 23, city: `Stockholm` }]\n * Copenhagen: [{ age: 14, city: `Copenhagen` }]\n * ```\n * @param array Array to group\n * @param grouper Function that returns a key for a given item\n * @typeParam K Type of key to group by. Typically string.\n * @typeParam V Type of values\n * @returns Map\n */\nexport const groupBy = (array, grouper) => {\n    const map = new Map();\n    for (const a of array) {\n        const key = grouper(a);\n        let existing = map.get(key);\n        if (!existing) {\n            existing = [];\n            map.set(key, existing);\n        }\n        existing.push(a);\n    }\n    return map;\n};\n","import { isEqualDefault } from \"./util/is-equal.js\";\nimport { toStringDefault } from \"./util/to-string.js\";\n//import { additionalValues } from \"../iterables/sync/AdditionalValues.js\";\n/**\n * Combines the values of one or more arrays, removing duplicates.\n * ```js\n * const v = Arrays.uniqueDeep([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.uniqueDeep([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n *\n * By default uses Javascript's default equality checking\n *\n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * {@link additionalValues}: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays\n * @param comparer\n * @returns\n */\nexport const uniqueDeep = (arrays, comparer = (isEqualDefault)) => {\n    const t = [];\n    const contains = (v) => {\n        for (const tValue of t) {\n            if (comparer(tValue, v))\n                return true;\n        }\n        return false;\n    };\n    const flattened = arrays.flat(10);\n    for (const v of flattened) {\n        if (!contains(v))\n            t.push(v);\n    }\n    return t;\n};\n/**\n * Combines the values of one or more arrays, removing duplicates.\n * Compares based on a string representation of object. Uses a Set\n * to avoid unnecessary comparisons, perhaps faster than `uniqueDeep`.\n *\n * ```js\n * const v = Arrays.unique([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.unique([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n *\n * By default uses JSON.toString() to compare values.\n *\n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * {@link additionalValues}: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays\n * @param comparer\n * @returns\n */\nexport const unique = (arrays, toString = toStringDefault) => {\n    const matching = new Set();\n    const t = [];\n    const flattened = arrays.flat(10);\n    for (const a of flattened) {\n        const stringRepresentation = toString(a);\n        if (matching.has(stringRepresentation))\n            continue;\n        matching.add(stringRepresentation);\n        t.push(a);\n    }\n    return t;\n};\n","/**\n * Inserts `values` at position `index`, shuffling remaining\n * items further down.\n * @param data\n * @param index\n * @param values\n * @returns\n */\nexport const insertAt = (data, index, ...values) => {\n    if (!Array.isArray(data)) {\n        throw new TypeError(`Param 'data' is not an arry`);\n    }\n    return [...data.slice(0, index), ...values, ...data.slice(index + 1)];\n};\n","import { isContentsTheSame } from \"./equality.js\";\n/**\n * Returns an interleaving of two or more arrays. All arrays must be the same length.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const a = [`a`, `b`, `c`];\n * const b = [`1`, `2`, `3`];\n * const c = Arrays.interleave(a, b);\n * // Yields:\n * // [`a`, `1`, `b`, `2`, `c`, `3`]\n * ```\n * @param arrays\n * @returns\n */\nexport const interleave = (...arrays) => {\n    if (arrays.some((a) => !Array.isArray(a))) {\n        throw new Error(`All parameters must be an array`);\n    }\n    const lengths = arrays.map(a => a.length);\n    if (!isContentsTheSame(lengths)) {\n        throw new Error(`Arrays must be of same length`);\n    }\n    const returnValue = [];\n    const length = lengths[0];\n    for (let index = 0; index < length; index++) {\n        for (const array of arrays) {\n            returnValue.push(array[index]);\n        }\n    }\n    return returnValue;\n};\n","import { isEqualDefault } from \"./util/is-equal.js\";\n/**\n * Returns the _intersection_ of two arrays: the elements that are in common.\n *\n * ```js\n * intersection([1, 2, 3], [2, 4, 6]);\n// returns [2]\n * ```\n * See also:\n * * {@link unique}: Unique set of items amongst one or more arrays\n * @param arrayA\n * @param arrayB\n * @param equality\n * @returns\n */\nexport const intersection = (arrayA, arrayB, equality = isEqualDefault) => arrayA.filter((valueFromA) => arrayB.some((valueFromB) => equality(valueFromA, valueFromB)));\n","/**\n * Merges arrays left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also {@link Data.Maps.mergeByKey} if the input data is in Map form.\n *\n * For example, if we have the array A:\n * [`A-1`, `A-2`, `A-3`]\n *\n * And array B:\n * [`B-1`, `B-2`, `B-4`]\n *\n * And with the key function:\n * ```js\n * // Make a key for value based on last char\n * const keyFn = (v) => v.substr(-1, 1);\n * ```\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(keyFn, reconcile, arrayA, arrayB);\n * ```\n *\n * The final result will be:\n *\n * [`B!1`, `B!2`, `A-3`, `B-4`]\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param keyFunction Function to generate a unique key for data\n * @param reconcile Returns value to decide 'winner' when keys conflict.\n * @param arrays Arrays of data to merge\n */\nexport const mergeByKey = (keyFunction, reconcile, ...arrays) => {\n    const result = new Map();\n    for (const m of arrays) {\n        for (const mv of m) {\n            if (mv === undefined)\n                continue;\n            const mk = keyFunction(mv);\n            let v = result.get(mk);\n            v = v ? reconcile(v, mv) : mv;\n            result.set(mk, v);\n        }\n    }\n    return [...result.values()];\n};\n","import { guardArray } from \"@ixfx/guards\";\n/**\n * Combines values in pairwise fashion.\n * Throws an error if there are less than two entries.\n *\n * ```js\n * pairwise([1, 2, 3, 4, 5]);\n * Yields:\n * [[1,2],[2,3],[3,4],[4,5] ]\n *\n * pairwise([ 1, 2, 3, 4 ]);\n * Yields:\n * [1,2],[2,3],[3,4]\n * ```\n * @param values\n */\nexport function* pairwise(values) {\n    guardArray(values, `values`);\n    if (values.length < 2)\n        throw new Error(`Array needs to have at least two entries. Length: ${values.length}`);\n    for (let index = 1; index < values.length; index++) {\n        yield [values[index - 1], values[index]];\n    }\n}\n/**\n * Reduces in a pairwise fashion.\n *\n * Eg, if we have input array of [1, 2, 3, 4, 5], the\n * `reducer` fn will run with 1,2 as parameters, then 2,3, then 3,4 etc.\n * ```js\n * const values = [1, 2, 3, 4, 5]\n * reducePairwise(values, (acc, a, b) => {\n *  return acc + (b - a);\n * }, 0);\n * ```\n *\n * If input array has less than two elements, the initial value is returned.\n *\n * ```js\n * const reducer = (acc:string, a:string, b:string) => acc + `[${a}-${b}]`;\n * const result = reducePairwise(`a b c d e f g`.split(` `), reducer, `!`);\n * Yields: `![a-b][b-c][c-d][d-e][e-f][f-g]`\n * ```\n * @param array\n * @param reducer\n * @param initial\n * @returns\n */\nexport const pairwiseReduce = (array, reducer, initial) => {\n    guardArray(array, `arr`);\n    if (array.length < 2)\n        return initial;\n    //eslint-disable-next-line functional/no-let\n    for (let index = 0; index < array.length - 1; index++) {\n        initial = reducer(initial, array[index], array[index + 1]);\n    }\n    return initial;\n};\n","import { guardArray } from \"@ixfx/guards\";\n/**\n * Returns a shuffled copy of the input array.\n * @example\n * ```js\n * const d = [1, 2, 3, 4];\n * const s = shuffle(d);\n * // d: [1, 2, 3, 4], s: [3, 1, 2, 4]\n * ```\n * @param dataToShuffle\n * @param rand Random generator. `Math.random` by default.\n * @returns Copy with items moved around randomly\n * @typeParam V - Type of array items\n */\nexport const shuffle = (dataToShuffle, rand = Math.random) => {\n    guardArray(dataToShuffle, `dataToShuffle`);\n    const array = [...dataToShuffle];\n    for (let index = array.length - 1; index > 0; index--) {\n        const index_ = Math.floor(rand() * (index + 1));\n        [array[index], array[index_]] = [array[index_], array[index]];\n    }\n    return array;\n};\n/**\n * Returns random element.\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomElement(v); // Yields `blue`, `red` or `orange`\n * ```\n *\n * Use {@link randomIndex} if you want a random index within `array`.\n *\n * @param array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomElement = (array, rand = Math.random) => {\n    guardArray(array, `array`);\n    return array[Math.floor(rand() * array.length)];\n};\n","import { guardIndex } from \"@ixfx/guards\";\n/**\n * Removes an element at `index` index from `data`, returning the resulting array without modifying the original.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const v = [ 100, 20, 50 ];\n * const vv = Arrays.remove(2);\n *\n * Yields:\n *  v: [ 100, 20, 50 ]\n * vv: [ 100, 20 ]\n * ```\n *\n * Consider {@link without} if you want to remove an item by value.\n *\n * Throws an exception if `index` is outside the range of `data` array.\n * @param data Input array\n * @param index Index to remove\n * @typeParam V Type of array\n * @returns\n */\nexport const remove = (\n//eslint-disable-next-line functional/prefer-readonly-type\ndata, index) => {\n    // ✔️ Unit tested\n    if (!Array.isArray(data)) {\n        throw new TypeError(`'data' parameter should be an array`);\n    }\n    guardIndex(data, index, `index`);\n    return [...data.slice(0, index), ...data.slice(index + 1)];\n};\n","import { throwIntegerTest } from '@ixfx/guards';\n/**\n * Samples values from an array. If `amount` is less or equal to 1, it's treated as a percentage to sample.\n * Otherwise it's treated as every _n_th value to sample.\n *\n * @example\n * By percentage - get half of the items\n * ```\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const list = [1,2,3,4,5,6,7,8,9,10];\n * const sub = Arrays.sample(list, 0.5);\n * // Yields: [2, 4, 6, 8, 10]\n * ```\n *\n * @example\n * By steps - every third value\n * ```\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const list = [1,2,3,4,5,6,7,8,9,10];\n * const sub = Arrays.sample(list, 3);\n * // Yields:\n * // [3, 6, 9]\n * ```\n * @param array Array to sample\n * @param amount Amount, given as a percentage (0..1) or the number of interval (ie 3 for every third item)\n * @returns\n */\nexport const sample = (array, amount) => {\n    if (!Array.isArray(array))\n        throw new TypeError(`Param 'array' is not actually an array. Got type: ${typeof array}`);\n    let subsampleSteps = 1;\n    if (amount <= 1) {\n        // Subsample based on a percentage\n        const numberOfItems = array.length * amount;\n        subsampleSteps = Math.round(array.length / numberOfItems);\n    }\n    else {\n        subsampleSteps = amount;\n    }\n    throwIntegerTest(subsampleSteps, `positive`, `amount`);\n    if (subsampleSteps > array.length - 1) {\n        throw new Error(`Subsample steps exceeds array length`);\n    }\n    const r = [];\n    for (let index = subsampleSteps - 1; index < array.length; index += subsampleSteps) {\n        r.push(array[index]);\n    }\n    return r;\n};\n","import { guardArray } from '@ixfx/guards';\n/**\n * Sorts an array of objects in ascending order\n * by the given property name, assuming it is a number.\n *\n * ```js\n * const data = [\n *  { size: 10, colour: `red` },\n *  { size: 20, colour: `blue` },\n *  { size: 5, colour: `pink` }\n * ];\n * const sorted = Arrays.sortByNumericProperty(data, `size`);\n *\n * Yields items ascending order:\n * [ { size: 5, colour: `pink` }, { size: 10, colour: `red` }, { size: 20, colour: `blue` } ]\n * ```\n * @param data\n * @param propertyName\n */\nexport const sortByNumericProperty = (data, propertyName) => [...data].sort((a, b) => {\n    guardArray(data, `data`);\n    const av = a[propertyName];\n    const bv = b[propertyName];\n    if (av < bv)\n        return -1;\n    if (av > bv)\n        return 1;\n    return 0;\n});\nexport const sortByProperty = (data, propertyName) => [...data].sort((a, b) => {\n    guardArray(data, `data`);\n    const av = a[propertyName];\n    const bv = b[propertyName];\n    if (av < bv)\n        return -1;\n    if (av > bv)\n        return 1;\n    return 0;\n});\n","/**\n * Yields all items in `data` for as long as `predicate` returns true.\n *\n * `predicate` yields arrays of `[stop:boolean, acc:A]`. The first value\n * is _true_ when the iteration should stop, and the `acc` is the accumulated value.\n * This allows `until` to be used to carry over some state from item to item.\n *\n * @example Stop when we hit an item with value of 3\n * ```js\n * const v = [...until([1,2,3,4,5], v => [v === 3, 0])];\n * // [ 1, 2 ]\n * ```\n *\n * @example Stop when we reach a total\n * ```js\n * // Stop when accumulated value reaches 6\n * const v = Arrays.until[1,2,3,4,5], (v, acc) => [acc >= 7, v+acc], 0);\n * // [1, 2, 3]\n * ```\n * @param data\n * @param predicate\n * @returns\n */\nexport function* until(data, predicate, initial) {\n    let total = initial;\n    for (const datum of data) {\n        const [stop, accumulator] = predicate(datum, total);\n        if (stop)\n            break;\n        total = accumulator;\n        yield datum;\n    }\n}\n;\n","import { isContentsTheSame } from \"./equality.js\";\n/**\n * Zip combines the elements of two or more arrays based on their index.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const a = [1,2,3];\n * const b = [`red`, `blue`, `green`];\n *\n * const c = Arrays.zip(a, b);\n * // Yields:\n * // [\n * //   [1, `red`],\n * //   [2, `blue`],\n * //   [3, `green`]\n * // ]\n * ```\n *\n * Typically the arrays you zip together are all about the same logical item. Eg, in the above example\n * perhaps `a` is size and `b` is colour. So thing #1 (at array index 0) is a red thing of size 1. Before\n * zipping we'd access it by `a[0]` and `b[0]`. After zipping, we'd have c[0], which is array of [1, `red`].\n * @param arrays\n * @returns Zipped together array\n */\nexport const zip = (...arrays) => {\n    if (arrays.some((a) => !Array.isArray(a))) {\n        throw new Error(`All parameters must be an array`);\n    }\n    const lengths = arrays.map((a) => a.length);\n    if (!isContentsTheSame(lengths)) {\n        throw new Error(`Arrays must be of same length`);\n    }\n    const returnValue = [];\n    const length = lengths[0];\n    for (let index = 0; index < length; index++) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        returnValue.push(arrays.map((a) => a[index]));\n    }\n    return returnValue;\n};\n","export * from './array-cycle.js';\nexport * from './at-wrap.js';\nexport * from './chunks.js';\nexport * from './contains.js';\nexport * from './ensure-length.js';\nexport * from './equality.js';\nexport * from './filter.js';\nexport * from './flatten.js';\nexport * from './frequency.js';\nexport * from './group-by.js';\nexport * from './unique.js';\nexport * from './insert-at.js';\nexport * from './interleave.js';\nexport * from './intersection.js';\nexport * from './merge-by-key.js';\nexport * from './pairwise.js';\nexport * from './random.js';\nexport * from './remove.js';\nexport * from './sample.js';\nexport * from './sort.js';\nexport * from './unique.js';\nexport * from './until.js';\nexport * from './zip.js';\n","//import { intervalToMs, type Interval } from './IntervalType.js';\n//import { elapsedMillisecondsAbsolute, relative } from './Timer.js';\n\nexport type Since = () => number;\n\n/**\n * Returns elapsed time since the initial call.\n * ```js\n * // Record start\n * const elapsed = elapsedSince();\n *\n * // Get elapsed time in millis\n * // since Elapsed.since()\n * elapsed(); // Yields number\n * ```\n *\n * If you want to initialise a stopwatch, but not yet start it, consider:\n * ```js\n * // Init\n * let state = {\n *  clicked: Stopwatch.infinity()\n * };\n *\n * state.click(); // Returns a giant value\n *\n * // Later, when click happens:\n * state = { click: elapsedSince() }\n * ```\n *\n * See also:\n * * {@link elapsedOnce} if you want to measure a single period, and stop it.\n * * {@link elapsedInterval} time _between_ calls\n * @returns\n */\nexport const elapsedSince = (): Since => {\n  const start = performance.now();\n  return (): number => {\n    return performance.now() - start;\n  };\n};\n\n/**\n * Returns the interval between the start and each subsequent call.\n * \n * ```js\n * const interval = elapsedInterval();\n * interval(); // Time from elapsedInterval()\n * interval(); // Time since last interval() call\n * ```\n * \n * See also:\n * * {@link elapsedSince}: time since first call\n * * {@link elapsedOnce}: time between two events\n * @returns \n */\nexport const elapsedInterval = (): Since => {\n  let start = performance.now();\n  return (): number => {\n    const now = performance.now();\n    const x = now - start;\n    start = now;\n    return x;\n  }\n}\n/**\n * Returns elapsed time since initial call, however\n * unlike {@link elapsedSince}, timer stops when first invoked.\n *\n * ```js\n * const elapsed = elapsedOnce();\n * // ...do stuff\n * elapsed(); // Yields time since elapsedOnce() was called\n * // ...do more stuff\n * elapsed(); // Is still the same number as above\n * ```\n * \n * See also:\n * * {@link elapsedSince}: elapsed time\n * * {@link elapsedInterval}: time _between_ calls\n * @returns\n */\nexport const elapsedOnce = (): Since => {\n  const start = Date.now();\n  let stoppedAt = 0;\n  return (): number => {\n    if (stoppedAt === 0) {\n      stoppedAt = Date.now() - start;\n    }\n    return stoppedAt;\n  };\n};\n/**\n * Returns a function that reports an 'infinite' elapsed time.\n * this can be useful as an initialiser for `elapsedSince` et al.\n *\n * ```js\n * // Init clicked to be an infinite time\n * let clicked = elapsedInfinity();\n *\n * document.addEventListener('click', () => {\n *  // Now that click has happened, we can assign it properly\n *  clicked = Stopwatch.since();\n * });\n * ```\n * @returns\n */\nexport const elapsedInfinity = (): Since => {\n  return (): number => {\n    return Number.POSITIVE_INFINITY;\n  };\n};\n\n","import type { Reactive, ReactiveInitial } from \"./types-reactive.js\";\n\n/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx \n * @returns \n */\nexport const isReactive = <V>(rx: object): rx is Reactive<V> => {\n  if (typeof rx !== `object`) return false;\n  if (rx === null) return false;\n  return (`on` in rx && `onValue` in rx)\n}\n\nexport const hasLast = <V>(rx:  object): rx is ReactiveInitial<V> => {\n  if (!isReactive(rx)) return false;\n  if (`last` in rx) {\n    const v = (rx as any).last();\n    if (v !== undefined) return true;\n  }\n  return false;\n}","//import { hasLast, isReactive } from \"@ixfx/rx\";\n//import type { ReactiveNonInitial } from \"@ixfx/rx\";\nimport type { BasicType } from \"@ixfx/core\";\nimport { getErrorMessage } from \"@ixfx/debug\";\nimport type { ReactiveNonInitial } from \"./types-reactive.js\";\nimport { hasLast, isReactive } from \"./reactive-core.js\";\n\n\n/**\n * Something that can resolve to a value\n */\nexport type ResolveToValueSync<V> = BasicType | ReactiveNonInitial<V> | Generator<V> | IterableIterator<V> | ((args: any) => V)\nexport type ResolveToValueAsync<V> = AsyncGenerator<V> | AsyncIterableIterator<V> | Promise<V> | ((args: any) => Promise<V>);\nexport type ResolveToValue<V> = ResolveToValueAsync<V> | ResolveToValueSync<V>;\n\n/**\n * Resolves `r` to a value, where `r` is:\n * * primitive value\n * * a/sync function\n * * a/sync generator/iterator\n * * ReactiveNonInitial\n * ```js\n * await resolve(10);       // 10\n * await resolve(() => 10); // 10\n * await resole(async () => {\n *  sleep(100);\n *  return 10;\n * });                // 10\n * ```\n * \n * To resolve an object's properties, use {@link resolveFields}.\n * \n * Resolve is not recursive. So if `r` is an object, it will be returned, even\n * though its properties may be resolvable.\n * @param r \n * @param args \n * @returns \n */\nexport async function resolve<V extends BasicType>(r: ResolveToValue<V>, ...args: any): Promise<V> {\n  if (typeof r === `object`) {\n    if (`next` in r) {\n      const tag = (r as any)[ Symbol.toStringTag ];\n      if (tag === `Generator` || tag == `Array Iterator`) {\n        const v = r.next();\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else if (tag === `AsyncGenerator`) {\n        const v = await r.next();\n        //console.log(`  hasDone: ${ `done` in v } value:`, v);\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else {\n        throw new Error(`Object has 'next' prop, but does not have 'AsyncGenerator', 'Generator' or 'Array Iterator' string tag symbol. Got: '${ tag }'`);\n      }\n    } else if (isReactive<V>(r)) {\n      if (hasLast(r)) return r.last() as V;\n      throw new Error(`Reactive does not have last value`);\n    } else {\n      // Some regular object\n      return r as V;\n    }\n  } else if (typeof r === `function`) {\n    const v = await r(args) as V;\n    return v;\n  } else {\n    // Primitive value?\n    return r as V;\n  }\n}\n\nexport function resolveSync<V extends BasicType>(r: ResolveToValueSync<V>, ...args: any): V {\n  if (typeof r === `object`) {\n    if (`next` in r) {\n      const tag = (r as any)[ Symbol.toStringTag ];\n      if (tag === `Generator` || tag == `Array Iterator`) {\n        const v = r.next();\n        if (`done` in v && `value` in v) return v.value as V;\n        return v as V;\n      } else if (tag === `AsyncGenerator`) {\n        throw new Error(`resolveSync cannot work with an async generator`);\n      } else {\n        throw new Error(`Object has 'next' prop, but does not have 'Generator' or 'Array Iterator' string tag symbol. Got: '${ tag }'`);\n      }\n    } else if (isReactive<V>(r)) {\n      if (hasLast(r)) return r.last() as V;\n      throw new Error(`Reactive does not have last value`);\n    } else {\n      // Some regular object\n      return r as V;\n    }\n  } else if (typeof r === `function`) {\n    return r(args);\n  } else {\n    // Primitive value?\n    return r as V;\n  }\n}\n\n/**\n * Resolves a value as per {@link resolve}, however\n * If an error is thrown or the resolution results in _undefined_ \n * or NaN, `fallbackValue` is returned instead.\n * \n * `null` is an allowed return value.\n * \n * ```js\n * // Function returns undefined 50% of the time or 0\n * const fn = () => {\n *  if (Math.random() >= 0.5) return; // undefined\n *  return 0;\n * }\n * const r = resolveWithFallback(fn, 1);\n * const value = r(); // Always 0 or 1\n * ```\n * @param p Thing to resolve\n * @param fallback Fallback value if an error happens, undefined or NaN\n * @param args \n * @returns \n */\nexport async function resolveWithFallback<T extends BasicType>(p: ResolveToValue<T>, fallback: ResolveFallbackOpts<T>, ...args: any) {\n  let errored = false;\n  let fallbackValue = fallback.value;\n  const overrideWithLast = fallback.overrideWithLast ?? false;\n  if (fallbackValue === undefined) throw new Error(`Needs a fallback value`);\n\n  try {\n    const r = await resolve(p, ...args);\n    if (typeof r === `undefined`) return fallbackValue;\n    if (typeof r === `number` && Number.isNaN(r)) return fallbackValue;\n    if (overrideWithLast) fallbackValue = r;\n    return r;\n  } catch (error) {\n    if (!errored) {\n      errored = true;\n      console.warn(`resolveWithFallback swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n    }\n    return fallbackValue;\n  }\n}\n\nexport function resolveWithFallbackSync<T extends BasicType>(p: ResolveToValueSync<T>, fallback: ResolveFallbackOpts<T>, ...args: any) {\n  let errored = false;\n  let fallbackValue = fallback.value;\n  const overrideWithLast = fallback.overrideWithLast ?? false;\n  if (fallbackValue === undefined) throw new Error(`Needs a fallback value`);\n\n  try {\n    const r = resolveSync(p, ...args);\n    if (typeof r === `undefined`) return fallbackValue;\n    if (typeof r === `number` && Number.isNaN(r)) return fallbackValue;\n    if (overrideWithLast) fallbackValue = r;\n    return r;\n  } catch (error) {\n    if (!errored) {\n      errored = true;\n      console.warn(`resolveWithFallbackSync swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n    }\n    return fallbackValue;\n  }\n}\n\nexport type ResolveFallbackOpts<T> = { value: T, overrideWithLast?: boolean }","import { throwNumberTest } from '@ixfx/guards';\nimport { intervalToMs } from './interval-type.js';\nimport type { Interval } from './types.js';\n\nexport type SleepOpts<V> = Interval & Partial<{\n  readonly signal: AbortSignal;\n  readonly value: V;\n}>;\n\nif (typeof window === `undefined` || !(`requestAnimationFrame` in window)) {\n\n  if (typeof window === `undefined`) {\n    // @ts-expect-error\n    globalThis.requestAnimationFrame = (callback) => {\n      setTimeout(callback, 1);\n    }\n  }\n}\n\n/**\n * Returns after timeout period.\n *\n * @example In an async function\n * ```js\n * console.log(`Hello`);\n * await sleep(1000);\n * console.log(`There`); // Prints one second after\n * ```\n *\n * @example As a promise\n * ```js\n * console.log(`Hello`);\n * sleep({ millis: 1000 })\n *  .then(() => console.log(`There`)); // Prints one second after\n * ```\n *\n * If a timeout of 0 is given, `requestAnimationFrame` is used instead of `setTimeout`.\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * A value can be provided, which is returned on awaking:\n * ```js\n * const v = await sleep({ seconds: 1, value: `hello`);\n * // v = `hello`\n * ```\n *\n * Provide an AbortSignal to cancel the sleep and throwing an exception\n * so code after the sleep doesn't happen.\n *\n * ```js\n * const ac = new AbortController();\n * setTimeout(() => { ac.abort(); }, 1000); // Abort after 1s\n *\n * // Sleep for 1min\n * await sleep({ minutes: 1, signal: ac.signal });\n * console.log(`Awake`); // This line doesn't get called because an exception is thrown when aborting\n * ```\n * @param optsOrMillis Milliseconds to sleep, or options\n * @return\n */\nexport const sleep = <V>(\n  optsOrMillis: SleepOpts<V>\n): Promise<V | undefined> => {\n  const timeoutMs = intervalToMs(optsOrMillis, 1);\n  const signal = optsOrMillis.signal;\n  const value = optsOrMillis.value;\n  throwNumberTest(timeoutMs, `positive`, `timeoutMs`);\n\n\n  if (timeoutMs === 0) {\n    return new Promise<V | undefined>((resolve) =>\n      requestAnimationFrame((_) => {\n        resolve(value);\n      })\n    );\n  } else {\n    return new Promise<V | undefined>((resolve, reject) => {\n      const onAbortSignal = () => {\n        clearTimeout(t);\n        if (signal) {\n          signal.removeEventListener(`abort`, onAbortSignal);\n          reject(new Error(signal.reason));\n        } else {\n          reject(new Error(`Cancelled`));\n        }\n      }\n\n      if (signal) {\n        signal.addEventListener(`abort`, onAbortSignal);\n      }\n      const t = setTimeout(() => {\n        signal?.removeEventListener(`abort`, onAbortSignal);\n        if (signal?.aborted) {\n          reject(new Error(signal.reason));\n          return;\n        }\n        resolve(value);\n      }, timeoutMs);\n    });\n  }\n};\n\n/**\n * Delays until `predicate` returns true.\n * Can be useful for synchronising with other async activities.\n * ```js\n * // Delay until 'count' reaches 5\n * await sleepWhile(() => count >= 5, 100);\n * ```\n * @param predicate \n * @param checkInterval \n */\nexport const sleepWhile = async (predicate: () => boolean, checkInterval: Interval = 100) => {\n  while (predicate()) {\n    await sleep(checkInterval);\n  }\n}","/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = <V>(itemToMakeStringFor: V): string =>\n  typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);","import { toStringDefault } from \"./to-string.js\";\n\n/**\n * Function that returns true if `a` and `b` are considered equal\n */\nexport type IsEqual<T> = (a: T, b: T) => boolean;\n\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n * \n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor \n * @returns \n */\n// export const toStringOrdered = (itemToMakeStringFor: unknown) => {\n//   if (typeof itemToMakeStringFor === `string`) return itemToMakeStringFor;\n//   const allKeys = new Set<string>();\n   \n//   JSON.stringify(itemToMakeStringFor, (key: string, value: unknown) => (allKeys.add(key), value));\n//   return JSON.stringify(itemToMakeStringFor, [ ...allKeys ].sort());\n// }\n\n\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = <T>(a: T, b: T): boolean => a === b;\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n * \n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n * \n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n * \n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = <T>(a: T, b: T): boolean => {\n  // ✔ UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n * \n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n * \n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n * \n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a \n * @param b \n * @param fieldComparer \n * @returns \n */\nexport const isEqualValuePartial = (a: Record<string,unknown>, b: Record<string,unknown>, fieldComparer?: IsEqual<unknown>): boolean => {\n  if (typeof a !== `object`) throw new Error(`Param 'a' expected to be object`);\n  if (typeof b !== `object`) throw new Error(`Param 'b' expected to be object`);\n\n  if (Object.is(a, b)) return true;\n  const comparer = fieldComparer ?? isEqualValuePartial;\n  for (const entryB of Object.entries(b)) {\n    const valueOnAKeyFromB = a[ entryB[ 0 ] ];\n    const valueB = entryB[ 1 ];\n    if (typeof valueOnAKeyFromB === `object` && typeof valueB === `object`) {\n      if (!comparer(valueOnAKeyFromB as Record<string,unknown>, valueB as Record<string,unknown>)) {\n        return false;\n      }\n    } else {\n      if (valueOnAKeyFromB !== valueB) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n * \n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n * \n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n * @typeParam T - Type of objects being compared\n */\n// export const isEqualValueIgnoreOrder = <T>(a: T, b: T): boolean => {\n//   // ✔ UNIT TESTED\n//   if (a === b) return true; // Object references are the same, or string values are the same\n//   return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n// };\n\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value \n * @returns \n */\nexport const isEmptyEntries = (value: object) => [ ...Object.entries(value) ].length === 0;\n\n/**\n * Return _true_ if `a` and `b` ought to be considered equal\n * at a given path\n */\nexport type IsEqualContext<V> = (a: V, b: V | undefined, path: string) => boolean\n\n/**\n * Returns _true_ if `a` and `b are equal based on their JSON representations.\n * `path` is ignored.\n * @param a \n * @param b \n * @param path \n * @returns \n */\nexport const isEqualContextString: IsEqualContext<unknown> = (a: unknown, b: unknown, _path: string): boolean => {\n  return JSON.stringify(a) === JSON.stringify(b);\n}","import { isEqualDefault, isEqualValueDefault, type IsEqual } from \"./util/is-equal.js\";\nimport { guardArray } from \"@ixfx/guards\";\n\n/**\n * Returns _true_ if the two arrays have the same items at same indexes. \n * \n * Returns _false_ if arrays are of different length.\n * By default uses === semantics for equality checking.\n * \n * ```js\n * isEqual([ 1, 2, 3], [ 1, 2, 3 ]); // true\n * isEqual([ 1, 2, 3], [ 3, 2, 1 ]); // false\n * ```\n * \n * Compare by value\n * ```js\n * isEqual(a, b, isEqualValueDefault);\n * ```\n * \n * Custom compare, eg based on `name` field:\n * ```js\n * isEqual(a, b, (compareA, compareB) => compareA.name === compareB.name);\n * ```\n * @param arrayA \n * @param arrayB \n * @param equality Function to compare values\n */\nexport const isEqual = <V>(arrayA: V[], arrayB: V[], equality = isEqualDefault<V>): boolean => {\n  // TODO: 'eq' function could be a key-generating function too\n  guardArray(arrayA, `arrayA`);\n  guardArray(arrayB, `arrayB`);\n\n  if (arrayA.length !== arrayB.length) return false;\n\n  for (let indexA = 0; indexA < arrayA.length; indexA++) {\n    if (!(equality(arrayA[ indexA ], arrayB[ indexA ]))) return false;\n  }\n  return true;\n}\n\n/**\n * Returns _true_ if all values in the array are the same\n * \n * Uses value-based equality checking by default.\n * \n * @example Uses default equality function:\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const a1 = [ 10, 10, 10 ];\n * Arrays.isContentsTheSame(a1); // True\n *\n * const a2 = [ { name:`Jane` }, { name:`John` } ];\n * Arrays.isContentsTheSame(a2); // True, even though object references are different\n * ```\n *\n * If we want to compare by value for objects that aren't readily\n * converted to JSON, you need to provide a function:\n *\n * ```js\n * Arrays.isContentsTheSame(someArray, (a, b) => {\n *  return (a.eventType === b.eventType);\n * });\n * ```\n *\n * Returns _true_ if `array` is empty.\n * @param array Array\n * @param equality Equality checker. Uses string-conversion checking by default\n * @returns\n */\nexport const isContentsTheSame = <V>(\n  array: readonly V[] | V[],\n  equality?: IsEqual<V>\n): boolean => {\n  // TODO: 'equality' function could be a key-generating function too\n\n  if (!Array.isArray(array)) throw new Error(`Param 'array' is not an array.`);\n  if (array.length === 0) return true;\n  const eq = equality ?? isEqualValueDefault;\n  const a = array[ 0 ];\n  const r = array.some((v) => !eq(a, v));\n  if (r) return false;\n  return true;\n};","import { isEqualDefault } from \"./util/is-equal.js\";\nimport { toStringDefault } from \"./util/to-string.js\";\n//import { additionalValues } from \"../iterables/sync/AdditionalValues.js\";\n\n/**\n * Combines the values of one or more arrays, removing duplicates.\n * ```js\n * const v = Arrays.uniqueDeep([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.uniqueDeep([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n * \n * By default uses Javascript's default equality checking\n * \n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * {@link additionalValues}: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays\n * @param comparer\n * @returns\n */\nexport const uniqueDeep = <V>(\n  arrays:\n    | V[][]\n    | V[]\n    | readonly V[]\n    | readonly (readonly V[])[],\n  comparer = isEqualDefault<V>\n): V[] => {\n  const t: V[] = [];\n  const contains = (v: V) => {\n    for (const tValue of t) {\n      if (comparer(tValue, v)) return true;\n    }\n    return false;\n  }\n\n  const flattened = arrays.flat(10) as V[];\n\n  for (const v of flattened) {\n    if (!contains(v)) t.push(v);\n  }\n  return t;\n};\n\n/**\n * Combines the values of one or more arrays, removing duplicates.\n * Compares based on a string representation of object. Uses a Set\n * to avoid unnecessary comparisons, perhaps faster than `uniqueDeep`.\n * \n * ```js\n * const v = Arrays.unique([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.unique([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n * \n * By default uses JSON.toString() to compare values.\n * \n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * {@link additionalValues}: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays\n * @param comparer\n * @returns\n */\nexport const unique = <V>(\n  arrays:\n    | V[][]\n    | V[]\n    | readonly V[]\n    | readonly (readonly V[])[],\n  toString = toStringDefault\n): V[] => {\n  const matching = new Set<string>();\n  const t: V[] = [];\n  const flattened = arrays.flat(10) as V[];\n  for (const a of flattened) {\n    const stringRepresentation = toString(a);\n    if (matching.has(stringRepresentation)) continue;\n    matching.add(stringRepresentation);\n    t.push(a);\n  }\n  return t;\n}","/**\n * Inserts `values` at position `index`, shuffling remaining\n * items further down.\n * @param data \n * @param index \n * @param values \n * @returns \n */\nexport const insertAt = <V>(\n  data: readonly V[] | V[],\n  index: number,\n  ...values: V[]\n): V[] => {\n  if (!Array.isArray(data)) {\n    throw new TypeError(`Param 'data' is not an arry`);\n  }\n  return [ ...data.slice(0, index), ...values, ...data.slice(index + 1) ];\n};","import { guardArray } from \"@ixfx/guards\";\n\n/**\n * Returns a shuffled copy of the input array.\n * @example\n * ```js\n * const d = [1, 2, 3, 4];\n * const s = shuffle(d);\n * // d: [1, 2, 3, 4], s: [3, 1, 2, 4]\n * ```\n * @param dataToShuffle\n * @param rand Random generator. `Math.random` by default.\n * @returns Copy with items moved around randomly\n * @typeParam V - Type of array items\n */\nexport const shuffle = <V>(\n  dataToShuffle: readonly V[],\n  rand: () => number = Math.random\n): V[] => {\n  guardArray(dataToShuffle, `dataToShuffle`);\n\n  const array = [ ...dataToShuffle ];\n  for (let index = array.length - 1; index > 0; index--) {\n    const index_ = Math.floor(rand() * (index + 1));\n    [ array[ index ], array[ index_ ] ] = [ array[ index_ ], array[ index ] ];\n  }\n  return array;\n};\n\n/**\n * Returns random element.\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomElement(v); // Yields `blue`, `red` or `orange`\n * ```\n *\n * Use {@link randomIndex} if you want a random index within `array`.\n *\n * @param array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomElement = <V>(\n  array: ArrayLike<V>,\n  rand: () => number = Math.random\n): V => {\n  guardArray(array, `array`);\n  return array[ Math.floor(rand() * array.length) ];\n};","import { guardIndex } from \"@ixfx/guards\";\n\n/**\n * Removes an element at `index` index from `data`, returning the resulting array without modifying the original.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const v = [ 100, 20, 50 ];\n * const vv = Arrays.remove(2);\n *\n * Yields:\n *  v: [ 100, 20, 50 ]\n * vv: [ 100, 20 ]\n * ```\n *\n * Consider {@link without} if you want to remove an item by value.\n *\n * Throws an exception if `index` is outside the range of `data` array.\n * @param data Input array\n * @param index Index to remove\n * @typeParam V Type of array\n * @returns\n */\nexport const remove = <V>(\n  //eslint-disable-next-line functional/prefer-readonly-type\n  data: readonly V[] | V[],\n  index: number\n): V[] => {\n  // ✔️ Unit tested\n  if (!Array.isArray(data)) {\n    throw new TypeError(`'data' parameter should be an array`);\n  }\n  guardIndex(data, index, `index`);\n  return [ ...data.slice(0, index), ...data.slice(index + 1) ];\n};","import { isContentsTheSame } from \"./equality.js\";\n\n/**\n * Zip combines the elements of two or more arrays based on their index.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const a = [1,2,3];\n * const b = [`red`, `blue`, `green`];\n *\n * const c = Arrays.zip(a, b);\n * // Yields:\n * // [\n * //   [1, `red`],\n * //   [2, `blue`],\n * //   [3, `green`]\n * // ]\n * ```\n *\n * Typically the arrays you zip together are all about the same logical item. Eg, in the above example\n * perhaps `a` is size and `b` is colour. So thing #1 (at array index 0) is a red thing of size 1. Before\n * zipping we'd access it by `a[0]` and `b[0]`. After zipping, we'd have c[0], which is array of [1, `red`].\n * @param arrays\n * @returns Zipped together array\n */\nexport const zip = (\n  ...arrays: any[][] | readonly any[][] | readonly (readonly any[])[]\n): any[] => {\n  if (arrays.some((a) => !Array.isArray(a))) {\n    throw new Error(`All parameters must be an array`);\n  }\n  const lengths = arrays.map((a) => (a as any[]).length);\n  if (!isContentsTheSame(lengths)) {\n    throw new Error(`Arrays must be of same length`);\n  }\n\n  const returnValue: any[] = [];\n  const length = lengths[ 0 ];\n\n  for (let index = 0; index < length; index++) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    returnValue.push(arrays.map((a) => a[ index ]));\n  }\n  return returnValue;\n};","export const piPi= Math.PI*2;","import { wrap } from './wrap.js';\nimport { throwNumberTest } from '@ixfx/guards';\nimport { clamp } from './clamp.js';\nimport { piPi } from './pi-pi.js';\n\n/**\n * Interpolation options.\n * \n * Limit: What to do if interpolation amount exceeds 0..1 range\n * * clamp: lock to A & B (inclusive) Default.\n * * wrap: wrap from end to start again\n * * ignore: allow return values outside of A..B range\n * \n * Transform: name of function to transform `amount` prior to interpolate. This is useful for creating non-linear interpolation results.\n * \n * For example:\n * ```js\n * // Divide interpolation amount in half\n * const interpolatorInterval({ mins: 1 }, 10, 100, {\n *  transform: (amount) => amount * Math.random()\n * });\n * ```\n * In the above example, the results would get more random over time.\n * `interpolatorInterval` will still step through the interpolation range of 0..1 in an orderly fashion, but we're transforming that range using a custom function before producing the result. \n * \n */\nexport type BasicInterpolateOptions = {\n  limits: `clamp` | `wrap` | `ignore`\n  transform: (v: number) => number\n}\n\n/**\n * Returns an interpolation function with a fixed interpolation amount. This\n * function will need the A and B values to interpolate between (ie start and end)\n * \n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * // Create function\n * const fn = interpolate(0.1);\n * \n * // Later, use to interpolate between a and b\n * fn(50, 100); // 10% of 50..100 range\n * ```\n * \n * This is useful if you have a fixed interpolation amount, but varying A and B values.\n * @param amount Interpolation value (0..1 usually)\n * @param options Options\n */\nexport function interpolate(amount: number, options?: Partial<BasicInterpolateOptions>): (a: number, b: number) => number;\n\n/**\n * Interpolates between `a` and `b` by `amount`.\n * \n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * // Get the value at 10% of range between 50-100\n * const fn = interpolate(0.1, 50, 100);\n * ```\n * \n * This is useful if you have dynamic interpolation amount as well as A & B values.\n * Consider using `interpolate(amount)` if you have a fixed interpolation amount.\n * @param amount Interpolation value (0..1 usually)\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport function interpolate(amount: number, a: number, b: number, options?: Partial<BasicInterpolateOptions>): number;\n\n/**\n * Returns an interpolation function with a fixed A and B values.\n * The returned function requires an interpolation amount. This is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * // Create function to interpolate between 50..100\n * const fn = interpolate(50, 100);\n * \n * // Later, use to interpolate\n * fn(0.1); // 10% of 50..100 range\n * ```\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport function interpolate(a: number, b: number, options?: Partial<BasicInterpolateOptions>): (amount: number) => number;\n\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide on Interpolation](https://ixfx.fun/data/interpolation/overview/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * interpolate(0.5, 30, 60);\n * ```\n *\n * See also {@link interpolatorStepped} and {@link interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n * \n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n * \n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n * \n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * To interpolate certain types: {@link Visual.Colour.interpolator | Visual.Colour.interpolator }, {@link Geometry.Points.interpolate | Points.interpolate}.\n * \n * There are a few variations when calling `interpolate`, depending on what parameters are fixed.\n * * `interpolate(amount)`: returns a function that needs a & b \n * * `interpolate(a, b)`:  returns a function that needs the interpolation amount\n */\nexport function interpolate(pos1: number, pos2?: number | Partial<BasicInterpolateOptions>, pos3?: number | Partial<BasicInterpolateOptions>, pos4?: Partial<BasicInterpolateOptions>) {\n  let amountProcess: undefined | ((v: number) => number);\n  let limits: BasicInterpolateOptions[ 'limits' ] = `clamp`;\n\n  const handleAmount = (amount: number) => {\n    if (amountProcess) amount = amountProcess(amount);\n    if (limits === undefined || limits === `clamp`) {\n      amount = clamp(amount);\n    } else if (limits === `wrap`) {\n      if (amount > 1) amount = amount % 1;\n      else if (amount < 0) {\n        amount = 1 + (amount % 1);\n      }\n    }\n    return amount;\n  }\n\n  const doTheEase = (_amt: number, _a: number, _b: number) => {\n    throwNumberTest(_a, ``, `a`);\n    throwNumberTest(_b, ``, `b`);\n    throwNumberTest(_amt, ``, `amount`);\n    _amt = handleAmount(_amt);\n    return (1 - _amt) * _a + _amt * _b\n  }\n\n\n  const readOpts = (o: Partial<BasicInterpolateOptions> = {}) => {\n    if (o.transform) {\n      if (typeof o.transform !== `function`) throw new Error(`Param 'transform' is expected to be a function. Got: ${ typeof o.transform }`);\n      amountProcess = o.transform;\n    }\n    limits = o.limits ?? `clamp`;\n  }\n\n  const rawEase = (_amt: number, _a: number, _b: number) => (1 - _amt) * _a + _amt * _b\n\n  if (typeof pos1 !== `number`) throw new TypeError(`First param is expected to be a number. Got: ${ typeof pos1 }`);\n  if (typeof pos2 === `number`) {\n    let a: number;\n    let b: number;\n    if (pos3 === undefined || typeof pos3 === `object`) {\n      //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n      a = pos1;\n      b = pos2;\n      readOpts(pos3);\n      return (amount: number) => doTheEase(amount, a, b);\n    } else if (typeof pos3 === `number`) {\n      //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n      a = pos2;\n      b = pos3;\n      readOpts(pos4);\n      return doTheEase(pos1, a, b);\n    } else {\n      throw new Error(`Values for 'a' and 'b' not defined`);\n    }\n  } else if (pos2 === undefined || typeof pos2 === `object`) {\n    //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n    const amount = handleAmount(pos1);\n    readOpts(pos2);\n    throwNumberTest(amount, ``, `amount`);\n    return (aValue: number, bValue: number) => rawEase(amount, aValue, bValue);\n  }\n};\n\n\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link interpolatorInterval}\n * which steps on the basis of clock time.\n * \n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n * \n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n * \n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n * \n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n * \n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorStepped = (incrementAmount: number, a = 0, b = 1, startInterpolationAt = 0, options?: Partial<BasicInterpolateOptions>) => {\n  let amount = startInterpolationAt;\n  return (retargetB?: number, retargetA?: number) => {\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    amount += incrementAmount;\n    return value;\n  }\n}\n\n\n\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (\n  amount: number,\n  aRadians: number,\n  bRadians: number,\n  options?: Partial<BasicInterpolateOptions>\n): number => {\n  const t = wrap(bRadians - aRadians, 0, piPi);\n  return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n\n","import type { Coord } from \"./types.js\";\n\n/**\n * Returns true if `p` seems to be a {@link Polar.Coord} (ie has both distance & angleRadian fields)\n * @param p\n * @returns True if `p` seems to be a PolarCoord\n */\nexport const isPolarCoord = (p: unknown): p is Coord => {\n  if ((p as Coord).distance === undefined) return false;\n  if ((p as Coord).angleRadian === undefined) return false;\n  return true;\n};\n\n/**\n * Throws an error if Coord is invalid\n * @param p\n * @param name\n */\nexport const guard = (p: Coord, name = `Point`) => {\n  if (p === undefined) {\n    throw new Error(\n      `'${ name }' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p === null) {\n    throw new Error(\n      `'${ name }' is null. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.angleRadian === undefined) {\n    throw new Error(\n      `'${ name }.angleRadian' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.distance === undefined) {\n    throw new Error(\n      `'${ name }.distance' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (typeof p.angleRadian !== `number`) {\n    throw new TypeError(\n\n      `'${ name }.angleRadian' must be a number. Got ${ p.angleRadian }`\n    );\n  }\n  if (typeof p.distance !== `number`) {\n\n    throw new TypeError(`'${ name }.distance' must be a number. Got ${ p.distance }`);\n  }\n\n  if (p.angleRadian === null) throw new Error(`'${ name }.angleRadian' is null`);\n  if (p.distance === null) throw new Error(`'${ name }.distance' is null`);\n\n  if (Number.isNaN(p.angleRadian)) {\n    throw new TypeError(`'${ name }.angleRadian' is NaN`);\n  }\n  if (Number.isNaN(p.distance)) throw new Error(`'${ name }.distance' is NaN`);\n};","import type { Point } from \"../point/point-type.js\";\nimport { guard, isPolarCoord } from \"./guard.js\";\nimport type { Coord } from \"./types.js\";\nimport { subtract as subtractPoint } from \"../point/subtract.js\";\nimport { guard as guardPoint } from \"../point/guard.js\";\nimport { Empty as EmptyPoint } from '../point/empty.js';\nimport { isPoint } from \"../point/guard.js\";\nimport { radianToDegree } from \"../angles.js\";\n/**\n * Converts to Cartesian coordiantes\n */\ntype ToCartesian = {\n  (point: Coord, origin?: Point): Point;\n  (distance: number, angleRadians: number, origin?: Point): Point;\n};\n/**\n * Converts to Cartesian coordinate from polar.\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * const origin = { x: 50, y: 50}; // Polar origin\n * // Yields: { x, y }\n * const polar = Polar.toCartesian({ distance: 10, angleRadian: 0 }, origin);\n * ```\n *\n * Distance and angle can be provided as numbers intead:\n *\n * ```\n * // Yields: { x, y }\n * const polar = Polar.toCartesian(10, 0, origin);\n * ```\n *\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const toCartesian: ToCartesian = (\n  a: Coord | number,\n  b?: Point | number,\n  c?: Point\n): Point => {\n  if (isPolarCoord(a)) {\n    if (b === undefined) b = EmptyPoint;\n    if (isPoint(b)) {\n      return polarToCartesian(a.distance, a.angleRadian, b);\n    }\n    throw new Error(\n      `Expecting (Coord, Point). Second parameter is not a point`\n    );\n  } else if (typeof a === `object`) {\n    throw new TypeError(\n      `First param is an object, but not a Coord: ${ JSON.stringify(a) }`\n    );\n  } else {\n    if (typeof a === `number` && typeof b === `number`) {\n      if (c === undefined) c = EmptyPoint;\n      if (!isPoint(c)) {\n        throw new Error(\n          `Expecting (number, number, Point). Point param wrong type`\n        );\n      }\n      return polarToCartesian(a, b, c);\n    } else {\n      throw new TypeError(\n        `Expecting parameters of (number, number). Got: (${ typeof a }, ${ typeof b }, ${ typeof c }). a: ${ JSON.stringify(\n          a\n        ) }`\n      );\n    }\n  }\n};\n\n/**\n * Converts a Cartesian coordinate to polar\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * // Yields: { angleRadian, distance }\n * const polar = Polar.fromCartesian({x: 50, y: 50}, origin);\n * ```\n *\n * Any additional properties of `point` are copied to object.\n * @param point Point\n * @param origin Origin\n * @returns\n */\nexport const fromCartesian = (\n  point: Point,\n  origin: Point\n): Coord => {\n  point = subtractPoint(point, origin);\n\n  const angle = Math.atan2(point.y, point.x);\n  return Object.freeze({\n    ...point,\n    angleRadian: angle,\n    distance: Math.hypot(point.x, point.y),\n  });\n};\n\n/**\n * Converts a polar coordinate to Cartesian\n * @param distance Distance\n * @param angleRadians Angle in radians\n * @param origin Origin, or 0,0 by default.\n * @returns\n */\nconst polarToCartesian = (\n  distance: number,\n  angleRadians: number,\n  origin: Point = EmptyPoint\n): Point => {\n  guardPoint(origin);\n  return Object.freeze({\n    x: origin.x + distance * Math.cos(angleRadians),\n    y: origin.y + distance * Math.sin(angleRadians),\n  });\n};\n\n/**\n * Returns a human-friendly string representation `(distance, angleDeg)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport const toString = (p: Coord, digits?: number): string => {\n  if (p === undefined) return `(undefined)`;\n  if (p === null) return `(null)`;\n\n  const angleDeg = radianToDegree(p.angleRadian);\n  const d = digits ? p.distance.toFixed(digits) : p.distance;\n  const a = digits ? angleDeg.toFixed(digits) : angleDeg;\n  return `(${ d },${ a })`;\n};\n\nexport const toPoint = (v: Coord, origin = EmptyPoint): Point => {\n  guard(v, `v`);\n  return Object.freeze({\n    x: origin.x + v.distance * Math.cos(v.angleRadian),\n    y: origin.y + v.distance * Math.sin(v.angleRadian),\n  });\n};","import { isPoint, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\nexport function abs(pt: Point3d): Point3d;\nexport function abs(pt: Point): Point;\n\n/**\n * Returns a point with Math.abs applied to x,y and z if present.\n * ```js\n * Points.abs({ x:1,  y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:-1 }); // { x: 1, y: 1 }\n * ```\n * @param pt\n * @returns\n */\nexport function abs(pt: Point): Point {\n  if (isPoint3d(pt)) {\n    return Object.freeze({\n      ...pt,\n      x: Math.abs(pt.x),\n      y: Math.abs(pt.y),\n      z: Math.abs(pt.z)\n    });\n  } else if (isPoint(pt)) {\n    return Object.freeze({\n      ...pt,\n      x: Math.abs(pt.x),\n      y: Math.abs(pt.y)\n    });\n  } else throw new TypeError(`Param 'pt' is not a point`);\n};","import type { Point, Point3d } from \"./point-type.js\";\n\n/**\n * Returns -2 if both x & y of a is less than b\n * Returns -1 if either x/y of a is less than b\n *\n * Returns 2 if both x & y of a is greater than b\n * Returns 1 if either x/y of a is greater than b's x/y\n *\n * Returns 0 if x/y of a and b are equal\n * @param a\n * @param b\n * @returns\n */\nexport const compare = (a: Point, b: Point): number => {\n  if (a.x < b.x && a.y < b.y) return -2;\n  if (a.x > b.x && a.y > b.y) return 2;\n  if (a.x < b.x || a.y < b.y) return -1;\n  if (a.x > b.x || a.y > b.y) return 1;\n  if (a.x === b.x && a.x === b.y) return 0;\n  return Number.NaN;\n};\n\n/**\n * Compares points based on x value. Y value is ignored.\n * \n * Return values:\n * * 0: If a.x === b.x\n * * 1: a is to the right of b (ie. a.x > b.x)\n * * -1: a is to the left of b (ie. a.x < b.x)\n *\n * @example Sorting by x\n * ```js\n * arrayOfPoints.sort(Points.compareByX);\n * ```\n * \n * @param a\n * @param b\n * @returns\n */\nexport const compareByX = (a: Point, b: Point): number => {\n  if (a.x === b.x) return 0;\n  if (a.x < b.x) return -1;\n  return 1;\n\n  // a.x - b.x || a.y - b.y;\n}\n\n/**\n * Compares points based on Y value. X value is ignored.\n * Returns values:\n * * 0: If a.y === b.y\n * * 1: A is below B (ie. a.y > b.y)\n * * -1: A is above B (ie. a.y < b.y)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByY);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByY = (a: Point, b: Point): number => {\n  if (a.y === b.y) return 0;\n  if (a.y < b.y) return -1;\n  return 1;\n}\n\n/**\n * Compares points based on Z value. XY values are ignored.\n * Returns values:\n * * 0: If a.z === b.z\n * * 1: A is below B (ie. a.z > b.z)\n * * -1: A is above B (ie. a.z < b.z)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByZ);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByZ = (a: Point3d, b: Point3d): number => {\n  if (a.z === b.z) return 0;\n  if (a.z < b.z) return -1;\n  return 1;\n}","import type { Point } from \"./point-type.js\";\nimport { interpolate as lineInterpolate } from '../line/interpolate.js';\n\n/**\n * Returns a relative point between two points\n * ```js\n * interpolate(0.5, a, b); // Halfway point between a and b\n * ```\n *\n * Alias for Lines.interpolate(amount, a, b);\n *\n * @param amount Relative amount, 0-1\n * @param a\n * @param b\n * @param allowOverflow If true, length of line can be exceeded for `amount` of below 0 and above `1`.\n * @returns {@link Point}\n */\nexport const interpolate = (\n  amount: number,\n  a: Point,\n  b: Point,\n  allowOverflow = false\n): Point => lineInterpolate(amount, a, b, allowOverflow); //({x: (1-amt) * a.x + amt * b.x, y:(1-amt) * a.y + amt * b.y });\n","import { isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\n/**\n * Inverts one or more axis of a point\n * ```js\n * invert({x:10, y:10}); // Yields: {x:-10, y:-10}\n * invert({x:10, y:10}, `x`); // Yields: {x:-10, y:10}\n * ```\n * @param pt Point to invert\n * @param what Which axis. If unspecified, both axies are inverted\n * @returns\n */\nexport const invert = (\n  pt: Point | Point3d,\n  what: `both` | `x` | `y` | `z` = `both`\n): Point => {\n  switch (what) {\n    case `both`: {\n      return isPoint3d(pt) ? Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n        y: pt.y * -1,\n        z: pt.z * -1,\n      }) : Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n        y: pt.y * -1,\n      });\n    }\n    case `x`: {\n      return Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n      });\n    }\n    case `y`: {\n      return Object.freeze({\n        ...pt,\n        y: pt.y * -1,\n      });\n    }\n    case `z`: {\n      if (isPoint3d(pt)) {\n        return Object.freeze({\n          ...pt,\n          z: pt.z * -1,\n        });\n      } else throw new Error(`pt parameter is missing z`);\n    }\n    default: {\n      throw new Error(`Unknown what parameter. Expecting 'both', 'x' or 'y'`);\n    }\n  }\n};","import type { Point } from \"./point-type.js\";\n\n/**\n * Runs a sequential series of functions on `pt`. The output from one feeding into the next.\n * ```js\n * const p = Points.pipelineApply(somePoint, Points.normalise, Points.invert);\n * ```\n *\n * If you want to make a reusable pipeline of functions, consider {@link pipeline} instead.\n * @param point\n * @param pipelineFns\n * @returns\n */\nexport const pipelineApply = (\n  point: Point,\n  ...pipelineFns: ReadonlyArray<(pt: Point) => Point>\n): Point => pipeline(...pipelineFns)(point); // pipeline.reduce((prev, curr) => curr(prev), pt);\n\n/**\n * Returns a pipeline function that takes a point to be transformed through a series of functions\n * ```js\n * // Create pipeline\n * const p = Points.pipeline(Points.normalise, Points.invert);\n *\n * // Now run it on `somePoint`.\n * // First we normalised, and then invert\n * const changedPoint = p(somePoint);\n * ```\n *\n * If you don't want to create a pipeline, use {@link pipelineApply}.\n * @param pipeline Pipeline of functions\n * @returns\n */\nexport const pipeline =\n  (...pipeline: ReadonlyArray<(pt: Point) => Point>) =>\n    (pt: Point) =>\n      // eslint-disable-next-line unicorn/no-array-reduce\n      pipeline.reduce((previous, current) => current(previous), pt);\n","import { throwNumberTest } from '@ixfx/guards';\nimport { type RandomOptions, type RandomSource } from \"./types.js\";\n\n/**\n * Source for random bipolar values\n * ```js\n * const r = bipolarSource();\n * r(); // Produce random value on -1...1 scale\n * ```\n * \n * Options can be provided, for example\n * ```js\n * // -0.5 to 0.5 range\n * bipolarSource({ max: 0.5 });\n * ```\n * \n * \n * @param maxOrOptions Maximum value (number) or options for random generation\n * @returns \n */\nexport const bipolarSource = (maxOrOptions?: number | RandomOptions): RandomSource => {\n  const source = floatSource(maxOrOptions);\n  return () => (source() * 2) - 1;\n}\n\n/**\n * Returns a random bipolar value\n * ```js\n * const r = bipolar(); // -1...1 random\n * ```\n * \n * Options can be provided, eg.\n * ```js\n * bipolar({ max: 0.5 }); // -0.5..0.5 random\n * ```\n * \n * Use {@link bipolarSource} if you want to generate random\n * values with same settings repeatedly.\n * @param maxOrOptions \n * @returns \n */\nexport const bipolar = (maxOrOptions?: number | RandomOptions): number => {\n  const source = bipolarSource(maxOrOptions);\n  return source();\n}\n\n/**\n * Returns a function that produces random float values.\n * Use {@link float} to produce a valued directly.\n *\n * Random float between `max` (exclusive) and 0 (inclusive). Max is 1 if unspecified.\n *\n *\n * ```js\n * // Random number between 0..1 (but not including 1)\n * // (this would be identical to Math.random())\n * const r = floatSource();\n * r(); // Execute to produce random value\n *\n * // Random float between 0..100 (but not including 100)\n * const v = floatSource(100)();\n * ```\n *\n * Options can be used:\n * ```js\n * // Random float between 20..40 (possibly including 20, but always lower than 40)\n * const r = floatSource({ min: 20, max: 40 });\n * ```\n * @param maxOrOptions Maximum value (exclusive) or options\n * @returns Random number\n */\nexport const floatSource = (maxOrOptions: (number | RandomOptions) = 1): RandomSource => {\n  const options = typeof maxOrOptions === `number` ? { max: maxOrOptions } : maxOrOptions;\n  let max = options.max ?? 1;\n  let min = options.min ?? 0;\n  const source = options.source ?? Math.random;\n\n  throwNumberTest(min, ``, `min`);\n  throwNumberTest(max, ``, `max`);\n\n  if (!options.min && max < 0) {\n    min = max;\n    max = 0;\n  }\n  if (min > max) {\n    throw new Error(`Min is greater than max. Min: ${ min.toString() } max: ${ max.toString() }`);\n  }\n\n  return () => source() * (max - min) + min;\n};\n\n/**\n * Returns a random float between `max` (exclusive) and 0 (inclusive). Max is 1 if unspecified.\n * Use {@link floatSource} to get a function that produces values. This is used internally.\n *\n * ```js\n * // Random number between 0..1 (but not including 1)\n * // (this would be identical to Math.random())\n * const v = float();\n * // Random float between 0..100 (but not including 100)\n * const v = float(100);\n * ```\n *\n * Options can be used:\n * ```js\n * // Random float between 20..40 (possibly including 20, but always lower than 40)\n * const v = float({ min: 20, max: 40 });\n * ```\n * @param maxOrOptions Maximum value (exclusive) or options\n * @returns Random number\n */\nexport const float = (maxOrOptions: (number | RandomOptions) = 1): number =>\n  floatSource(maxOrOptions)();","import type { Point } from \"../point/point-type.js\";\nimport { guardDim } from \"./guard.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\nimport { guard as PointsGuard } from '../point/guard.js';\n\n/**\n * Creates a rectangle from its top-left coordinate, a width and height.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Rectangle at 50,50 with width of 100, height of 200.\n * const rect = Rects.fromTopLeft({ x: 50, y:50 }, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromTopLeft = (\n  origin: Point,\n  width: number,\n  height: number\n): RectPositioned => {\n  guardDim(width, `width`);\n  guardDim(height, `height`);\n  PointsGuard(origin, `origin`);\n\n  return { x: origin.x, y: origin.y, width: width, height: height };\n};\n","import { isPoint } from \"../point/guard.js\";\nimport { guard } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\nimport { joinPointsToLines as LinesJoinPointsToLines } from '../line/join-points-to-lines.js';\n\nimport type { Point } from '../point/point-type.js';\nimport { corners } from \"./corners.js\";\nimport type { Line } from \"../line/line-type.js\";\n\n/**\n * Returns four lines based on each corner.\n * Lines are given in order: top, right, bottom, left\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lines = Rects.lines(rect);\n * ```\n *\n * @param {(RectPositioned|Rect)} rect\n * @param {Points.Point} [origin]\n * @returns {Lines.Line[]}\n */\nexport const edges = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): ReadonlyArray<Line> => {\n  const c = corners(rect, origin);\n\n  // Connect all the corners, back to first corner again\n  return LinesJoinPointsToLines(...c, c[ 0 ]);\n};\n\n/**\n * Returns a point on the edge of rectangle\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeX(r1, `right`);  // Yields: 110\n * Rects.getEdgeX(r1, `bottom`); // Yields: 10\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeX(r2, `right`);  // Yields: 100\n * Rects.getEdgeX(r2, `bottom`); // Yields: 0\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeX = (\n  rect: RectPositioned | Rect,\n  edge: `right` | `bottom` | `left` | `top`\n): number => {\n  guard(rect);\n  switch (edge) {\n    case `top`: {\n      return isPoint(rect) ? rect.x : 0;\n    }\n    case `bottom`: {\n      return isPoint(rect) ? rect.x : 0;\n    }\n    case `left`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n    case `right`: {\n      return isPoint(rect) ? rect.x + rect.width : rect.width;\n    }\n  }\n};\n\n/**\n * Returns a point on the edge of rectangle\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeY(r1, `right`);  // Yields: 10\n * Rects.getEdgeY(r1, `bottom`); // Yields: 60\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeY(r2, `right`);  // Yields: 0\n * Rects.getEdgeY(r2, `bottom`); // Yields: 50\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeY = (\n  rect: RectPositioned | Rect,\n  edge: `right` | `bottom` | `left` | `top`\n): number => {\n  guard(rect);\n  switch (edge) {\n    case `top`: {\n      return (isPoint(rect) ? rect.y : 0);\n    }\n    case `bottom`: {\n      return isPoint(rect) ? rect.y + rect.height : rect.height;\n    }\n    case `left`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n    case `right`: {\n      return isPoint(rect) ? rect.y : 0;\n    }\n  }\n};","import { Bezier as BezierLibrary } from 'bezier-js';\nimport { interpolate as LinesInterpolate } from '../line/interpolate.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/from-top-left.js';\nimport type { Point } from '../point/point-type.js';\nimport type { CubicBezier, CubicBezierPath, QuadraticBezier, QuadraticBezierPath } from './bezier-type.js';\nimport { isCubicBezier, isQuadraticBezier } from './guard.js';\nimport { to2d } from '../point/To.js';\nexport * from './bezier-type.js';\nexport * from './guard.js';\n/**\n * Returns a new quadratic bezier with specified bend amount\n *\n * @param {QuadraticBezier} b Curve\n * @param {number} [bend=0] Bend amount, from -1 to 1\n * @returns {QuadraticBezier}\n */\n// export const quadraticBend = (a: Point, b: Point, bend = 0): QuadraticBezier => quadraticSimple(a, b, bend);\n\n/**\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve.\n * \n * Use {@link interpolator} to calculate a point along the curve.\n * @param {Point} start Start of curve\n * @param {Point} end End of curve\n * @param {number} [bend=0] Bend amount, -1 to 1\n * @returns {QuadraticBezier}\n */\nexport const quadraticSimple = (start: Point, end: Point, bend = 0): QuadraticBezier => {\n  if (Number.isNaN(bend)) throw new Error(`bend is NaN`);\n  if (bend < -1 || bend > 1) throw new Error(`Expects bend range of -1 to 1`);\n\n  const middle = LinesInterpolate(0.5, start, end);\n  let target = middle;\n  if (end.y < start.y) {\n    // Upward slope\n    target = bend > 0 ? { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.max(start.x, end.x), y: Math.max(start.y, end.y) };\n  } else {\n    // Downward slope\n    target = bend > 0 ? { x: Math.max(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.min(start.x, end.x), y: Math.max(start.y, end.y) };\n  }\n\n  const handle = LinesInterpolate(Math.abs(bend), middle, target,);\n  return quadratic(start, end, handle);\n};\n\n/**\n * Returns a relative point on a simple quadratic \n * @param start Start\n * @param end  End\n * @param bend Bend (-1 to 1)\n * @param amt Amount\n * @returns Point\n */\n// export const computeQuadraticSimple = (start: Point, end: Point, bend: number, amt: number): Point => {\n//   const q = quadraticSimple(start, end, bend);\n//   const bzr = new BezierLibrary(q.a, q.quadratic, q.b);\n//   return bzr.compute(amt);\n// };\n\n/**\n * Interpolate cubic or quadratic bezier\n * ```js\n * const i = interpolator(myBezier);\n * \n * // Get point at 50%\n * i(0.5); // { x, y }\n * ```\n * @param q \n * @returns \n */\nexport const interpolator = (q: QuadraticBezier | CubicBezier): (amount: number) => Point => {\n  //console.log(q);\n  //if (isCubicBezier(q)) console.log(`is cubic`);\n  //const bzr = isCubicBezier(q) ? new BezierLibrary(to2d(q.a), to2d(q.cubic1), to2d(q.cubic2), to2d(q.b)) : new BezierLibrary(q.a, q.quadratic, q.b);\n  const bzr = isCubicBezier(q) ?\n    new BezierLibrary(q.a.x, q.a.y, q.cubic1.x, q.cubic1.y, q.cubic2.x, q.cubic2.y, q.b.x, q.b.y) :\n    new BezierLibrary(q.a, q.quadratic, q.b);\n\n  return (amount: number) => bzr.compute(amount);\n};\n\n//https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\nexport const quadraticToSvgString = (start: Point, end: Point, handle: Point): ReadonlyArray<string> => [ `M ${ start.x } ${ start.y } Q ${ handle.x } ${ handle.y } ${ end.x } ${ end.y }` ];\n\nexport const toPath = (cubicOrQuadratic: CubicBezier | QuadraticBezier): CubicBezierPath | QuadraticBezierPath => {\n  if (isCubicBezier(cubicOrQuadratic)) {\n    return cubicToPath(cubicOrQuadratic);\n  } else if (isQuadraticBezier(cubicOrQuadratic)) {\n    return quadratictoPath(cubicOrQuadratic);\n  } else {\n    throw new Error(`Unknown bezier type`);\n  }\n};\n\nexport const cubic = (start: Point, end: Point, cubic1: Point, cubic2: Point): CubicBezier => (\n  {\n    a: Object.freeze(start),\n    b: Object.freeze(end),\n    cubic1: Object.freeze(cubic1),\n    cubic2: Object.freeze(cubic2)\n  });\n\nconst cubicToPath = (cubic: CubicBezier): CubicBezierPath => {\n  const { a, cubic1, cubic2, b } = cubic;\n\n  const bzr = new BezierLibrary(a, cubic1, cubic2, b);\n  return Object.freeze({\n    ...cubic,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n    },\n    toSvgString: () => [ `brrup` ],\n    kind: `bezier/cubic`\n  });\n};\n\nexport const quadratic = (start: Point, end: Point, handle: Point): QuadraticBezier => ({\n  a: Object.freeze(start),\n  b: Object.freeze(end),\n  quadratic: Object.freeze(handle)\n});\n\n\nconst quadratictoPath = (quadraticBezier: QuadraticBezier): QuadraticBezierPath => {\n  const { a, b, quadratic } = quadraticBezier;\n  const bzr = new BezierLibrary(a, quadratic, b);\n  return Object.freeze({\n    ...quadraticBezier,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    toString: () => bzr.toString(),\n    toSvgString: () => quadraticToSvgString(a, b, quadratic),\n    kind: `bezier/quadratic`\n  });\n};\n\n","\n\nexport const isAsyncIterable = (v: any): v is AsyncIterable<any> => {\n  if (typeof v !== `object`) return false;\n  if (v === null) return false;\n  return Symbol.asyncIterator in v;\n\n}\n\nexport const isIterable = (v: any): v is Iterable<any> => {\n  if (typeof v !== `object`) return false;\n  if (v === null) return false;\n  return Symbol.iterator in v;\n\n}\n\n","import type { QueueOpts } from './queue-types.js';\n\nexport const debug = (opts: QueueOpts<any>, message: string): void => {\n  opts.debug ? console.log(`queue:${ message }`) : undefined;\n};\n\nexport const trimQueue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>,\n  toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  const potentialLength = queue.length + toAdd.length;\n  const capacity = opts.capacity ?? potentialLength;\n  const toRemove = potentialLength - capacity;\n  const policy = opts.discardPolicy ?? `additions`;\n  // debug(\n  //   opts,\n  //   `queueLen: ${queue.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy} toAdd.length: ${toAdd.length} capacity: ${capacity}`\n  // );\n  // debug(opts, `to add: ${JSON.stringify(toAdd)}`);\n\n  switch (policy) {\n    // Only add what we can from toAdd\n    case `additions`: {\n      // debug(\n      //   opts,\n      //   `trimQueue:DiscardAdditions: queueLen: ${queue.length} slice: ${\n      //     potentialLength - capacity\n      //   } toAddLen: ${toAdd.length} nowFull: ${queue.length === opts.capacity}`\n      // );\n      if (queue.length === 0) return toAdd.slice(0, toAdd.length - toRemove);\n      // eslint-disable-next-line unicorn/prefer-ternary\n      if (queue.length === opts.capacity) {\n        return queue; // Completely full\n      } else {\n        // Only add some from the new array (from the front)\n        return [ ...queue, ...toAdd.slice(0, toRemove - 1) ];\n      }\n    }\n    // Remove from rear of queue (last index) before adding new things\n    case `newer`: {\n      if (toRemove >= queue.length) {\n        // New items will completely flush out old\n        //debug(opts, `slice start: ${toAdd.length - capacity}`);\n        if (queue.length === 0) {\n          // Special case when queue starts off empty\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          return [ ...toAdd.slice(0, capacity - 1), toAdd.at(-1)! ];\n        }\n        return toAdd.slice(\n          Math.max(0, toAdd.length - capacity),\n          Math.min(toAdd.length, capacity) + 1\n        );\n        //debug(opts, `Final value: ${JSON.stringify(tmp)}`);\n        //return tmp;\n      } else {\n        // Keep some of the old\n        // const toAddFinal = toAdd.slice(\n        //   0,\n        //   Math.min(toAdd.length, capacity - toRemove + 1)\n        // );\n        // Cap 5, queue 5, toAdd: 10.\n        const countToAdd = Math.max(1, toAdd.length - queue.length);\n        const toAddFinal = toAdd.slice(toAdd.length - countToAdd, toAdd.length);\n        const toKeep = queue.slice(0, Math.min(queue.length, capacity - 1)); //toRemove);\n        // debug(\n        //   opts,\n        //   `trimQueue: countToAdd: ${countToAdd} qLen: ${\n        //     queue.length\n        //   } capacity: ${capacity} toRemove: ${toRemove} keeping: ${JSON.stringify(\n        //     toKeep\n        //   )} from orig: ${JSON.stringify(queue)} toAddFinal: ${JSON.stringify(\n        //     toAddFinal\n        //   )}`\n        // );\n        const t = [ ...toKeep, ...toAddFinal ];\n        //debug(opts, `final: ${JSON.stringify(t)}`);\n        return t;\n      }\n    }\n    // Remove from the front of the queue (0 index). ie. older items are discarded\n    case `older`: {\n      // If queue is A, B and toAdd is C, D this yields A, B, C, D\n      return [ ...queue, ...toAdd ].slice(toRemove);\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown overflow policy ${ policy }`);\n    }\n  }\n};\n\n/**\n * Adds to the back of the queue (last array index)\n * Last item of `toAdd` will potentially be the new end of the queue (depending on capacity limit and overflow policy)\n * @typeParam V - Type of values\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @param {...V[]} toAdd\n * @returns {V[]}\n */\nexport const enqueue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>,\n  ...toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (opts === undefined) throw new Error(`opts parameter undefined`);\n\n  const potentialLength = queue.length + toAdd.length;\n  const overSize = opts.capacity && potentialLength > opts.capacity;\n\n  const toReturn = overSize\n    ? trimQueue(opts, queue, toAdd)\n    : [ ...queue, ...toAdd ];\n  if (opts.capacity && toReturn.length !== opts.capacity && overSize) {\n    throw new Error(\n      `Bug! Expected return to be at capacity. Return len: ${ toReturn.length\n      } capacity: ${ opts.capacity } opts: ${ JSON.stringify(opts) }`\n    );\n  }\n  if (!opts.capacity && toReturn.length !== potentialLength) {\n    throw new Error(\n      `Bug! Return length not expected. Return len: ${ toReturn.length\n      } expected: ${ potentialLength } opts: ${ JSON.stringify(opts) }`\n    );\n  }\n  return toReturn;\n};\n\n// Remove from front of queue (0 index)\nexport const dequeue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (queue.length === 0) throw new Error(`Queue is empty`);\n  return queue.slice(1);\n};\n\n/**\n * Returns front of queue (oldest item), or undefined if queue is empty\n *\n * @typeParam V - Type of values stored\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @returns {(V | undefined)}\n */\nexport const peek = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): V | undefined => queue[ 0 ];\n\nexport const isEmpty = <V>(opts: QueueOpts<V>, queue: ReadonlyArray<V>): boolean =>\n  queue.length === 0;\n\nexport const isFull = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): boolean => {\n  if (opts.capacity) {\n    return queue.length >= opts.capacity;\n  }\n  return false;\n};\n","import { type IQueueMutable, type IQueueMutableWithEvents, type QueueMutableEvents } from './iqueue-mutable.js';\nimport { enqueue, peek, dequeue, isEmpty, isFull } from './queue-fns.js';\nimport { type QueueOpts } from './queue-types.js';\nimport { isEqualDefault, type IsEqual } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events'; //'../../Events.js';\n\n/**\n * Mutable queue that fires events when manipulated.\n * \n * Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * const q = Queues.mutable();       // Create\n * q.enqueue(`a`, `b`);     // Add two strings\n * const front = q.dequeue();  // `a` is at the front of queue (oldest)\n * ```\n *\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.mutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * Events can be used to monitor data flows.\n * * 'enqueue': fires when item(s) are added\n * * 'dequeue': fires when an item is dequeued from front\n * * 'removed': fires when an item is dequeued, queue is cleared or .removeWhere is used to trim queue\n * \n * Each of the event handlers return the state of the queue as the 'finalData'\n * field.\n * \n * ```js\n * q.addEventListener(`enqueue`, e => {\n *  // e.added, e.finalData\n * });\n * q.addEventListener(`removed`, e => {\n *  // e.removed, e.finalData\n * });\n * q.addEventListener(`dequeue`, e=> {\n *  // e.removed, e.finalData\n * })\n * ```\n * @typeParam V - Data type of items\n */\nexport class QueueMutable<V> extends SimpleEventEmitter<QueueMutableEvents<V>> implements IQueueMutable<V> {\n  readonly options: QueueOpts<V>;\n  data: readonly V[];\n  eq: IsEqual<V>;\n\n  constructor(opts: QueueOpts<V> = {}, data: readonly V[] = []) {\n    super();\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\n    this.options = opts;\n    this.data = data;\n    this.eq = opts.eq ?? isEqualDefault;\n  }\n\n  clear() {\n    const copy = [ ...this.data ];\n    this.data = [];\n    this.fireEvent(`removed`, { finalData: this.data, removed: copy });\n    this.onClear();\n  }\n\n  /**\n   * Called when all data is cleared\n   */\n  protected onClear() { /** no-op */\n  }\n\n  at(index: number): V {\n    if (index >= this.data.length) throw new Error(`Index outside bounds of queue`);\n    const v = this.data.at(index);\n    if (v === undefined) throw new Error(`Index appears to be outside range of queue`);\n    return v;\n  }\n\n  enqueue(...toAdd: readonly V[]): number {\n    this.data = enqueue(this.options, this.data, ...toAdd);\n    const length = this.data.length;\n    this.onEnqueue(this.data, toAdd);\n    return length;\n  }\n\n  protected onEnqueue(result: readonly V[], attemptedToAdd: readonly V[]) {\n    this.fireEvent(`enqueue`, { added: attemptedToAdd, finalData: result });\n  }\n\n  dequeue(): V | undefined {\n    const v = peek(this.options, this.data);\n    if (v === undefined) return;\n    /* eslint-disable-next-line functional/immutable-data */\n    this.data = dequeue(this.options, this.data);\n    this.fireEvent(`dequeue`, { removed: v, finalData: this.data });\n    this.onRemoved([ v ], this.data);\n    return v;\n  }\n\n  protected onRemoved(removed: readonly V[], finalData: readonly V[]) {\n    this.fireEvent(`removed`, { removed, finalData });\n  }\n\n  /**\n   * Removes values that match `predicate`.\n   * @param predicate \n   * @returns Returns number of items removed.\n   */\n  removeWhere(predicate: (item: V) => boolean): number {\n    const countPre = this.data.length;\n    const toRemove = this.data.filter(v => predicate(v));\n    if (toRemove.length === 0) return 0;\n    this.data = this.data.filter((element) => !predicate(element));\n    this.onRemoved(toRemove, this.data);\n    return countPre - this.data.length;\n  }\n\n  /**\n * Return a copy of the array\n * @returns \n */\n  toArray(): V[] {\n    return [ ...this.data ];\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.options, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.options, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n\n  get peek(): V | undefined {\n    return peek(this.options, this.data);\n  }\n}\n\n/**\n * Creates a new QueueMutable\n * @param options \n * @param startingItems \n * @returns \n */\nexport function mutable<V>(\n  options: QueueOpts<V> = {},\n  ...startingItems: readonly V[]\n): IQueueMutableWithEvents<V> {\n  return new QueueMutable({ ...options }, [ ...startingItems ]);\n}\n\n","import { intervalToMs, type Interval, type IsEqual, toStringDefault } from '@ixfx/core';\nimport { sleep, type SleepOpts } from '@ixfx/core';\nimport type { ForEachOptions, ToArrayOptions } from './types.js';\nimport { isAsyncIterable, isIterable } from './guard.js';\n\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * \n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport async function* fromArray<V>(array: V[], interval: Interval = 1): AsyncGenerator<V> {\n  for (const v of array) {\n    yield v;\n    await sleep(interval);\n  }\n}\n\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport async function* fromIterable<V>(iterable: Iterable<V> | AsyncIterable<V>, interval: Interval = 1): AsyncGenerator<V> {\n  for await (const v of iterable) {\n    yield v;\n    await sleep(interval);\n  }\n}\n\nexport async function* chunks<V>(it: AsyncIterable<V>, size: number) {\n  // Source: https://surma.github.io/underdash/\n  let buffer: V[] = [];\n  for await (const v of it) {\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      buffer = [];\n    }\n  }\n  if (buffer.length > 0) yield buffer;\n}\n\n\nexport async function* concat<V>(...its: readonly AsyncIterable<V>[]) {\n  // Source: https://surma.github.io/underdash/\n  for await (const it of its) yield* it;\n}\n\nexport async function* dropWhile<V>(\n  it: AsyncIterable<V>,\n  f: (v: V) => boolean\n) {\n  for await (const v of it) {\n    if (!f(v)) {\n      yield v;\n    }\n  }\n}\n\n/**\n * Loops over a generator until it finishes, calling `callback`.\n * Useful if you don't care about the value generator produces, just the number of loops.\n * \n * In this version, we do a `for await of` over `gen`, and also `await callback()`. \n\n * ```js\n * await until(count(5), () => {\n * // do something 5 times\n * });\n * ```\n * \n * If you want the value from the generator, use a `for of` loop as usual.\n * \n * If `callback` explicitly returns _false_, the generator is aborted.\n * @param it Generator to run\n * @param callback Code to call for each iteration\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = async (it: AsyncIterable<any> | Iterable<any>, callback: () => (void | Promise<boolean> | undefined | boolean | Promise<undefined> | Promise<void>)): Promise<undefined> => {\n  for await (const _ of it) {\n    const value = await callback();\n    if (typeof value === `boolean` && !value) break;\n  }\n}\n\n/**\n * This generator will repeat another generator up until some condition. This is the version\n * that can handle async generators.\n * \n * For example, {@link count} will count from 0..number and then finish:\n * ```js\n * for (const v of count(5)) {\n *  // v: 0, 1, 2, 3, 4\n * }\n * ```\n * \n * But what if we want to repeat the count? We have to provide a function to create the generator,\n * rather than using the generator directly, since it's \"one time use\"\n * ```js\n * for await (const v of repeat(() => count(5))) {\n *  // v: 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, ...\n *  // warning: never ends\n * }\n * ```\n * \n * Limiting the number of repeats can be done by passing in extra parameters\n * ```js\n * repeat(generator, { count: 5} ); // Iterate over `generator` five times\n * ```\n * \n * ```js\n * const ac = new AbortController();\n * repeat(generator, { signal: ac.signal }); // Pass in signal\n * ...\n * ac.abort(); // Trigger signal at some point\n * ```\n * @param genCreator \n * @param repeatsOrSignal \n */\nexport const repeat = async function*<T>(genCreator: () => Iterable<T> | AsyncIterable<T>, repeatsOrSignal: number | AbortSignal): AsyncGenerator<T> {\n  const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n  const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n  let count = repeats;\n\n  while (true) {\n    for await (const v of genCreator()) {\n      yield v;\n      if (signal?.aborted) break;\n    }\n    if (Number.isFinite(repeats)) {\n      count--;\n      if (count === 0) break;\n    }\n    if (signal?.aborted) break;\n  }\n}\n\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport async function equals<V>(\n  it1: AsyncIterable<V>,\n  it2: AsyncIterable<V>,\n  equality?: IsEqual<V>\n) {\n  // https://surma.github.io/underdash/\n  const iit1 = it1[ Symbol.asyncIterator ]();// it1[ Symbol.iterator ]();\n  const iit2 = it2[ Symbol.asyncIterator ]();\n  while (true) {\n    const index1 = await iit1.next();\n    const index2 = await iit2.next();\n    if (equality !== undefined) {\n      if (!equality(index1.value, index2.value)) return false;\n    } else if (index1.value !== index2.value) return false;\n    if (index1.done ?? index2.done) return index1.done && index2.done;\n  }\n}\n\nexport async function every<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  for await (const v of it) {\n    const result = await f(v);\n    if (!result) return false;\n  }\n  return true;\n}\n\nexport async function* fill<V>(it: AsyncIterable<V>, v: V) {\n  // https://surma.github.io/underdash/\n  for await (const _ of it) yield v;\n}\n\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport async function* filter<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (!await f(v)) continue;\n    yield v;\n  }\n}\n\n\nexport async function find<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (await f(v)) return v;\n  }\n}\n\n\nexport async function* flatten<V>(it: AsyncIterable<V>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (typeof v === `object`) {\n      if (Array.isArray(v)) {\n        for (const vv of v) yield vv;\n      } else if (isAsyncIterable(v)) {\n        for await (const vv of v) {\n          yield vv;\n        }\n      } else if (isIterable(v)) {\n        for (const vv of v) {\n          yield vv;\n        }\n      }\n    } else {\n      yield v;\n    }\n\n  }\n}\n\n/**\n * Iterates over an async iterable or array, calling `fn` for each value, with optional\n * interval between each loop. If the async `fn` returns _false_, iterator cancels.\n *\n * ```\n * import { forEach } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * // Prints items from array every second\n * await forEach([0,1,2,3], i => console.log(i), 1000);\n * ```\n *\n * ```\n * // Retry up to five times, with 5 seconds between each attempt\n * await forEach(count(5), i=> {\n *  try {\n *    await doSomething();\n *    return false; // Succeeded, exit early\n *  } catch (ex) {\n *    console.log(ex);\n *    return true; // Keep trying\n *  }\n * }, 5000);\n * ```\n * @param iterator Iterable thing to loop over\n * @param fn Function to invoke on each item. If it returns _false_ loop ends.\n * @param options Options\n * @typeParam V Type of iterable\n */\nexport const forEach = async function <T>(\n  iterator: AsyncIterable<T> | T[],\n  fn: (v?: T) => Promise<boolean> | Promise<void> | boolean | void,\n  options: Partial<ForEachOptions> = {}\n) {\n  const interval = options.interval;\n  if (Array.isArray(iterator)) {\n    // Handle array\n    for (const x of iterator) {\n      const r = await fn(x);\n      if (typeof r === `boolean` && !r) break;\n      if (interval) await sleep(interval);\n    }\n  } else {\n    // Handle an async iterator\n    for await (const x of iterator) {\n      const r = await fn(x);\n      if (typeof r === `boolean` && !r) break;\n      if (interval) await sleep(interval);\n    }\n  }\n};\n\n// export async function forEach<V>(it: AsyncIterable<V>, f: (v: V) => void | boolean | Promise<boolean | void>) {\n//   // https://surma.github.io/underdash/\n//   for await (const v of it) {\n//     const result = await f(v);\n//     if (typeof result === `boolean` && !result) break;\n//   }\n// }\n\n/**\n * Returns last value from an iterable, or _undefined_\n * if no values are generated\n * @param it\n */\nexport async function last<V>(it: AsyncIterable<V>, opts: Partial<{ abort: AbortSignal }> = {}): Promise<V | undefined> {\n  const abort = opts.abort;\n  let returnValue: V | undefined;\n\n  for await (const value of it) {\n    if (abort?.aborted) return undefined;\n    returnValue = value;\n  }\n  return returnValue;\n}\n\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n * \n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\n\nexport async function* map<V, X>(it: AsyncIterable<V>, f: (v: V) => X) {\n  // https://surma.github.io/underdash/\n\n  for await (const v of it) {\n    yield f(v);\n  }\n}\n\n\nexport async function* max<V>(it: AsyncIterable<V>, gt = ((a: V, b: V) => a > b)) {\n  let max: V | undefined;\n  for await (const v of it) {\n    if (max === undefined) {\n      max = v;\n      yield (max);\n      continue;\n    }\n    // If V is bigger than max, we have a new max\n    if (gt(v, max)) {\n      max = v;\n      yield v;\n    }\n  }\n}\n\n/**\n * Returns the minimum seen of an iterable as it changes.\n * Streaming result: works with endless iterables.\n * \n * Note that `gt` function returns true if A is _greater_ than B, even\n * though we're looking for the minimum.\n * \n * ```js\n * // Rank objects based on 'v' value\n * const rank = (a,b) => a.v > b.v;\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns\n */\nexport async function* min<V>(it: AsyncIterable<V>, gt = (a: V, b: V) => a > b) {\n  let min: V | undefined;\n  for await (const v of it) {\n    if (min === undefined) {\n      min = v;\n      yield min;\n      continue;\n    }\n    // If min is bigger than V, V is the new min\n    if (gt(min, v)) {\n      min = v;\n      yield v;\n    }\n  }\n  return min;\n}\n\nexport async function reduce<V>(\n  it: AsyncIterable<V>,\n  f: (accumulator: V, current: V) => V,\n  start: V\n) {\n  // https://surma.github.io/underdash/\n\n  for await (const v of it) start = f(start, v);\n  return start;\n}\n\n/**\n * Calls `callback` whenever the async generator produces a value.\n * \n * When using `asCallback`, call it with `await` to let generator \n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n * \n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input \n * @param callback \n */\nexport async function asCallback<V>(input: AsyncIterable<V>, callback: (v: V) => unknown, onDone?: () => void) {\n  for await (const value of input) {\n    callback(value);\n  }\n  if (onDone) onDone();\n}\n\nexport async function* slice<V>(\n  it: AsyncIterable<V>,\n  start = 0,\n  end = Number.POSITIVE_INFINITY\n) {\n  console.log(`Async slice start: ${ start }`);\n\n  // https://surma.github.io/underdash/\n  const iit = it[ Symbol.asyncIterator ]();\n  if (end < start) throw new Error(`Param 'end' should be more than 'start'`);\n\n  for (; start > 0; start--, end--) await iit.next();\n\n  for await (const v of it) {\n    if (end-- > 0) {\n      yield v;\n    } else {\n      break;\n    }\n  }\n}\n\n/**\n * Enumerates over an input iterable, with a delay between items.\n * @param it \n * @param delay \n */\nexport async function* withDelay<V>(it: Iterable<V>, delay: Interval) {\n  for (const v of it) {\n    await sleep(delay);\n    yield v;\n  }\n}\n\n/***\n * Returns the next IteratorResult,\n * throwing an error if it does not happen\n * within `interval` (default: 1s)\n */\nexport async function nextWithTimeout<V>(it: AsyncIterableIterator<V> | IterableIterator<V>, options: SleepOpts<any>) {\n  const ms = intervalToMs(options, 1000);\n\n  const value: IteratorResult<V> | undefined = await Promise.race([\n    (async () => {\n      await sleep({ millis: ms, signal: options.signal });\n\n      return undefined;\n    })(),\n    (async () => {\n      return await it.next();\n    })()\n  ]);\n  if (value === undefined) throw new Error(`Timeout`);\n  return value;\n}\n\nexport async function some<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (await f(v)) return true;\n  }\n  return false;\n}\n\n// export async function* takeWhile<V>(\n//   it: AsyncIterable<V>,\n//   f: (v: V) => boolean\n// ) {\n//   // https://surma.github.io/underdash/\n\n//   for await (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\n\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide limits via the options.\n * ```js\n * // Return maximum five items\n * const data = await toArray(iterable, { limit: 5 });\n * // Return results for a maximum of 5 seconds\n * const data = await toArray(iterable, { elapsed: 5000 });\n * ```\n * Note that limits are ORed, `toArray` will finish if either of them is true.\n * \n * @param it Asynchronous iterable\n * @param options Options when converting to array\n * @returns\n */\nexport async function toArray<V>(it: AsyncIterable<V>, options: Partial<ToArrayOptions> = {}): Promise<V[]> {\n  // https://2ality.com/2016/10/asynchronous-iteration.html\n  const result: V[] = [];\n  const iterator = it[ Symbol.asyncIterator ]();\n  const started = Date.now();\n  const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n  const whileFunction = options.while;\n  const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n\n  while (result.length < maxItems && (Date.now() - started < maxElapsed)) {\n    if (whileFunction) {\n      if (!whileFunction(result.length)) break;\n    }\n    const r = await iterator.next();\n    if (r.done) break;\n    //eslint-disable-next-line functional/immutable-data\n    result.push(r.value);\n  }\n  return result;\n}\n\n\nexport async function* unique<V>(\n  iterable: AsyncIterable<V> | AsyncIterable<V>[]\n) {\n  const buffer: any[] = [];\n  const itera: AsyncIterable<V>[] = Array.isArray(iterable) ? iterable : [ iterable ];\n  for await (const it of itera) {\n    for await (const v of it) {\n      if (buffer.includes(v)) continue;\n      buffer.push(v);\n      yield v;\n    }\n  }\n}\n\nexport async function* uniqueByValue<T>(input: AsyncIterable<T>, toString: (value: T) => string = toStringDefault, seen: Set<string> = new Set<string>()): AsyncGenerator<T> {\n  for await (const v of input) {\n    const key = toString(v);\n    if (seen.has(key)) continue;\n    seen.add(key);\n    yield v;\n  }\n}\n\n/**\n * Returns unique items from iterables, given a particular key function\n * ```js\n * unique([{i:0,v:2},{i:1,v:3},{i:2,v:2}], e => e.v);\n * Yields:  [{i:0,v:2},{i:1,v:3}]\n * @param it\n * @param f\n */\n\n// export async function* unique<V>(\n//   it: AsyncIterable<V>,\n//   f: (id: V) => V = (id) => id\n// ) {\n//   // https://surma.github.io/underdash/\n//   const buffer: Array<V> = [];\n\n//   for await (const v of it) {\n//     const fv = f(v);\n//     if (buffer.includes(fv)) continue;\n//     buffer.push(fv);\n//     yield v;\n//   }\n// }\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport async function* zip<V>(...its: readonly AsyncIterable<V>[]) {\n  // https://surma.github.io/underdash/\n  const iits = its.map((it) => it[ Symbol.asyncIterator ]());\n\n  while (true) {\n    const vs = await Promise.all(iits.map((it) => it.next()));\n    if (vs.some((v) => v.done)) return;\n    yield vs.map((v) => v.value as V);\n  }\n}\n","import type { ArrayKeys, EitherKey, ObjectKeys } from '../types.js';\n\n/**\n * Adds an array o [k,v] to the map, returning a new instance\n * @param map Initial data\n * @param data Data to add\n * @returns New map with data added\n */\nconst addArray = <K, V>(\n  map: ReadonlyMap<K, V>,\n  data: ArrayKeys<K, V>\n): ReadonlyMap<K, V> => {\n  const x = new Map<K, V>(map.entries());\n  for (const d of data) {\n    if (d[ 0 ] === undefined) throw new Error(`key cannot be undefined`);\n    if (d[ 1 ] === undefined) throw new Error(`value cannot be undefined`);\n    x.set(d[ 0 ], d[ 1 ]);\n  }\n  return x;\n};\n\n/**\n * Adds objects to the map, returning a new instance\n * @param map Initial data\n * @param data Data to add\n * @returns A new map with data added\n */\nconst addObjects = <K, V>(\n  map: ReadonlyMap<K, V>,\n  data: ObjectKeys<K, V>\n): ReadonlyMap<K, V> => {\n  const x = new Map<K, V>(map.entries());\n  for (const d of data) {\n    if (d.key === undefined) throw new Error(`key cannot be undefined`);\n    if (d.value === undefined) throw new Error(`value cannot be undefined`);\n\n    x.set(d.key, d.value);\n  }\n  return x;\n};\n\n/**\n * Returns true if map contains key\n *\n * @example\n * ```js\n * if (has(map, `London`)) ...\n * ```\n * @param map Map to search\n * @param key Key to find\n * @returns True if map contains key\n */\nexport const has = <K, V>(map: ReadonlyMap<K, V>, key: K): boolean =>\n  map.has(key);\n\n/**\n * Adds data to a map, returning the new map.\n *\n * Can add items in the form of [key,value] or {key, value}.\n * @example These all produce the same result\n * ```js\n * map.set(`hello`, `samantha`);\n * map.add([`hello`, `samantha`]);\n * map.add({key: `hello`, value: `samantha`})\n * ```\n * @param map Initial data\n * @param data One or more data to add in the form of [key,value] or {key, value}\n * @returns New map with data added\n */\nexport const add = <K, V>(\n  map: ReadonlyMap<K, V>,\n  ...data: EitherKey<K, V>\n): ReadonlyMap<K, V> => {\n  if (map === undefined) throw new Error(`map parameter is undefined`);\n  if (data === undefined) throw new Error(`data parameter i.s undefined`);\n  if (data.length === 0) return map;\n\n  const firstRecord = data[ 0 ];\n  const isObject =\n    typeof (firstRecord as { readonly key: K; readonly value: V }).key !==\n    `undefined` &&\n    typeof (firstRecord as { readonly key: K; readonly value: V }).value !==\n    `undefined`; //(typeof (data[0] as {readonly key:K}).key !== undefined && typeof (data[0] as {readonly value:V}).value !== undefined);\n  return isObject\n    ? addObjects(map, data as ObjectKeys<K, V>)\n    : addArray(map, data as ArrayKeys<K, V>);\n};\n\n/**\n * Sets data in a copy of the initial map\n * @param map Initial map\n * @param key Key\n * @param value Value to  set\n * @returns New map with data set\n */\nexport const set = <K, V>(map: ReadonlyMap<K, V>, key: K, value: V) => {\n  const x = new Map<K, V>(map.entries());\n  x.set(key, value);\n  return x;\n};\n\n/**\n * Delete a key from the map, returning a new map\n * @param map Initial data\n * @param key\n * @returns New map with data deleted\n */\nexport const del = <K, V>(\n  map: ReadonlyMap<K, V>,\n  key: K\n): ReadonlyMap<K, V> => {\n  const x = new Map<K, V>(map.entries());\n  x.delete(key);\n  return x;\n};\n","import { type EitherKey } from '../types.js';\nimport type { IMapBase } from './imap-base.js';\nimport { add, del, set } from './map-immutable-fns.js';\n\n/**\n * An immutable map. Rather than changing the map, functions like `add` and `delete`\n * return a new map reference which must be captured.\n *\n * Immutable data is useful because as it gets passed around your code, it never\n * changes from underneath you. You have what you have.\n *\n * @example\n * ```js\n * let m = map(); // Create\n * let m2 = m.set(`hello`, `samantha`);\n * // m is still empty, only m2 contains a value.\n * ```\n *\n * @typeParam K - Type of map keys. Typically `string`\n * @typeParam V - Type of stored values\n */\n//eslint-disable-next-line @typescript-eslint/consistent-type-definitions\nexport interface IMapImmutable<K, V> extends IMapBase<K, V> {\n  /**\n   * Adds one or more items, returning the changed map.\n   *\n   * Can add items in the form of `[key,value]` or `{key, value}`.\n   * @example These all produce the same result\n   * ```js\n   * map.set(`hello`, `samantha`);\n   * map.add([`hello`, `samantha`]);\n   * map.add({key: `hello`, value: `samantha`})\n   * ```\n   * @param itemsToAdd\n   */\n  add(...itemsToAdd: EitherKey<K, V>): IMapImmutable<K, V>;\n  /**\n   * Deletes an item by key, returning the changed map\n   * @param key\n   */\n  delete(key: K): IMapImmutable<K, V>;\n  /**\n   * Returns an empty map\n   */\n  clear(): IMapImmutable<K, V>;\n\n\n  /**\n   * Sets `key` to be `value`, overwriting anything existing.\n   * Returns a new map with added key.\n   * @param key\n   * @param value\n   */\n  set(key: K, value: V): IMapImmutable<K, V>;\n\n}\n\n/**\n * Returns an {@link IMapImmutable}.\n * Use {@link Maps.mutable} as a mutable alternatve.\n *\n * @example Basic usage\n * ```js\n * // Creating\n * let m = map();\n * // Add\n * m = m.set(\"name\", \"sally\");\n * // Recall\n * m.get(\"name\");\n * ```\n *\n * @example Enumerating\n * ```js\n * for (const [key, value] of map.entries()) {\n *  console.log(`${key} = ${value}`);\n * }\n * ```\n *\n * @example Overview\n * ```js\n * // Create\n * let m = map();\n * // Add as array or key & value pair\n * m = m.add([\"name\" , \"sally\"]);\n * m = m.add({ key: \"name\", value: \"sally\" });\n * // Add using the more typical set\n * m = m.set(\"name\", \"sally\");\n * m.get(\"name\");   // \"sally\";\n * m.has(\"age\");    // false\n * m.has(\"name\");   // true\n * m.isEmpty;       // false\n * m = m.delete(\"name\");\n * m.entries();     // Iterator of key value pairs\n * ```\n *\n * Since it is immutable, `add()`, `delete()` and `clear()` return a new version with change.\n *\n * @param dataOrMap Optional initial data in the form of an array of `{ key: value }` or `[ key, value ]`\n */\nexport const immutable = <K, V>(\n  dataOrMap?: ReadonlyMap<K, V> | EitherKey<K, V>\n): IMapImmutable<K, V> => {\n  if (dataOrMap === undefined) return immutable([]);\n  if (Array.isArray(dataOrMap)) return immutable<K, V>(add(new Map(), ...dataOrMap));\n\n  const data = dataOrMap as ReadonlyMap<K, V>;\n  return {\n    add: (...itemsToAdd: EitherKey<K, V>) => {\n      const s = add(data, ...itemsToAdd);\n      return immutable(s);\n    },\n    set: (key: K, value: V) => {\n      const s = set(data, key, value);\n      return immutable(s);\n    },\n    get: (key: K) => data.get(key),\n    delete: (key: K) => immutable(del(data, key)),\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    clear: () => immutable(),\n    has: (key: K) => data.has(key),\n    entries: () => data.entries(),\n    values: () => data.values(),\n    isEmpty: () => data.size === 0,\n  };\n};\n","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { StackMutable } from \"../stack/StackMutable.js\"\nimport { QueueMutable } from \"../queue/queue-mutable.js\"\nimport { PriorityMutable } from \"../queue/priority-mutable.js\"\nimport { immutable as immutableMap, type IMapImmutable } from \"../map/map.js\"\nimport { NumberMap } from \"../map/number-map.js\"\nimport * as Sync from \"@ixfx/iterables/sync\"\nimport { Table } from \"../table.js\"\nimport { throwStringTest } from \"@ixfx/guards\"\n\nexport type DistanceCompute = (graph: DirectedGraph, edge: Edge) => number;\n\n/**\n * Vertex. These are the _nodes_ of the graph. Immutable.\n * \n * They keep track of all of their outgoing edges, and\n * a unique id.\n * \n * Ids are used for accessing/updating vertices as well as in the\n * {@link Edge} type. They must be unique.\n */\nexport type Vertex = Readonly<{\n  out: readonly Edge[]\n  id: string\n}>\n\n/**\n * Edge. Immutable.\n * \n * Only encodes the destination vertex. The from\n * is known since edges are stored on the from vertex.\n */\nexport type Edge = Readonly<{\n  /**\n   * Vertex id edge connects to (ie. destination)\n   */\n  id: string,\n  /**\n   * Optional weight of edge\n   */\n  weight?: number\n}>\n\n/**\n * Create a vertex with given id\n * @param id \n * @returns \n */\nexport const createVertex = (id: string): Vertex => {\n  return {\n    id,\n    out: []\n  }\n}\n\n/**\n * Options for connecting vertices\n */\nexport type ConnectOptions = Readonly<{\n  /**\n   * From, or source of connection\n   */\n  from: string\n  /**\n   * To, or destination of connection. Can be multiple vertices for quick use\n   */\n  to: string | string[]\n  /**\n   * If true, edges in opposite direction are made as well\n   */\n  bidi?: boolean\n  /**\n   * Weight for this connection (optional)\n   */\n  weight?: number\n}>\n\n/**\n * Directed graph. Immutable.\n * \n * Consists of {@link Vertex|vertices}, which all have zero or more outgoing {@link Edge|Edges}.\n */\nexport type DirectedGraph = Readonly<{\n  vertices: IMapImmutable<string, Vertex>\n}>\n\n/**\n * Returns _true_ if graph contains `key`.\n * \n * ```js\n * // Same as\n * g.vertices.has(key)\n * ```\n * @param graph\n * @param key \n * @returns \n */\nexport function hasKey(graph: DirectedGraph, key: string): boolean {\n  throwGraphTest(graph);\n  return graph.vertices.has(key);\n}\n\n/**\n * Returns {@link Vertex} under `key`, or _undefined_\n * if not found.\n * \n * ```js\n * // Same as\n * g.vertices.get(key)\n * ```\n * @param graph \n * @param key \n * @returns \n */\nexport function get(graph: DirectedGraph, key: string): Vertex | undefined {\n  throwGraphTest(graph);\n  throwStringTest(key, `non-empty`, `key`);\n  return graph.vertices.get(key);\n\n}\n\n// export function fromAdjacenyMatrix(m: Array<Array<boolean>>): DirectedGraph {\n//   let g = graph();\n//   for (const row of m) {\n//     connect(g, { from, to })\n//   }\n//   return g;\n// }\n\n/**\n * Returns the graph connections as an adjacency matrix\n * @param graph \n * @returns \n */\nexport function toAdjacencyMatrix(graph: DirectedGraph): Table<boolean> {\n  throwGraphTest(graph);\n\n  const v = [ ...graph.vertices.values() ];\n  //const m: Array<Array<boolean>> = [];\n  const table = new Table<boolean>();\n  table.labelColumns(...v.map(vv => vv.id));\n  table.labelRows(...v.map(vv => vv.id));\n\n  // const row: Array<boolean> = [];\n  // for (let index = 0; index < v.length; index++) {\n  //   row[ index ] = false;\n  // }\n\n  // eslint-disable-next-line unicorn/prevent-abbreviations\n  for (let i = 0; i < v.length; i++) {\n    //m[ i ] = [ ...row ];\n    table.setRow(i, v.length, false);\n    const ii = v[ i ];\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (const [ j, jj ] of v.entries()) {\n      if (ii.out.some(o => o.id === jj.id)) {\n        //m[ i ][ j ] = true;\n        table.set(i, j, true);\n      }\n    }\n  }\n  return table;\n}\n\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph \n * @returns \n */\nexport const dumpGraph = (graph: DirectedGraph | Iterable<Vertex>): string => {\n  const lines = debugGraphToArray(graph);\n  return lines.join(`\\n`);\n}\n\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph \n * @returns \n */\nconst debugGraphToArray = (graph: DirectedGraph | Iterable<Vertex>): string[] => {\n\n  const r: string[] = [];\n  const vertices = (`vertices` in graph) ? graph.vertices.values() : graph;\n\n  for (const v of vertices) {\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const str = debugDumpVertex(v);\n    r.push(...str.map(line => ` ${ line }`));\n  }\n  return r;\n}\n\n\nexport const distance = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Iterate over all the edges in the graph\n * @param graph \n */\nexport function* edges(graph: DirectedGraph) {\n  throwGraphTest(graph);\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    for (const edge of vertex.out) {\n      yield edge;\n    }\n  }\n}\n\n/**\n * Iterate over all the vertices of the graph\n * @param graph \n */\nexport function* vertices(graph: DirectedGraph) {\n  throwGraphTest(graph);\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    yield vertex;\n  }\n}\n\nfunction testGraph(g: DirectedGraph, parameterName = `graph`) {\n  if (g === undefined) return [ false, `Param '${ parameterName }' is undefined. Expected Graph` ];\n  if (g === null) return [ false, `Param '${ parameterName }' is null. Expected Graph` ];\n  if (typeof g === `object`) {\n    if (!(`vertices` in g)) return [ false, `Param '${ parameterName }.vertices' does not exist. Is it a Graph type?` ]\n  } else {\n    return [ false, `Param '${ parameterName } is type '${ typeof g }'. Expected an object Graph` ];\n  }\n  return [ true ];\n}\n\nfunction throwGraphTest(g: DirectedGraph, parameterName = `graph`) {\n  const r = testGraph(g, parameterName);\n  if (r[ 0 ]) return;\n  throw new Error(r[ 1 ] as string)\n}\n/**\n * Iterate over all the vertices connected to `context` vertex\n * @param graph Graph\n * @param context id or Vertex.\n * @returns \n */\nexport function* adjacentVertices(graph: DirectedGraph, context: Vertex | string | undefined) {\n  throwGraphTest(graph);\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of vertex.out) {\n    const edgeV = graph.vertices.get(edge.id);\n    if (edgeV === undefined) throw new Error(`Could not find vertex: ${ edge.id }`);\n    yield edgeV;\n  }\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to\n * the supplied id or vertex.\n * \n * If `vertex` is undefined, _false_ is returned.\n * @param vertex From vertex\n * @param outIdOrVertex To vertex\n * @returns \n */\nexport const vertexHasOut = (vertex: Vertex, outIdOrVertex: string | Vertex): boolean => {\n  if (vertex === undefined) return false;\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return vertex.out.some(edge => edge.id === outId);\n}\n\n/**\n * Returns _true_ if `vertex` has no outgoing connections\n * @param graph \n * @param vertex \n * @returns \n */\nexport const hasNoOuts = (graph: DirectedGraph, vertex: string | Vertex): boolean => {\n  throwGraphTest(graph);\n\n  const context = typeof vertex === `string` ? graph.vertices.get(vertex) : vertex;\n  if (context === undefined) return false;\n  return context.out.length === 0;\n}\n\n/**\n * Returns _true_ if `vertex` only has the given list of vertices.\n * Returns _false_ early if the length of the list does not match up with `vertex.out`\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOnlyOuts = (graph: DirectedGraph, vertex: string | Vertex, ...outIdOrVertex: (string | Vertex)[]): boolean => {\n  throwGraphTest(graph);\n\n  const context = resolveVertex(graph, vertex);\n  const outs = outIdOrVertex.map(o => resolveVertex(graph, o));\n\n  if (outs.length !== context.out.length) {\n    //console.log(`length mismatch. context: ${ JSON.stringify(context.out) } out ${ JSON.stringify(outIdOrVertex) }`);\n    return false;\n  }\n  for (const out of outs) {\n    //console.log(`Testing ${ context.id } -> ${ out.id }`);\n    if (!hasOut(graph, context, out)) {\n      //console.log(`  no`);\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to the given vertex.\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOut = (graph: DirectedGraph, vertex: string | Vertex, outIdOrVertex: string | Vertex): boolean => {\n  throwGraphTest(graph);\n\n  const context = resolveVertex(graph, vertex);\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return context.out.some(edge => edge.id === outId);\n}\n\n// export const hasIn = (graph: Graph, contextIdOrVertex: string | Vertex, id: string): boolean => {\n//   const context = typeof contextIdOrVertex === `string` ? graph.vertices.get(contextIdOrVertex) : contextIdOrVertex;\n\n//   if (context === undefined) return false;\n//   if (context.in === undefined) return false;\n//   return context.in.some(edge => edge.id === id);\n// }\n\n/**\n * Gets a vertex by id, creating it if it does not exist.\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrCreate = (graph: DirectedGraph, id: string): Readonly<{ graph: DirectedGraph, vertex: Vertex }> => {\n  throwGraphTest(graph);\n\n  const v = graph.vertices.get(id);\n  if (v !== undefined) return { graph, vertex: v };\n\n  const vv = createVertex(id);\n  const gg = updateGraphVertex(graph, vv);\n  return { graph: gg, vertex: vv };\n}\n\n/**\n * Gets a vertex by id, throwing an error if it does not exist\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrFail = (graph: DirectedGraph, id: string): Vertex => {\n  throwGraphTest(graph);\n\n  const v = graph.vertices.get(id);\n  if (v === undefined) throw new Error(`Vertex '${ id }' not found in graph`);\n  return v;\n}\n\n/**\n * Updates a vertex by returning a mutated graph\n * @param graph Graph\n * @param vertex Newly changed vertex\n * @returns \n */\nexport const updateGraphVertex = (graph: DirectedGraph, vertex: Vertex): DirectedGraph => {\n  throwGraphTest(graph);\n\n  const gr = {\n    ...graph,\n    vertices: graph.vertices.set(vertex.id, vertex)\n  }\n  return gr;\n}\n\n/**\n * Default distance computer. Uses `weight` property of edge, or `1` if not found.\n * @param graph \n * @param edge \n * @returns \n */\nexport const distanceDefault = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Returns a mutation of `graph`, with a given edge removed.\n * \n * If edge was not there, original graph is returned.\n * @param graph \n * @param from \n * @param to \n * @returns \n */\nexport function disconnect(graph: DirectedGraph, from: string | Vertex, to: string | Vertex): DirectedGraph {\n  throwGraphTest(graph);\n\n  const fromV = resolveVertex(graph, from);\n  const toV = resolveVertex(graph, to);\n\n  return hasOut(graph, fromV, toV) ? updateGraphVertex(graph, {\n    ...fromV,\n    out: fromV.out.filter(t => t.id !== toV.id)\n  }) : graph;\n}\n\n/**\n * Make a connection between two vertices with a given weight.\n * It returns the new graph as wll as the created edge.\n * @param graph \n * @param from \n * @param to \n * @param weight \n * @returns \n */\nexport function connectTo(graph: DirectedGraph, from: string, to: string, weight?: number): { graph: DirectedGraph, edge: Edge } {\n  throwGraphTest(graph);\n\n  const fromResult = getOrCreate(graph, from);\n  graph = fromResult.graph;\n  const toResult = getOrCreate(graph, to);\n  graph = toResult.graph;\n\n  const edge: Edge = {\n    id: to,\n    weight\n  }\n\n  if (!hasOut(graph, fromResult.vertex, toResult.vertex)) {\n    graph = updateGraphVertex(graph, {\n      ...fromResult.vertex,\n      // Add new edge to list of edges for this node\n      out: [ ...fromResult.vertex.out, edge ]\n    });\n  }\n  return { graph, edge }\n}\n\n/**\n * Connect from -> to. Same as {@link connectWithEdges}, but this version just returns the graph.\n * \n * By default unidirectional, meaning a connection is made only from->to. Use `bidi` option to set a bidirection connection, adding also to->from.\n * \n * Returns a result of `{ graph, edges }`, where `graph` is the new {@link DirectedGraph} and `edges`\n * is an array of {@link Edge Edges}. One for unidirectional, or two for bidirectional.\n * @param graph \n * @param options \n * @returns \n */\nexport function connect(graph: DirectedGraph, options: ConnectOptions): DirectedGraph {\n  if (typeof graph !== `object`) throw new TypeError(`Param 'graph' is expected to be a DirectedGraph object. Got: ${ typeof graph }`);\n  if (typeof options !== `object`) throw new TypeError(`Param 'options' is expected to be ConnectOptions object. Got: ${ typeof options }`);\n\n  const result = connectWithEdges(graph, options);\n  return result.graph;\n}\n\n/**\n * Connect from -> to. Same as {@link connect} except you get back the edges as well. \n * \n * By default unidirectional, meaning a connection is made only from->to. Use `bidi` option to set a bidirection connection, adding also to->from.\n * \n * Returns a result of `{ graph, edges }`, where `graph` is the new {@link DirectedGraph} and `edges`\n * is an array of {@link Edge Edges}. One for unidirectional, or two for bidirectional.\n * @param graph \n * @param options \n * @returns \n */\nexport function connectWithEdges(graph: DirectedGraph, options: ConnectOptions): { graph: DirectedGraph, edges: Edge[] } {\n  throwGraphTest(graph);\n\n  const { to, weight, from } = options;\n  const bidi = options.bidi ?? false;\n  const toList = Array.isArray(to) ? to : [ to ];\n\n  const edges: Edge[] = []\n  // Connect from -> to\n  for (const toSingle of toList) {\n    const result = connectTo(graph, from, toSingle, weight);\n    graph = result.graph;\n    edges.push(result.edge);\n  }\n\n  if (!bidi) return { graph, edges };\n\n  // Bidirectional connection\n  // Connect to -> from\n  for (const toSingle of toList) {\n    const result = connectTo(graph, toSingle, from, weight);\n    graph = result.graph;\n    edges.push(result.edge);\n  }\n  return { graph, edges };\n}\n\n/**\n * Returns an array of debug-representations for the given vertex.\n * @param v \n * @returns \n */\nconst debugDumpVertex = (v: Vertex): string[] => {\n  const r = [\n    v.id\n  ]\n  const stringForEdge = (edge: Edge) => edge.weight === undefined ? edge.id : `${ edge.id } (${ edge.weight })`\n\n  // for (const edge of v.in) {\n  //   r.push(` <- ${ stringForEdge(edge) }`);\n  // }\n  for (const edge of v.out) {\n    r.push(` -> ${ stringForEdge(edge) }`);\n  }\n  if (v.out.length === 0) r[ 0 ] += ` (terminal)`;\n\n  return r;\n}\n\n/**\n * Returns _true_ if a->b or b->a\n * @param graph \n * @param a \n * @param b \n * @returns \n */\nexport function areAdjacent(graph: DirectedGraph, a: Vertex, b: Vertex) {\n  throwGraphTest(graph);\n\n  if (hasOut(graph, a, b.id)) return true;\n  if (hasOut(graph, b, a.id)) return true;\n}\n\n/**\n * Resolves the id or vertex into a Vertex.\n * throws an error if vertex is not found\n * @param graph \n * @param idOrVertex \n * @returns \n */\nfunction resolveVertex(graph: DirectedGraph, idOrVertex: string | Vertex): Vertex {\n  throwGraphTest(graph);\n\n  if (idOrVertex === undefined) throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);\n\n  const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n  if (v === undefined) throw new Error(`Id not found ${ idOrVertex as string }`);\n  return v;\n}\n\n/**\n * Iterates over vertices from a starting vertex in an bread-first-search\n * @param graph \n * @param startIdOrVertex \n * @param targetIdOrVertex \n * @returns \n */\nexport function* bfs(graph: DirectedGraph, startIdOrVertex: string | Vertex, targetIdOrVertex?: string | Vertex) {\n  throwGraphTest(graph);\n\n  const start = resolveVertex(graph, startIdOrVertex);\n  const target = targetIdOrVertex === undefined ? undefined : resolveVertex(graph, targetIdOrVertex);\n\n  const queue = new QueueMutable<Vertex>();\n  const seen = new Set<string>();\n  queue.enqueue(start);\n  while (!queue.isEmpty) {\n    const v = queue.dequeue()!;\n    yield v;\n    if (target !== undefined && target === v) return;\n    for (const edge of adjacentVertices(graph, v)) {\n      if (!seen.has(edge.id)) {\n        seen.add(edge.id);\n        queue.enqueue(resolveVertex(graph, edge.id));\n      }\n    }\n  }\n}\n\n/**\n * Iterates over vertices from a starting vertex in an depth-first-search\n * @param graph \n * @param startIdOrVertex \n */\nexport function* dfs(graph: DirectedGraph, startIdOrVertex: string | Vertex) {\n  throwGraphTest(graph);\n\n  const source = resolveVertex(graph, startIdOrVertex);\n\n  const s = new StackMutable<Vertex>();\n  const seen = new Set<string>();\n  s.push(source);\n  while (!s.isEmpty) {\n    const v = s.pop();\n    if (v === undefined) continue;\n    if (!seen.has(v.id)) {\n      seen.add(v.id);\n      yield v;\n      for (const edge of v.out) {\n        const destination = graph.vertices.get(edge.id);\n        if (destination) {\n          s.push(destination);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Compute shortest distance from the source vertex to the rest of the graph.\n * @param graph \n * @param sourceOrId \n * @returns \n */\nexport const pathDijkstra = (graph: DirectedGraph, sourceOrId: Vertex | string) => {\n  throwGraphTest(graph);\n\n  const source = typeof sourceOrId === `string` ? graph.vertices.get(sourceOrId) : sourceOrId;\n  if (source === undefined) throw new Error(`source vertex not found`);\n\n  const distances = new Map<string, number>();\n  const previous = new Map<string, Vertex | null>();\n\n  distances.set(source.id, 0);\n\n  const pq = new PriorityMutable<string>();\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const v of vertices) {\n    if (v.id !== source.id) {\n      distances.set(v.id, Number.MAX_SAFE_INTEGER);\n\n      previous.set(v.id, null);\n    }\n    pq.enqueueWithPriority(v.id, Number.MAX_SAFE_INTEGER);\n  }\n\n  while (!pq.isEmpty) {\n    const u = pq.dequeueMin();\n    if (u === undefined) throw new Error(`Bug. Queue unexpectedly empty`);\n    const vertexU = graph.vertices.get(u)!;\n    for (const neighbour of vertexU.out) {\n      //const vertexNeigbour = graph.vertices.get(neighbour.to)!;\n      const alt = distances.get(u)! + distance(graph, neighbour);\n      if (alt < distances.get(neighbour.id)!) {\n        distances.set(neighbour.id, alt);\n        previous.set(neighbour.id, vertexU);\n        pq.changePriority(neighbour.id, alt, true);\n      }\n    }\n  }\n\n  const pathTo = (id: string): Edge[] => {\n    const path: Edge[] = [];\n    while (true) {\n      if (id === source.id) break;\n      const v = previous.get(id);\n      if (v === undefined || v === null) throw new Error(`Id not present: ${ id }`);\n      path.push({ id, weight: distances.get(id) });\n      id = v.id;\n    }\n    return path;\n  }\n  return {\n    distances, previous, pathTo\n  }\n}\n\n/**\n * Clones the graph. Uses shallow clone, because it's all immutable\n * @param graph \n * @returns \n */\nexport const clone = (graph: DirectedGraph): DirectedGraph => {\n  throwGraphTest(graph);\n\n  const g: DirectedGraph = {\n    vertices: immutableMap<string, Vertex>([ ...graph.vertices.entries() ])\n  }\n  return g;\n}\n\n/**\n * Create a graph\n * ```js\n * let g = graph();\n * ```\n * \n * Can optionally provide initial connections:\n * ```js\n * let g = graph(\n *  { from: `a`, to: `b` },\n *  { from: `b`, to: `c` }\n * )\n * ```\n * @param initialConnections \n * @returns \n */\nexport const graph = (...initialConnections: ConnectOptions[]): DirectedGraph => {\n  let g: DirectedGraph = {\n    vertices: immutableMap()\n  }\n  for (const ic of initialConnections) {\n    g = connect(g, ic);\n  }\n  return g;\n}\n\n/**\n * Internal type for Tarjan algorithm\n */\ntype TarjanVertex = Vertex & {\n  lowlink: number\n  index: number\n  onStack: boolean\n}\n\n/**\n * Returns _true_ if the graph contains is acyclic - that is, it has no loops\n * @param graph \n */\nexport function isAcyclic(graph: DirectedGraph): boolean {\n  throwGraphTest(graph);\n\n  const cycles = getCycles(graph);\n  return cycles.length === 0;\n}\n\n/**\n * Topological sort using Kahn's algorithm.\n * Returns a new graph that is sorted\n * @param graph \n */\nexport function topologicalSort(graph: DirectedGraph): DirectedGraph {\n  throwGraphTest(graph);\n\n  const indegrees = new NumberMap(0);\n\n  // Increment indegrees for each edge leading to a vertex\n  for (const edge of edges(graph)) {\n    indegrees.add(edge.id, 1);\n  }\n\n  // Enqueue all vertices with an indegree of 0\n  const queue = new QueueMutable<Vertex>();\n  let vertexCount = 0;\n  for (const vertex of vertices(graph)) {\n    if (indegrees.get(vertex.id) === 0) {\n      queue.enqueue(vertex);\n    }\n    vertexCount++;\n  }\n\n  const topOrder: Vertex[] = [];\n  while (!queue.isEmpty) {\n    // Add to topological order\n    const u = queue.dequeue()!;\n    topOrder.push(u);\n\n    // Iterate through neighbours\n    for (const neighbour of u.out) {\n      const result = indegrees.subtract(neighbour.id, 1);\n      if (result === 0) {\n        queue.enqueue(graph.vertices.get(neighbour.id)!);\n      }\n    }\n  }\n\n  if (topOrder.length !== vertexCount) {\n    throw new Error(`Graph contains cycles`);\n  }\n  return graphFromVertices(topOrder);\n}\n\n/**\n * Create a graph from an iterable of vertices\n * @param vertices \n * @returns \n */\nexport function graphFromVertices(vertices: Iterable<Vertex>): DirectedGraph {\n\n  const keyValues = Sync.map(vertices, f => {\n    return [ f.id, f ] as [ string, Vertex ]\n  });\n  const m = immutableMap<string, Vertex>([ ...keyValues ]);\n  return {\n    vertices: m\n  }\n}\n\n/**\n * Get all the cycles ('strongly-connected-components') within the graph\n * [Read more](https://en.wikipedia.org/wiki/Strongly_connected_component)\n * @param graph \n * @returns \n */\nexport function getCycles(graph: DirectedGraph): Vertex[][] {\n  throwGraphTest(graph);\n\n  let index = 0;\n  const stack = new StackMutable<TarjanVertex>();\n  const vertices = new Map<string, TarjanVertex>();\n  const scc: Vertex[][] = [];\n\n  for (const v of graph.vertices.values()) {\n    vertices.set(v.id, {\n      ...v,\n      lowlink: Number.NaN,\n      index: Number.NaN,\n      onStack: false\n    });\n  }\n\n  const strongConnect = (vertex: TarjanVertex) => {\n    vertex.index = index;\n    vertex.lowlink = index;\n    index++;\n    stack.push(vertex);\n    vertex.onStack = true;\n\n    for (const edge of vertex.out) {\n      const edgeV = vertices.get(edge.id)!;\n      if (Number.isNaN(edgeV.index)) {\n        strongConnect(edgeV);\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      } else if (edgeV.onStack) {\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      }\n    }\n\n    if (vertex.lowlink === vertex.index) {\n      const stronglyConnected: Vertex[] = [];\n      let w: TarjanVertex | undefined;\n      while (vertex !== w) {\n        w = stack.pop()!;\n        w.onStack = false;\n        stronglyConnected.push({ id: w.id, out: w.out });\n\n      }\n      if (stronglyConnected.length > 1)\n        scc.push(stronglyConnected);\n    }\n  }\n\n  for (const v of vertices.values()) {\n    if (Number.isNaN(v.index)) {\n      strongConnect(v);\n    }\n  }\n  return scc;\n}\n\n/**\n * Returns a new graph which is transitively reduced.\n * That is, redundant edges are removed\n * @param graph \n * @returns \n */\nexport function transitiveReduction(graph: DirectedGraph) {\n  throwGraphTest(graph);\n\n  for (const u of vertices(graph)) {\n    for (const v of adjacentVertices(graph, u)) {\n      for (const v1 of dfs(graph, v)) {\n        if (v.id === v1.id) continue;\n        if (hasOut(graph, u, v1)) {\n          const g = disconnect(graph, u, v1);\n          return transitiveReduction(g);\n        }\n      }\n    }\n  }\n  return graph;\n}","export const getOrGenerateSync = (map, fn) => (key, args) => {\n    let value = map.get(key);\n    if (value !== undefined)\n        return value;\n    value = fn(key, args);\n    map.set(key, value);\n    return value;\n};\n","import { getOrGenerateSync } from \"./util.js\";\n/**\n * Returns a console logging function which prefixes messages. This is\n * useful for tracing messages from different components. Each prefix\n * is assigned a colour, further helping to distinguish messages.\n *\n * Use {@link logSet} to get a bundled set.\n *\n * ```\n * // Initialise once\n * const log = logger(`a`);\n * const error = logger(`a`, `error`);\n * const warn = logger(`a`, `warn);\n *\n * // And then use\n * log(`Hello`);    // console.log(`a Hello`);\n * error(`Uh-oh`);  // console.error(`a Uh-oh`);\n * warn(`Eek!`);    // console.warn(`a Eeek!`);\n * ```\n *\n * Provide the `colourKey` parameter to make log messages\n * be coloured the same, even though the prefix is different.\n * ```js\n * // Both loggers will use the same colour because they\n * // share the colour key `system`\n * const log = logger(`a`,`log`,`system`);\n * const log2 = logger(`b`, `log`, `system`);\n * ```\n * @param prefix\n * @param kind\n * @param colourKey Optional key to colour log lines by instead of prefix\n * @returns\n */\nexport const logger = (prefix, kind = `log`, colourKey) => (m) => {\n    if (m === undefined) {\n        m = `(undefined)`;\n    }\n    else if (typeof m === `object`) {\n        m = JSON.stringify(m);\n    }\n    const colour = colourKey ?? prefix;\n    switch (kind) {\n        case `log`: {\n            console.log(`%c${prefix} ${m}`, `color: ${logColours(colour)}`);\n            break;\n        }\n        case `warn`: {\n            console.warn(prefix, m);\n            break;\n        }\n        case `error`: {\n            console.error(prefix, m);\n            break;\n        }\n    }\n};\n/**\n* Returns a bundled collection of {@link logger}s\n*\n* ```js\n* const con = logSet(`a`);\n* con.log(`Hello`);  // console.log(`a Hello`);\n* con.warn(`Uh-oh`); // console.warn(`a Uh-oh`);\n* con.error(`Eek!`); // console.error(`a Eek!`);\n* ```\n*\n* By default each prefix is assigned a colour. To use\n* another logic, provide the `colourKey` parameter.\n*\n* ```js\n* // Both set of loggers will use same colour\n* const con = logSet(`a`, true, `system`);\n* const con2 = logSet(`b`, true, `system`);\n* ```\n* @param prefix Prefix for log messages\n* @param verbose True by default. If false, log() messages are a no-op\n* @param colourKey If specified, log messages will be coloured by this key instead of prefix (default)\n* @returns\n*/\nexport const logSet = (prefix, verbose = true, colourKey) => {\n    if (verbose) {\n        return {\n            log: logger(prefix, `log`, colourKey),\n            warn: logger(prefix, `warn`, colourKey),\n            error: logger(prefix, `error`, colourKey),\n        };\n    }\n    return {\n        log: (_) => {\n            /** no-op */\n        },\n        warn: logger(prefix, `warn`, colourKey),\n        error: logger(prefix, `error`, colourKey),\n    };\n};\n/**\n * Resolve a LogOption to a function\n * @param l\n * @returns\n */\nexport const resolveLogOption = (l, defaults = {}) => {\n    if (l === undefined || (typeof l === `boolean` && !l)) {\n        return (_) => {\n            /** no-op */\n        };\n    }\n    const defaultCat = defaults.category ?? ``;\n    const defaultKind = defaults.kind ?? undefined;\n    if (typeof l === `boolean`) {\n        return (messageOrString) => {\n            const m = typeof messageOrString === `string` ? { msg: messageOrString } : messageOrString;\n            const kind = m.kind ?? defaultKind;\n            const category = m.category ?? defaultCat;\n            let message = m.msg;\n            if (category)\n                message = `[${category}] ${message}`;\n            switch (kind) {\n                case `error`: {\n                    console.error(message);\n                    break;\n                }\n                case `warn`: {\n                    console.warn(message);\n                    break;\n                }\n                case `info`: {\n                    console.info(message);\n                    break;\n                }\n                default: {\n                    console.log(message);\n                }\n            }\n        };\n    }\n    return l;\n};\nlet logColourCount = 0;\nexport const logColours = getOrGenerateSync(new Map(), () => {\n    const hue = ++logColourCount * 137.508; // use golden angle approximation\n    return `hsl(${hue},50%,75%)`;\n});\n","export const fpsCounter = (autoDisplay = true, computeAfterFrames = 500) => {\n    let count = 0;\n    let lastFps = 0;\n    let countStart = performance.now();\n    return () => {\n        if (count++ >= computeAfterFrames) {\n            const elapsed = performance.now() - countStart;\n            countStart = performance.now();\n            count = 0;\n            lastFps = Math.floor((computeAfterFrames / elapsed) * 1000);\n            if (autoDisplay)\n                console.log(`fps: ${lastFps}`);\n        }\n        return lastFps;\n    };\n};\n","export * from './types.js';\nexport * from './logger.js';\nexport * from './fps-counter.js';\nexport const getErrorMessage = (ex) => {\n    if (typeof ex === `string`)\n        return ex;\n    if (ex instanceof Error) {\n        return ex.message;\n    }\n    return ex;\n};\n","/**\n * Apples `fn` to every key of `obj` which is numeric.\n * ```js\n * const o = {\n *  name: 'john',\n *  x: 10,\n *  y: 20\n * };\n * const o2 = applyToValues(o, (v) => v * 2);\n *\n * // Yields: { name: 'john', x: 20, y: 40 }\n * ```\n * @param object\n * @param apply\n * @returns\n */\nexport const applyToValues = (object, apply) => {\n    const o = { ...object };\n    for (const [key, value] of Object.entries(object)) {\n        if (typeof value === `number`) {\n            // Run number through function\n            //eslint-disable-next-line functional/immutable-data\n            o[key] = apply(value);\n        }\n        else {\n            // Copy value\n            //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-unsafe-assignment\n            o[key] = value;\n        }\n    }\n    return o;\n};\n","/**\n * Applies a function `fn` to the elements of an array, weighting them based on their relative position.\n *\n * ```js\n * // Six items\n * weight([1,1,1,1,1,1], Modulation.gaussian());\n *\n * // Yields:\n * // [0.02, 0.244, 0.85, 0.85, 0.244, 0.02]\n * ```\n *\n * `fn` is expected to map (0..1) => (0..1), such as an easing function. The input to the\n * `fn` is the relative position of an element. Thus the first element will be 0, the middle 0.5 and so on.\n * The output of `fn` is then multiplied by the original value.\n *\n * In the below example (which is also the default if `fn` is not specified), the relative position is\n * how values are weighted:\n *\n * ```js\n * weight([1,1,1,1,1,1], (relativePos) => relativePos);\n * // Yields:\n * // [0, 0.2, 0.4, 0.6, 0.8, 1]\n * ```\n *\n * Throws TypeError if `data` is not an array or for any element not a number.\n * @param data Array of numbers\n * @param fn Returns a weighting based on the given relative position. If unspecified, `(x) => x` is used.\n */\nexport const weight = (data, fn) => {\n    if (!Array.isArray(data))\n        throw new TypeError(`Param 'data' is expected to be an array. Got type: ${typeof data}`);\n    const weightingFunction = fn ?? ((x) => x);\n    return data.map((value, index) => {\n        if (typeof value !== `number`)\n            throw new TypeError(`Param 'data' contains non-number at index: '${index}'. Type: '${typeof value}' value: '${value}'`);\n        const relativePos = index / (data.length - 1);\n        const weightForPosition = weightingFunction(relativePos);\n        if (typeof weightForPosition !== `number`)\n            throw new TypeError(`Weighting function returned type '${typeof weightForPosition}' rather than number for input: '${relativePos}'`);\n        const finalResult = value * weightForPosition;\n        //console.log(`finalResult: ${ finalResult.toFixed(2) } rel: ${ relativePos.toFixed(2) } weightForPosition: ${ weightForPosition.toFixed(2) } input: ${ value } index: ${ index }`);\n        return finalResult;\n    });\n};\n/**\n * Returns an array of all valid numbers from `data`\n *\n * @param data\n * @returns\n */\nexport const validNumbers = (data) => data.filter((d) => typeof d === `number` && !Number.isNaN(d));\n/**\n * Returns the dot product of arbitrary-sized arrays. Assumed they are of the same length.\n * @param values\n * @returns\n */\nexport const dotProduct = (values) => {\n    let r = 0;\n    const length = values[0].length;\n    for (let index = 0; index < length; index++) {\n        let t = 0;\n        for (const [p, value] of values.entries()) {\n            if (p === 0)\n                t = value[index];\n            else {\n                t *= value[index];\n            }\n        }\n        r += t;\n    }\n    return r;\n};\n/**\n * Calculates the average of all numbers in an array.\n * Array items which aren't a valid number are ignored and do not factor into averaging.\n *\n * Use {@link minMaxAvg} if you want min, max and total as well.\n *\n * @example\n * ```js\n * import * as Numbers from 'https://unpkg.com/ixfx/dist/numbers.js';\n *\n * // Average of a list\n * const avg = Numbers.average([1, 1.4, 0.9, 0.1]);\n *\n * // Average of a variable\n * const data = [100,200];\n * Numbers.average(data);\n * ```\n *\n * @see {@link averageWeighted} To weight items based on position in array\n * @param data Data to average.\n * @returns Average of array\n */\nexport const average = (data) => {\n    // ✔ UNIT TESTED\n    if (data === undefined)\n        throw new Error(`data parameter is undefined`);\n    const valid = validNumbers(data);\n    const total = valid.reduce((accumulator, v) => accumulator + v, 0);\n    return total / valid.length;\n};\n/**\n * Returns the minimum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/Numbers.js';\n * Numbers.min([10, 20, 0]); // Yields 0\n * ```\n * @param data\n * @returns Minimum number\n */\nexport const min = (data) => Math.min(...validNumbers(data));\n/**\n * Returns the index of the largest value.\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/Numbers.js';\n * const v = [ 10, 40, 5 ];\n * Numbers.maxIndex(v); // Yields 1\n * ```\n * @param data Array of numbers\n * @returns Index of largest value\n */\nexport const maxIndex = (data) => data.reduce((bestIndex, value, index, array) => value > array[bestIndex] ? index : bestIndex, 0);\n/**\n * Returns the index of the smallest value.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/Numbers.js';\n * const v = [ 10, 40, 5 ];\n * Numbers.minIndex(v); // Yields 2\n * ```\n * @param data Array of numbers\n * @returns Index of smallest value\n */\nexport const minIndex = (...data) => data.reduce((bestIndex, value, index, array) => value < array[bestIndex] ? index : bestIndex, 0);\n/**\n * Returns the maximum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.max(100, 200, 50); // 200\n * ```\n * @param data List of numbers\n * @returns Maximum number\n */\nexport const max = (data) => Math.max(...validNumbers(data));\n/**\n * Returns the total of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.total([1, 2, 3]); // 6\n * ```\n * @param data Array of numbers\n * @returns Total\n */\nexport const total = (data) => data.reduce((previous, current) => {\n    if (typeof current !== `number`)\n        return previous;\n    if (Number.isNaN(current))\n        return previous;\n    if (!Number.isFinite(current))\n        return previous;\n    return previous + current;\n}, 0);\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.maxFast([ 10, 0, 4 ]); // 10\n * ```\n * @param data\n * @returns Maximum\n */\nexport const maxFast = (data) => {\n    let m = Number.MIN_SAFE_INTEGER;\n    for (const datum of data) {\n        m = Math.max(m, datum);\n    }\n    return m;\n};\n/**\n * Returns the total of `data` without pre-filtering for speed.\n *\n * For most uses, {@link total} should suffice.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.totalFast([ 10, 0, 4 ]); // 14\n * ```\n * @param data\n * @returns Maximum\n */\nexport const totalFast = (data) => {\n    let m = 0;\n    for (const datum of data) {\n        m += datum;\n    }\n    return m;\n};\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.minFast([ 10, 0, 100 ]); // 0\n * ```\n * @param data\n * @returns Maximum\n */\nexport const minFast = (data) => {\n    let m = Number.MIN_SAFE_INTEGER;\n    for (const datum of data) {\n        m = Math.min(m, datum);\n    }\n    return m;\n};\n","import { zip } from '@ixfx/arrays';\nimport { weight } from './numeric-arrays.js';\n/**\n * Computes an average of an array with a set of weights applied.\n *\n * Weights can be provided as an array, expected to be on 0..1 scale, with indexes\n * matched up to input data. Ie. data at index 2 will be weighed by index 2 in the weightings array.\n *\n * ```js\n * // All items weighted evenly\n * averageWeighted([1,2,3], [1,1,1]); // 2\n *\n * // First item has full weight, second half, third quarter\n * averageWeighted([1,2,3], [1, 0.5, 0.25]); // 1.57\n *\n * // With reversed weighting of [0.25,0.5,1] value is 2.42\n * ```\n *\n * A function can alternatively be provided to compute the weighting based on array index, via {@link weight}.\n *\n * ```js\n * averageWeighted[1,2,3], Random.gaussian()); // 2.0\n * ```\n *\n * This is the same as:\n *\n * ```js\n * const data = [1,2,3];\n * const w = weight(data, Random.gaussian());\n * const avg = averageWeighted(data, w); // 2.0\n * ```\n * @param data Data to average\n * @param weightings Array of weightings that match up to data array, or an easing function\n * @see {@link average} Compute averages without weighting.\n */\nexport const averageWeighted = (data, weightings) => {\n    if (typeof weightings === `function`)\n        weightings = weight(data, weightings);\n    const ww = zip(data, weightings);\n    const [totalV, totalW] = ww.reduce((accumulator, v) => [accumulator[0] + v[0] * v[1], accumulator[1] + v[1]], [0, 0]);\n    return totalV / totalW;\n};\n","/**\n * Clamps a value between min and max (both inclusive)\n * Defaults to a 0-1 range, useful for percentages.\n *\n * @example Usage\n * ```js\n * // 0.5 - just fine, within default of 0 to 1\n * clamp(0.5);\n * // 1 - above default max of 1\n * clamp(1.5);\n * // 0 - below range\n * clamp(-50, 0, 100);\n * // 50 - within range\n * clamp(50, 0, 50);\n * ```\n *\n * For clamping integer ranges, consider {@link clampIndex }\n * For clamping `{ x, y }` points, consider {@link Geometry.Points.clamp | Geometry.Points.clamp}.\n * For clamping bipolar values: {@link Bipolar.clamp}\n * @param value Value to clamp\n * @param min value (inclusive)\n * @param max value (inclusive)\n * @returns Clamped value\n */\nexport const clamp = (value, min = 0, max = 1) => {\n    // ✔ UNIT TESTED\n    if (Number.isNaN(value))\n        throw new Error(`Param 'value' is NaN`);\n    if (Number.isNaN(min))\n        throw new Error(`Param 'min' is NaN`);\n    if (Number.isNaN(max))\n        throw new Error(`Param 'max' is NaN`);\n    if (value < min)\n        return min;\n    if (value > max)\n        return max;\n    return value;\n};\n/**\n * Returns a function that clamps values.\n *\n * ```js\n * const c = clamper(0,100);\n * c(50);   // 50\n * c(101); // 100\n * c(-5);  // 0\n * ```\n * @param min Minimum value. Default: 0\n * @param max Maximum value. Default: 1\n */\nexport const clamper = (min = 0, max = 1) => {\n    if (Number.isNaN(min))\n        throw new Error(`Param 'min' is NaN`);\n    if (Number.isNaN(max))\n        throw new Error(`Param 'max' is NaN`);\n    return (v) => {\n        if (v > max)\n            return max;\n        if (v < min)\n            return min;\n        return v;\n    };\n};\n/**\n * Clamps integer `v` between 0 (inclusive) and array length or length (exclusive).\n * Returns value then will always be at least zero, and a valid array index.\n *\n * @example Usage\n * ```js\n * // Array of length 4\n * const myArray = [`a`, `b`, `c`, `d`];\n * clampIndex(0, myArray);    // 0\n * clampIndex(5, 3); // 2\n * ```\n *\n * Throws an error if `v` is not an integer.\n *\n * For some data it makes sense that data might 'wrap around' if it exceeds the\n * range. For example rotation angle. Consider using {@link wrap} for this.\n *\n * @param v Value to clamp (must be an interger)\n * @param arrayOrLength Array, or length of bounds (must be an integer)\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\n */\nexport const clampIndex = (v, arrayOrLength) => {\n    // ✔ UNIT TESTED\n    if (!Number.isInteger(v)) {\n        throw new TypeError(`v parameter must be an integer (${v})`);\n    }\n    const length = Array.isArray(arrayOrLength)\n        ? arrayOrLength.length\n        : arrayOrLength;\n    if (!Number.isInteger(length)) {\n        throw new TypeError(`length parameter must be an integer (${length}, ${typeof length})`);\n    }\n    v = Math.round(v);\n    if (v < 0)\n        return 0;\n    if (v >= length)\n        return length - 1;\n    return v;\n};\n","/**\n * Returns the difference from the `initial` value. Defaults to absolute difference.\n * ```js\n * const rel = differenceFromFixed(100);\n * rel(100); // 0\n * rel(150); // 50\n * rel(50);  // 50\n * ```\n *\n * 'numerical' gives sign:\n * ```js\n * const rel = differenceFromFixed(100, `numerical`);\n * rel(100); // 0\n * rel(150); // 50\n * rel(50); // -50\n * ```\n *\n * 'relative' gives proportion to initial\n * ```js\n * const rel = differenceFromFixed(100, `relative`);\n * rel(100); // 0\n * rel(150); // 0.5\n * rel(10);  // 0.90\n * ```\n *\n * Using 'relativeSigned', we get negative relative result\n * when value is below the initial value.\n *\n * Use {@link differenceFromLast} to compare against the last value,\n * rather than the same fixed value.\n * @param {number} initial Value to compare against\n * @returns Difference from initial value\n */\nexport const differenceFromFixed = (initial, kind = `absolute`) => (value) => differenceFrom(kind, value, initial);\n/**\n * Returns a function which yields difference compared to last value.\n *\n * If no initial value is provided, the first difference will be returned as 0.\n *\n * Difference can be returned in various formats:\n * * 'absolute': numerical difference, without sign\n * * 'numerical': numerical difference, with sign, so you can see if difference is higher or lower\n * * 'relative': difference divided by last value, giving a proportional difference. Unsigned.\n * * 'relativeSigned': as above, but with sign\n *\n * Use {@link differenceFromFixed} to compare against a fixed value instead of the last value.\n *\n * ```js\n * let d = differenceFromLast(`absolute`);\n * d(10); // 0\n * d(11); // 1\n * d(10); // 1\n * ```\n *\n * ```js\n * let d = differenceFromLast(`numerical`);\n * d(10); // 0\n * d(11); // 1\n * d(10); // -1\n * ```\n *\n * ```js\n * let d = differenceFromLast(`relative`);\n * d(10); // 0\n * d(11); // 0.1\n * d(10); // 0.1\n * ```\n * ```js\n * let d = differenceFromLast(`relativeSigned`);\n * d(10); // 0\n * d(11); // 0.1\n * d(10); // -0.1\n * ```\n *\n * An initial value can be provided, eg:\n * ```js\n * let d = differenceFromLast(`absolute`, 10);\n * d(11); // 1\n * ```\n * @param kind Kind of output value\n * @param initialValue Optional initial value\n * @returns\n */\nexport const differenceFromLast = (kind = `absolute`, initialValue = Number.NaN) => {\n    let lastValue = initialValue;\n    return (value) => {\n        const x = differenceFrom(kind, value, lastValue);\n        lastValue = value;\n        return x;\n    };\n};\n//   const compute = (v: number) => {\n//     if (Number.isNaN(lastValue)) {\n//       lastValue = v;\n//       return 0;\n//     }\n//     const d = v - lastValue;\n//     let r = 0;\n//     if (kind === `absolute`) {\n//       r = Math.abs(d);\n//     } else if (kind === `numerical`) {\n//       r = d;\n//     } else if (kind === `relative`) {\n//       r = Math.abs(d / lastValue);\n//     } else if (kind === `relativeSigned`) {\n//       r = d / lastValue;\n//     } else throw new TypeError(`Unknown kind: '${ kind }' Expected: 'absolute', 'relative', 'relativeSigned' or 'numerical'`);\n//     lastValue = v;\n//     return r;\n//   }\n//   return compute;\n// }\nconst differenceFrom = (kind = `absolute`, value, from) => {\n    if (Number.isNaN(from)) {\n        return 0;\n    }\n    const d = value - from;\n    let r = 0;\n    if (kind === `absolute`) {\n        r = Math.abs(d);\n    }\n    else if (kind === `numerical`) {\n        r = d;\n    }\n    else if (kind === `relative`) {\n        r = Math.abs(d / from);\n    }\n    else if (kind === `relativeSigned`) {\n        r = d / from;\n    }\n    else\n        throw new TypeError(`Unknown kind: '${kind}' Expected: 'absolute', 'relative', 'relativeSigned' or 'numerical'`);\n    return r;\n};\n","/**\n * Returns true if `possibleNumber` is a number and not NaN\n * @param possibleNumber\n * @returns\n */\nexport const isValid = (possibleNumber) => {\n    if (typeof possibleNumber !== `number`)\n        return false;\n    if (Number.isNaN(possibleNumber))\n        return false;\n    return true;\n};\n","import { isValid } from './guard.js';\n/**\n * Filters an iterator of values, only yielding\n * those that are valid numbers\n *\n * ```js\n * import * as Numbers from 'https://unpkg.com/ixfx/dist/numbers.js';\n *\n * const data = [true, 10, '5', { x: 5 }];\n * for (const n of Numbers.filterIterable(data)) {\n *  // 5\n * }\n * ```\n * @param it\n */\nexport function* filterIterable(it) {\n    for (const v of it) {\n        if (isValid(v))\n            yield v;\n    }\n}\n/**\n * Returns a function that yields _true_ if a value\n * is at least `threshold`\n * ```js\n * const t = thresholdAtLeast(50);\n * t(50); // true\n * t(0);  // false\n * t(55); // true\n * ```\n * @param threshold\n * @returns\n */\nexport const thresholdAtLeast = (threshold) => {\n    return (v) => {\n        return v >= threshold;\n    };\n};\n/**\n * Returns a function that yields _true_\n * if a number is at least _min_ and no greater than _max_\n *\n * ```js\n * const t = rangeInclusive(50, 100);\n * t(40); // false\n * t(50); // true\n * t(60); // true\n * t(100); // true\n * t(101);  // false\n * ```\n * @param min\n * @param max\n * @returns\n */\nexport const rangeInclusive = (min, max) => {\n    return (v) => {\n        return v >= min && v <= max;\n    };\n};\n","import { throwNumberTest } from \"@ixfx/guards\";\n/**\n * Flips a percentage-scale number: `1 - v`.\n *\n * The utility of this function is that it sanity-checks\n * that `v` is in 0..1 scale.\n *\n * ```js\n * flip(1);   // 0\n * flip(0.5); // 0.5\n * flip(0);   // 1\n * ```\n * @param v\n * @returns\n */\nexport const flip = (v) => {\n    if (typeof v === `function`)\n        v = v();\n    throwNumberTest(v, `percentage`, `v`);\n    return 1 - v;\n};\n","import { throwIntegerTest } from \"@ixfx/guards\";\n/**\n * Rounds a number.\n *\n * If one parameter is given, it's the decimal places,\n * and a rounding function is returned:\n * ```js\n * import { round } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * const r = round(2);\n * r(10.12355); // 10.12\n * ```\n *\n * If two parameters are given, the first is decimal places,\n * the second the value to round.\n * ```js\n * round(2, 10.12355); // 10.12\n * ```\n * @param decimalPlaces\n * @returns\n */\nexport function round(a, b, roundUp) {\n    throwIntegerTest(a, `positive`, `decimalPlaces`);\n    const up = (typeof b === `boolean`) ? b : (roundUp ?? false);\n    let rounder;\n    if (a === 0) {\n        rounder = Math.round;\n    }\n    else {\n        const p = Math.pow(10, a);\n        if (up) {\n            rounder = (v) => Math.ceil(v * p) / p;\n        }\n        else {\n            rounder = (v) => Math.floor(v * p) / p;\n        }\n    }\n    if (typeof b === `number`)\n        return rounder(b);\n    return rounder;\n}\n","import { numberTest, throwNumberTest } from \"@ixfx/guards\";\nimport { round } from \"./round.js\";\n/**\n * Checks if a value is within range of a base value\n *\n * ```js\n * // Check if 101 is within 10% of 100\n * isApprox(0.1, 100, 101);\n *\n * // Gets a function to compare some value of 10% range to 100\n * const c = isApprox(0.1,100);\n * c(101);\n *\n * // Gets a function to compare some base value and value to 10% range\n * const c = isApprox(0.1);\n * c(100, 101);\n * ```\n *\n * Throws an error if range or base values are NaN.\n * If value being checked is NaN or infinity, _false_ is returned.\n * @param rangePercent\n * @param baseValue\n * @param v\n * @returns\n */\nexport function isApprox(rangePercent, baseValue, v) {\n    throwNumberTest(rangePercent, `percentage`, `rangePercent`);\n    // Round percentages to avoid floating point nonsense\n    const range = Math.floor(rangePercent * 100);\n    const test = (base, value) => {\n        try {\n            if (typeof value !== `number`)\n                return false;\n            if (Number.isNaN(value))\n                return false;\n            if (!Number.isFinite(value))\n                return false;\n            // Round value\n            const diff = Math.abs(value - base);\n            const relative = base === 0 ? Math.floor(diff * 100) : Math.floor((diff / base) * 100);\n            //console.log(`v: ${ value } base: ${ base } rel: ${ relative } range: ${ range } diff: ${ diff }`);\n            return relative <= range;\n        }\n        catch {\n            return false;\n        }\n    };\n    if (baseValue === undefined)\n        return test;\n    throwNumberTest(baseValue, ``, `baseValue`);\n    if (v === undefined) {\n        return (value) => test(baseValue, value);\n    }\n    else {\n        return test(baseValue, v);\n    }\n}\nexport const isCloseTo = (a, b, precision = 3) => {\n    const aa = a.toPrecision(precision);\n    const bb = b.toPrecision(precision);\n    if (aa !== bb)\n        return [false, `A is not close enough to B. A: ${a} B: ${b} Precision: ${precision}`];\n    else\n        return [true];\n};\n","//import { floatSource,type RandomOptions, type RandomSource } from '@ixfx/random';\nimport { throwNumberTest } from '@ixfx/guards';\nimport { interpolate, scaler as numberScaler } from '@ixfx/numbers';\n/**\n * Wrapper for bipolar-based values. Immutable.\n * All functions will clamp to keep it in legal range.\n *\n * ```js\n * let v = immutable(); // Starts with 0 by default\n * v = v.add(0.1);      // v.value is 0.1\n * v = v.inverse();     // v.value is -0.1\n * v = v.multiply(0.2); // v.value is -0.02\n *\n * v = immutable(1);\n * v = v.towardZero(0.1); // 0.9\n * v = v.interpolate(0.1, 1);\n * ```\n *\n * Wrapped values can be coerced into number:\n * ```js\n * const v = immutable(1);\n * const x = +v+10;\n * // x = 11\n * ```\n * @param startingValueOrBipolar Initial numeric value or BipolarWrapper instance\n * @returns\n */\nexport const immutable = (startingValueOrBipolar = 0) => {\n    if (typeof startingValueOrBipolar === `undefined`)\n        throw new Error(`Start value is undefined`);\n    const startingValue = (typeof startingValueOrBipolar === `number`) ? startingValueOrBipolar : startingValueOrBipolar.value;\n    if (startingValue > 1)\n        throw new Error(`Start value cannot be larger than 1`);\n    if (startingValue < -1)\n        throw new Error(`Start value cannot be smaller than -1`);\n    if (Number.isNaN(startingValue))\n        throw new Error(`Start value is NaN`);\n    const v = startingValue;\n    return {\n        [Symbol.toPrimitive](hint) {\n            if (hint === `number`)\n                return v;\n            else if (hint === `string`)\n                return v.toString();\n            return true;\n        },\n        value: v,\n        towardZero: (amt) => {\n            return immutable(towardZero(v, amt));\n        },\n        add: (amt) => {\n            return immutable(clamp(v + amt));\n        },\n        multiply: (amt) => {\n            return immutable(clamp(v * amt));\n        },\n        inverse: () => {\n            return immutable(-v);\n        },\n        interpolate: (amt, b) => {\n            return immutable(clamp(interpolate(amt, v, b)));\n        },\n        asScalar: () => {\n            return toScalar(v);\n        }\n    };\n};\n/**\n * Converts bipolar value to a scalar\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.toScalar(-1); // 0.0\n * Bipolar.toScalar( 0); // 0.5\n * Bipolar.toScalar( 1); // 1.0\n * ```\n *\n * Throws an error if `bipolarValue` is not a number or NaN\n * @param bipolarValue Value to convert to scalar\n * @returns Scalar value on 0..1 range.\n */\nexport const toScalar = (bipolarValue) => {\n    if (typeof bipolarValue !== `number`)\n        throw new Error(`Expected v to be a number. Got: ${typeof bipolarValue}`);\n    if (Number.isNaN(bipolarValue))\n        throw new Error(`Parameter is NaN`);\n    return (bipolarValue + 1) / 2;\n};\n/**\n * Makes a scalar into a bipolar value.\n *\n * That is, input range is 0..1, output range is -1...1\n *\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.fromScalar(1);   // 1\n * Bipolar.fromScalar(0);   // -1\n * Bipolar.fromScalar(0.5); // 0\n * ```\n *\n * Throws an error if `scalarValue` is not on 0..1 scale.\n * @param scalarValue Scalar value to convert\n * @returns Bipolar value on -1..1 scale\n */\nexport const fromScalar = (scalarValue) => {\n    throwNumberTest(scalarValue, `percentage`, `v`);\n    return (scalarValue * 2) - 1;\n};\n/**\n * Scale & clamp resulting number to bipolar range (-1..1)\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Scale 100 on 0..100 scale\n * Bipolar.scale(100, 0, 100); // 1\n * Bipolar.scale(50, 0, 100);  // 0\n * Bipolar.scale(0, 0, 100);   // -1\n * ```\n *\n * Return value is clamped.\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scale = (inputValue, inMin, inMax) => {\n    return clamp(numberScaler(inMin, inMax, -1, 1)(inputValue));\n};\n/**\n * Scale a number to bipolar range (-1..1). Not clamped to scale.\n *\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Scale 100 on 0..100 scale\n * Bipolar.scale(100, 0, 100); // 1\n * Bipolar.scale(50, 0, 100);  // 0\n * Bipolar.scale(0, 0, 100);   // -1\n * ```\n *\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scaleUnclamped = (inputValue, inMin, inMax) => {\n    return numberScaler(inMin, inMax, -1, 1)(inputValue);\n};\n/**\n * Clamp a bipolar value\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.clamp(-1);   // -1\n * Bipolar.clamp(-1.1); // -1\n * ```\n *\n * Throws an error if `bipolarValue` is not a number or NaN.\n * @param bipolarValue Value to clamp\n * @returns Clamped value on -1..1 scale\n */\nexport const clamp = (bipolarValue) => {\n    if (typeof bipolarValue !== `number`)\n        throw new Error(`Param 'bipolarValue' must be a number. Got: ${typeof bipolarValue}`);\n    if (Number.isNaN(bipolarValue))\n        throw new Error(`Param 'bipolarValue' is NaN`);\n    if (bipolarValue > 1)\n        return 1;\n    if (bipolarValue < -1)\n        return -1;\n    return bipolarValue;\n};\n/**\n * Pushes a bipolar value toward zero by `amount`.\n * Return value is clamped on bipolar range of -1..1\n *\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.towardZero(-1, 0.1); // -0.9\n * Bipolar.towardZero( 1, 0.1); //  0.9\n * Bipolar.towardZero( 0, 0.1); //  0.0\n * Bipolar.towardZero( 1, 1.1); //  0.0\n * ```\n *\n * If `amount` is greater than 1, 0 is returned.\n * Throws an error if `bipolarValue` or `amount` are not numbers.\n * Throws an error if `amount` is below zero.\n * @param bipolarValue Bipolar value to nudge toward zero\n * @param amount Amount to nudge by\n * @returns Bipolar value -1...1\n */\nexport const towardZero = (bipolarValue, amount) => {\n    if (typeof bipolarValue !== `number`)\n        throw new Error(`Parameter 'v' must be a number. Got: ${typeof bipolarValue}`);\n    if (typeof amount !== `number`)\n        throw new Error(`Parameter 'amt' must be a number. Got: ${typeof amount}`);\n    if (amount < 0)\n        throw new Error(`Parameter 'amt' must be positive`);\n    if (bipolarValue < 0) {\n        bipolarValue += amount;\n        if (bipolarValue > 0)\n            bipolarValue = 0;\n    }\n    else if (bipolarValue > 0) {\n        bipolarValue -= amount;\n        if (bipolarValue < 0)\n            bipolarValue = 0;\n    }\n    return bipolarValue;\n};\n","/* eslint-disable unicorn/prevent-abbreviations */\nimport { throwNumberTest, throwIntegerTest } from '@ixfx/guards';\n/**\n * Wraps an integer number within a specified range, defaulting to degrees (0-360). Use {@link wrap} for floating-point wrapping.\n *\n * This is useful for calculations involving degree angles and hue, which wrap from 0-360.\n * Eg: to add 200 to 200, we don't want 400, but 40.\n *\n * ```js\n * const v = wrapInteger(200+200, 0, 360); // 40\n * ```\n *\n * Or if we minus 100 from 10, we don't want -90 but 270\n * ```js\n * const v = wrapInteger(10-100, 0, 360); // 270\n * ```\n *\n * `wrapInteger` uses 0-360 as a default range, so both of these\n * examples could just as well be:\n *\n * ```js\n * wrapInteger(200+200);  // 40\n * wrapInteger(10-100);  // 270\n * ```\n *\n * Non-zero starting points can be used. A range of 20-70:\n * ```js\n * const v = wrapInteger(-20, 20, 70); // 50\n * ```\n *\n * Note that the minimum value is inclusive, while the maximum is _exclusive_.\n * So with the default range of 0-360, 360 is never reached:\n *\n * ```js\n * wrapInteger(360); // 0\n * wrapInteger(361); // 1\n * ```\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * @param v Value to wrap\n * @param min Integer minimum of range (default: 0). Inclusive\n * @param max Integer maximum of range (default: 360). Exlusive\n * @returns\n */\nexport const wrapInteger = (v, min = 0, max = 360) => {\n    throwIntegerTest(v, undefined, `v`);\n    throwIntegerTest(min, undefined, `min`);\n    throwIntegerTest(max, undefined, `max`);\n    if (v === min)\n        return min;\n    if (v === max)\n        return min; // Wraps\n    if (v > 0 && v < min)\n        v += min;\n    v -= min;\n    max -= min;\n    v = v % max;\n    if (v < 0)\n        v = max - Math.abs(v) + min;\n    return v + min;\n};\n/**\n * Wraps floating point numbers to be within a range (default: 0..1). Use {@link wrapInteger} if you want to wrap integer values.\n *\n * This logic makes sense for some things like rotation angle.\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * ```js\n * wrap(1.2);   // 0.2\n * wrap(2);     // 1.0\n * wrap(-0.2); // 0.8\n * ```\n *\n * A range can be provided too:\n * ```js\n * wrap(30, 20, 50);  \t // 30\n * wrap(60, 20, 50);    //  30\n * ```\n * @param v\n * @param min\n * @param max\n * @returns\n */\nexport const wrap = (v, min = 0, max = 1) => {\n    throwNumberTest(v, ``, `min`);\n    throwNumberTest(min, ``, `min`);\n    throwNumberTest(max, ``, `max`);\n    if (v === min)\n        return min;\n    if (v === max)\n        return min; // Wraps\n    while (v <= min || v >= max) {\n        if (v === max)\n            break;\n        if (v === min)\n            break;\n        if (v > max) {\n            v = min + (v - max);\n        }\n        else if (v < min) {\n            v = max - (min - v);\n        }\n    }\n    return v;\n};\n/**\n * Performs a calculation within a wrapping number range. This is a lower-level function.\n * See also: {@link wrapInteger} for simple wrapping within a range.\n *\n * `min` and `max` define the start and end of the valid range, inclusive. Eg for hue degrees it'd be 0, 360.\n * `a` and `b` is the range you want to work in.\n *\n * For example, let's say you want to get the middle point between a hue of 30 and a hue of 330 (ie warmer colours):\n * ```js\n * wrapRange(0,360, (distance) => {\n *  // for a:0 and b:330, distance would be 90 from 30 degrees to 330 (via zero)\n *  return distance * 0.5; // eg return middle point\n * }, 30, 330);\n * ```\n *\n * The return value of the callback should be in the range of 0-distance. `wrapRange` will subsequently\n * conform it to the `min` and `max` range before it's returned to the caller.\n *\n * @param a Output start (eg. 60)\n * @param b Output end (eg 300)\n * @param min Range start (eg 0)\n * @param max Range end (eg 360)\n * @param fn Returns a computed value from 0 to `distance`.\n * @returns\n */\nexport const wrapRange = (min, max, fn, a, b) => {\n    //eslint-disable-next-line functional/no-let\n    let r = 0;\n    const distF = Math.abs(b - a);\n    // When b is wrapped forwards\n    const distFwrap = Math.abs(max - a + b);\n    // When b is wrapped backwards (10, 300)\n    const distBWrap = Math.abs(a + (360 - b));\n    const distMin = Math.min(distF, distFwrap, distBWrap);\n    if (distMin === distBWrap) {\n        // (10, 300) = 70\n        r = a - fn(distMin);\n    }\n    else if (distMin === distFwrap) {\n        // (300, 60) = 120\n        r = a + fn(distMin);\n    }\n    else {\n        // Forwards or backwards without wrapping\n        if (a > b) {\n            // (240,120) -- backwards\n            r = a - fn(distMin);\n        }\n        else {\n            // (120,240) -- forwards\n            r = a + fn(distMin);\n        }\n    }\n    return wrapInteger(r, min, max);\n};\n","export const piPi = Math.PI * 2;\n","import { wrap } from './wrap.js';\nimport { throwNumberTest } from '@ixfx/guards';\nimport { clamp } from './clamp.js';\nimport { piPi } from './pi-pi.js';\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide on Interpolation](https://ixfx.fun/data/interpolation/overview/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * interpolate(0.5, 30, 60);\n * ```\n *\n * See also {@link interpolatorStepped} and {@link interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n *\n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n *\n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n *\n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * To interpolate certain types: {@link Visual.Colour.interpolator | Visual.Colour.interpolator }, {@link Geometry.Points.interpolate | Points.interpolate}.\n *\n * There are a few variations when calling `interpolate`, depending on what parameters are fixed.\n * * `interpolate(amount)`: returns a function that needs a & b\n * * `interpolate(a, b)`:  returns a function that needs the interpolation amount\n */\nexport function interpolate(pos1, pos2, pos3, pos4) {\n    let amountProcess;\n    let limits = `clamp`;\n    const handleAmount = (amount) => {\n        if (amountProcess)\n            amount = amountProcess(amount);\n        if (limits === undefined || limits === `clamp`) {\n            amount = clamp(amount);\n        }\n        else if (limits === `wrap`) {\n            if (amount > 1)\n                amount = amount % 1;\n            else if (amount < 0) {\n                amount = 1 + (amount % 1);\n            }\n        }\n        return amount;\n    };\n    const doTheEase = (_amt, _a, _b) => {\n        throwNumberTest(_a, ``, `a`);\n        throwNumberTest(_b, ``, `b`);\n        throwNumberTest(_amt, ``, `amount`);\n        _amt = handleAmount(_amt);\n        return (1 - _amt) * _a + _amt * _b;\n    };\n    const readOpts = (o = {}) => {\n        if (o.transform) {\n            if (typeof o.transform !== `function`)\n                throw new Error(`Param 'transform' is expected to be a function. Got: ${typeof o.transform}`);\n            amountProcess = o.transform;\n        }\n        limits = o.limits ?? `clamp`;\n    };\n    const rawEase = (_amt, _a, _b) => (1 - _amt) * _a + _amt * _b;\n    if (typeof pos1 !== `number`)\n        throw new TypeError(`First param is expected to be a number. Got: ${typeof pos1}`);\n    if (typeof pos2 === `number`) {\n        let a;\n        let b;\n        if (pos3 === undefined || typeof pos3 === `object`) {\n            //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n            a = pos1;\n            b = pos2;\n            readOpts(pos3);\n            return (amount) => doTheEase(amount, a, b);\n        }\n        else if (typeof pos3 === `number`) {\n            //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n            a = pos2;\n            b = pos3;\n            readOpts(pos4);\n            return doTheEase(pos1, a, b);\n        }\n        else {\n            throw new Error(`Values for 'a' and 'b' not defined`);\n        }\n    }\n    else if (pos2 === undefined || typeof pos2 === `object`) {\n        //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n        const amount = handleAmount(pos1);\n        readOpts(pos2);\n        throwNumberTest(amount, ``, `amount`);\n        return (aValue, bValue) => rawEase(amount, aValue, bValue);\n    }\n}\n;\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link interpolatorInterval}\n * which steps on the basis of clock time.\n *\n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n *\n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n *\n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n *\n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n *\n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns\n */\nexport const interpolatorStepped = (incrementAmount, a = 0, b = 1, startInterpolationAt = 0, options) => {\n    let amount = startInterpolationAt;\n    return (retargetB, retargetA) => {\n        if (retargetB !== undefined)\n            b = retargetB;\n        if (retargetA !== undefined)\n            a = retargetA;\n        if (amount >= 1)\n            return b;\n        const value = interpolate(amount, a, b, options);\n        amount += incrementAmount;\n        return value;\n    };\n};\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (amount, aRadians, bRadians, options) => {\n    const t = wrap(bRadians - aRadians, 0, piPi);\n    return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n","import { throwNumberTest } from \"@ixfx/guards\";\nimport { round } from \"./round.js\";\n/**\n * Generates a `step`-length series of values between `start` and `end` (inclusive).\n * Each value will be equally spaced.\n *\n * ```js\n * for (const v of linearSpace(1, 5, 6)) {\n *  // Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]\n * }\n * ```\n *\n * Numbers can be produced from large to small as well\n * ```js\n * const values = [...linearSpace(10, 5, 3)];\n * // Yields: [10, 7.5, 5]\n * ```\n * @param start Start number (inclusive)\n * @param end  End number (inclusive)\n * @param steps How many steps to make from start -> end\n * @param precision Number of decimal points to round to\n */\nexport function* linearSpace(start, end, steps, precision) {\n    throwNumberTest(start, ``, `start`);\n    throwNumberTest(end, ``, `end`);\n    throwNumberTest(steps, ``, `steps`);\n    const r = precision ? round(precision) : (v) => v;\n    const step = (end - start) / (steps - 1);\n    throwNumberTest(step, ``, `step`);\n    if (!Number.isFinite(step)) {\n        throw new TypeError(`Calculated step value is infinite`);\n    }\n    //eslint-disable-next-line functional/no-let\n    for (let index = 0; index < steps; index++) {\n        const v = start + step * index;\n        yield r(v);\n    }\n}\n","export class BasicQueueMutable {\n    #store = [];\n    enqueue(data) {\n        this.#store.push(data);\n    }\n    dequeue() {\n        return this.#store.shift();\n    }\n    get data() {\n        return this.#store;\n    }\n    get size() {\n        return this.#store.length;\n    }\n}\n","import { throwNumberTest, numberTest } from \"@ixfx/guards\";\nimport { BasicQueueMutable } from \"./util/queue-mutable.js\";\nimport { averageWeighted } from \"./average-weighted.js\";\nimport { average } from \"./numeric-arrays.js\";\nconst PiPi = Math.PI * 2;\n/**\n * A moving average calculator (exponential weighted moving average) which does not keep track of\n * previous samples. Less accurate, but uses less system resources.\n *\n * The `scaling` parameter determines smoothing. A value of `1` means that\n * the latest value is used as the average - that is, no smoothing. Higher numbers\n * introduce progressively more smoothing by weighting the accumulated prior average more heavily.\n *\n * ```\n * const ma = movingAverageLight(); // default scaling of 3\n * ma(50);  // 50\n * ma(100); // 75\n * ma(75);  // 75\n * ma(0);   // 50\n * ```\n *\n * Note that the final average of 50 is pretty far from the last value of 0. To make it more responsive,\n * we could use a lower scaling factor: `movingAverageLight(2)`. This yields a final average of `37.5` instead.\n *\n * @param scaling Scaling factor. 1 is no smoothing. Default: 3\n * @returns Function that adds to average.\n */\nexport const movingAverageLight = (scaling = 3) => {\n    throwNumberTest(scaling, `aboveZero`, `scaling`);\n    let average = 0;\n    let count = 0;\n    return (v) => {\n        const r = numberTest(v, ``, `v`);\n        if (r[0] && v !== undefined) {\n            // Valid number\n            count++;\n            average = average + (v - average) / Math.min(count, scaling);\n        }\n        return average;\n    };\n};\n/**\n * Creates a moving average for a set number of `samples`.\n * It returns a function which in turn yields an average value.\n *\n * Moving average are useful for computing the average over a recent set of numbers.\n * A lower number of samples produces a computed value that is lower-latency yet more jittery.\n * A higher number of samples produces a smoother computed value which takes longer to respond to\n * changes in data.\n *\n * Sample size is considered with respect to the level of latency/smoothness trade-off, and also\n * the rate at which new data is added to the moving average.\n *\n *\n * ```js\n * const ma = movingAverage(10);\n * ma(10); // 10\n * ma(5);  // 7.5\n * ```\n *\n * A weighting function can be provided to shape how the average is\n * calculated - eg privileging the most recent data over older data.\n * It uses `Arrays.averageWeighted` under the hood.\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n * import { gaussian } from 'https://unpkg.com/ixfx/dist/modulation.js';\n *\n * // Give more weight to data in middle of sampling window\n * const ma = movingAverage(100, gaussian());\n * ```\n *\n * Because it keeps track of `samples` previous data, there is a memory impact. A lighter version is {@link movingAverageLight} which does not keep a buffer of prior data, but can't be as easily fine-tuned.\n * @param samples Number of samples to compute average from\n * @param weighter Optional weighting function\n * @returns\n */\nexport const movingAverage = (samples = 100, weighter) => {\n    const q = new BasicQueueMutable();\n    return (v) => {\n        const r = numberTest(v);\n        if (r[0] && v !== undefined) {\n            q.enqueue(v);\n            while (q.size > samples) {\n                q.dequeue();\n            }\n        }\n        return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n    };\n};\n// export const movingAverageTimed = (\n//   updateRateMs = 200,\n//   value = 0,\n//   scaling = 3\n// ): MovingAverage => {\n//   throwNumberTest(scaling, `aboveZero`, `scaling`);\n//   throwNumberTest(updateRateMs, `aboveZero`, `decayRateMs`);\n//   const mal = movingAverageLight(scaling);\n//   //eslint-disable-next-line functional/no-let\n//   let timer = 0;\n//   const reschedule = () => {\n//     if (timer !== 0) clearTimeout(timer);\n//     // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n//     // @ts-ignore\n//     timer = setTimeout(decay, updateRateMs) as number;\n//   };\n//   const decay = () => {\n//     mal.add(value);\n//     if (!mal.isDisposed) setTimeout(decay, updateRateMs);\n//   };\n//   const ma: MovingAverage = {\n//     add(v: number) {\n//       reschedule();\n//       return mal.add(v);\n//     },\n//     dispose() {\n//       mal.dispose();\n//     },\n//     clear: function (): void {\n//       mal.clear();\n//     },\n//     compute: function (): number {\n//       return mal.compute();\n//     },\n//     isDisposed: false,\n//   };\n//   return ma;\n// };\nconst smoothingFactor = (timeDelta, cutoff) => {\n    const r = PiPi * cutoff * timeDelta;\n    return r / (r + 1);\n};\nconst exponentialSmoothing = (smoothingFactor, value, previous) => {\n    return smoothingFactor * value + (1 - smoothingFactor) * previous;\n};\n/**\n * Noise filtering\n *\n * Algorithm: https://gery.casiez.net/1euro/\n *\n * Based on [Jaan Tollander de Balsch's implementation](https://jaantollander.com/post/noise-filtering-using-one-euro-filter/)\n * @param cutoffMin Default: 1\n * @param speedCoefficient Default: 0\n * @param cutoffDefault Default: 1\n */\nexport const noiseFilter = (cutoffMin = 1, speedCoefficient = 0, cutoffDefault = 1) => {\n    let previousValue = 0;\n    let derivativeLast = 0;\n    let timestampLast = 0;\n    const compute = (value, timestamp) => {\n        timestamp ??= performance.now();\n        const timeDelta = timestamp - timestampLast;\n        // Filtered derivative\n        const s = smoothingFactor(timeDelta, cutoffDefault);\n        const valueDelta = (value - previousValue) / timeDelta;\n        const derivative = exponentialSmoothing(s, valueDelta, derivativeLast);\n        // Filtered signal\n        const cutoff = cutoffMin + speedCoefficient * Math.abs(derivative);\n        const a = smoothingFactor(timeDelta, cutoff);\n        const smoothed = exponentialSmoothing(a, value, previousValue);\n        previousValue = smoothed;\n        derivativeLast = derivative;\n        timestampLast = timestamp;\n        return smoothed;\n    };\n    return compute;\n};\n","import { clamp, clamper } from './clamp.js';\nimport { throwNumberTest } from '@ixfx/guards';\n/**\n * Scales `v` from an input range to an output range (aka `map`)\n *\n * For example, if a sensor's useful range is 100-500, scale it to a percentage:\n *\n * ```js\n * import { scale } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * scale(sensorReading, 100, 500, 0, 1);\n * ```\n *\n * `scale` defaults to a percentage-range output, so you can get away with:\n * ```js\n * scale(sensorReading, 100, 500);\n * ```\n *\n * If `v` is outside of the input range, it will likewise be outside of the output range.\n * Use {@link scaleClamped} to clip value to range.\n *\n * If inMin and inMax are equal, outMax will be returned.\n *\n * An easing function can be provided for non-linear scaling. In this case\n * the input value is 'pre scaled' using the function before it is applied to the\n * output range.\n *\n * ```js\n * scale(sensorReading, 100, 500, 0, 1, Easings.gaussian());\n * ```\n * @param v Value to scale\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @returns Scaled value\n */\nexport const scale = (v, inMin, inMax, outMin, outMax, easing) => scaler(inMin, inMax, outMin, outMax, easing)(v);\n/**\n * Returns a scaling function\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @param clamped If true, value is clamped. Default: false\n * @returns\n */\nexport const scaler = (inMin, inMax, outMin, outMax, easing, clamped) => {\n    throwNumberTest(inMin, `finite`, `inMin`);\n    throwNumberTest(inMax, `finite`, `inMax`);\n    const oMax = outMax ?? 1;\n    const oMin = outMin ?? 0;\n    const clampFunction = clamped ? clamper(outMin, outMax) : undefined;\n    return (v) => {\n        if (inMin === inMax)\n            return oMax;\n        let a = (v - inMin) / (inMax - inMin);\n        if (easing !== undefined)\n            a = easing(a);\n        const x = a * (oMax - oMin) + oMin;\n        if (clampFunction)\n            return clampFunction(x);\n        return x;\n    };\n};\n/**\n * Returns a 'null' scaler that does nothing - the input value is returned as output.\n * @returns\n */\nexport const scalerNull = () => (v) => v;\n/**\n * As {@link scale}, but result is clamped to be\n * within `outMin` and `outMax`.\n *\n * @param v\n * @param inMin\n * @param inMax\n * @param outMin 1 by default\n * @param outMax 0 by default d\n * @param easing\n * @returns\n */\nexport const scaleClamped = (v, inMin, inMax, outMin, outMax, easing) => {\n    if (outMax === undefined)\n        outMax = 1;\n    if (outMin === undefined)\n        outMin = 0;\n    if (inMin === inMax)\n        return outMax;\n    const x = scale(v, inMin, inMax, outMin, outMax, easing);\n    return clamp(x, outMin, outMax);\n};\n/**\n * Scales an input percentage to a new percentage range.\n *\n * If you have an input percentage (0-1), `scalePercentageOutput` maps it to an\n * _output_ percentage of `outMin`-`outMax`.\n *\n * ```js\n * import { scalePercentages } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Scales 50% to a range of 0-10%\n * scalePercentages(0.5, 0, 0.10); // 0.05 - 5%\n * ```\n *\n * An error is thrown if any parameter is outside of percentage range. This added\n * safety is useful for catching bugs. Otherwise, you could just as well call\n * `scale(percentage, 0, 1, outMin, outMax)`.\n *\n * If you want to scale some input range to percentage output range, just use `scale`:\n * ```js\n * import { scale } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Yields 0.5\n * scale(2.5, 0, 5);\n * ```\n * @param percentage Input value, within percentage range\n * @param outMin Output minimum, between 0-1\n * @param outMax Output maximum, between 0-1\n * @returns Scaled value between outMin-outMax.\n */\nexport const scalePercentages = (percentage, outMin, outMax = 1) => {\n    throwNumberTest(percentage, `percentage`, `v`);\n    throwNumberTest(outMin, `percentage`, `outMin`);\n    throwNumberTest(outMax, `percentage`, `outMax`);\n    return scale(percentage, 0, 1, outMin, outMax);\n};\n/**\n * Scales an input percentage value to an output range\n * If you have an input percentage (0-1), `scalePercent` maps it to an output range of `outMin`-`outMax`.\n * ```js\n * import { scalePercent } from 'https://unpkg.com/ixfx/dist/data.js';\n * scalePercent(0.5, 10, 20); // 15\n * ```\n *\n * @see {@link scalerPercent} Returns a function\n * @param v Value to scale\n * @param outMin Minimum for output\n * @param outMax Maximum for output\n * @returns\n */\nexport const scalePercent = (v, outMin, outMax) => scalerPercent(outMin, outMax)(v);\n/**\n * Returns a function that scales an input percentage value to an output range\n * @see {@link scalePercent} Calculates value\n * @param outMin\n * @param outMax\n * @returns Function that takes a single argument\n */\nexport const scalerPercent = (outMin, outMax) => {\n    return (v) => {\n        throwNumberTest(v, `percentage`, `v`);\n        return scale(v, 0, 1, outMin, outMax);\n    };\n};\n/**\n * Returns a two-way scaler\n * ```js\n * // Input range 0..100, output range 0..1\n * const s = scalerTwoWay(0,100,0,1);\n *\n * // Scale from input to output\n * s.out(50); // 0.5\n *\n * // Scale from output range to input\n * s.in(1); // 100\n * ```\n * @param inMin\n * @param inMax\n * @param outMin\n * @param outMax\n * @returns\n */\nexport const scalerTwoWay = (inMin, inMax, outMin = 0, outMax = 1, clamped = false, easing) => {\n    const toOut = scaler(inMin, inMax, outMin, outMax, easing, clamped);\n    const toIn = scaler(outMin, outMax, inMin, inMax, easing, clamped);\n    return { out: toOut, in: toIn };\n};\n","/**\n * Calculate the min, max, total, average and count of input array `data`.\n * ```js\n * const { total, min, max, avg, count } = numberArrayCompute([ 1, 2, 3 ]);\n * ```\n * @param data\n * @param opts\n * @returns\n */\nexport const numberArrayCompute = (data, opts = {}) => {\n    if (data.length === 0) {\n        return {\n            total: Number.NaN,\n            min: Number.NaN,\n            max: Number.NaN,\n            avg: Number.NaN,\n            count: Number.NaN\n        };\n    }\n    const nonNumbers = opts.nonNumbers ?? `throw`;\n    let total = 0;\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = Number.MIN_SAFE_INTEGER;\n    let count = 0;\n    for (let index = 0; index < data.length; index++) {\n        let value = data[index];\n        if (typeof value !== `number`) {\n            if (nonNumbers === `ignore`)\n                continue;\n            if (nonNumbers === `throw`)\n                throw new Error(`Param 'data' contains a non-number at index: ${index.toString()}`);\n            if (nonNumbers === `nan`)\n                value = Number.NaN;\n        }\n        if (Number.isNaN(value))\n            continue;\n        min = Math.min(min, value);\n        max = Math.max(max, value);\n        total += value;\n        count++;\n    }\n    return {\n        total, max, min, count,\n        avg: total / count\n    };\n};\n","import { scale } from './scale.js';\nimport { throwNumberTest } from \"@ixfx/guards\";\nimport { clamp } from './clamp.js';\nimport { numberArrayCompute } from './number-array-compute.js';\n/**\n * Normalises numbers, adjusting min/max as new values are processed.\n * Normalised return values will be in the range of 0-1 (inclusive).\n *\n * [ixfx Guide on Normalising](https://ixfx.fun/cleaning/normal/)\n *\n * @example\n * ```js\n * import {Normalise} from 'https://unpkg.com/ixfx/dist/numbers.js'\n * const s = Normalise.stream();\n * s(2);    // 1 (because 2 is highest seen)\n * s(1);    // 0 (because 1 is the lowest so far)\n * s(1.5);  // 0.5 (50% of range 1-2)\n * s(0.5);  // 0 (because it's the new lowest)\n * ```\n *\n * Since normalisation is being adjusted as new min/max are encountered, it might\n * be that value normalised to 1 at one time is different to what normalises to 1\n * at a later time.\n *\n * If you already know what to expect of the number range, passing in `minDefault`\n * and `maxDefault` primes the normalisation.\n * ```js\n * const s = Normalise.stream();\n * s(5); // 1, because it's the highest seen\n *\n * // With priming:\n * const s = Normalise.stream(0, 10);\n * s(5); // 0.5, because we're expecting range 0-10\n * ```\n *\n * If a value exceeds the default range, normalisation adjusts.\n * Errors are thrown if min/max defaults are NaN or if one attempts to\n * normalise NaN.\n * @returns\n */\nexport const stream = (minDefault, maxDefault) => {\n    let min = minDefault ?? Number.MAX_SAFE_INTEGER;\n    let max = maxDefault ?? Number.MIN_SAFE_INTEGER;\n    throwNumberTest(min);\n    throwNumberTest(max);\n    return (v) => {\n        throwNumberTest(v);\n        min = Math.min(min, v);\n        max = Math.max(max, v);\n        return scale(v, min, max);\n    };\n};\n/**\n * Normalises an array. By default uses the actual min/max of the array\n * as the normalisation range. [ixfx Guide on Normalising](https://ixfx.fun/cleaning/normal/)\n *\n * ```js\n * import {Normalise} from 'https://unpkg.com/ixfx/dist/numbers.js'\n * // Yields: [0.5, 0.1, 0.0, 0.9, 1]\n * Normalise.array([5,1,0,9,10]);\n * ```\n *\n * `minForced` and/or `maxForced` can\n * be provided to use an arbitrary range.\n * ```js\n * // Forced range 0-100\n * // Yields: [0.05, 0.01, 0.0, 0.09, 0.10]\n * Normalise.array([5,1,0,9,10], 0, 100);\n * ```\n *\n * Return values are clamped to always be 0-1, inclusive.\n *\n * @param values Values\n * @param minForced If provided, this will be min value used\n * @param maxForced If provided, this will be the max value used\n */\nexport const array = (values, minForced, maxForced) => {\n    if (!Array.isArray(values)) {\n        throw new TypeError(`Param 'values' should be an array. Got: ${typeof values}`);\n    }\n    const mma = numberArrayCompute(values);\n    const min = minForced ?? mma.min;\n    const max = maxForced ?? mma.max;\n    return values.map((v) => clamp(scale(v, min, max)));\n};\n","import { throwNumberTest } from \"@ixfx/guards\";\n/**\n * Scales a percentage-scale number, ie: `v * t`.\n * The utility of this function is that it sanity-checks that\n *  both parameters are in the 0..1 scale.\n * @param v Value\n * @param t Scale amount\n * @returns Scaled value\n */\nexport const proportion = (v, t) => {\n    if (typeof v === `function`)\n        v = v();\n    if (typeof t === `function`)\n        t = t();\n    throwNumberTest(v, `percentage`, `v`);\n    throwNumberTest(t, `percentage`, `t`);\n    return v * t;\n};\n","import { throwIntegerTest, throwNumberTest } from \"@ixfx/guards\";\n/**\n * Rounds `v` by `every`. Middle values are rounded up by default.\n *\n * ```js\n * quantiseEvery(11, 10);  // 10\n * quantiseEvery(25, 10);  // 30\n * quantiseEvery(0, 10);   // 0\n * quantiseEvery(4, 10);   // 0\n * quantiseEvery(100, 10); // 100\n * ```\n *\n * Also works with decimals\n * ```js\n * quantiseEvery(1.123, 0.1); // 1.1\n * quantiseEvery(1.21, 0.1);  // 1.2\n * ```\n *\n * @param v Value to quantise\n * @param every Number to quantise to\n * @param middleRoundsUp If _true_ (default), the exact middle rounds up to next step.\n * @returns\n */\nexport const quantiseEvery = (v, every, middleRoundsUp = true) => {\n    const everyString = every.toString();\n    const decimal = everyString.indexOf(`.`);\n    let multiplier = 1;\n    if (decimal >= 0) {\n        const d = everyString.substring(decimal + 1).length;\n        multiplier = 10 * d;\n        every = Math.floor(multiplier * every);\n        v = v * multiplier;\n    }\n    throwNumberTest(v, ``, `v`);\n    throwIntegerTest(every, ``, `every`);\n    let div = v / every;\n    const divModule = div % 1;\n    div = Math.floor(div);\n    if ((divModule === 0.5 && middleRoundsUp) || divModule > 0.5)\n        div++;\n    const vv = (every * div) / multiplier;\n    return vv;\n};\n","/**\n * Via: https://gist.github.com/cyphunk/6c255fa05dd30e69f438a930faeb53fe\n * @param logits\n * @returns\n */\nexport const softmax = (logits) => {\n    const maxLogit = logits.reduce((a, b) => Math.max(a, b), Number.NEGATIVE_INFINITY);\n    const scores = logits.map((l) => Math.exp(l - maxLogit));\n    const denom = scores.reduce((a, b) => a + b);\n    return scores.map((s) => s / denom);\n};\n","\nexport const HelloTest = () => { console.log(`hello test`) };\n\nexport * from '@ixfx/numbers';\nexport type * from '@ixfx/numbers';","import { resolveEls, type QueryOrElements } from \"./resolve-el.js\";\n\nexport function setText(selectors: QueryOrElements): (value: any) => string;\nexport function setText(selectors: QueryOrElements, value?: any): string;\nexport function setText(selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  return setProperty(`textContent`, selectors, value)\n};\n\nexport function setHtml(selectors: QueryOrElements): (value: any) => string;\nexport function setHtml(selectors: QueryOrElements, value?: any): string;\nexport function setHtml(selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  return setProperty(`innerHTML`, selectors, value)\n};\n\nexport function setProperty(property: string, selectors: QueryOrElements): (value: any) => string;\nexport function setProperty(property: string, selectors: QueryOrElements, value: any): string;\n\nexport function setProperty(property: string, selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  let elements: Array<HTMLElement> = [];\n  const set = (v: any) => {\n    const typ = typeof v;\n    const vv = (typ === `string` || typ === `number` || typ === `boolean`) ? v as string :\n      JSON.stringify(v);\n\n    if (elements.length === 0) {\n      elements = resolveEls(selectors);\n    }\n    for (const element of elements) {\n      (element as any)[ property ] = vv;\n    }\n    return vv;\n  }\n  return value === undefined ? set : set(value);\n};","export type Dispatch<V> = (value: V) => void;\n\ntype Wrap<V> = {\n  readonly handler: Dispatch<V>\n  readonly id: string\n  readonly once: boolean\n}\n\nexport class DispatchList<V> {\n  #handlers: Wrap<V>[]\n  #counter = 0;\n  readonly #id = Math.floor(Math.random() * 100);\n  constructor() {\n\n    this.#handlers = [];\n  }\n\n  /**\n   * Returns _true_ if list is empty\n   * @returns \n   */\n  isEmpty() {\n    return this.#handlers.length === 0;\n  }\n\n  /**\n   * Adds a handler\n   * @param handler \n   * @param options \n   * @returns \n   */\n  add(handler: Dispatch<V>, options: { once?: boolean } = {}): string {\n    this.#counter++;\n    const once = options.once ?? false;\n    const wrap: Wrap<V> = {\n      id: `${ this.#id } - ${ this.#counter }`,\n      handler,\n      once\n    }\n    this.#handlers.push(wrap);\n    return wrap.id;\n  }\n\n  remove(id: string): boolean {\n    const length = this.#handlers.length;\n    this.#handlers = this.#handlers.filter(handler => handler.id !== id);\n    return this.#handlers.length !== length;\n  }\n\n  notify(value: V) {\n    for (const handler of this.#handlers) {\n      handler.handler(value);\n      if (handler.once) {\n        this.remove(handler.id);\n      }\n    }\n  }\n\n  clear() {\n    this.#handlers = [];\n  }\n}","import { throwIntegerTest, integerTest } from '@ixfx/guards';\nimport { type HasCompletion, type HasCompletionRunStates } from '@ixfx/core';\n\nimport { intervalToMs, type Interval } from '@ixfx/core';\n\nexport type TimeoutSyncCallback = (\n  elapsedMs?: number,\n  ...args: readonly unknown[]\n) => void;\nexport type TimeoutAsyncCallback = (\n  elapsedMs?: number,\n  ...args: readonly unknown[]\n) => Promise<void>;\n\n/**\n * A resettable timeout, returned by {@link timeout}\n */\nexport type Timeout = HasCompletion & {\n  /**\n   * Starts the timer.\n   * If the timer has already been started and has a scheduled execution, this is cancelled \n   * and re-scheduled.\n   * @param altTimeoutMs Optional override for the interval. Use _undefined_ to use the original interval\n   * @param args \n   */\n  start(altTimeoutMs?: number, args?: readonly unknown[]): void;\n  /**\n   * Cancels the timer, aborting any scheduled execution.\n   */\n  cancel(): void;\n};\n\n/**\n * Returns a {@link Timeout} that can be triggered, cancelled and reset. Use {@link continuously} for interval-\n * based loops.\n *\n * Once `start()` is called, `callback` will be scheduled to execute after `interval`.\n * If `start()` is called again, the waiting period will be reset to `interval`.\n *\n * @example Essential functionality\n * ```js\n * const fn = () => {\n *  console.log(`Executed`);\n * };\n * const t = timeout(fn, 60*1000);\n * t.start();   // After 1 minute `fn` will run, printing to the console\n * ```\n *\n * @example Control execution functionality\n * ```\n * t.cancel();  // Cancel it from running\n * t.start();   // Schedule again after 1 minute\n * t.start(30*1000); // Cancel that, and now scheduled after 30s\n * \n * // Get the current state of timeout\n * t.runState;    // \"idle\", \"scheduled\" or \"running\"\n * ```\n *\n * Callback function receives any additional parameters passed in from start. This can be useful for passing through event data:\n *\n * @example\n * ```js\n * const t = timeout( (elapsedMs, ...args) => {\n *  // args contains event data\n * }, 1000);\n * el.addEventListener(`click`, t.start);\n * ```\n *\n * Asynchronous callbacks can be used as well:\n * ```js\n * timeout(async () => {...}, 100);\n * ```\n *\n * If you don't expect to need to control the timeout, consider using {@link delay},\n * which can run a given function after a specified delay.\n * @param callback\n * @param interval\n * @returns {@link Timeout}\n */\nexport const timeout = (\n  callback: TimeoutSyncCallback | TimeoutAsyncCallback,\n  interval: Interval\n): Timeout => {\n  if (callback === undefined) {\n    throw new Error(`callback parameter is undefined`);\n  }\n  const intervalMs = intervalToMs(interval);\n  throwIntegerTest(intervalMs, `aboveZero`, `interval`);\n\n  let timer: ReturnType<typeof setTimeout>;\n  let startedAt = 0;\n  let startCount = 0;\n  let startCountTotal = 0;\n  let state: HasCompletionRunStates = `idle`;\n\n  const clear = () => {\n    startedAt = 0;\n    globalThis.clearTimeout(timer);\n    state = `idle`;\n  }\n\n  const start = async (\n    altInterval: Interval = interval,\n    args: unknown[]\n  ): Promise<void> => {\n    const p = new Promise<void>((resolve, reject) => {\n      startedAt = performance.now();\n      const altTimeoutMs = intervalToMs(altInterval);\n      const it = integerTest(altTimeoutMs, `aboveZero`, `altTimeoutMs`);\n      if (!it[ 0 ]) {\n        reject(new Error(it[ 1 ]));\n        return;\n      }\n\n      switch (state) {\n        case `scheduled`: {\n          // Cancel other scheduled execution\n          cancel();\n          break;\n        }\n        case `running`: {\n          //console.warn(`Timeout being rescheduled while task is already running`);\n          break;\n        }\n      }\n      state = `scheduled`;\n\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      timer = globalThis.setTimeout(async () => {\n        if (state !== `scheduled`) {\n          console.warn(`Timeout skipping execution since state is not 'scheduled'`);\n          clear();\n          return;\n        }\n        const args_ = args ?? [];\n        startCount++;\n        startCountTotal++;\n        state = `running`;\n        await callback(performance.now() - startedAt, ...args_);\n        state = `idle`\n        clear();\n        resolve();\n      }, altTimeoutMs);\n    });\n    return p;\n  };\n\n  const cancel = () => {\n    if (state === `idle`) return;\n    clear();\n  };\n\n  return {\n\n    start,\n    cancel,\n    get runState() {\n      return state;\n    },\n    get startCount() {\n      return startCount;\n    },\n    get startCountTotal() {\n      return startCountTotal;\n    }\n  };\n};\n\n\n// const average = movingAverageLight();\n// const rm = rateMinimum({\n//   interval: { secs: 1 },\n//   whatToCall: (distance: number) => {\n//     average(distance);\n//   },\n//   fallback() {\n//     return 0;\n//   }\n// })\n// document.addEventListener(`pointermove`, event => {\n//   rm(event.movementX + event.movementY);\n// });","import type { BasicType } from '@ixfx/core';\nimport { resolve, resolveSync, type ResolveToValue, type ResolveToValueSync } from '@ixfx/core';\nimport { intervalToMs, type Interval } from '@ixfx/core';\nimport { sleep } from '@ixfx/core';\n\nexport type RepeatDelayOpts = RepeatOpts & Readonly<Partial<{\n  /**\n * Sleep a fixed period of time regardless of how long each invocation of 'produce' takes\n */\n  delay: Interval;\n  /**\n   * Minimum interval. That is, only sleep if there is time left over after 'produce'\n   * is invoked.\n   */\n  delayMinimum: Interval;\n\n  /**\n * When to perform delay. Default is before 'produce' is invoked.\n * Default: 'before'\n */\n  delayWhen: `before` | `after` | `both`;\n}>>\n\n\n/**\n * Options for repeat\n */\nexport type RepeatOpts = Partial<Readonly<{\n  /**\n   * If specified, repeating stops if this function returns false\n   * @param count\n   * @returns \n   */\n  while: (count: number) => boolean\n  /**\n   * By default, if the callback returns\n   * _undefined_ the repeating exits. Set this to _true_ to\n   * ignore undefined values\n   * @default false\n   */\n  allowUndefined: boolean\n  /**\n   * Optional signal to abort\n   */\n  signal: AbortSignal;\n\n  /**\n   * Maximum times to repeat (default: no limit)\n   */\n  count: number\n  /**\n   * Function to call when initialising\n   * @returns \n   */\n  onStart: () => void\n\n  /**\n   * Function to call when done (or an error occurs)\n   * @returns \n   */\n  onComplete: (withError: boolean) => void\n}>>;\n\n\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an async function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n * \n * @example\n * Produce a random number every 500ms\n * ```js\n * const randomGenerator = repeat(() => Math.random(), 500);\n * for await (const r of randomGenerator) {\n *  // Random value every 1 second\n *  // Warning: does not end by itself, a `break` statement is needed\n * }\n * ```\n *\n * @example\n * Return values from a generator every 500ms\n * ```js\n * import { repeat } from 'https://unpkg.com/ixfx/dist/flow.js'\n * import { count } from 'https://unpkg.com/ixfx/dist/numbers.js'\n * for await (const v of repeat(count(10), { fixed: 1000 })) {\n *  // Do something with `v`\n * }\n * ```\n *\n * Options allow either fixed interval (wait this long between iterations), or a minimum interval (wait at least this long). The latter is useful if `produce` takes some time - it will only wait the remaining time or not at all.\n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n * \n * @see {@link continuously}: loop that runs at a constant speed. Able to be started and stopped\n * @see {@link repeat}: run a function a certain number of times, collecting results\n *\n * @param produce Function/generator to use\n * @param opts\n * @typeParam T - Data type\n * @returns Returns value of `produce` function\n */\nexport async function* repeat<T extends BasicType>(\n  produce: ResolveToValue<T> | ArrayLike<T>,\n  opts: RepeatDelayOpts\n): AsyncGenerator<T> {\n  const signal = opts.signal ?? undefined;\n  const delayWhen = opts.delayWhen ?? `before`;\n  const count = opts.count ?? undefined;\n  const allowUndefined = opts.allowUndefined ?? false;\n  const minIntervalMs = opts.delayMinimum ? intervalToMs(opts.delayMinimum) : undefined;\n  const whileFunction = opts.while;\n\n  let cancelled = false;\n  let sleepMs = intervalToMs(opts.delay, intervalToMs(opts.delayMinimum, 0));\n  let started = performance.now();\n\n  const doDelay = async () => {\n    const elapsed = performance.now() - started;\n    if (typeof minIntervalMs !== `undefined`) {\n      sleepMs = Math.max(0, minIntervalMs - elapsed);\n    }\n    if (sleepMs) {\n      await sleep({ millis: sleepMs, signal });\n    }\n    started = performance.now();\n    if (signal?.aborted) throw new Error(`Signal aborted ${ signal.reason }`);\n  };\n\n  if (Array.isArray(produce)) produce = produce.values();\n\n  if (opts.onStart) opts.onStart();\n\n  let errored = true;\n  let loopedTimes = 0;\n  try {\n    while (!cancelled) {\n      loopedTimes++;\n      if (delayWhen === `before` || delayWhen === `both`) await doDelay();\n      const result = await resolve<T>(produce);\n      if (typeof result === `undefined` && !allowUndefined) {\n        cancelled = true;\n      } else {\n        yield result;\n        if (delayWhen === `after` || delayWhen === `both`) await doDelay();\n        if (count !== undefined && loopedTimes >= count) cancelled = true;\n      }\n      if (whileFunction) {\n        if (!whileFunction(loopedTimes)) {\n          cancelled = true;\n        }\n      }\n    }\n    errored = false\n  } finally {\n    cancelled = true;\n    if (opts.onComplete) opts.onComplete(errored);\n  }\n};\n\n\n/**\n * Generates values from `produce` with a time delay.\n * `produce` can be a simple function that returns a value, an function, or a generator.\n * If `produce` returns _undefined_, generator exits.\n * \n * This is the synchronous version. {@link repeat} allows for delays between loops\n * as well as asynchronous callbacks. \n *\n * If the AbortSignal is triggered, an exception will be thrown, stopping iteration.\n * \n * @param produce Function/generator to use\n * @param opts Options\n * @typeParam T - Data type\n * @returns Returns value of `produce` function\n */\nexport function* repeatSync<T extends BasicType>(\n  produce: ResolveToValueSync<T> | ArrayLike<T>,\n  opts: RepeatOpts\n) {\n  const signal = opts.signal ?? undefined;\n  const count = opts.count ?? undefined;\n  const allowUndefined = opts.allowUndefined ?? false;\n  let cancelled = false;\n\n  if (Array.isArray(produce)) produce = produce.values();\n\n  if (opts.onStart) opts.onStart();\n\n  let errored = true;\n  let loopedTimes = 0;\n\n  try {\n    while (!cancelled) {\n      loopedTimes++;\n      const result = resolveSync<T>(produce);\n      if (typeof result === `undefined` && !allowUndefined) {\n        cancelled = true;\n      } else {\n        yield result;\n        if (count !== undefined && loopedTimes >= count) cancelled = true;\n        if (signal?.aborted) cancelled = true;\n      }\n    }\n    errored = false\n  } finally {\n    cancelled = true;\n    if (opts.onComplete) opts.onComplete(errored);\n  }\n};\n\n/**\n * Logic for continuing repeats\n */\n// export type RepeatPredicate = (\n//   repeats: number,\n//   valuesProduced: number\n// ) => boolean;\n\n\n/**\n * Calls and waits for the async function `fn` repeatedly, yielding each result asynchronously.\n * Use {@link repeat} if `fn` does not need to be awaited.\n *\n * ```js\n * // Eg. iterate\n * const r = Flow.repeat(5, async () => Math.random());\n * for await (const v of r) {\n *\n * }\n * // Eg read into array\n * const results = await Array.fromAsync(Flow.repeatAwait(5, async () => Math.random()));\n * ```\n *\n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n *\n * Using a fixed number of repeats:\n * ```js\n * // Calls - and waits - for Flow.sleep(1) 5 times\n * await Flow.repeatAwait(5, async () => {\n *    // some kind of async function where we can use await\n *    // eg. sleep for 1s\n *    await Flow.sleep(1);\n * });\n * ```\n *\n * Using a function to dynamically determine number of repeats. The function gets\n * passed the number of repeats so far as well as the number of values produced. This\n * is count of non-undefined results from `cb` that is being repeated.\n *\n * ```js\n * async function task() {\n *  // do something\n * }\n *\n * await Flow.repeatAwait(\n *  (repeats, valuesProduced) => {\n *    // Logic for deciding whether to repeat or not\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n *\n * In the above cases we're not using the return value from `fn`. This would look like:\n * ```js\n * const g = Flow.repeatAwait(5, async () => Math.random);\n * for await (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n * @param countOrPredicate Number of times to repeat, or a function that returns _false_ to stop the loop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @typeParam V - Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\n// export function repeatAwait<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V): AsyncIterable<V> {\n//   return typeof countOrPredicate === `number` ? repeatTimesAwaited(countOrPredicate, fn) : repeatWhileAwaited(countOrPredicate, fn);\n// }\n\n/**\n * Calls `fn` repeatedly, yielding each result.\n * Use {@link repeatAwait} if `fn` is asynchronous and you want to wait for it.\n *\n * The number of repeats is determined by the first parameter. If it's a:\n * - number: how many times to repeat\n * - function: it gets called before each repeat, if it returns _false_ repeating stops.\n *\n * Example: using a fixed number of repeats\n * ```js\n * // Results will be an array with five random numbers\n * const results = [...repeat(5, () => Math.random())];\n *\n * // Or as an generator (note also the simpler expression form)\n * for (const result of repeat(5, Math.random)) {\n * }\n * ```\n *\n * Example: Using a function to dynamically determine number of repeats\n * ```js\n * function task() {\n * }\n *\n * Flow.repeat(\n *  (repeats, valuesProduced) => {\n *    if (repeats > 5) return false; // Stop repeating\n *  },\n *  task\n * );\n * ```\n *\n * In the above cases we're not using the return value from `fn`. To do so,\n * this would look like:\n * ```js\n * const g = Flow.repeat(5, () => Math.random);\n * for (const v of g) {\n *  // Loops 5 times, v is the return value of calling `fn` (Math.random)\n * }\n * ```\n *\n * Alternatives:\n * * {@link Flow.forEach | Flow.forEach} - if you don't need return values\n * * {@link Flow.interval} - if you want to repeatedly call something with an interval between\n * @param countOrPredicate Numnber of repeats, or a function that returns _false_ for when to stop.\n * @param fn Function to execute. Asynchronous functions will be awited\n * @typeParam V - Return type of repeating function\n * @returns Asynchronous generator of `fn` results.\n */\n// export function repeat<V>(countOrPredicate: number | RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   return typeof countOrPredicate === `number` ? repeatTimes(countOrPredicate, fn) : repeatWhile(countOrPredicate, fn);\n// }\n\n\n/**\n * Calls `fn` until `predicate` returns _false_. Awaits result of `fn` each time.\n * Yields result of `fn` asynchronously\n * @param predicate\n * @param fn\n * @typeParam V - Return type of repeating function\n */\n// async function* repeatWhileAwaited<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V): AsyncGenerator<V> {\n//   let repeats = 0;\n//   let valuesProduced = 0;\n//   while (predicate(repeats, valuesProduced)) {\n//     repeats++;\n//     const v = await fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n\n/**\n * Calls `fn` until `predicate` returns _false_. Yields result of `fn`.\n * @param predicate Determiner for whether repeating continues\n * @param fn Function to call\n * @typeParam V - Return type of repeating function\n */\n// function* repeatWhile<V>(predicate: RepeatPredicate, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   let repeats = 0;\n//   let valuesProduced = 0;\n//   while (predicate(repeats, valuesProduced)) {\n//     repeats++;\n//     const v = fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n\n/**\n * Calls `fn`, `count` number of times, waiting for the result of `fn`.\n * Yields result of `fn` asynchronously\n * @param count Number of times to run\n * @param fn Function to run\n * @typeParam V - Return type of repeating function\n */\n// async function* repeatTimesAwaited<V>(count: number, fn: (repeats: number, valuesProduced: number) => Promise<V | undefined> | V | undefined) {\n//   throwNumberTest(count, `positive`, `count`);\n//   let valuesProduced = 0;\n//   let repeats = 0;\n//   while (count-- > 0) {\n//     repeats++;\n//     const v = await fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n\n/**\n * Calls `fn`, `count` times. Assumes a synchronous function. Yields result of `fn`.\n *\n * Note that if `fn` returns _undefined_ repeats will stop.\n * @typeParam V - Return type of repeating function\n * @param count Number of times to run\n * @param fn Function to run\n */\n// function* repeatTimes<V>(count: number, fn: (repeats: number, valuesProduced: number) => V | undefined): Generator<V> {\n//   throwNumberTest(count, `positive`, `count`);\n//   let valuesProduced = 0;\n//   let repeats = 0;\n//   while (count-- > 0) {\n//     //console.log(`Flow.repeatTimes count: ${ count } repeats: ${ repeats } values: ${ valuesProduced }`);\n//     repeats++;\n//     const v = fn(repeats, valuesProduced);\n//     if (v === undefined) continue;\n//     yield v;\n//     valuesProduced++;\n//   }\n// }\n\n\n/**\n * Repeatedly calls `fn`, reducing via `reduce`.\n *\n * ```js\n * repeatReduce(10, () => 1, (acc, v) => acc + v);\n * // Yields: 10\n *\n * // Multiplies random values against each other 10 times\n * repeatReduce(10, Math.random, (acc, v) => acc * v);\n * // Yields a single number\n * ```\n * @param countOrPredicate Number of times to run, or function to keep running\n * @param fn Function to call\n * @param initial Initial value\n * @param reduce Function to reduce value\n * @typeParam V - Return type of repeating function\n * @returns Final result\n */\n// export const repeatReduce = <V>(\n//   countOrPredicate: number | RepeatPredicate,\n//   fn: () => V | undefined,\n//   reduce: (accumulator: V, value: V) => V,\n//   initial: V\n// ): V => {\n\n//   return IterableReduce(repeat(countOrPredicate, fn), reduce, initial);\n\n//   // if (typeof countOrPredicate === `number`) {\n//   //   throwNumberTest(countOrPredicate, `positive`, `countOrPredicate`);\n//   //   while (countOrPredicate-- > 0) {\n//   //     const v = fn();\n//   //     if (v === undefined) continue;\n//   //     initial = reduce(initial, v);\n//   //   }\n//   // } else {\n//   //   //eslint-disable-next-line functional/no-let\n//   //   let repeats, valuesProduced;\n//   //   repeats = valuesProduced = 0;\n//   //   while (countOrPredicate(repeats, valuesProduced)) {\n//   //     repeats++;\n//   //     const v = fn();\n//   //     if (v === undefined) continue;\n//   //     initial = reduce(initial, v);\n//   //     valuesProduced++;\n//   //   }\n//   // }\n//   // return initial;\n// };","import { clamp } from '@ixfx/numbers';\nimport { intervalToMs, type HasCompletion, type Interval } from '@ixfx/core';\n\n/**\n * Creates a timer\n */\nexport type TimerSource = () => Timer;\n\n/**\n * A timer instance.\n * {@link CompletionTimer} also contains an 'isDone' field.\n * \n * Implementations: {@link elapsedMillisecondsAbsolute}, {@link elapsedTicksAbsolute}, {@link frequencyTimer}\n */\nexport type Timer = {\n  reset(): void\n  get elapsed(): number\n};\n\n/**\n * A {@link Timer} that has a sense of completion, when `isDone` returns _true_.\n * See {@link relative}\n */\nexport type CompletionTimer = Timer & {\n  /**\n   * Returns _true_ if this timer has completed.\n   */\n  get isDone(): boolean\n}\n\nexport type ModulationTimer = CompletionTimer & {\n  mod(amt: number): void;\n};\n\n\nexport type TimerOpts = {\n  /**\n   * Timer to use. By default {@link elapsedMillisecondsAbsolute}.\n   */\n  readonly timer: Timer;\n};\n\n/**\n * Options for relative timer\n */\nexport type RelativeTimerOpts = TimerOpts & {\n  /**\n   * If true, returned value will be clamped to 0..1. False by default\n   */\n  readonly clampValue: boolean\n  readonly wrapValue: boolean\n};\n\n/**\n * A function that returns _true_ when an interval has elapsed\n *\n * ```js\n * import { hasElapsed } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const oneSecond = hasElapsed(1000);\n * \n * // Keep calling to check if time has elapsed.\n * // Will return _true_ when it has\n * oneSecond();\n * ```\n * \n * @param elapsed\n * @returns\n */\nexport function hasElapsed(elapsed: Interval): () => boolean {\n  const t = relative(intervalToMs(elapsed, 0), { timer: elapsedMillisecondsAbsolute(), clampValue: true });\n  return () => t.isDone;\n}\n\n// export const frequencyTimerSource =\n//   (frequency: number): TimerSource =>\n//     () =>\n//       frequencyTimer(frequency, { timer: elapsedMillisecondsAbsolute() });\n\n/**\n * Returns a function that returns the percentage of timer completion.\n * Starts when return function is first invoked.\n *\n * ```js\n * import * as Flow from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const timer = Flow.ofTotal(1000);\n * \n * // Call timer() to find out the completion\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Flow.ofTotal(1000, { clampValue: true });\n * ```\n *\n * Takes an {@link Interval} for more expressive time:\n * ```js\n * const timer = Flow.ofTotal({ mins: 4 });\n * ```\n * \n * Is a simple wrapper around {@link relative}.\n * @param duration\n * @see {@link ofTotalTicks} - Use ticks instead of time\n * @see {@link hasElapsed} - Simple _true/false_ if interval has elapsed\n * @returns\n */\nexport function ofTotal(\n  duration: Interval,\n  opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean } = {}\n): () => number {\n  const totalMs = intervalToMs(duration);\n  if (!totalMs) throw new Error(`Param 'duration' not valid`);\n  const timerOpts = {\n    ...opts,\n    timer: elapsedMillisecondsAbsolute(),\n  };\n  let t: ModulationTimer | undefined;\n  return () => {\n    t ??= relative(totalMs, timerOpts);\n    return t.elapsed;\n  }\n}\n\n/**\n * Returns a function that returns the percentage (0..1) of timer completion.\n * Uses 'ticks' as a measure. Use {@link ofTotal} if you want time-based.\n *\n * ```js\n * import * as Flow from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const timer = Flow.ofTotalTicks(1000);\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Flow.ofTotalTicks(1000, { clampValue: true });\n * ```\n *\n * This is a a simple wrapper around {@link relative}.\n * @see {@link ofTotal}\n * @see {@link hasElapsed}: Simple _true/false_ if interval has elapsed\n * @param totalTicks\n * @returns\n */\nexport function ofTotalTicks(totalTicks: number, opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean } = {}\n): () => number {\n  const timerOpts = {\n    ...opts,\n    timer: elapsedTicksAbsolute(),\n  };\n  let t: ModulationTimer | undefined;\n  return () => {\n    t ??= relative(totalTicks, timerOpts);\n    return t.elapsed;\n  }\n}\n\n/**\n * Returns a {@link ModulationTimer} that is always at 100%.\n * Opposite: {@link timerNeverDone}.\n * @returns \n */\nexport const timerAlwaysDone = (): ModulationTimer => ({\n  elapsed: 1,\n  isDone: true,\n  reset(): void {\n\n  },\n  mod(amt) {\n\n  },\n})\n\n/**\n * Returns a {@link ModulationTimer} that is always at 0%.\n * Opposite: {@link timerAlwaysDone}.\n * @returns \n */\nexport const timerNeverDone = (): ModulationTimer => (\n  {\n    elapsed: 0,\n    isDone: false,\n    reset() {\n\n    },\n    mod() {\n\n    }\n  }\n);\n\n/**\n * Wraps a timer, returning a relative elapsed value based on\n * a given total. ie. percentage complete toward a total value.\n * This is useful because other parts of code don't need to know\n * about the absolute time values, you get a nice relative completion number.\n *\n * If no timer is specified, a milliseconds-based timer is used.\n *\n * ```js\n * const t = relative(1000);\n * t.elapsed;   // returns % completion (0...1)\n * ```\n * It can also use a tick based timer\n * ```js\n * // Timer that is 'done' at 100 ticks\n * const t = relative(100, { timer: ticksElapsedTimer() });\n * ```\n * \n * Additional fields/methods on the timer instance\n * ```js\n * t.isDone;  // _true_ if .elapsed has reached (or exceeded) 1\n * t.reset(); // start from zero again\n * ```\n *\n * Options:\n * * timer: timer to use. If not specified, `elapsedMillisecondsAbsolute()` is used.\n * * clampValue: if _true_, return value is clamped to 0..1 (default: _false_)\n * * wrapValue: if _true_, return value wraps around continously from 0..1..0 etc. (default: _false_)\n * \n * Note that `clampValue` and `wrapValue` are mutually exclusive: only one can be _true_, but both can be _false_.\n * \n * With options\n * ```js\n * // Total duration of 1000 ticks\n * const t = Timer.relative(1000, { timer: ticksElapsedTimer(); clampValue:true });\n * ```\n *\n * If `total` is Infinity, a 'always completed; timer is returned. Use a value of `NaN` for a\n * timer that always returns 0.\n * @private\n * @param total Total (of milliseconds or ticks, depending on timer source)\n * @param options Options\n * @returns Timer\n */\nexport const relative = (\n  total: number,\n  options: Partial<RelativeTimerOpts> = {}\n): ModulationTimer => {\n\n  if (!Number.isFinite(total)) {\n    return timerAlwaysDone()\n  } else if (Number.isNaN(total)) {\n    return timerNeverDone();\n  }\n\n  const clampValue = options.clampValue ?? false;\n  const wrapValue = options.wrapValue ?? false;\n  if (clampValue && wrapValue) throw new Error(`clampValue and wrapValue cannot both be enabled`);\n\n  let modulationAmount = 1;\n\n  // Create and starts timer\n  const timer = options.timer ?? elapsedMillisecondsAbsolute();\n  // Keep track of value to avoid over-advancing the tick counter\n  let lastValue = 0;\n  const computeElapsed = (value: number) => {\n    lastValue = value;\n    let v = value / (total * modulationAmount);\n    if (clampValue) v = clamp(v);\n    else if (wrapValue && v >= 1) v = v % 1;\n    return v;\n  }\n\n  return {\n    mod(amt: number) {\n      modulationAmount = amt;\n    },\n    get isDone() {\n      //const tmp = computeElapsed();\n      //console.log(`Timer.relative ${ tmp } elapsed: ${ timer.elapsed } total: ${ total }`)\n      return computeElapsed(lastValue) >= 1;\n    },\n    get elapsed() {\n      return computeElapsed(timer.elapsed);\n    },\n    reset: () => {\n      timer.reset();\n    }\n  };\n};\n\n\n/**\n * A timer based on frequency: cycles per unit of time. These timers return a number from\n * 0..1 indicating position with a cycle.\n *\n * In practice, timers are used to 'drive' something like an Oscillator.\n *\n * By default it uses elapsed clock time as a basis for frequency. ie., cycles per second.\n *\n * It returns a `ModulationTimer`, which allows for a modulation amount to be continually applied\n * to the calculation of the 'position' within a cycle.\n *\n * @example Prints around 0/0.5 each second, as timer is half a cycle per second\n * ```js\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const t = frequencyTimer(0.5);\n * setInterval(() => {\n *  console.log(t.elapsed);\n * }, 1000);\n * ```\n * @param frequency Cycles\n * @param options Options for timer\n * @returns\n */\nexport const frequencyTimer = (\n  frequency: number,\n  options: Partial<TimerOpts> = {}\n): ModulationTimer => {\n  const timer = options.timer ?? elapsedMillisecondsAbsolute();\n  const cyclesPerSecond = frequency / 1000;\n  let modulationAmount = 1;\n\n  const computeElapsed = () => {\n    // Get position in a cycle\n    const v = timer.elapsed * (cyclesPerSecond * modulationAmount);\n\n    // Get fractional part\n    const f = v - Math.floor(v);\n    if (f < 0) {\n      throw new Error(\n        `Unexpected cycle fraction less than 0. Elapsed: ${ v } f: ${ f }`\n      );\n    }\n    if (f > 1) {\n      throw new Error(\n        `Unexpected cycle fraction more than 1. Elapsed: ${ v } f: ${ f }`\n      );\n    }\n    return f;\n  }\n  return {\n    mod: (amt: number) => {\n      modulationAmount = amt;\n    },\n    reset: () => {\n      timer.reset();\n    },\n    get isDone() {\n      return computeElapsed() >= 1;\n    },\n    get elapsed() {\n      return computeElapsed();\n    },\n  };\n};\n\n/**\n * A timer that uses clock time. Start time is from the point of invocation.\n *\n * ```js\n * const t = elapsedMillisecondsAbsolute();\n * t.reset(); // reset start\n * t.elapsed; // milliseconds since start\n * ```\n * @returns {Timer}\n * @see {ticksElapsedTimer}\n */\nexport const elapsedMillisecondsAbsolute = (): Timer => {\n  let start = performance.now();\n  return {\n    /**\n     * Reset timer\n     */\n    reset: () => {\n      start = performance.now();\n    },\n    /**\n     * Returns elapsed time since start\n     */\n    get elapsed() {\n      return performance.now() - start;\n    }\n  };\n};\n\n/**\n * A timer that progresses with each call to `elapsed`.\n *\n * The first call to elapsed will return 1.\n *\n * ```js\n * const timer = elapsedTicksAbsolute();\n * timer.reset(); // Reset to 0\n * timer.elapsed; // Number of ticks (and also increment ticks)\n * timer.peek;    // Number of ticks (without incrementing)\n * ```\n * \n * Like other {@link Timer} functions, returns with a `isDone` field,\n * but this will always return _true_.\n * @returns {Timer}\n * @see {elapsedMillisecondsAbsolute}\n */\nexport const elapsedTicksAbsolute = (): Timer & { peek: number } => {\n  let start = 0;\n  return {\n    /**\n     * Reset ticks to 0. The next call to `elapsed` will return 1.\n     */\n    reset: () => {\n      start = 0;\n    },\n    /**\n     * Get current ticks without incrementing.\n     */\n    get peek() {\n      return start;\n    },\n    /**\n     * Returns the number of elapsed ticks as well as\n     * incrementing the tick count. \n     * \n     * Minimum is 1\n     * \n     * Use {@link peek} to get the current ticks without incrementing.\n     */\n    get elapsed() {\n      return ++start;\n    }\n  };\n};\n\n\n/**\n * Wraps `timer`, computing a value based on its elapsed value.\n * `fn` creates this value.\n * \n * ```js\n * const t = timerWithFunction(v=>v/2, relativeTimer(1000));\n * t.compute();\n * ```\n * \n * In the above case, `relativeTimer(1000)` creates a timer that goes\n * from 0..1 over one second. `fn` will divide that value by 2, so\n * `t.compute()` will yield values 0..0.5.\n * \n * @param fn \n * @param timer \n * @returns \n */\nexport const timerWithFunction = (\n  fn: ((v: number) => number),\n  timer: CompletionTimer\n): HasCompletion & CompletionTimer & { compute: () => number } => {\n  if (typeof fn !== `function`) throw new Error(`Param 'fn' should be a function. Got: ${ typeof fn }`);\n  let startCount = 1;\n  return {\n    get elapsed() {\n      return timer.elapsed;\n    },\n    get isDone() {\n      return timer.isDone;\n    },\n    get runState() {\n      if (timer.isDone) return `idle`;\n      return `scheduled`;\n    },\n    /**\n     * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n     */\n    get startCount() {\n      return startCount;\n    },\n    get startCountTotal() {\n      return startCount;\n    },\n    compute: () => {\n      const elapsed = timer.elapsed;\n      return fn(elapsed);\n    },\n    reset: () => {\n      timer.reset();\n      startCount++;\n    },\n  };\n};","export const adsrStateTransitions = Object.freeze({\n    attack: [`decay`, `release`],\n    decay: [`sustain`, `release`],\n    sustain: [`release`],\n    release: [`complete`],\n    complete: null,\n});\n","import { unique } from '@ixfx/arrays';\nimport type { Machine, MachineState, StateNames, StateTarget, StateTargetStrict, TransitionCondition, Transitions, TransitionsStrict } from './types.js';\n\n/**\n * Clones machine state\n * @param toClone\n * @returns Cloned of `toClone`\n */\nexport const cloneState = <V extends Transitions>(\n  toClone: MachineState<V>\n): MachineState<V> => {\n  return Object.freeze({\n    value: toClone.value,\n    visited: [ ...toClone.visited ],\n    machine: toClone.machine,\n  });\n};\n/**\n * Initialises a state machine\n * ```js\n * const desc = {\n *  pants: ['shoes','socks'],\n *  socks: ['shoes', 'pants'],\n *  shoes: 'shirt',\n *  shirt: null\n * }\n * // Defaults to first key, 'pants'\n * let sm = StateMachine.init(descr);\n * // Move to 'shoes' state\n * sm = StateMachine.to(sm, 'shoes');\n * sm.state; // 'shoes'\n * sm.visited; // [ 'pants' ]\n * StateMachineLight.isDdone(sm); // false\n * StateMachineLight.possible(sm); // [ 'shirt' ]\n * ```\n * @param stateMachine Settings for state machine\n * @param initialState Initial state name\n * @returns\n */\nexport const init = <V extends Transitions>(\n  stateMachine: Machine<V> | Transitions | TransitionsStrict,\n  initialState?: StateNames<V>\n): MachineState<V> => {\n  const [ machine, machineValidationError ] = validateMachine(stateMachine);\n  if (!machine) throw new Error(machineValidationError);\n\n  const state: StateNames<V> =\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    (initialState!) ?? Object.keys(machine.states)[ 0 ];\n  if (typeof machine.states[ state ] === `undefined`) {\n    throw new TypeError(`Initial state ('${ state }') not found`);\n  }\n\n  // Normalise states\n  const transitions = validateAndNormaliseTransitions(machine.states);\n  if (transitions === undefined) {\n    throw new Error(`Could not normalise transitions`);\n  }\n  return Object.freeze({\n    value: state,\n    visited: [],\n    machine: Object.freeze(Object.fromEntries(transitions)) as any as Readonly<Record<StateNames<V>, readonly StateTargetStrict<V>[]>>,\n  });\n};\n\nexport const reset = <V extends Transitions>(\n  sm: MachineState<V>\n): MachineState<V> => {\n  return init<V>(sm.machine as any);\n};\n\nexport const validateMachine = <V extends Transitions>(\n  smOrTransitions: Machine<V> | Transitions | TransitionsStrict\n): [ machine: Machine<V> | undefined, msg: string ] => {\n  if (typeof smOrTransitions === `undefined`) {\n    return [ undefined, `Parameter undefined` ];\n  }\n  if ((smOrTransitions as unknown) === null) {\n    return [ undefined, `Parameter null` ];\n  }\n  if (`states` in smOrTransitions) {\n    // Assume Machine type\n    return [ smOrTransitions as Machine<V>, `` ];\n  }\n  if (typeof smOrTransitions === `object`) {\n    return [\n      {\n        states: smOrTransitions as V,\n      },\n      ``,\n    ];\n  }\n  return [\n    undefined,\n    `Unexpected type: ${ typeof smOrTransitions }. Expected object`,\n  ];\n};\n\n// export const validateMachine = <V extends Transitions>(\n//   sm: Machine<V>\n// ): [machine: Machine<V> | undefined, msg: string] => {\n//   if (typeof sm === 'undefined') {\n//     return [undefined, `Parameter 'sm' is undefined`];\n//   }\n//   if (sm === null) return [undefined, `Parameter 'sm' is null`];\n//   if (`states` in sm) {\n//     const [transitions, validationError] = validateAndNormaliseTransitions(\n//       sm.states\n//     );\n//     if (transitions) {\n//       const machine: Machine<V> = {\n//         // @ts-ignore\n//         states: Object.fromEntries(transitions),\n//       };\n//       return [machine, ''];\n//     } else {\n//       return [undefined, validationError];\n//     }\n//   } else {\n//     return [undefined, `Parameter 'sm.states' is undefined`];\n//   }\n// };\n\n/**\n * Returns _true_ if MachineState `sm` is in its final state.\n * @param sm\n * @returns\n */\nexport const isDone = <V extends Transitions>(sm: MachineState<V>): boolean => {\n  return possible(sm).length === 0;\n};\n\n/**\n * Returns a list of possible state targets for `sm`, or\n * an empty list if no transitions are possible.\n * @param sm\n * @returns\n */\nexport const possibleTargets = <V extends Transitions>(\n  sm: MachineState<V>\n): readonly StateTargetStrict<V>[] => {\n  // Validate current state\n  validateMachineState(sm);\n  // get list of possible targets\n  const fromS = sm.machine[ sm.value ];\n\n  if (fromS.length === 1 && fromS[ 0 ].state === null) return [];\n  return fromS;\n};\n\n/**\n * Returns a list of possible state names for `sm`, or\n * an empty list if no transitions are possible.\n *\n * @param sm\n * @returns\n */\nexport const possible = <V extends Transitions>(\n  sm: MachineState<V>\n): (StateNames<V> | null)[] => {\n  const targets = possibleTargets(sm);\n  return targets.map((v) => v.state);\n};\n\nexport const normaliseTargets = <V extends Transitions>(\n  targets:\n    | StateTarget<V>\n    | readonly StateTargetStrict<V>[]\n    | StateTargetStrict<V>\n): StateTargetStrict<V>[] | null | undefined => {\n  const normaliseSingleTarget = (\n    target: string | undefined | null | object\n  ): StateTargetStrict<V> | undefined => {\n    // Terminal target\n    if (target === null) return { state: null };\n    // String is the target state\n    if (typeof target === `string`) {\n      return {\n        state: target,\n      };\n    } else if (typeof target === `object` && `state` in target) {\n      const targetState = target.state;\n      if (typeof targetState !== `string`) {\n        throw new TypeError(\n          `Target 'state' field is not a string. Got: ${ typeof targetState }`\n        );\n      }\n      if (`preconditions` in target) {\n        return {\n          state: targetState,\n          preconditions: target.preconditions as TransitionCondition<V>[],\n        };\n      }\n      return { state: targetState };\n    } else {\n      throw new Error(\n        `Unexpected type: ${ typeof target }. Expected string or object with 'state' field.`\n      );\n    }\n  };\n\n  // Array of targets (either strings or objects)\n  if (Array.isArray(targets)) {\n    let containsNull = false;\n    const mapResults = targets.map((t) => {\n      const r = normaliseSingleTarget(t);\n      if (!r) throw new Error(`Invalid target`);\n      containsNull = containsNull || r.state === null;\n      return r;\n    });\n    if (containsNull && mapResults.length > 1) {\n      throw new Error(`Cannot have null as an possible state`);\n    }\n    return mapResults;\n  } else {\n    const target = normaliseSingleTarget(targets);\n    if (!target) return;\n    return [ target ];\n  }\n};\n\nconst validateAndNormaliseTransitions = (\n  d: Transitions\n): Map<string, StateTargetStrict<typeof d>[]> | undefined => {\n  const returnMap = new Map<string, StateTargetStrict<typeof d>[]>();\n\n  // 1. Index top-level states\n  for (const [ topLevelState, topLevelTargets ] of Object.entries(d)) {\n    if (typeof topLevelState === `undefined`) {\n      throw new TypeError(`Top-level undefined state`);\n    }\n    if (typeof topLevelTargets === `undefined`) {\n      throw new TypeError(`Undefined target state for ${ topLevelState }`);\n    }\n    if (returnMap.has(topLevelState)) {\n      throw new Error(`State defined twice: ${ topLevelState }`);\n    }\n    if (topLevelState.includes(` `)) {\n      throw new Error(`State names cannot contain spaces`);\n    }\n    returnMap.set(topLevelState, []);\n  }\n\n  // 2. Normalise target\n  for (const [ topLevelState, topLevelTargets ] of Object.entries(d)) {\n    const targets = normaliseTargets(topLevelTargets);\n    if (targets === undefined) throw new Error(`Could not normalise target`);\n    if (targets !== null) {\n      // Check that they all exist as top-level states\n      const seenStates = new Set();\n      for (const target of targets) {\n        if (seenStates.has(target.state)) {\n          throw new Error(\n\n            `Target state '${ target.state }' already exists for '${ topLevelState }'`\n          );\n        }\n        seenStates.add(target.state);\n        if (target.state === null) continue;\n        if (!returnMap.has(target.state)) {\n          throw new Error(\n            `Target state '${ target.state }' is not defined as a top-level state. Defined under: '${ topLevelState }'`\n          );\n        }\n      }\n      returnMap.set(topLevelState, targets);\n    }\n  }\n  return returnMap;\n};\n\n/**\n * Validates machine state, throwing an exception if not valid\n * and returning `StateTargetStrict`\n * @param state\n * @returns\n */\nconst validateMachineState = <V extends Transitions>(\n  state: MachineState<V>\n): void => {\n  if (typeof state === `undefined`) {\n    throw new TypeError(`Param 'state' is undefined`);\n  }\n  if (typeof state.value !== `string`) {\n    throw new TypeError(`Existing state is not a string`);\n  }\n};\n\n/**\n * Attempts to transition to a new state. Either a new\n * `MachineState` is returned reflecting the change, or\n * an exception is thrown.\n * @param sm\n * @param toState\n * @returns\n */\nexport const to = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): MachineState<V> => {\n  validateMachineState(sm); // throws if not OK\n  validateTransition(sm, toState); // throws if not OK\n  return Object.freeze({\n    value: toState,\n    machine: sm.machine,\n    visited: unique<string>([ sm.visited as string[], [ sm.value ] as string[] ]),\n  });\n};\n\nexport const next = <V extends Transitions>(\n  sm: MachineState<V>\n): MachineState<V> => {\n  //validateMachineState(sm);\n  const first = possibleTargets(sm).at(0);\n  // eslint-disable-next-line @typescript-eslint/prefer-optional-chain\n  if (!first || first.state === null) {\n    throw new Error(\n      `Not possible to move to a next state from '${ sm.value }`\n    );\n  }\n  return to(sm, first.state);\n};\n\n/**\n * Returns _true_ if `toState` is a valid transition from current state of `sm`\n * @param sm\n * @param toState\n * @returns\n */\nexport const isValidTransition = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): boolean => {\n  try {\n    validateTransition(sm, toState);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\nexport const validateTransition = <V extends Transitions>(\n  sm: MachineState<V>,\n  toState: StateNames<V>\n): void => {\n  if ((toState as unknown) === null) throw new Error(`Cannot transition to null state`);\n  if (typeof toState === `undefined`) {\n    throw new Error(`Cannot transition to undefined state`);\n  }\n  if (typeof toState !== `string`) {\n    throw new TypeError(\n      `Parameter 'toState' should be a string. Got: ${ typeof toState }`\n    );\n  }\n\n  //const toS = sm.machine[toState];\n  //if (typeof toS === 'undefined') throw new Error(`Target state '${toState}' not defined`);\n\n  const p = possible(sm);\n  if (p.length === 0) throw new Error(`Machine is in terminal state`);\n  if (!p.includes(toState)) {\n    throw new Error(\n      `Target state '${ toState }' not available at current state '${ sm.value\n      }'. Possible states: ${ p.join(`, `) }`\n    );\n  }\n};\n\n/**\n * Returns state transitions based on a list of strings.\n * The last string is the terminal state.\n *  A -> B -> C -> D\n * \n * See also: {@link fromListBidirectional}\n *\n * ```js\n * const transitions = fromList([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states List of states\n * @return MachineDescription\n */\nexport const fromList = (...states: readonly string[]): Transitions => {\n  const t = {};\n  if (!Array.isArray(states)) throw new Error(`Expected array of strings`);\n  if (states.length <= 2) throw new Error(`Expects at least two states`);\n  for (let index = 0; index < states.length; index++) {\n    const s = states[ index ] as string;\n    if (typeof s !== `string`) {\n      throw new TypeError(\n        `Expected array of strings. Got type '${ typeof s }' at index ${ index.toString() }`\n      );\n    }\n    t[ s ] = (index === states.length - 1) ? null : states[ index + 1 ] as string;\n  }\n  return t;\n};\n\n/**\n * Returns a machine description based on a list of strings. Machine\n * can go back and forth between states:\n *  A <-> B <-> C <-> D\n * \n * See also {@link fromList}.\n * \n * ```js\n * const transitions = fromListBidirectional([`a`, `b`, `c`, `d`]);\n * // Object state machine with events\n * const sm = new StateMachine.WithEvents(transitions);\n * // OR, immutable state machine\n * const sm = StateMachine.init(transitions);\n * ```\n * @param states\n * @returns\n */\nexport const fromListBidirectional = (\n  ...states: readonly string[]\n): Transitions => {\n  const t = {};\n  if (!Array.isArray(states)) throw new Error(`Expected array of strings`);\n  if (states.length < 2) throw new Error(`Expects at least two states`);\n\n  for (const [ index, s ] of states.entries()) {\n    if (typeof s !== `string`) {\n      throw new TypeError(\n        `Expected array of strings. Got type '${ typeof s }' at index ${ index.toString() }`\n      );\n    }\n    t[ s ] = [];\n  }\n\n  for (let index = 0; index < states.length; index++) {\n    const v = t[ states[ index ] as string ] as string[];\n    if (index === states.length - 1) {\n      if (states.length > 1) {\n        v.push(states[ index - 1 ] as string);\n      } else {\n        t[ states[ index ] as string ] = null;\n      }\n    } else {\n      v.push(states[ index + 1 ] as string);\n      if (index > 0) v.push(states[ index - 1 ] as string);\n    }\n  }\n  return t;\n};\n\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport * as StateMachine from './state-machine.js';\nimport type { StateNames, Transitions, MachineState } from './types.js';\nimport { elapsedInfinity, elapsedSince } from '@ixfx/core/elapsed';\n\nexport type StateChangeEvent<V extends Transitions> = {\n  readonly newState: StateNames<V>;\n  readonly priorState: StateNames<V>;\n};\n\nexport type StopEvent<V extends Transitions> = {\n  readonly state: StateNames<V>;\n};\n\nexport type StateMachineEventMap<V extends Transitions> = {\n  readonly change: StateChangeEvent<V>;\n  readonly stop: StopEvent<V>;\n};\n\nexport type StateMachineWithEventsOptions<V extends Transitions> = {\n  readonly debug?: boolean;\n  readonly initial?: StateNames<V>;\n};\n\n/**\n * A state machine that fires events when state changes.\n * \n * ```js\n * const transitions = StateMachine.fromList(`a`, `b`, `c`);\n * const m = new StateMachineWithEvents(transitions);\n * m.addEventListener(`change`, event => {\n *  console.log(`${event.priorState} -> ${event.newState}`);\n * });\n * m.addEventListener(`stop`, event => {\n *  console.log(`State machine has reached final state`);\n * });\n * ```\n */\nexport class StateMachineWithEvents<\n  V extends Transitions,\n> extends SimpleEventEmitter<StateMachineEventMap<V>> {\n  #sm: MachineState<V>;\n  #smInitial: MachineState<V>;\n\n  #debug: boolean;\n  #isDoneNeedsFiring = false;\n  #isDone = false;\n  #changedAt = elapsedInfinity();\n\n  /**\n   * Create a state machine with initial state, description and options\n   * @param m Machine description\n   * @param opts Options for machine (defaults to `{debug:false}`)\n   */\n  constructor(m: V, opts: StateMachineWithEventsOptions<V> = {}) {\n    super();\n\n    this.#debug = opts.debug ?? false;\n    this.#sm = StateMachine.init(m, opts.initial);\n    this.#smInitial = StateMachine.cloneState(this.#sm);\n  }\n\n\n\n  #setIsDone(v: boolean) {\n    if (this.#isDone === v) return;\n    this.#isDone = v;\n    if (v) {\n      this.#isDoneNeedsFiring = true;\n      setTimeout(() => {\n        if (!this.#isDoneNeedsFiring) return;\n        this.#isDoneNeedsFiring = false;\n        //console.log(`StateMachine isDone (${this.#state}), firing stop.`);\n        this.fireEvent(`stop`, { state: this.#sm.value });\n      }, 2);\n    } else {\n      this.#isDoneNeedsFiring = false;\n    }\n  }\n\n  /**\n   * Return a list of possible states from current state.\n   *\n   * If list is empty, no states are possible. Otherwise lists\n   * possible states, including 'null' for terminal\n   */\n  get statesPossible(): readonly (StateNames<V> | null)[] {\n    return StateMachine.possible(this.#sm);\n  }\n\n  /**\n   * Return a list of all defined states\n   */\n  get statesDefined(): readonly StateNames<V>[] {\n    return Object.keys(this.#sm.machine);\n  }\n\n  /**\n   * Moves to the next state if possible. If multiple states are possible, it will use the first.\n   * If machine is finalised, no error is thrown and null is returned.\n   *\n   * @returns {(string|null)} Returns new state, or null if machine is finalised\n   */\n  next(): string | null {\n    const p = StateMachine.possible(this.#sm);\n    if (p.length === 0) return null;\n    this.state = p[ 0 ]!;\n    return p[ 0 ]!;\n  }\n\n  /**\n   * Returns _true_ if state machine is in its final state\n   *\n   * @returns\n   */\n  get isDone(): boolean {\n    return StateMachine.isDone(this.#sm);\n  }\n\n  /**\n   * Resets machine to initial state\n   */\n  reset() {\n    this.#setIsDone(false);\n    this.#sm = StateMachine.cloneState(this.#smInitial);\n    this.#changedAt = elapsedSince();\n  }\n\n  /**\n   * Throws if it's not valid to transition to `newState`\n   * @param newState\n   * @returns\n   */\n  validateTransition(newState: StateNames<V>): void {\n    StateMachine.validateTransition(this.#sm, newState);\n  }\n\n  /**\n   * Returns _true_ if `newState` is valid transition from current state.\n   * Use {@link validateTransition} if you want an explanation for the _false_ results.\n   * @param newState\n   * @returns\n   */\n  isValid(newState: StateNames<V>): boolean {\n    return StateMachine.isValidTransition(this.#sm, newState);\n  }\n\n  /**\n   * Gets or sets state. Throws an error if an invalid transition is attempted.\n   * Use `isValid()` to check validity without changing.\n   *\n   * If `newState` is the same as current state, the request is ignored silently.\n   */\n  set state(newState: StateNames<V>) {\n    const priorState = this.#sm.value;\n    if (newState === this.#sm.value) return;\n\n    // Try to change state\n    this.#sm = StateMachine.to(this.#sm, newState);\n    if (this.#debug) {\n      console.log(`StateMachine: ${ priorState } -> ${ newState }`);\n    }\n    this.#changedAt = elapsedSince();\n    setTimeout(() => {\n      this.fireEvent(`change`, { newState: newState, priorState: priorState });\n    }, 1);\n\n    if (StateMachine.isDone(this.#sm)) this.#setIsDone(true);\n  }\n\n  get state(): string {\n    return this.#sm.value;\n  }\n\n  /**\n   * Returns timestamp when state was last changed.\n   * See also `elapsed`\n   */\n  get changedAt(): number {\n    return this.#changedAt();\n  }\n\n  /**\n   * Returns milliseconds elapsed since last state change.\n   * See also `changedAt`\n   */\n  get elapsed(): number {\n    return this.#changedAt();\n  }\n}\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport { elapsedMillisecondsAbsolute } from '@ixfx/flow';\nimport { adsrStateTransitions } from './Types.js';\nimport { StateMachineWithEvents } from '@ixfx/flow/state-machine';\nexport const defaultAdsrTimingOpts = Object.freeze({\n    attackDuration: 600,\n    decayDuration: 200,\n    releaseDuration: 800,\n    shouldLoop: false\n});\n/**\n * Base class for an ADSR envelope.\n *\n * It outputs values on a scale of 0..1 corresponding to each phase.\n */\nexport class AdsrBase extends SimpleEventEmitter {\n    #sm;\n    #timeSource;\n    #timer;\n    #holding;\n    #holdingInitial;\n    #disposed = false;\n    #triggered = false;\n    attackDuration;\n    decayDuration;\n    releaseDuration;\n    decayDurationTotal;\n    /**\n     * If _true_ envelope will loop\n     */\n    shouldLoop;\n    constructor(opts = {}) {\n        super();\n        this.attackDuration = opts.attackDuration ?? defaultAdsrTimingOpts.attackDuration;\n        this.decayDuration = opts.decayDuration ?? defaultAdsrTimingOpts.decayDuration;\n        this.releaseDuration = opts.releaseDuration ?? defaultAdsrTimingOpts.releaseDuration;\n        this.shouldLoop = opts.shouldLoop ?? defaultAdsrTimingOpts.shouldLoop;\n        this.#sm = new StateMachineWithEvents(adsrStateTransitions, { initial: `attack` });\n        this.#sm.addEventListener(`change`, (event) => {\n            // Reset timer on release\n            if (event.newState === `release` && this.#holdingInitial) {\n                this.#timer?.reset();\n            }\n            super.fireEvent(`change`, event);\n        });\n        this.#sm.addEventListener(`stop`, (event) => {\n            super.fireEvent(`complete`, event);\n        });\n        this.#timeSource = () => elapsedMillisecondsAbsolute();\n        this.#holding = this.#holdingInitial = false;\n        this.decayDurationTotal = this.attackDuration + this.decayDuration;\n    }\n    dispose() {\n        if (this.#disposed)\n            return;\n        this.#sm.dispose();\n    }\n    get isDisposed() {\n        return this.#disposed;\n    }\n    /**\n     * Changes state based on timer status\n     * @returns _True_ if state was changed\n     */\n    switchStateIfNeeded(allowLooping) {\n        if (this.#timer === undefined)\n            return false;\n        let elapsed = this.#timer.elapsed;\n        const wasHeld = this.#holdingInitial && !this.#holding;\n        // Change through states for as long as needed\n        let hasChanged = false;\n        //console.log(`AdsrBase.switchStateIfNeeded elapsed: ${ elapsed } wasHeld: ${ wasHeld }`);\n        let state = this.#sm.state;\n        do {\n            hasChanged = false;\n            state = this.#sm.state;\n            //console.log(`  AdsrBase.switchStateIfNeeded: ${ state }`);\n            switch (state) {\n                case `attack`: {\n                    if (elapsed > this.attackDuration || wasHeld) {\n                        this.#sm.next();\n                        hasChanged = true;\n                    }\n                    break;\n                }\n                case `decay`: {\n                    if (elapsed > this.decayDurationTotal || wasHeld) {\n                        this.#sm.next();\n                        hasChanged = true;\n                    }\n                    break;\n                }\n                case `sustain`: {\n                    if (!this.#holding || wasHeld) {\n                        elapsed = 0;\n                        this.#sm.next();\n                        this.#timer.reset();\n                        hasChanged = true;\n                    }\n                    break;\n                }\n                case `release`: {\n                    if (elapsed > this.releaseDuration) {\n                        this.#sm.next();\n                        hasChanged = true;\n                    }\n                    break;\n                }\n                case `complete`: {\n                    if (this.shouldLoop && allowLooping) {\n                        this.trigger(this.#holdingInitial);\n                    }\n                }\n            }\n        } while (hasChanged && state !== `complete`);\n        return hasChanged;\n    }\n    /**\n     * Computes a stage's progress from 0-1\n     * @param allowStateChange\n     * @returns\n     */\n    computeRaw(allowStateChange = true, allowLooping = true) {\n        if (this.#timer === undefined) {\n            return [undefined, 0, this.#sm.state];\n        }\n        // Change state if necessary based on elapsed time\n        if (allowStateChange)\n            this.switchStateIfNeeded(allowLooping);\n        const previousStage = this.#sm.state;\n        const elapsed = this.#timer.elapsed;\n        let relative = 0;\n        const state = this.#sm.state;\n        switch (state) {\n            case `attack`: {\n                relative = elapsed / this.attackDuration;\n                break;\n            }\n            case `decay`: {\n                relative = (elapsed - this.attackDuration) / this.decayDuration;\n                break;\n            }\n            case `sustain`: {\n                relative = 1;\n                break;\n            }\n            case `release`: {\n                relative = Math.min(elapsed / this.releaseDuration, 1);\n                break;\n            }\n            case `complete`: {\n                return [`complete`, 1, previousStage];\n            }\n            default: {\n                throw new Error(`State machine in unknown state: ${state}`);\n            }\n        }\n        return [state, relative, previousStage];\n    }\n    /**\n     * Returns _true_ if envelope has finished\n     */\n    get isDone() {\n        return this.#sm.isDone;\n    }\n    onTrigger() {\n        /* no op */\n    }\n    /**\n     * Triggers envelope, optionally _holding_ it.\n     *\n     * If `hold` is _false_ (default), envelope will run through all stages,\n     * but sustain stage won't have an affect.\n     *\n     * If `hold` is _true_, it will run to, and stay at the sustain stage.\n     * Use {@link release} to later release the envelope.\n     *\n     * If event is already trigged it will be _retriggered_.\n     * Initial value depends on `opts.retrigger`\n     * * _false_ (default): envelope continues at current value.\n     * * _true_: envelope value resets to `opts.initialValue`.\n     *\n     * @param hold If _true_ envelope will hold at sustain stage\n     */\n    trigger(hold = false) {\n        this.onTrigger();\n        this.#triggered = true;\n        this.#sm.reset();\n        this.#timer = this.#timeSource();\n        this.#holding = hold;\n        this.#holdingInitial = hold;\n    }\n    get hasTriggered() {\n        return this.#triggered;\n    }\n    compute() {\n        /* no-op */\n    }\n    /**\n     * Release if 'trigger(true)' was previouslly called.\n     * Has no effect if not triggered or held.\n     * @returns\n     */\n    release() {\n        if (this.isDone || !this.#holdingInitial)\n            return; // Was never holding or done\n        // Setting holding flag to false, computeRaw will change state\n        this.#holding = false;\n        this.compute();\n    }\n}\n","import { Paths, Beziers } from '@ixfx/geometry';\nimport { scale } from '@ixfx/numbers';\nimport { AdsrBase } from './AdsrBase.js';\nexport const defaultAdsrOpts = Object.freeze({\n    attackBend: -1,\n    decayBend: -0.3,\n    releaseBend: -0.3,\n    peakLevel: 1,\n    initialLevel: 0,\n    sustainLevel: 0.6,\n    releaseLevel: 0,\n    retrigger: false\n});\nexport class AdsrIterator {\n    adsr;\n    constructor(adsr) {\n        this.adsr = adsr;\n    }\n    next(...args) {\n        if (!this.adsr.hasTriggered) {\n            this.adsr.trigger();\n        }\n        const c = this.adsr.compute();\n        return {\n            value: c[1],\n            done: c[0] === `complete`\n        };\n    }\n    get [Symbol.toStringTag]() {\n        return `Generator`;\n    }\n}\n/**\n * ADSR (Attack Decay Sustain Release) envelope. An envelope is a value that changes over time,\n * usually in response to an intial trigger.\n *\n * [See the ixfx Guide on Envelopes](https://ixfx.fun/modulation/envelopes/introduction/).\n *\n * @example Setup\n * ```js\n * import { Envelopes } from 'https://unpkg.com/ixfx/dist/modulation.js'\n * const env = new Envelopes.Adsr({\n *  attackDuration: 1000,\n *  decayDuration: 200,\n *  sustainDuration: 100\n * });\n * ```\n *\n * Options for envelope are as follows:\n *\n * ```js\n * initialLevel?: number\n * attackBend: number\n * attackDuration: number\n * decayBend: number\n * decayDuration:number\n * sustainLevel: number\n * releaseBend: number\n * releaseDuration: number\n * releaseLevel?: number\n * peakLevel: number\n * retrigger?: boolean\n * shouldLoop: boolean\n * ```\n *\n * If `retrigger` is _false_ (default), a re-triggered envelope continues at current value\n * rather than resetting to `initialLevel`.\n *\n * If `shouldLoop` is true, envelope loops until `release()` is called.\n *\n * @example Using\n * ```js\n * env.trigger(); // Start envelope\n * ...\n * // Get current value of envelope\n * const [state, scaled, raw] = env.compute();\n * ```\n *\n * * `state` is a string, one of the following: 'attack', 'decay', 'sustain', 'release', 'complete'\n * * `scaled` is a value scaled according to the stage's _levels_\n * * `raw` is the progress from 0 to 1 within a stage. ie. 0.5 means we're halfway through a stage.\n *\n * Instead of `compute()`, most usage of the envelope is just fetching the `value` property, which returns the same scaled value of `compute()`:\n *\n * ```js\n * const value = env.value; // Get scaled number\n * ```\n *\n * @example Hold & release\n * ```js\n * env.trigger(true);   // Pass in true to hold\n * ...envelope will stop at sustain stage...\n * env.release();      // Release into decay\n * ```\n *\n * Check if it's done:\n *\n * ```js\n * env.isDone; // True if envelope is completed\n * ```\n *\n * Envelope has events to track activity: 'change' and 'complete':\n *\n * ```\n * env.addEventListener(`change`, ev => {\n *  console.log(`Old: ${evt.oldState} new: ${ev.newState}`);\n * })\n * ```\n *\n * It's also possible to iterate over the values of the envelope:\n * ```js\n * const env = new Envelopes.Adsr();\n * for await (const v of env) {\n *  // v is the numeric value\n *  await Flow.sleep(100); // Want to pause a little to give envelope time to run\n * }\n * // Envelope has finished\n * ```\n */\nexport class Adsr extends AdsrBase {\n    attackPath;\n    decayPath;\n    releasePath;\n    initialLevel;\n    peakLevel;\n    releaseLevel;\n    sustainLevel;\n    attackBend;\n    decayBend;\n    releaseBend;\n    initialLevelOverride;\n    retrigger;\n    releasedAt;\n    constructor(opts = {}) {\n        super(opts);\n        this.retrigger = opts.retrigger ?? defaultAdsrOpts.retrigger;\n        this.initialLevel = opts.initialLevel ?? defaultAdsrOpts.initialLevel;\n        this.peakLevel = opts.peakLevel ?? defaultAdsrOpts.peakLevel;\n        this.releaseLevel = opts.releaseLevel ?? defaultAdsrOpts.releaseLevel;\n        this.sustainLevel = opts.sustainLevel ?? defaultAdsrOpts.sustainLevel;\n        this.attackBend = opts.attackBend ?? defaultAdsrOpts.attackBend;\n        this.releaseBend = opts.releaseBend ?? defaultAdsrOpts.releaseBend;\n        this.decayBend = opts.decayBend ?? defaultAdsrOpts.decayBend;\n        const max = 1;\n        this.attackPath = Beziers.toPath(Beziers.quadraticSimple({ x: 0, y: this.initialLevel }, { x: max, y: this.peakLevel }, -this.attackBend));\n        this.decayPath = Beziers.toPath(Beziers.quadraticSimple({ x: 0, y: this.peakLevel }, { x: max, y: this.sustainLevel }, -this.decayBend));\n        this.releasePath = Beziers.toPath(Beziers.quadraticSimple({ x: 0, y: this.sustainLevel }, { x: max, y: this.releaseLevel }, -this.releaseBend));\n    }\n    onTrigger() {\n        this.initialLevelOverride = undefined;\n        if (!this.retrigger) {\n            const [_stage, scaled, _raw] = this.compute(true, false);\n            //console.log(`Adsr stage: ${ _stage } scaled: ${ scaled } raw: ${ _raw }`);\n            if (!Number.isNaN(scaled) && scaled > 0) {\n                this.initialLevelOverride = scaled;\n            }\n        }\n    }\n    [Symbol.iterator]() {\n        return new AdsrIterator(this);\n    }\n    /**\n     * Returns the scaled value\n     * Same as .compute()[1]\n     */\n    get value() {\n        return this.compute(true)[1];\n    }\n    /**\n     * Compute value of envelope at this point in time.\n     *\n     * Returns an array of [stage, scaled, raw]. Most likely you want to use {@link value} to just get the scaled value.\n     * @param allowStateChange If true (default) envelope will be allowed to change state if necessary before returning value\n     */\n    compute(allowStateChange = true, allowLooping = true) {\n        const [stage, amt] = super.computeRaw(allowStateChange, allowLooping);\n        //console.log(`Adsr.compute: stage: ${ stage } amt: ${ amt }!`);\n        // Stage is undefined when envelope is complete or underlying timer is undefined\n        if (stage === undefined)\n            return [undefined, Number.NaN, Number.NaN];\n        let v;\n        switch (stage) {\n            case `attack`: {\n                v = this.attackPath.interpolate(amt).y;\n                if (this.initialLevelOverride !== undefined) {\n                    v = scale(v, 0, 1, this.initialLevelOverride, 1);\n                }\n                this.releasedAt = v;\n                break;\n            }\n            case `decay`: {\n                v = this.decayPath.interpolate(amt).y;\n                this.releasedAt = v;\n                break;\n            }\n            case `sustain`: {\n                v = this.sustainLevel;\n                this.releasedAt = v;\n                break;\n            }\n            case `release`: {\n                v = this.releasePath.interpolate(amt).y;\n                // Bound release level to the amp level that we released at.\n                // ie. when release happens before a stage completes\n                if (this.releasedAt !== undefined) {\n                    v = scale(v, 0, this.sustainLevel, 0, this.releasedAt);\n                }\n                break;\n            }\n            case `complete`: {\n                v = this.releaseLevel;\n                this.releasedAt = undefined;\n                break;\n            }\n            default: {\n                throw new Error(`Unknown state: ${stage}`);\n            }\n        }\n        return [stage, v, amt];\n    }\n}\n","import { Adsr } from './Adsr.js';\nimport { resolveWithFallbackSync } from '@ixfx/core';\nimport { repeat } from '@ixfx/flow';\nexport * from './Types.js';\nexport * from './Adsr.js';\nexport * from './AdsrBase.js';\n/**\n * Returns a function that iterates over an envelope\n * ```js\n * const e = Envelopes.adsr();\n *\n * e(); // Yields current value\n * ```\n *\n * Starts the envelope the first time the return function is called.\n * When the envelope finishes, it continues to return the `releaseLevel` of the envelope.\n *\n * Options can be provided to set the shape of the envelope as usual, eg:\n * ```js\n * const e = Envelopes.adsr({\n *  attackDuration: 1000,\n *  releaseDuration: 500\n * });\n * ```\n * @param opts\n * @returns\n */\nexport const adsr = (opts = {}) => {\n    const envelope = new Adsr(opts);\n    const finalValue = envelope.releaseLevel;\n    const iterator = envelope[Symbol.iterator]();\n    return () => resolveWithFallbackSync(iterator, { overrideWithLast: true, value: finalValue });\n};\n/**\n * Creates and runs an envelope, sampling its values at `sampleRateMs`.\n * Note that if the envelope loops, iterator never returns.\n *\n * @example Init\n * ```js\n * import { Envelopes } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * import { IterableAsync } from  'https://unpkg.com/ixfx/dist/util.js';\n *\n * const opts = {\n *  attackDuration: 1000,\n *  releaseDuration: 1000,\n *  sustainLevel: 1,\n *  attackBend: 1,\n *  decayBend: -1\n * };\n * ```\n *\n * ```js\n * //  Add data to array\n * // Sample an envelope every 20ms into an array\n * const data = await IterableAsync.toArray(Envelopes.adsrIterable(opts, 20));\n * ```\n *\n * ```js\n * // Iterate with `for await`\n * // Work with values as sampled\n * for await (const v of Envelopes.adsrIterable(opts, 5)) {\n *  // Work with envelope value `v`...\n * }\n * ```\n * @param opts Envelope options\n * @returns\n */\nexport async function* adsrIterable(opts) {\n    const envelope = new Adsr(opts.env);\n    const sampleRateMs = opts.sampleRateMs ?? 100;\n    envelope.trigger();\n    const r = repeat(() => envelope.value, {\n        while: () => !envelope.isDone,\n        delay: sampleRateMs,\n        signal: opts.signal,\n    });\n    for await (const v of r) {\n        yield v;\n    }\n}\n","import { throwIntegerTest } from \"@ixfx/guards\";\n/**\n * Returns a function which cycles between 0..1 (inclusive of 0 and 1).\n * `totalTicks` is how many ticks it takes to get to 1. Since we want an inclusive 0 & 1,\n * the total ticks is actually +1.\n *\n * Ie. if totalTicks = 10, we get: 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0\n *\n * Use 'exclusiveStart' and 'exclusiveEnd' flags to shift range. Eg, with `totalTicks` of 10:\n * * 'exclusiveStart:true': first value is 0.1, last value is 1.0 (10 values total)\n * * 'exclusiveEnd:true': first value is 0, last value is 0.9 (10 values total)\n * * If both are true, first value is 0.1, last value is 0.9 (9 values total)\n * * If both are false (or not set), we get the case described earlier, first value is 0, last value is 1 (11 values total)\n *\n * Other examples:\n * * totalTicks: 20, value goes up by 0.05\n * * totalTicks: 1, value goes up by 1\n * @param totalTicks Positive, integer value. How many ticks to complete a cycle\n * @param options\n * @returns\n */\nexport function ticks(totalTicks, options = {}) {\n    throwIntegerTest(totalTicks, `aboveZero`, `totalTicks`);\n    const exclusiveStart = options.exclusiveStart ?? false;\n    const exclusiveEnd = options.exclusiveEnd ?? false;\n    const cycleLimit = options.cycleLimit ?? Number.MAX_SAFE_INTEGER;\n    const startPoint = exclusiveStart ? 1 : 0;\n    const endPoint = exclusiveEnd ? totalTicks - 1 : totalTicks;\n    let cycleCount = 0;\n    let v = options.startAt ?? startPoint;\n    if (options.startAtRelative) {\n        let totalTicksForReal = totalTicks;\n        if (exclusiveStart)\n            totalTicksForReal--;\n        if (exclusiveEnd)\n            totalTicksForReal--;\n        v = Math.round(options.startAtRelative * totalTicksForReal);\n    }\n    return (feedback) => {\n        if (feedback) {\n            if (feedback.resetAt !== undefined) {\n                v = feedback.resetAt;\n            }\n            if (feedback.resetAtRelative !== undefined) {\n                v = Math.floor(feedback.resetAtRelative * totalTicks);\n            }\n        }\n        if (cycleCount >= cycleLimit)\n            return 1;\n        const current = v / totalTicks;\n        v++;\n        if (v > endPoint) {\n            cycleCount++;\n            v = startPoint;\n        }\n        return current;\n    };\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { throwNumberTest } from \"@ixfx/guards\";\n/**\n * Returns the percentage of time toward `interval`. See also: {@link bpm}, {@link hertz} which are the same but\n * using different units for time.\n *\n * By default, it continues forever, cycling from 0..1 repeatedly for each interval. Use\n * `cycleLimit` to restrict this. A value of 1 means it won't loop.\n *\n * The starting 'position' is `performance.now()`. If `startAt` option is provided, this will be used instead.\n * It probably should be an offset of `performance.now()`, eg: `{ startAt: performance.now() - 500 }` to shift\n * the cycle by 500ms.\n *\n * When using `startAtRelative`, the starting position will be set backward by the relative amount. A value\n * of 0.5, for example, will set the timer back 50% of the interval, meaning the cycle will start half way through.\n *\n * @param interval\n * @param options\n * @returns\n */\nexport function elapsed(interval, options = {}) {\n    const cycleLimit = options.cycleLimit ?? Number.MAX_SAFE_INTEGER;\n    const limitValue = 1;\n    let start = options.startAt ?? performance.now();\n    let cycleCount = 0;\n    const intervalMs = intervalToMs(interval, 1000);\n    if (options.startAtRelative) {\n        throwNumberTest(options.startAtRelative, `percentage`, `startAtRelative`);\n        start = performance.now() - (intervalMs * options.startAtRelative);\n    }\n    //let stopAt = cycleLimit > 0 ? (intervalMs + start) : Number.MAX_SAFE_INTEGER;\n    return (feedback) => {\n        if (feedback) {\n            if (feedback.resetAt !== undefined) {\n                start = feedback.resetAt;\n                if (start === 0)\n                    start = performance.now();\n            }\n            if (feedback.resetAtRelative !== undefined) {\n                throwNumberTest(feedback.resetAtRelative, `percentage`, `resetAtRelative`);\n                start = performance.now() - (intervalMs * feedback.resetAtRelative);\n            }\n        }\n        if (cycleCount >= cycleLimit)\n            return limitValue;\n        const now = performance.now();\n        const elapsedCycle = now - start;\n        if (elapsedCycle >= intervalMs) {\n            cycleCount += Math.floor(elapsedCycle / intervalMs);\n            start = now;\n            if (cycleCount >= cycleLimit)\n                return limitValue;\n        }\n        return (elapsedCycle % intervalMs) / intervalMs;\n    };\n    // } else {\n    //   return () => ((performance.now() - start) % intervalMs) / intervalMs;\n    // }\n}\n/**\n * Counts beats based on a BPM.\n * Uses {@link elapsed} internally.\n * @param bpm\n * @param options\n * @returns\n */\nexport function bpm(bpm, options = {}) {\n    const interval = (60 * 1000) / bpm; // milliseconds between beats.\n    return elapsed(interval, options);\n}\n/**\n * Counts based on hertz (oscillations per second).\n * Uses {@link elapsed} internally.\n * @param hz\n * @param options\n * @returns\n */\nexport function hertz(hz, options = {}) {\n    const interval = 1000 / hz;\n    return elapsed(interval, options);\n}\n","/**\n * Returns a proportion of `amount` depending on elapsed time.\n * Cumulatively, `amount` is yielded every second.\n *\n * ```js\n * // Calculate a proportion of 0.1 every second\n * const x = perSecond(0.1);\n * x();\n * ```\n *\n * The faster `x()` is called, the smaller the chunks of `amount` are returned.\n * Values accumulate. For example, `x()` isn't called for two seconds, 2*amount is returned.\n *\n * @example Usage\n * ```js\n * const settings = {\n *  ageMod: perSecond(0.1);\n * };\n *\n * let state = {\n *  age: 1\n * };\n *\n * // Update\n * setInterval(() => {\n *  let { age } = state;\n *  // Add 0.1 per second, regardless of\n *  // loop speed\n *  age += settings.ageMod();\n *  state = {\n *    ...state,\n *    age: clamp(age)\n *  }\n * });\n * ```\n *\n * Use the `clamp` option so the returned value never exceeds `amount`.\n * Alternatively, `min`/`max` options allow you to set arbitrary limits.\n * @param amount\n * @returns\n */\nexport const perSecond = (amount, options = {}) => {\n    const perMilli = amount / 1000;\n    let min = options.min ?? Number.MIN_SAFE_INTEGER;\n    let max = options.max ?? Number.MAX_SAFE_INTEGER;\n    const clamp = options.clamp ?? false;\n    if (clamp && options.max)\n        throw new Error(`Use either 'max' or 'clamp', not both.`);\n    if (clamp)\n        max = amount;\n    let called = performance.now();\n    return () => {\n        const now = performance.now();\n        const elapsed = now - called;\n        called = now;\n        const x = perMilli * elapsed;\n        if (x > max)\n            return max;\n        if (x < min)\n            return min;\n        return x;\n    };\n};\n/**\n * As {@link perSecond}, but per minute.\n * @param amount\n * @param options\n * @returns\n */\nexport const perMinute = (amount, options = {}) => {\n    return perSecond(amount / 60, options);\n};\n","export * from './ticks.js';\nexport * from './time.js';\nexport * from './per-second.js';\n","/**\n * Creates an easing function using a simple cubic bezier defined by two points.\n *\n * Eg: https://cubic-bezier.com/#0,1.33,1,-1.25\n *  a:0, b: 1.33, c: 1, d: -1.25\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Time-based easing using bezier\n * const e = Easings.time(fromCubicBezier(1.33, -1.25), 1000);\n * e.compute();\n * ```\n * @param b\n * @param d\n * @returns Value\n */\nexport const cubicBezierShape = (b, d) => (t) => {\n    const s = 1 - t;\n    const s2 = s * s;\n    const t2 = t * t;\n    const t3 = t2 * t;\n    return 3 * b * s2 * t + 3 * d * s * t2 + t3;\n};\n","/**\n * WIP\n * Returns a {@link Drifter} that moves a value over time.\n *\n * It keeps track of how much time has elapsed, accumulating `driftAmtPerMs`.\n * The accumulated drift is wrapped on a 0..1 scale.\n * ```js\n * // Set up the drifer\n * const d = drif(0.001);\n *\n * d.update(1.0);\n * // Returns 1.0 + accumulated drift\n * ```\n * @param driftAmtPerMs\n * @returns\n */\nexport const drift = (driftAmtPerMs) => {\n    //eslint-disable-next-line functional/no-let\n    let lastChange = performance.now();\n    const update = (v = 1) => {\n        const elapsed = performance.now() - lastChange;\n        const amt = (driftAmtPerMs * elapsed) % 1;\n        lastChange = performance.now();\n        const calc = (v + amt) % 1;\n        return calc;\n    };\n    const reset = () => {\n        lastChange = performance.now();\n    };\n    return { update, reset };\n};\n","//const sqrt = Math.sqrt;\nconst pow = Math.pow;\n//const pi = Math.PI;\n//const piPi = Math.PI*2;\nconst gaussianA = 1 / Math.sqrt(2 * Math.PI);\n/**\n * Returns a roughly gaussian easing function\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = Easings.gaussian();\n * ```\n *\n * Try different positive and negative values for `stdDev` to pinch\n * or flatten the bell shape.\n * @param standardDeviation\n * @returns\n */\nexport const gaussian = (standardDeviation = 0.4) => {\n    //const a = 1 / sqrt(2 * pi);\n    const mean = 0.5;\n    return (t) => {\n        const f = gaussianA / standardDeviation;\n        // p:-8 pinched\n        let p = -2.5; // -1/1.25;\n        let c = (t - mean) / standardDeviation;\n        c *= c;\n        p *= c;\n        const v = f * pow(Math.E, p); // * (2/pi);//0.62;\n        if (v > 1)\n            return 1;\n        if (v < 0)\n            return 0;\n        return v;\n    };\n};\n","import { gaussian } from \"../gaussian.js\";\n// Easings from https://easings.net/\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst cos = Math.cos;\nconst pi = Math.PI;\nconst sin = Math.sin;\nexport const bounceOut = (x) => {\n    const n1 = 7.5625;\n    const d1 = 2.75;\n    if (x < 1 / d1) {\n        return n1 * x * x;\n    }\n    else if (x < 2 / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    }\n    else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    }\n    else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984_375;\n    }\n};\nexport const quintIn = (x) => x * x * x * x * x;\nexport const quintOut = (x) => 1 - pow(1 - x, 5);\nexport const arch = (x) => x * (1 - x) * 4;\nexport const smoothstep = (x) => x * x * (3 - 2 * x);\nexport const smootherstep = (x) => (x * (x * 6 - 15) + 10) * x * x * x;\nexport const sineIn = (x) => 1 - cos((x * pi) / 2);\nexport const sineOut = (x) => sin((x * pi) / 2);\nexport const quadIn = (x) => x * x;\nexport const quadOut = (x) => 1 - (1 - x) * (1 - x);\nexport const sineInOut = (x) => -(cos(pi * x) - 1) / 2;\nexport const quadInOut = (x) => x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2;\nexport const cubicIn = (x) => x * x * x;\nexport const cubicOut = (x) => 1 - pow(1 - x, 3);\nexport const quartIn = (x) => x * x * x * x;\nexport const quartOut = (x) => 1 - pow(1 - x, 4);\nexport const expoIn = (x) => (x === 0 ? 0 : pow(2, 10 * x - 10));\nexport const expoOut = (x) => (x === 1 ? 1 : 1 - pow(2, -10 * x));\nexport const quintInOut = (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2;\nexport const expoInOut = (x) => x === 0\n    ? 0\n    : x === 1\n        ? 1\n        // eslint-disable-next-line unicorn/no-nested-ternary\n        : x < 0.5\n            ? pow(2, 20 * x - 10) / 2\n            : (2 - pow(2, -20 * x + 10)) / 2;\nexport const circIn = (x) => 1 - sqrt(1 - pow(x, 2));\nexport const circOut = (x) => sqrt(1 - pow(x - 1, 2));\nexport const backIn = (x) => {\n    const c1 = 1.701_58;\n    const c3 = c1 + 1;\n    return c3 * x * x * x - c1 * x * x;\n};\nexport const backOut = (x) => {\n    const c1 = 1.701_58;\n    const c3 = c1 + 1;\n    return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\n};\nexport const circInOut = (x) => x < 0.5\n    ? (1 - sqrt(1 - pow(2 * x, 2))) / 2\n    : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;\nexport const backInOut = (x) => {\n    const c1 = 1.701_58;\n    const c2 = c1 * 1.525;\n    return x < 0.5\n        ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\n        : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n};\nexport const elasticIn = (x) => {\n    const c4 = (2 * pi) / 3;\n    return x === 0\n        ? 0\n        : (x === 1\n            ? 1\n            : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4));\n};\nexport const elasticOut = (x) => {\n    const c4 = (2 * pi) / 3;\n    return x === 0\n        ? 0\n        : (x === 1\n            ? 1\n            : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1);\n};\nexport const bounceIn = (x) => 1 - bounceOut(1 - x);\nexport const bell = gaussian();\nexport const elasticInOut = (x) => {\n    const c5 = (2 * pi) / 4.5;\n    return x === 0\n        ? 0\n        : x === 1\n            ? 1\n            // eslint-disable-next-line unicorn/no-nested-ternary\n            : x < 0.5\n                ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2\n                : (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\n};\nexport const bounceInOut = (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2;\n","import { Points, Beziers } from '@ixfx/geometry';\nimport { scale } from '@ixfx/numbers';\n/**\n * Interpolates points along a line.\n * By default it's a straight line, so use `bend` to make a non-linear curve.\n * @param bend -1...1. -1 will pull line up, 1 will push it down.\n * @returns\n */\nexport const line = (bend = 0, warp = 0) => {\n    const max = 1;\n    const cubicB = {\n        x: scale(bend, -1, 1, 0, max),\n        y: scale(bend, -1, 1, max, 0),\n    };\n    // Add in bend as 'drive'\n    let cubicA = Points.interpolate(Math.abs(bend), Points.Empty, cubicB);\n    // Warp\n    if (bend !== 0 && warp > 0) {\n        if (bend > 0) {\n            cubicA = Points.interpolate(warp, cubicA, { x: 0, y: cubicB.x * 2 });\n        }\n        else {\n            cubicA = Points.interpolate(warp, cubicA, { x: cubicB.y * 2, y: 0 });\n        }\n    }\n    const bzr = Beziers.cubic(Points.Empty, Points.Unit, cubicA, cubicB);\n    const inter = Beziers.interpolator(bzr);\n    return (value) => inter(value);\n};\n","import { intervalToMs } from \"@ixfx/core\";\nimport * as Flow from '@ixfx/flow';\nimport { throwFunctionTest } from \"@ixfx/guards\";\n/**\n * Produce values over time. When the modulate function is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n *\n * ```js\n * const fn = (t) => {\n *  // 't' will be values 0..1 where 1 represents end of time period.\n *  // Return some computed value based on 't'\n *  return t*Math.random();\n * }\n * const e = Modulate.time(fn, 1000);\n *\n * // Keep calling e() to get the current value\n * e();\n * ```\n * @param fn Modulate function\n * @param duration Duration\n * @returns\n */\nexport const time = (fn, duration) => {\n    throwFunctionTest(fn, `fn`);\n    let relative;\n    return () => {\n        if (relative === undefined)\n            relative = Flow.ofTotal(duration, { clampValue: true });\n        return fn(relative());\n    };\n};\n/**\n * Creates an modulator based on clock time. Time\n * starts being counted when modulate function is created.\n *\n * `timeModulator` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n * @example Time based easing\n * ```\n * import { timeModulator } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = (t) => {\n *  // 't' will be a value 0..1 representing time elapsed. 1 being end of period.\n *  return t*Math.random();\n * }\n * const t = timeModulator(fn, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of modulator\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param fn Modulator\n * @param duration Duration\n * @returns ModulatorTimed\n */\nexport const timeModulator = (fn, duration) => {\n    throwFunctionTest(fn, `fn`);\n    const timer = Flow.elapsedMillisecondsAbsolute();\n    const durationMs = intervalToMs(duration);\n    if (durationMs === undefined)\n        throw new Error(`Param 'duration' not provided`);\n    const relativeTimer = Flow.relative(durationMs, {\n        timer,\n        clampValue: true\n    });\n    return Flow.timerWithFunction(fn, relativeTimer);\n};\n/**\n * Produce modulate values with each invocation. When the time is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n *\n * If you need to check if a modulator is done or reset it, consider {@link tickModulator}.\n *\n * ```js\n * const fn = (t) => {\n *  // 't' will be values 0..1 representing elapsed ticks toward totwal\n * }\n * const e = ticks(fn, 100);\n *\n * // Keep calling e() to get the current value\n * e();\n * ```\n * @param fn Function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns\n */\nexport const ticks = (fn, totalTicks) => {\n    throwFunctionTest(fn, `fn`);\n    let relative;\n    return () => {\n        if (relative === undefined)\n            relative = Flow.ofTotalTicks(totalTicks, { clampValue: true });\n        return fn(relative());\n    };\n};\n/**\n * Creates an modulator based on ticks.\n *\n * `tickModulator` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based modulator\n * ```\n * import { tickModulator } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = (t) => {\n *  // 't' will be values 0..1 based on completion\n *  return Math.random() * t;\n * }\n * const t = tickModulator(fn, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param fn Modulate function that returns 0..1\n * @param durationTicks Duration in ticks\n * @returns ModulatorTimed\n */\nexport const tickModulator = (fn, durationTicks) => {\n    throwFunctionTest(fn, `fn`);\n    const timer = Flow.elapsedTicksAbsolute();\n    const relativeTimer = Flow.relative(durationTicks, {\n        timer,\n        clampValue: true\n    });\n    return Flow.timerWithFunction(fn, relativeTimer);\n};\n","import * as Named from './easings-named.js';\nimport { throwStringTest } from '@ixfx/guards';\nimport {} from '@ixfx/core';\nexport * as Named from './easings-named.js';\nexport * from './line.js';\nimport * as ModuleTimed from '../modulator-timed.js';\n/**\n * Creates an easing function\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const e = Easings.create({ duration: 1000, name: `quadIn` });\n * const e = Easings.create({ ticks: 100, name: `sineOut` });\n * const e = Easings.create({\n *  duration: 1000,\n *  fn: (v) => {\n *    // v will be 0..1 based on time\n *    return Math.random() * v\n *  }\n * });\n * ```\n * @param options\n * @returns\n */\nexport const create = (options) => {\n    const name = resolveEasingName(options.name ?? `quintIn`);\n    const fn = name ?? options.fn;\n    if (typeof fn === `undefined`)\n        throw new Error(`Either 'name' or 'fn' must be set`);\n    if (`duration` in options) {\n        return time(fn, options.duration);\n    }\n    else if (`ticks` in options) {\n        return ticks(fn, options.ticks);\n    }\n    else {\n        throw new Error(`Expected 'duration' or 'ticks' in options`);\n    }\n};\n/**\n * Creates an easing based on clock time. Time\n * starts being counted when easing function is created.\n *\n * `timeEasing` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n *\n * @example Time based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.timeEasing(`quintIn`, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of easing\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n *\n * Thisi function is just a wrapper around Modulator.timedModulator.\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration\n * @returns Easing\n */\nexport const timeEasing = (nameOrFunction, duration) => {\n    const fn = resolveEasingName(nameOrFunction);\n    return ModuleTimed.timeModulator(fn, duration);\n    // const timer = Timer.elapsedMillisecondsAbsolute();\n    // const durationMs = intervalToMs(duration);\n    // if (durationMs === undefined) throw new Error(`Param 'duration' not provided`);\n    // const relativeTimer = Timer.relative(\n    //   durationMs,\n    //   {\n    //     timer,\n    //     clampValue: true\n    //   });\n    // return Timer.timerWithFunction(fn, relativeTimer);\n};\n/**\n * Produce easing values over time. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n *\n * If you need to check if an easing is done or reset it, consider {@link timeEasing}.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Quad-in easing over one second\n * const e = Easings.time(`quadIn`, 1000);\n *\n * // Keep calling e() to get the current value\n * e();\n * ```\n *\n * This function is just a wrapper around Modulate.time\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param duration Duration\n * @returns\n */\nexport const time = (nameOrFunction, duration) => {\n    const fn = resolveEasingName(nameOrFunction);\n    return ModuleTimed.time(fn, duration);\n    // let relative: undefined | (() => number);\n    // return () => {\n    //   if (relative === undefined) relative = Timer.ofTotal(duration, { clampValue: true });\n    //   return fn(relative());\n    // }\n};\n/**\n * Produce easing values with each invocation. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n *\n * If you need to check if an easing is done or reset it, consider {@link tickEasing}.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Quad-in easing over 100 ticks\n * const e = Easings.ticks(`quadIn`, 100);\n *\n * // Keep calling e() to get the current value\n * e();\n * ```\n *\n * This is just a wrapper around Modulator.ticks\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns\n */\nexport const ticks = (nameOrFunction, totalTicks) => {\n    const fn = resolveEasingName(nameOrFunction);\n    return ModuleTimed.ticks(fn, totalTicks);\n    // let relative: undefined | (() => number);\n    // return () => {\n    //   if (relative === undefined) relative = Timer.ofTotalTicks(totalTicks, { clampValue: true });\n    //   return fn(relative());\n    // }\n};\n/**\n * Creates an easing based on ticks.\n *\n * `tickEasing` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.tickEasing(`sineIn`, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param durationTicks Duration in ticks\n * @returns Easing\n */\nexport const tickEasing = (nameOrFunction, durationTicks) => {\n    const fn = resolveEasingName(nameOrFunction);\n    return ModuleTimed.tickModulator(fn, durationTicks);\n    // const timer = Timer.elapsedTicksAbsolute();\n    // const relativeTimer = Timer.relative(\n    //   durationTicks,\n    //   {\n    //     timer,\n    //     clampValue: true\n    //   });\n    // return Timer.timerWithFunction(fn, relativeTimer);\n};\nconst resolveEasingName = (nameOrFunction) => {\n    const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n    if (typeof fn === `undefined`) {\n        const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${nameOrFunction}'`) : new Error(`Easing function not found`);\n        throw error;\n    }\n    return fn;\n};\n/**\n * Creates a new easing by name\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const e = Easings.create(`circInOut`, 1000, elapsedMillisecondsAbsolute);\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration (meaning depends on timer source)\n * @param timerSource Timer source\n * @returns\n */\n// const create = function (\n//   nameOrFunction: EasingName | ((v: number) => number),\n//   duration: number,\n//   timerSource: TimerSource\n// ): Easing {\n//   const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n//   if (fn === undefined) {\n//     const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${ nameOrFunction }'`) : new Error(`Easing function not found`);\n//     throw error;\n//   }\n//   // Get a relative version of timer\n//   const timer = relativeTimer(duration, {\n//     timer: timerSource(),\n//     clampValue: true,\n//   });\n//   let startCount = 1;\n//   return {\n//     get isDone() {\n//       return timer.isDone;\n//     },\n//     get runState() {\n//       if (timer.isDone) return `idle`;\n//       return `scheduled`;\n//     },\n//     /**\n//      * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n//      */\n//     get startCount() {\n//       return startCount;\n//     },\n//     get startCountTotal() {\n//       return startCount;\n//     },\n//     compute: () => {\n//       const relative = timer.elapsed;\n//       return fn(relative);\n//     },\n//     reset: () => {\n//       timer.reset();\n//       startCount++;\n//     },\n//   };\n// };\nlet easingsMap;\n/**\n * Returns an easing function by name. Throws an error if\n * easing is not found.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = Easings.get(`sineIn`);\n * // Returns 'eased' transformation of 0.5\n * fn(0.5);\n * ```\n * @param easingName eg `sineIn`\n * @returns Easing function\n */\nexport const get = function (easingName) {\n    throwStringTest(easingName, `non-empty`, `easingName`);\n    const found = cacheEasings().get(easingName.toLowerCase());\n    if (found === undefined)\n        throw new Error(`Easing not found: '${easingName}'`);\n    return found;\n};\n// Cache named easings\nfunction cacheEasings() {\n    if (easingsMap === undefined) {\n        easingsMap = new Map();\n        for (const [k, v] of Object.entries(Named)) {\n            easingsMap.set(k.toLowerCase(), v);\n        }\n        return easingsMap;\n    }\n    else\n        return easingsMap;\n}\n/**\n * Iterate over available easings.\n * @private\n * @returns Returns list of available easing names\n */\nexport function* getEasingNames() {\n    const map = cacheEasings();\n    yield* map.keys();\n}\n;\n","/**\n * Acknowledgements: much of the work here is an adapation from Daniel Shiffman's excellent _The Nature of Code_ website.\n */\nimport { Points, Polar, Rects } from '@ixfx/geometry';\nimport { clamp } from '@ixfx/numbers';\nimport { interpolateAngle } from '@ixfx/numbers';\n/**\n * Throws an error if `t` is not of the `ForceAffected` shape.\n * @param t\n * @param name\n */\nexport const guard = (t, name = `t`) => {\n    if (t === undefined) {\n        throw new Error(`Parameter ${name} is undefined. Expected ForceAffected`);\n    }\n    if (t === null) {\n        throw new Error(`Parameter ${name} is null. Expected ForceAffected`);\n    }\n    if (typeof t !== `object`) {\n        throw new TypeError(`Parameter ${name} is type ${typeof t}. Expected object of shape ForceAffected`);\n    }\n};\n/**\n * `constrainBounce` yields a function that affects `t`'s position and velocity such that it\n * bounces within bounds.\n *\n * ```js\n * // Setup bounce with area constraints\n * // Reduce velocity by 10% with each impact\n * const b = constrainBounce({ width:200, height:500 }, 0.9);\n *\n * // Thing\n * const t = {\n *  position: { x: 50,  y: 50 },\n *  velocity: { x: 0.3, y: 0.01 }\n * };\n *\n * // `b` returns an altereted version of `t`, with the\n * // bounce logic applied.\n * const bounced = b(t);\n * ```\n *\n * `dampen` parameter allows velocity to be dampened with each bounce. A value\n * of 0.9 for example reduces velocity by 10%. A value of 1.1 will increase velocity by\n * 10% with each bounce.\n * @param bounds Constraints of area\n * @param dampen How much to dampen velocity by. Defaults to 1 meaning there is no damping.\n * @returns A function that can perform bounce logic\n */\nexport const constrainBounce = (bounds, dampen = 1) => {\n    if (!bounds)\n        bounds = { width: 1, height: 1 };\n    const minX = Rects.getEdgeX(bounds, `left`);\n    const maxX = Rects.getEdgeX(bounds, `right`);\n    const minY = Rects.getEdgeY(bounds, `top`);\n    const maxY = Rects.getEdgeY(bounds, `bottom`);\n    return (t) => {\n        const position = computePositionFromVelocity(t.position ?? Points.Empty, t.velocity ?? Points.Empty);\n        let velocity = t.velocity ?? Points.Empty;\n        let { x, y } = position;\n        if (x > maxX) {\n            x = maxX;\n            velocity = Points.invert(Points.multiplyScalar(velocity, dampen), `x`);\n        }\n        else if (x < minX) {\n            x = minX;\n            velocity = Points.invert(Points.multiplyScalar(velocity, dampen), `x`);\n        }\n        if (y > maxY) {\n            y = maxY;\n            velocity = Points.multiplyScalar(Points.invert(velocity, `y`), dampen);\n        }\n        else if (position.y < minY) {\n            y = minY;\n            velocity = Points.invert(Points.multiplyScalar(velocity, dampen), `y`);\n        }\n        return Object.freeze({\n            ...t,\n            position: { x, y },\n            velocity,\n        });\n    };\n};\n/**\n * For a given set of attractors, returns a function that a sets acceleration of attractee.\n * Keep note though that this bakes-in the values of the attractor, it won't reflect changes to their state. For dynamic\n * attractors, it might be easier to use `computeAttractionForce`.\n *\n * @example Force\n * ```js\n * const f = Forces.attractionForce(sun, gravity);\n * earth = Forces.apply(earth, f);\n * ```\n *\n * @example Everything mutually attracted\n * ```js\n * // Create a force with all things as attractors.\n * const f = Forces.attractionForce(things, gravity);\n * // Apply force to all things.\n * // The function returned by attractionForce will automatically ignore self-attraction\n * things = things.map(a => Forces.apply(a, f));\n * ```\n * @param attractors\n * @param gravity\n * @param distanceRange\n * @returns\n */\nexport const attractionForce = (attractors, gravity, distanceRange = {}) => (attractee) => {\n    let accel = attractee.acceleration ?? Points.Empty;\n    for (const a of attractors) {\n        if (a === attractee)\n            continue;\n        const f = computeAttractionForce(a, attractee, gravity, distanceRange);\n        accel = Points.sum(accel, f);\n    }\n    return {\n        ...attractee,\n        acceleration: accel,\n    };\n};\n/**\n * Computes the attraction force between two things.\n * Value for `gravity` will depend on what range is used for `mass`. It's probably a good idea\n * to keep mass to mean something relative - ie 1 is 'full' mass, and adjust the `gravity`\n * value until it behaves as you like. Keeping mass in 0..1 range makes it easier to apply to\n * visual properties later.\n *\n * @example Attractee and attractor, gravity 0.005\n * ```js\n * const attractor = { position: { x:0.5, y:0.5 }, mass: 1 };\n * const attractee = { position: Points.random(), mass: 0.01 };\n * attractee = Forces.apply(attractee, Forces.computeAttractionForce(attractor, attractee, 0.005));\n * ```\n *\n * @example Many attractees for one attractor, gravity 0.005\n * ```js\n * attractor =  { position: { x:0.5, y:0.5 }, mass: 1 };\n * attractees = attractees.map(a => Forces.apply(a, Forces.computeAttractionForce(attractor, a, 0.005)));\n * ```\n *\n * @example Everything mutually attracted\n * ```js\n * // Create a force with all things as attractors.\n * const f = Forces.attractionForce(things, gravity);\n * // Apply force to all things.\n * // The function returned by attractionForce will automatically ignore self-attraction\n * things = things.map(a => Forces.apply(a, f));\n * ```\n *\n * `attractor` thing attracting (eg, earth)\n * `attractee` thing being attracted (eg. satellite)\n *\n *\n * `gravity` will have to be tweaked to taste.\n * `distanceRange` clamps the computed distance. This affects how tightly the particles will orbit and can also determine speed. By default it is 0.001-0.7\n * @param attractor Attractor (eg earth)\n * @param attractee Attractee (eg satellite)\n * @param gravity Gravity constant\n * @param distanceRange Min/max that distance is clamped to.\n * @returns\n */\nexport const computeAttractionForce = (attractor, attractee, gravity, distanceRange = {}) => {\n    if (attractor.position === undefined) {\n        throw new Error(`attractor.position not set`);\n    }\n    if (attractee.position === undefined) {\n        throw new Error(`attractee.position not set`);\n    }\n    const distributionRangeMin = distanceRange.min ?? 0.01;\n    const distributionRangeMax = distanceRange.max ?? 0.7;\n    // Vector between objects\n    const f = Points.normalise(Points.subtract(attractor.position, attractee.position));\n    // Distance\n    const d = clamp(Points.distance(f), distributionRangeMin, distributionRangeMax);\n    // Multiply vector by gravity, scaled by mass of things and distance\n    return Points.multiplyScalar(f, (gravity * (attractor.mass ?? 1) * (attractee.mass ?? 1)) / (d * d));\n};\n/**\n * A force that moves a thing toward `targetPos`.\n *\n * ```js\n * const t = Forces.apply(t, Forces.targetForce(targetPos));\n * ```\n * @param targetPos\n * @param opts\n * @returns\n */\nexport const targetForce = (targetPos, opts = {}) => {\n    const fn = (t) => {\n        const accel = computeAccelerationToTarget(targetPos, t.position ?? { x: 0.5, y: 0.5 }, opts);\n        return {\n            ...t,\n            acceleration: Points.sum(t.acceleration ?? Points.Empty, accel),\n        };\n    };\n    return fn;\n};\n/**\n * Returns `pt` with x and y set to `setpoint` if either's absolute value is below `v`\n * @param pt\n * @param v\n * @returns\n */\n// const roundTo = (pt: Point, v: number, setpoint: number): Point => {\n//   const x = Math.abs(pt.x);\n//   const y = Math.abs(pt.y);\n//   if (x < v && y < v) return { x: setpoint, y: setpoint };\n//   if (x < v) return { x: setpoint, y: pt.y };\n//   if (y < v) return { x: pt.x, y: setpoint };\n//   return pt;\n// };\n/**\n * Apply a series of force functions or forces to `t`. Null/undefined entries are skipped silently.\n * It also updates the velocity and position of the returned version of `t`.\n *\n * ```js\n * // Wind adds acceleration. Force is dampened by mass\n * const wind = Forces.accelerationForce({ x: 0.00001, y: 0 }, `dampen`);\n *\n * // Gravity adds acceleration. Force is magnified by mass\n * const gravity = Forces.accelerationForce({ x: 0, y: 0.0001 }, `multiply`);\n *\n * // Friction is calculated based on velocity. Force is magnified by mass\n * const friction = Forces.velocityForce(0.00001, `multiply`);\n *\n *  // Flip movement velocity if we hit a wall. And dampen it by 10%\n * const bouncer = Forces.constrainBounce({ width: 1, height: 1 }, 0.9);\n *\n * let t = {\n *  position: Points.random(),\n *  mass: 0.1\n * };\n *\n * // Apply list of forces, returning a new version of the thing\n * t = Forces.apply(t,\n *   gravity,\n *   wind,\n *   friction,\n *   bouncer\n * );\n * ```\n */\nexport const apply = (t, ...accelForces) => {\n    if (t === undefined)\n        throw new Error(`t parameter is undefined`);\n    for (const f of accelForces) {\n        if (f === null || f === undefined)\n            continue;\n        t = typeof f === `function` ? f(t) : {\n            ...t,\n            acceleration: Points.sum(t.acceleration ?? Points.Empty, f),\n        };\n    }\n    // Integate velocity from acceleration\n    const velo = computeVelocity(t.acceleration ?? Points.Empty, t.velocity ?? Points.Empty);\n    // Compute position\n    const pos = computePositionFromVelocity(t.position ?? Points.Empty, velo);\n    const ff = {\n        ...t,\n        position: pos,\n        velocity: velo,\n        // Clear accel, because it has been integrated into velocity\n        acceleration: Points.Empty,\n    };\n    return ff;\n};\n/**\n * Apples `vector` to acceleration, scaling according to mass, based on the `mass` option.\n * It returns a function which can later be applied to a thing.\n *\n * ```js\n * import { Forces } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * // Acceleration vector of (0.1, 0), ie moving straight on horizontal axis\n * const f = Forces.accelerationForce({ x:0.1, y:0 }, `dampen`);\n *\n * // Thing to move\n * let t = { position: ..., acceleration: ... }\n *\n * // Apply force\n * t = f(t);\n * ```\n * @param vector\n * @returns Force function\n */\nexport const accelerationForce = (vector, mass = `ignored`) => (t) => Object.freeze({\n    ...t,\n    acceleration: massApplyAccel(vector, t, mass), //Points.sum(t.acceleration ?? Points.Empty, op(t.mass ?? 1))\n});\n/**\n * Returns an acceleration vector with mass either dampening or multiplying it.\n * The passed-in `thing` is not modified.\n *\n * ```js\n * // Initial acceleration vector\n * const accel = { x: 0.1, y: 0};\n *\n * // Thing being moved\n * const thing = { mass: 0.5, position: ..., acceleration: ... }\n *\n * // New acceleration vector, affected by mass of `thing`\n * const accelWithMass = massApplyAccel(accel, thing, `dampen`);\n * ```\n * Mass of thing can be factored in, according to `mass` setting. Use `dampen`\n * to reduce acceleration with greater mass of thing. Use `multiply` to increase\n * the effect of acceleration with a greater mass of thing. `ignored` means\n * mass is not taken into account.\n *\n * If `t` has no mass, the `mass` setting is ignored.\n *\n * This function is used internally by the predefined forces.\n *\n * @param vector Vector force\n * @param thing Thing being affected\n * @param mass How to factor in mass of thing (default ignored)\n * @returns Acceleration vector\n */\nconst massApplyAccel = (vector, thing, mass = `ignored`) => {\n    let op;\n    switch (mass) {\n        case `dampen`: {\n            op = (mass) => Points.divide(vector, mass, mass);\n            break;\n        }\n        case `multiply`: {\n            op = (mass) => Points.multiply(vector, mass, mass);\n            break;\n        }\n        case `ignored`: {\n            op = (_mass) => vector;\n            break;\n        }\n        default: {\n            throw new Error(`Unknown 'mass' parameter '${mass}. Expected 'dampen', 'multiply' or 'ignored'`);\n        }\n    }\n    return Points.sum(thing.acceleration ?? Points.Empty, op(thing.mass ?? 1));\n    // if (t.mass) {\n    //   if (dampen) return Points.sum(t.acceleration ?? Points.Empty, Points.divide(v, t.mass ?? 1));\n    //   else return Points.sum(t.acceleration ?? Points.Empty, Points.multiply(v, t.mass ?? 1));\n    // }\n    // return v;\n};\n/**\n * A force based on the square of the thing's velocity.\n * It's like {@link velocityForce}, but here the velocity has a bigger impact.\n *\n * ```js\n * const thing = {\n *  position: { x: 0.5, y:0.5 },\n *  velocity: { x: 0.001, y:0 }\n * };\n * const drag = magnitudeForce(0.1);\n *\n * // Apply drag force to thing, returning result\n * const t = Forces.apply(thing, drag);\n * ```\n * @param force Force value\n * @param mass How to factor in mass\n * @returns Function that computes force\n */\nexport const magnitudeForce = (force, mass = `ignored`) => (t) => {\n    if (t.velocity === undefined)\n        return t;\n    const mag = Points.distance(Points.normalise(t.velocity));\n    const magSq = force * mag * mag;\n    const vv = Points.multiplyScalar(Points.invert(t.velocity), magSq);\n    return Object.freeze({\n        ...t,\n        acceleration: massApplyAccel(vv, t, mass),\n    });\n};\n/**\n * Null force does nothing\n * @returns A force that does nothing\n */\nexport const nullForce = (t) => t;\n/**\n * Force calculated from velocity of object. Reads velocity and influences acceleration.\n *\n * ```js\n * let t = { position: Points.random(), mass: 0.1 };\n * const friction = velocityForce(0.1, `dampen`);\n *\n * // Apply force, updating position and velocity\n * t = Forces.apply(t, friction);\n * ```\n * @param force Force\n * @param mass How to factor in mass\n * @returns Function that computes force\n */\nexport const velocityForce = (force, mass) => {\n    // Invert velocity and then multiply by force\n    const pipeline = Points.pipeline(\n    // Points.normalise,\n    Points.invert, (v) => Points.multiplyScalar(v, force));\n    return (t) => {\n        if (t.velocity === undefined)\n            return t;\n        // Apply pipeline\n        const v = pipeline(t.velocity);\n        return Object.freeze({\n            ...t,\n            acceleration: massApplyAccel(v, t, mass),\n        });\n    };\n};\n/**\n * Sets angle, angularVelocity and angularAcceleration based on\n *  angularAcceleration, angularVelocity, angle\n * @returns\n */\nexport const angularForce = () => (t) => {\n    const accumulator = t.angularAcceleration ?? 0;\n    const vel = t.angularVelocity ?? 0;\n    const angle = t.angle ?? 0;\n    const v = vel + accumulator;\n    const a = angle + v;\n    return Object.freeze({\n        ...t,\n        angle: a,\n        angularVelocity: v,\n        angularAcceleration: 0,\n    });\n};\n// export const positionFromAngleForce = () => (t:ForceAffected) => {\n//   return Object.freeze({\n//     ...t,\n//     position: computePositionFromAngle()\n//   });\n// };\n/**\n * Yields a force function that applies the thing's acceleration.x to its angular acceleration.\n * @param scaling Use this to scale the accel.x value. Defaults to 20 (ie accel.x*20). Adjust if rotation is too much or too little\n * @returns\n */\nexport const angleFromAccelerationForce = (scaling = 20) => (t) => {\n    const accel = t.acceleration ?? Points.Empty;\n    return Object.freeze({\n        ...t,\n        angularAcceleration: accel.x * scaling,\n    });\n};\n/**\n * Yields a force function that applies the thing's velocity to its angle.\n * This will mean it points in the direction of travel.\n * @param interpolateAmt If provided, the angle will be interpolated toward by this amount. Defaults to 1, no interpolation\n * @returns\n */\nexport const angleFromVelocityForce = (interpolateAmt = 1) => (t) => {\n    const a = Points.angleRadian(t.velocity ?? Points.Empty);\n    return Object.freeze({\n        ...t,\n        angle: interpolateAmt < 1\n            ? interpolateAngle(interpolateAmt, t.angle ?? 0, a)\n            : a,\n    });\n};\n/**\n * Spring force\n *\n *  * ```js\n * // End of spring that moves\n * let thing = {\n *   position: { x: 1, y: 0.5 },\n *   mass: 0.1\n * };\n *\n * // Anchored other end of spring\n * const pinnedAt = {x: 0.5, y: 0.5};\n *\n * // Create force: length of 0.4\n * const springForce = Forces.springForce(pinnedAt, 0.4);\n *\n * continuously(() => {\n *  // Apply force\n *  thing = Forces.apply(thing, springForce);\n * }).start();\n * ```\n * [Read more](https://www.joshwcomeau.com/animation/a-friendly-introduction-to-spring-physics/)\n *\n * @param pinnedAt Anchored end of the spring\n * @param restingLength Length of spring-at-rest (default: 0.5)\n * @param k Spring stiffness (default: 0.0002)\n * @param damping Damping factor to apply, so spring slows over time. (default: 0.995)\n * @returns\n */\nexport const springForce = (pinnedAt, restingLength = 0.5, k = 0.0002, damping = 0.999) => (t) => {\n    const direction = Points.subtract(t.position ?? Points.Empty, pinnedAt);\n    const mag = Points.distance(direction);\n    const stretch = Math.abs(restingLength - mag);\n    const f = Points.pipelineApply(direction, Points.normalise, (p) => Points.multiplyScalar(p, -k * stretch));\n    const accel = massApplyAccel(f, t, `dampen`);\n    const velo = computeVelocity(accel ?? Points.Empty, t.velocity ?? Points.Empty);\n    const veloDamped = Points.multiply(velo, damping, damping);\n    return {\n        ...t,\n        velocity: veloDamped,\n        acceleration: Points.Empty,\n    };\n};\n/**\n * The pendulum force swings something back and forth.\n *\n * ```js\n * // Swinger\n * let thing = {\n *   position: { x: 1, y: 0.5 },\n *   mass: 0.1\n * };\n *\n * // Position thing swings from (middle of screen)\n * const pinnedAt = {x: 0.5, y: 0.5};\n *\n * // Create force: length of 0.4\n * const pendulumForce = Forces.pendulumForce(pinnedAt, { length: 0.4 });\n *\n * continuously(() => {\n *  // Apply force\n *  // Returns a new thing with recalculated angularVelocity, angle and position.\n *  thing = Forces.apply(thing, pendulumForce);\n * }).start();\n * ```\n *\n * [Read more](https://natureofcode.com/book/chapter-3-oscillation/)\n *\n * @param pinnedAt Location to swing from (x:0.5, y:0.5 default)\n * @param opts Options\n * @returns\n */\nexport const pendulumForce = (pinnedAt, opts = {}) => (t) => {\n    if (!pinnedAt)\n        pinnedAt = { x: 0, y: 0 };\n    const length = opts.length ?? Points.distance(pinnedAt, t.position ?? Points.Empty);\n    const speed = opts.speed ?? 0.001;\n    const damping = opts.damping ?? 0.995;\n    let angle = t.angle;\n    if (angle === undefined) {\n        if (t.position) {\n            angle = Points.angleRadian(pinnedAt, t.position) - Math.PI / 2;\n        }\n        else {\n            angle = 0; // Position wherever\n        }\n    }\n    const accel = ((-1 * speed) / length) * Math.sin(angle);\n    const v = (t.angularVelocity ?? 0) + accel;\n    angle += v;\n    return Object.freeze({\n        angularVelocity: v * damping,\n        angle,\n        position: computePositionFromAngle(length, angle + Math.PI / 2, pinnedAt),\n    });\n};\n/**\n * Compute velocity based on acceleration and current velocity\n * @param acceleration Acceleration\n * @param velocity Velocity\n * @param velocityMax If specified, velocity will be capped at this value\n * @returns\n */\nexport const computeVelocity = (acceleration, velocity, velocityMax) => {\n    const p = Points.sum(velocity, acceleration);\n    return velocityMax === undefined ? p : Points.clampMagnitude(p, velocityMax);\n};\n/**\n * Returns the acceleration to get from `currentPos` to `targetPos`.\n *\n * @example Barebones usage:\n * ```js\n * const accel = Forces.computeAccelerationToTarget(targetPos, currentPos);\n * const vel = Forces.computeVelocity(accel, currentVelocity);\n *\n * // New position:\n * const pos = Points.sum(currentPos, vel);\n * ```\n *\n * @example Implementation:\n * ```js\n * const direction = Points.subtract(targetPos, currentPos);\n * const accel = Points.multiply(direction, diminishBy);\n * ```\n * @param currentPos Current position\n * @param targetPos Target position\n * @param opts Options\n * @returns\n */\nexport const computeAccelerationToTarget = (targetPos, currentPos, opts = {}) => {\n    const diminishBy = opts.diminishBy ?? 0.001;\n    // Compare to current position of thing to get vector direction\n    const direction = Points.subtract(targetPos, currentPos);\n    if (opts.range && // If direction is less than range, return { x: 0, y: 0}\n        Points.compare(Points.abs(direction), opts.range) === -2) {\n        return Points.Empty;\n    }\n    // Diminish vector to make a meaningful acceleration\n    return Points.multiplyScalar(direction, diminishBy);\n};\n/**\n * Compute a new position based on existing position and velocity vector\n * @param position Position Current position\n * @param velocity Velocity vector\n * @returns Point\n */\nexport const computePositionFromVelocity = (position, velocity) => Points.sum(position, velocity);\n/**\n * Compute a position based on distance and angle from origin\n * @param distance Distance from origin\n * @param angleRadians Angle, in radians from origin\n * @param origin Origin point\n * @returns Point\n */\nexport const computePositionFromAngle = (distance, angleRadians, origin) => Polar.toCartesian(distance, angleRadians, origin);\nconst _angularForce = angularForce();\nconst _angleFromAccelerationForce = angleFromAccelerationForce();\n/**\n * A force that orients things according to direction of travel.\n *\n * Under the hood, it applies:\n * * angularForce,\n * * angleFromAccelerationForce, and\n * * angleFromVelocityForce\n * @param interpolationAmt\n * @returns\n */\nexport const orientationForce = (interpolationAmt = 0.5) => {\n    const angleFromVel = angleFromVelocityForce(interpolationAmt);\n    return (t) => {\n        t = _angularForce(t);\n        t = _angleFromAccelerationForce(t);\n        t = angleFromVel(t);\n        return t;\n    };\n};\n","export const piPi = Math.PI * 2;\n","import { clamp, wrap } from \"@ixfx/numbers\";\nimport { ofTotal } from \"@ixfx/flow\";\nimport { throwNumberTest } from '@ixfx/guards';\nimport { get as getEasing } from './easing/index.js';\nimport { piPi } from \"./util/pi-pi.js\";\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide on Interpolation](https://ixfx.fun/data/interpolation/overview/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * interpolate(0.5, 30, 60);\n * ```\n *\n * See also {@link interpolatorStepped} and {@link interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n *\n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n *\n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n *\n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * To interpolate certain types: {@link Visual.Colour.interpolator | Visual.Colour.interpolator }, {@link Geometry.Points.interpolate | Points.interpolate}.\n *\n * There are a few variations when calling `interpolate`, depending on what parameters are fixed.\n * * `interpolate(amount)`: returns a function that needs a & b\n * * `interpolate(a, b)`:  returns a function that needs the interpolation amount\n */\nexport function interpolate(pos1, pos2, pos3, pos4) {\n    let amountProcess;\n    let limits = `clamp`;\n    const handleAmount = (amount) => {\n        if (amountProcess)\n            amount = amountProcess(amount);\n        if (limits === undefined || limits === `clamp`) {\n            amount = clamp(amount);\n        }\n        else if (limits === `wrap`) {\n            if (amount > 1)\n                amount = amount % 1;\n            else if (amount < 0) {\n                amount = 1 + (amount % 1);\n            }\n        }\n        return amount;\n    };\n    const doTheEase = (_amt, _a, _b) => {\n        throwNumberTest(_a, ``, `a`);\n        throwNumberTest(_b, ``, `b`);\n        throwNumberTest(_amt, ``, `amount`);\n        _amt = handleAmount(_amt);\n        return (1 - _amt) * _a + _amt * _b;\n    };\n    const readOpts = (o = {}) => {\n        if (o.easing) {\n            const easer = getEasing(o.easing);\n            if (!easer)\n                throw new Error(`Easing function '${o.easing}' not found`);\n            amountProcess = easer;\n        }\n        else if (o.transform) {\n            if (typeof o.transform !== `function`)\n                throw new Error(`Param 'transform' is expected to be a function. Got: ${typeof o.transform}`);\n            amountProcess = o.transform;\n        }\n        limits = o.limits ?? `clamp`;\n    };\n    const rawEase = (_amt, _a, _b) => (1 - _amt) * _a + _amt * _b;\n    if (typeof pos1 !== `number`)\n        throw new TypeError(`First param is expected to be a number. Got: ${typeof pos1}`);\n    if (typeof pos2 === `number`) {\n        let a;\n        let b;\n        if (pos3 === undefined || typeof pos3 === `object`) {\n            //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n            a = pos1;\n            b = pos2;\n            readOpts(pos3);\n            return (amount) => doTheEase(amount, a, b);\n        }\n        else if (typeof pos3 === `number`) {\n            //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n            a = pos2;\n            b = pos3;\n            readOpts(pos4);\n            return doTheEase(pos1, a, b);\n        }\n        else {\n            throw new Error(`Values for 'a' and 'b' not defined`);\n        }\n    }\n    else if (pos2 === undefined || typeof pos2 === `object`) {\n        //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n        const amount = handleAmount(pos1);\n        readOpts(pos2);\n        throwNumberTest(amount, ``, `amount`);\n        return (aValue, bValue) => rawEase(amount, aValue, bValue);\n    }\n}\n;\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link interpolatorInterval}\n * which steps on the basis of clock time.\n *\n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n *\n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n *\n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n *\n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n *\n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns\n */\nexport const interpolatorStepped = (incrementAmount, a = 0, b = 1, startInterpolationAt = 0, options) => {\n    let amount = startInterpolationAt;\n    return (retargetB, retargetA) => {\n        if (retargetB !== undefined)\n            b = retargetB;\n        if (retargetA !== undefined)\n            a = retargetA;\n        if (amount >= 1)\n            return b;\n        const value = interpolate(amount, a, b, options);\n        amount += incrementAmount;\n        return value;\n    };\n};\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (amount, aRadians, bRadians, options) => {\n    const t = wrap(bRadians - aRadians, 0, piPi);\n    return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n/**\n * Interpolates between A->B over `duration`.\n * Given the same A & B values, steps will be larger if it's a longer\n * duration, and shorter if it's a smaller duration.\n *\n * A function is returned, which when invoked yields a value between A..B.\n *\n * Alternatively to step through by the same amount regardless\n * of time, use {@link interpolatorStepped}.\n *\n * ```js\n * // Interpolate from 0..1 over one minute\n * const v = interpolatorInterval({mins:1});\n * v(); // Compute current value\n * ```\n *\n * Use start and end points:\n * ```js\n * // Interpolate from 100-200 over 10 seconds\n * const v = interpolatorInterval({secs:10}, 100, 200);\n * v(); // Compute current value\n * ```\n * @param duration Duration for interpolation\n * @param a Start point\n * @param b End point\n * @param options Options for interpolation\n * @returns\n */\nexport const interpolatorInterval = (duration, a = 0, b = 1, options) => {\n    const durationProgression = ofTotal(duration, { clampValue: true });\n    return (retargetB, retargetA) => {\n        const amount = durationProgression();\n        if (retargetB !== undefined)\n            b = retargetB;\n        if (retargetA !== undefined)\n            a = retargetA;\n        if (amount >= 1)\n            return b;\n        const value = interpolate(amount, a, b, options);\n        return value;\n    };\n};\n","import { throwNumberTest } from '@ixfx/guards';\nimport { clamp } from '@ixfx/numbers';\nimport { floatSource as randomFloatFunction, float as randomFloat } from '@ixfx/random';\n/**\n * Returns a {@link Jitterer} that works with absolute values,\n * ie. values outside of 0..1 range.\n *\n * Jitter amount is _absolute_, meaning a fixed value regardless of input value,\n * or _relative_, meaning it is scaled according to input value.\n *\n * ```js\n * // Jitter by -10 to +10 (absolute value: 10)\n * const j1 = jitterAbsolute({ absolute: 10 });\n * j1(100); // Produces range of 90...110\n *\n * // Jitter by -20 to +20 (relative value 20%)\n * const j2 = jitterAbsolute({ relative: 0.20 });\n * j2(100); // Produces a range of -80...120\n * ```\n *\n * The expected used case is calling `jitterAbsolute` to set up a jitterer\n * and then reusing it with different input values, as above with the `j1` and `j2`.\n *\n * However to use it 'one-off', just call the returned function immediately:\n * ```js\n * const v = jitterAbsolute({ absolute: 10 })(100); // v is in range of 90-110\n * ```\n *\n * When `clamped` is true, return value is clamped to 0...value.\n * That is, rather than the usual bipolar jittering, the jittering only goes below.\n * ```js\n * const j = jitterAbsolute({ absolute: 10, clamped: true })\n * j(100); // Produces range of 90-100\n * ```\n * @param options\n * @returns\n */\nexport const jitterAbsolute = (options) => {\n    const { relative, absolute } = options;\n    const clamped = options.clamped ?? false;\n    const source = options.source ?? Math.random;\n    if (absolute !== undefined) {\n        return (value) => {\n            const abs = (source() * absolute * 2) - absolute;\n            const valueNew = value + abs;\n            if (clamped)\n                return clamp(valueNew, 0, value);\n            return valueNew;\n        };\n    }\n    if (relative !== undefined) {\n        return (value) => {\n            const rel = value * relative;\n            const abs = (source() * rel * 2) - rel;\n            const valueNew = value + abs;\n            if (clamped)\n                return clamp(valueNew, 0, value);\n            return valueNew;\n        };\n    }\n    throw new Error(`Either absolute or relative fields expected`);\n};\n/**\n * Jitters `value` by the absolute `jitter` amount. Returns a function.\n *\n * All values should be on a 0..1 scale, and the return value is by default clamped to 0..1.\n * Pass `clamped:false` as an option to allow for arbitary ranges.\n *\n * `jitter` returns a function that calculates jitter. If you only need a one-off\n * jitter, you can immediately execute the returned function:\n * ```js\n * import { jitter } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * // Compute 10% jitter of input 0.5\n * const value = jitter({ relative: 0.1 })(0.5);\n * ```\n *\n * However, if the returned jitter function is to be used again,\n * assign it to a variable:\n * ```js\n * import { jitter } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * const myJitter = jitter({ absolute: 0.5 });\n *\n * // Jitter an input value 1.0\n * const value = myJitter(1);\n * ```\n *\n * A custom source for random numbers can be provided. Eg, use a weighted\n * random number generator:\n *\n * ```js\n * import { weighted } from 'https://unpkg.com/ixfx/dist/random.js';\n * jitter({ relative: 0.1, source: weighted });\n * ```\n *\n * Options\n * * clamped: If false, `value`s out of percentage range can be used and return value may be beyond percentage range. True by default\n * * random: Random source (default is Math.random)\n * @param options Options\n * @returns Function that performs jitter\n */\nexport const jitter = (options = {}) => {\n    const clamped = options.clamped ?? true;\n    let r = (_) => 0;\n    if (options.absolute !== undefined) {\n        throwNumberTest(options.absolute, clamped ? `percentage` : `bipolar`, `opts.absolute`);\n        const absRand = randomFloatFunction({\n            min: -options.absolute,\n            max: options.absolute,\n            source: options.source,\n        });\n        r = (v) => v + absRand();\n    }\n    else if (options.relative === undefined) {\n        throw new TypeError(`Either absolute or relative jitter amount is required.`);\n    }\n    else {\n        const rel = options.relative ?? 0.1;\n        throwNumberTest(rel, clamped ? `percentage` : `bipolar`, `opts.relative`);\n        r = (v) => v +\n            randomFloat({\n                min: -Math.abs(rel * v),\n                max: Math.abs(rel * v),\n                source: options.source,\n            });\n    }\n    const compute = (value) => {\n        throwNumberTest(value, clamped ? `percentage` : `bipolar`, `value`);\n        //eslint-disable-next-line functional/no-let\n        let v = r(value);\n        if (clamped)\n            v = clamp(v);\n        return v;\n    };\n    return compute;\n};\n","import { interpolate } from \"@ixfx/numbers\";\n/**\n * Mixes in modulation. This is used when you want to\n * fold in a controllable amount of modulation.\n *\n * For example, we have a base value of 0.5 (50%) that we want to modulate\n * by 0.9 (90%). That is, reduce its value by 10%. `mix` allows us\n * to slowly ramp up to the fully modulated value.\n *\n * ```js\n * import { mix } from 'https://unpkg.com/ixfx/dist/modulation.js'\n * // When 'amt' is 0, modulation doesn't affect value at all,\n * // original is returned\n * mix(0, 0.5, 0.9); // 0.5\n * // Mixing in 50% of modulation\n * mix(0.5, 0.5, 0.9); // 0.475\n * // All modulation applied, so now we get 90% of 0.5\n * mix(1, 0.5, 0.9); // 0.45 (ie. 90% of 0.5)\n * ```\n * @param amount Amount of modulation (0..1). 0 means modulation value has no effect\n * @param original Original value to modulate\n * @param modulation Modulation amount (0..1)\n * @returns\n */\nexport const mix = (amount, original, modulation) => {\n    const m = modulation * amount;\n    const base = (1 - amount) * original;\n    return base + (original * m);\n};\n/**\n * Returns a modulator that mixes between two modulation functions.\n * Both modulators are given the same input value.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Get a 50/50 mix of two easing functions\n * const mix = Easings.mix(0.5, Easings.Named.sineIn, Easings.Named.sineOut);\n *\n * // 10% of sineIn, 90% of sineOut\n * Easings.mix(0.90, 0.25, Easings.Named.sineIn, Easings.Named.sineOut);\n * ```\n * @param balance Mix between a and b\n * @param a\n * @param b\n * @returns Numeric value\n */\nexport const mixModulators = (balance, a, b) => (amt) => interpolate(balance, a(amt), b(amt));\n/**\n * Returns a 'crossfader` function of two easing functions, synchronised with the progress through the easing.\n *\n * Example `amt` values:\n * * 0.0 will yield 100% of easingA at its `easing(0)` value.\n * * 0.2 will yield 80% of easingA, 20% of easingB, both at their `easing(0.2)` values\n * * 0.5 will yield 50% of both functions both at their `easing(0.5)` values\n * * 0.8 will yield 20% of easingA, 80% of easingB, with both at their `easing(0.8)` values\n * * 1.0 will yield 100% of easingB at its `easing(1)` value.\n *\n * So easingB will only ever kick in at higher `amt` values and `easingA` will only be present in lower values.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * Easings.crossFade(0.5, Easings.Named.sineIn, Easings.Named.sineOut);\n * ```\n * @param a Easing A\n * @param b Easing B\n * @returns Numeric value\n */\nexport const crossfade = (a, b) => {\n    return (amt) => {\n        const mixer = mixModulators(amt, a, b);\n        return mixer(amt);\n    };\n};\n","/**\n * A 'no-op' function. Returns the input value without modification.\n * Useful for when some default is needed\n * @param v\n * @returns\n */\nexport const noop = (v) => v;\n","import * as Flow from '@ixfx/flow';\nconst piPi = Math.PI * 2;\n/**\n * Sine oscillator.\n *\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist//flow.js\";\n * // Setup\n * const osc = Oscillators.sine(frequencyTimer(10));\n * const osc = Oscillators.sine(0.1);\n *\n * // Call whenever a value is needed\n * const v = osc.next().value;\n * ```\n *\n * @example Saw/tri pinch\n * ```js\n * const v = Math.pow(osc.value, 2);\n * ```\n *\n * @example Saw/tri bulge\n * ```js\n * const v = Math.pow(osc.value, 0.5);\n * ```\n *\n */\nexport function* sine(timerOrFreq) {\n    if (timerOrFreq === undefined)\n        throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n    if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    while (true) {\n        // Rather than -1 to 1, we want 0 to 1\n        yield (Math.sin(timerOrFreq.elapsed * piPi) + 1) / 2;\n    }\n}\n/**\n * Bipolar sine (-1 to 1)\n * @param timerOrFreq\n */\nexport function* sineBipolar(timerOrFreq) {\n    if (timerOrFreq === undefined)\n        throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n    if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    while (true) {\n        yield Math.sin(timerOrFreq.elapsed * piPi);\n    }\n}\n/**\n * Triangle oscillator\n *\n * ```js\n * // Setup\n * const osc = triangle(Timers.frequencyTimer(0.1));\n * const osc = triangle(0.1);\n *\n * // Call whenver a value is needed\n * const v = osc.next().value;\n * ```\n */\nexport function* triangle(timerOrFreq) {\n    if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    while (true) {\n        // elapsed is repeatedly 0->1\n        //eslint-disable-next-line functional/no-let\n        let v = timerOrFreq.elapsed;\n        // /2 = 0->0.5\n        if (v < 0.5) {\n            // Upward\n            v *= 2;\n        }\n        else {\n            // Downward\n            v = 2 - v * 2;\n        }\n        yield v;\n    }\n}\n/**\n * Saw oscillator\n *\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist//flow.js\";\n * // Setup\n * const osc = Oscillators.saw(Timers.frequencyTimer(0.1));\n *\n * // Or\n * const osc = Oscillators.saw(0.1);\n *\n * // Call whenever a value is needed\n * const v = osc.next().value;\n * ```\n */\nexport function* saw(timerOrFreq) {\n    if (timerOrFreq === undefined)\n        throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n    if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    while (true) {\n        yield timerOrFreq.elapsed;\n    }\n}\n/**\n * Square oscillator\n *\n * ```js\n * import { Oscillators } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n *\n * // Setup\n * const osc = Oscillators.square(Timers.frequencyTimer(0.1));\n * const osc = Oscillators.square(0.1);\n *\n * // Call whenever a value is needed\n * osc.next().value;\n * ```\n */\nexport function* square(timerOrFreq) {\n    if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    while (true) {\n        yield timerOrFreq.elapsed < 0.5 ? 0 : 1;\n    }\n}\n","import { throwNumberTest } from '@ixfx/guards';\n/**\n * Continually loops up and down between 0 and 1 by a specified interval.\n * Looping returns start value, and is inclusive of 0 and 1.\n *\n * @example Usage\n * ```js\n * import {percentPingPong} from 'https://unpkg.com/ixfx/dist/modulation.js';\n * for (const v of percentPingPong(0.1)) {\n *  // v will go up and down. Make sure you have a break somewhere because it is infinite\n * }\n * ```\n *\n * @example Alternative:\n * ```js\n * const pp = pingPongPercent(0.1, 0.5); // Setup generator one time\n * const v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n *\n * Because limits are capped to -1 to 1, using large intervals can produce uneven distribution. Eg an interval of 0.8 yields 0, 0.8, 1\n *\n * `upper` and `lower` define the percentage range. Eg to ping pong between 40-60%:\n * ```\n * const pp = pingPongPercent(0.1, 0.4, 0.6);\n * ```\n * @param interval Amount to increment by. Defaults to 10%\n * @param start Starting point within range. Defaults to 0 using a positive interval or 1 for negative intervals\n * @param rounding Rounding to apply. This avoids floating-point rounding errors.\n */\nexport const pingPongPercent = function (interval = 0.1, lower, upper, start, rounding) {\n    if (lower === undefined)\n        lower = 0;\n    if (upper === undefined)\n        upper = 1;\n    if (start === undefined)\n        start = lower;\n    throwNumberTest(interval, `bipolar`, `interval`);\n    throwNumberTest(upper, `bipolar`, `end`);\n    throwNumberTest(start, `bipolar`, `offset`);\n    throwNumberTest(lower, `bipolar`, `start`);\n    return pingPong(interval, lower, upper, start, rounding);\n};\n/**\n * Ping-pongs continually back and forth a `lower` and `upper` value (both inclusive) by a given `interval`. Use `pingPongPercent` for 0-1 ping-ponging\n *\n * In a loop:\n * ```\n * for (const c of pingPong(10, 0, 100)) {\n *  // 0, 10, 20 .. 100, 90, 80, 70 ...\n * }\n * ```\n *\n * Manual:\n * ```\n * const pp = pingPong(10, 0, 100);\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n * @param interval Amount to increment by. Use negative numbers to start counting down\n * @param lower Lower bound (inclusive)\n * @param upper Upper bound (inclusive, must be greater than start)\n * @param start Starting point within bounds (defaults to `lower`)\n * @param rounding Rounding is off by default. Use say 1000 if interval is a fractional amount to avoid rounding errors.\n */\nexport const pingPong = function* (interval, lower, upper, start, rounding) {\n    if (lower === undefined)\n        throw new Error(`Parameter 'lower' is undefined`);\n    if (interval === undefined) {\n        throw new Error(`Parameter 'interval' is undefined`);\n    }\n    if (upper === undefined)\n        throw new Error(`Parameter 'upper' is undefined`);\n    if (rounding === undefined && interval <= 1 && interval >= 0) {\n        rounding = 10 / interval;\n    }\n    else if (rounding === undefined)\n        rounding = 1234;\n    if (Number.isNaN(interval))\n        throw new Error(`interval parameter is NaN`);\n    if (Number.isNaN(lower))\n        throw new Error(`lower parameter is NaN`);\n    if (Number.isNaN(upper))\n        throw new Error(`upper parameter is NaN`);\n    if (Number.isNaN(start))\n        throw new Error(`upper parameter is NaN`);\n    if (lower >= upper)\n        throw new Error(`lower must be less than upper`);\n    if (interval === 0)\n        throw new Error(`Interval cannot be zero`);\n    const distance = upper - lower;\n    if (Math.abs(interval) >= distance) {\n        throw new Error(`Interval should be between -${distance} and ${distance}`);\n    }\n    //eslint-disable-next-line functional/no-let\n    let incrementing = interval > 0;\n    // Scale up values by rounding factor\n    upper = Math.floor(upper * rounding);\n    lower = Math.floor(lower * rounding);\n    interval = Math.floor(Math.abs(interval * rounding));\n    if (interval === 0) {\n        throw new Error(`Interval is zero (rounding: ${rounding})`);\n    }\n    start = start === undefined ? lower : Math.floor(start * rounding);\n    if (start > upper || start < lower) {\n        throw new Error(`Start (${start / rounding}) must be within lower (${lower / rounding}) and upper (${upper / rounding})`);\n    }\n    let v = start;\n    yield v / rounding;\n    let firstLoop = true;\n    while (true) {\n        v = v + (incrementing ? interval : -interval);\n        if (incrementing && v >= upper) {\n            incrementing = false;\n            v = upper;\n            if (v === upper && firstLoop) {\n                // Edge case where we start at upper bound and increment\n                v = lower;\n                incrementing = true;\n            }\n        }\n        else if (!incrementing && v <= lower) {\n            incrementing = true;\n            v = lower;\n            if (v === lower && firstLoop) {\n                // Edge case where we start at lower bound and decrement\n                v = upper;\n                incrementing = false;\n            }\n        }\n        yield v / rounding;\n        firstLoop = false;\n    }\n};\n","import * as Flow from '@ixfx/flow';\n/**\n * Produces values according to rough spring physics.\n * ```js\n * import { continuously } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * import { spring } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n *\n * const s = spring();\n *\n * continuously(() => {\n *  const result = s.next();\n *  if (result.done) return false; // Exit loop\n *  const value = result.value;\n *  // Value is mostly within 0..1 range but will exceed these limits\n * }, 10).start();\n * ```\n *\n * Parameters to the spring can be provided.\n * ```js\n * import { spring } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * const s = spring({\n *  mass: 5,\n *  damping: 10\n *  stiffness: 100\n * });\n * ```\n *\n * If you don't want to use a generator: {@link springValue}.\n *\n * Note that the generated value can exceed 0..1 range. This is by design, since\n * a spring can 'overshoot'. See Data.Normalise for functions to normalise.\n *\n * @param opts Options for spring\n * @param timerOrFreq Timer to use, or frequency\n */\nexport function* spring(opts = {}, timerOrFreq) {\n    if (timerOrFreq === undefined)\n        timerOrFreq = Flow.elapsedMillisecondsAbsolute();\n    else if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    const fn = springShape(opts);\n    // Give it some iterations to settle\n    let doneCountdown = opts.countdown ?? 10;\n    while (doneCountdown > 0) {\n        const s = fn(timerOrFreq.elapsed / 1000);\n        yield s;\n        if (s === 1) {\n            doneCountdown--;\n        }\n        else {\n            doneCountdown = 100;\n        }\n    }\n}\n/**\n * The same as {@link spring} but instead of a generator we get\n * a value. When the spring is done, 1 is returned instead of undefined.\n *\n * ```js\n * import { springValue } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * const s = springValue();\n * s(); // 0..1 (roughly - exceeding 1 is possible)\n * ```\n *\n * Options can be provided:\n * ```js\n * import { spring } from \"https://unpkg.com/ixfx/dist/modulation.js\"\n * const s = springValue({\n *  stiffness: 100,\n *  damping: 10\n * })\n * ```\n * @example Applied\n * ```js\n * import { Modulation, Data } from  \"https://unpkg.com/ixfx/dist/bundle.js\"\n * let state = {\n *  spring: Modulation.springValue()\n * }\n *\n * function loop() {\n *  const d = Data.resolveFields(state);\n *\n *  // Apply calculated spring value to compute x value\n *  const x = window.innerWidth * d.spring;\n *\n *\n *  window.requestAnimationFrame(loop);\n * }\n * loop();\n * ```\n * Note that the generated value can exceed 0..1 range. This is by design, since\n * a spring can 'overshoot'. See Data.Normalise for functions to normalise.\n *\n * @param opts\n * @param timerOrFreq\n * @returns\n */\nexport function springValue(opts = {}, timerOrFreq) {\n    const s = spring(opts, timerOrFreq);\n    return () => {\n        const v = s.next();\n        if (v.done)\n            return 1;\n        return v.value;\n    };\n}\n/**\n * Spring-dynamics modulator.\n * To have spring driven by time or ticks, use {@link spring} or {@link springValue}.\n * This is a lower-level function.\n * @param opts\n * @returns\n */\nexport const springShape = (opts = {}) => {\n    /** MIT License github.com/pushkine/ */\n    const from = 0;\n    const to = 1;\n    const mass = opts.mass ?? 1;\n    const stiffness = opts.stiffness ?? 100;\n    const soft = opts.soft ?? false;\n    const damping = opts.damping ?? 10;\n    const velocity = opts.velocity ?? 0.1;\n    const delta = to - from;\n    if (soft || 1 <= damping / (2 * Math.sqrt(stiffness * mass))) {\n        const angularFrequency = -Math.sqrt(stiffness / mass);\n        const leftover = -angularFrequency * delta - velocity;\n        return (t) => to - (delta + t * leftover) * Math.E ** (t * angularFrequency);\n    }\n    else {\n        const dampingFrequency = Math.sqrt(4 * mass * stiffness - damping ** 2);\n        const leftover = (damping * delta - 2 * mass * velocity) / dampingFrequency;\n        const dfm = (0.5 * dampingFrequency) / mass;\n        const dm = -(0.5 * damping) / mass;\n        return (t) => to -\n            (Math.cos(t * dfm) * delta + Math.sin(t * dfm) * leftover) *\n                Math.E ** (t * dm);\n    }\n};\n","import * as TimeSources from './source/time.js';\n/**\n * A factory function for creating a timing source. It returns\n * a function which creates a designated timer.\n *\n * This is useful in times where you need to recreate timers, eg for reset\n * type of behaviours because the options for the timer to be\n * consolidated in one place.\n *\n * ```js\n * // Get a factory for an elapsed timer\n * const factory = sources(`elapsed`, 1000);\n *\n * // Create the timer\n * let t = factory();\n *\n * // Get a value from the timer\n * const value = t();\n *\n * // Recreate the timer, note we don't need any options\n * t = factory();\n * ```\n *\n * @param source Kind of timer to make\n * @param duration Duration depends on the timer used. Will be milliseconds, hertz or bpm.\n * @param options Options to pass to timer.\n * @returns\n */\nexport const timingSourceFactory = (source, duration, options = {}) => {\n    switch (source) {\n        case `elapsed`:\n            return () => TimeSources.elapsed(duration, options);\n        case `bpm`:\n            return () => TimeSources.bpm(duration, options);\n        case `hertz`:\n            return () => TimeSources.hertz(duration, options);\n        default:\n            throw new Error(`Unknown source '${source}'. Expected: 'elapsed', 'hertz' or 'bpm'`);\n    }\n};\n","import { throwIntegerTest } from \"@ixfx/guards\";\nimport * as Sources from './source/index.js';\n/**\n * Returns a function that shapes a 0..1 value as a\n * triangle waveform.\n *\n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period\n * @returns\n */\nexport function triangleShape(period = 1) {\n    period = 1 / period;\n    const halfPeriod = period / 2;\n    return (t) => {\n        const v = Math.abs((t % period) - halfPeriod);\n        //console.log(`t: ${ t.toFixed(2) } v: ${ v.toFixed(2) }`);\n        return v;\n    };\n}\n/**\n * Returns a function that shapes a 0..1 value as a square waveform.\n * `period` sets the number of cycles in the 0..1 range.\n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period\n * @returns\n */\nexport function squareShape(period = 1) {\n    period = 1 / period;\n    const halfPeriod = period / 2;\n    return (t) => {\n        return (t % period) < halfPeriod ? 1 : 0;\n        //console.log(`square: ${ t } v: ${ v }`);\n        //return v;\n    };\n}\n/**\n * Returns a function that shapes a 0..1 value as a sine waveform.\n * ```js\n * const s = sineShape();\n * // Calculate value of sine wave at 50%\n * // By default there is one oscillation, thus\n * // it will be the middle of the cycle.\n * s(0.5);\n * ```\n *\n * The `period` determines number of cycles for\n * an input value of 1.\n * ```js\n * // Oscillate twice in 0..1 range\n * const s = sineShape(2);\n * ```\n *\n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period\n * @returns\n */\nexport function sineShape(period = 1) {\n    period = period * (Math.PI * 2);\n    return (t) => {\n        const v = (Math.sin(t * period) + 1) / 2;\n        //console.log(`t: ${ t.toFixed(2) } v: ${ v.toFixed(2) }`);\n        return v;\n    };\n}\n/**\n * A series of arcs, sort of like a bouncing ball.\n * @param period\n * @returns\n */\nexport function arcShape(period = 1) {\n    period = period * (Math.PI * 2);\n    return (t) => Math.abs(Math.sin(t * period));\n}\nexport function sineBipolarShape(period = 1) {\n    period = period * (Math.PI * 2);\n    return (t) => Math.sin(t * period);\n}\n/**\n * Creates a wave modulator. Defaults to 5-second sine wave.\n * ```js\n * import { wave } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * // Triangle wave that has a single cycle over two seconds\n * const m = wave({ secs: 2, shape: `triangle`});\n *\n * // Call m() to get current value of wave, eg in\n * // an animation loop\n * const v = m();\n * ```\n *\n * @example\n * ```js\n * import { wave } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * import { resolveFields } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const state = {\n *  intensity: wave({secs: 2, shape: `sine` }),\n *  someOtherState: 10\n * }\n *\n * const use = async () {\n *  const { intensity } = await resolveFields(state);\n *  // Do something with intensity value...\n * }\n * ```\n * @param options\n * @returns\n */\nexport function wave(options) {\n    const shape = options.shape ?? `sine`;\n    const invert = options.invert ?? false;\n    const period = options.period ?? 1;\n    let sourceFunction;\n    throwIntegerTest(period, `aboveZero`, `period`);\n    const sourceOptions = {\n        ...options\n    };\n    if (options.ticks) {\n        sourceFunction = Sources.ticks(options.ticks, sourceOptions);\n    }\n    else if (options.hertz) {\n        sourceFunction = Sources.hertz(options.hertz, sourceOptions);\n    }\n    else if (options.millis) {\n        sourceFunction = Sources.elapsed(options.millis, sourceOptions);\n    }\n    else if (options.source) {\n        sourceFunction = options.source;\n    }\n    else {\n        const secs = options.secs ?? 5;\n        sourceFunction = Sources.elapsed(secs * 1000, sourceOptions);\n    }\n    let shaperFunction;\n    switch (shape) {\n        case `saw`:\n            shaperFunction = (v) => v;\n            break;\n        case `sine`:\n            shaperFunction = sineShape(period);\n            break;\n        case `sine-bipolar`:\n            shaperFunction = sineBipolarShape(period);\n            break;\n        case `square`:\n            shaperFunction = squareShape(period);\n            break;\n        case `triangle`:\n            shaperFunction = triangleShape(period);\n            break;\n        case `arc`:\n            shaperFunction = arcShape(period);\n            break;\n        default:\n            throw new Error(`Unknown wave shape '${shape}'. Expected: sine, sine-bipolar, saw, triangle, arc or square`);\n    }\n    return waveFromSource(sourceFunction, shaperFunction, invert);\n}\n/**\n * Returns a wave-shaping modulator from a source and shaper\n * @param sourceFn\n * @param shaperFn\n * @returns\n */\nexport function waveFromSource(sourceFunction, shaperFunction, invert = false) {\n    return (feedback) => {\n        let v = sourceFunction(feedback?.clock);\n        if (feedback?.override)\n            v = feedback.override;\n        v = shaperFunction(v);\n        if (invert)\n            v = 1 - v;\n        return v;\n    };\n}\n","/**\n * Weighted average\n *\n * @param currentValue\n * @param targetValue\n * @param slowDownFactor\n * @returns\n */\nexport const weightedAverage = (currentValue, targetValue, slowDownFactor) => {\n    return ((currentValue * (slowDownFactor - 1)) + targetValue) / slowDownFactor;\n};\n","import { get } from \"./easing/index.js\";\n/***\n * Returns a random number, 0..1, weighted by a given easing function.\n * Default easing is `quadIn`, which skews towards zero.\n *\n * Use {@link weightedSource} to return a function instead.\n *\n * ```js\n * import * as Random from 'https://unpkg.com/ixfx/dist/random.js';\n * Random.weighted();          // quadIn easing by default, which skews toward low values\n * Random.weighted(`quadOut`); // quadOut favours high values\n * ```\n * @param easingNameOrOptions Options. Uses 'quadIn' by default.\n * @see {@link weightedSource} Returns a function rather than value\n * @returns Random number (0-1)\n */\nexport const weighted = (easingNameOrOptions = `quadIn`) => weightedSource(easingNameOrOptions)();\n/***\n * Returns a random number, 0..1, weighted by a given easing function.\n * Default easing is `quadIn`, which skews towards zero.\n * Use {@link weighted} to get a value directly.\n *\n * ```js\n * import * as Random from 'https://unpkg.com/ixfx/dist/random.js';\n * const r1 = Random.weightedSource();          // quadIn easing by default, which skews toward low values\n * r1(); // Produce a value\n *\n * const r2 = Random.weightedSource(`quadOut`); // quadOut favours high values\n * r2(); // Produce a value\n * ```\n * @param easingNameOrOptions Easing name or options `quadIn` by default.\n * @see {@link weighted} Returns value instead of function\n * @returns Function which returns a weighted random value\n */\nexport const weightedSource = (easingNameOrOptions = `quadIn`) => {\n    const options = typeof easingNameOrOptions === `string`\n        ? { easing: easingNameOrOptions }\n        : easingNameOrOptions;\n    const source = options.source ?? Math.random;\n    const easingName = options.easing ?? `quadIn`;\n    const easingFunction = get(easingName);\n    if (typeof easingFunction === `undefined`) {\n        throw new Error(`Easing function '${easingName}' not found.`);\n    }\n    const compute = () => {\n        const r = source();\n        return easingFunction(r);\n    };\n    return compute;\n};\n","export * from '@ixfx/modulation';","import { isIterable } from \"@ixfx/iterables\";\nexport function messageIsSignal(message) {\n    if (message.value !== undefined)\n        return false;\n    if (`signal` in message && message.signal !== undefined)\n        return true;\n    return false;\n}\nexport function messageIsDoneSignal(message) {\n    if (message.value !== undefined)\n        return false;\n    if (`signal` in message && message.signal === `done`)\n        return true;\n    return false;\n}\n/**\n * Returns _true_ if `v` has a non-undefined value. Note that sometimes\n * _undefined_ is a legal value to pass\n * @param v\n * @returns\n */\nexport function messageHasValue(v) {\n    if (v.value !== undefined)\n        return true;\n    return false;\n}\nexport const isPingable = (rx) => {\n    if (!isReactive(rx))\n        return false;\n    if (`ping` in rx) {\n        return true;\n    }\n    return false;\n};\nexport const hasLast = (rx) => {\n    if (!isReactive(rx))\n        return false;\n    if (`last` in rx) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        const v = rx.last();\n        if (v !== undefined)\n            return true;\n    }\n    return false;\n};\n/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx\n * @returns\n */\nexport const isReactive = (rx) => {\n    if (typeof rx !== `object`)\n        return false;\n    if (rx === null)\n        return false;\n    return (`on` in rx && `onValue` in rx);\n};\n/**\n * Returns true if `rx` is a disposable reactive.\n * @param rx\n * @returns\n */\n// export const isDisposable = <V>(rx: Reactive<V> | ReactiveWritable<V>): rx is ReactiveDisposable<V> => {\n//   if (!isReactive(rx)) return false;\n//   return (`isDisposed` in rx && `dispose` in rx);\n// }\n/**\n * Returns _true_ if `rx` is a writable Reactive\n * @param rx\n * @returns\n */\nexport const isWritable = (rx) => {\n    if (!isReactive(rx))\n        return false;\n    if (`set` in rx)\n        return true;\n    return false;\n};\nexport const isWrapped = (v) => {\n    if (typeof v !== `object`)\n        return false;\n    if (!(`source` in v))\n        return false;\n    if (!(`annotate` in v))\n        return false;\n    return true;\n};\n// export const opify = <TIn, TOut = TIn,>(fn: (source: ReactiveOrSource<TIn>, ...args: Array<any>) => Reactive<TOut>, ...args: Array<any>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     return fn(source, ...args);\n//   }\n// }\nexport const opify = (fn, ...args) => {\n    return (source) => {\n        return fn(source, ...args);\n    };\n};\nexport const isTriggerValue = (t) => (`value` in t);\nexport const isTriggerFunction = (t) => (`fn` in t);\nexport const isTriggerGenerator = (t) => isIterable(t);\nexport const isTrigger = (t) => {\n    if (typeof t !== `object`)\n        return false;\n    if (isTriggerValue(t))\n        return true;\n    if (isTriggerFunction(t))\n        return true;\n    if (isTriggerGenerator(t))\n        return true;\n    return false;\n};\n/**\n * Resolves a trigger value.\n *\n * A trigger can be a value, a function or generator. Value triggers never complete.\n * A trigger function is considered complete if it returns undefined.\n * A trigger generator is considered complete if it returns done.\n *\n * Returns `[value, _false_]` if we have a value and trigger is not completed.\n * Returns `[value, _true_]` trigger is completed\n * @param t\n * @returns\n */\nexport function resolveTriggerValue(t) {\n    if (isTriggerValue(t))\n        return [t.value, false];\n    if (isTriggerFunction(t)) {\n        const v = t.fn();\n        if (v === undefined)\n            return [undefined, true];\n        return [v, false];\n    }\n    if (isTriggerGenerator(t)) {\n        const v = t.gen.next();\n        if (v.done)\n            return [undefined, true];\n        return [v.value, false];\n    }\n    throw new Error(`Invalid trigger. Missing 'value' or 'fn' fields`);\n}\n","import { continuously, intervalToMs } from \"@ixfx/core\";\nimport { getErrorMessage } from \"@ixfx/debug\";\nimport { sleep } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\n/**\n * Produces a reactive from the basis of a function. `callback` is executed, with its result emitted via the returned reactive.\n *\n * ```js\n * // Produce a random number every second\n * const r = Rx.From.func(Math.random, { interval: 1000 });\n * ```\n *\n * `callback` can be called repeatedly by providing the `interval` option to set the rate of repeat.\n * Looping can be limited with `options.maximumRepeats`, or passing a signal `options.signal`\n * and then activating it.\n * ```js\n * // Reactive that emits a random number every second, five times\n * const r1 = Rx.From.func(Math.random, { interval: 1000, maximumRepeats: 5 }\n * ```\n *\n * ```js\n * // Generate a random number every second until ac.abort() is called\n * const ac = new AbortController();\n * const r2 = Rx.From.func(Math.random, { interval: 1000, signal: ac.signal });\n * ```\n *\n * The third option is for `callback` to fire the provided abort function.\n * ```js\n * Rx.From.func((abort) => {\n *  if (Math.random() > 0.5) abort('Random exit');\n *  return 1;\n * });\n * ```\n *\n * By default has a laziness of 'very' meaning that `callback` is run only when there's a subscriber\n * By default stream closes if `callback` throws an error. Use `options.closeOnError:'ignore'` to change.\n * @param callback\n * @param options\n * @returns\n */\nexport function func(callback, options = {}) {\n    const maximumRepeats = options.maximumRepeats ?? Number.MAX_SAFE_INTEGER;\n    const closeOnError = options.closeOnError ?? true;\n    const intervalMs = options.interval ? intervalToMs(options.interval) : -1;\n    let manual = options.manual ?? false;\n    // If niether interval or manual is set, assume manual\n    if (options.interval === undefined && options.manual === undefined)\n        manual = true;\n    if (manual && options.interval)\n        throw new Error(`If option 'manual' is set, option 'interval' cannot be used`);\n    const predelay = intervalToMs(options.predelay, 0);\n    const lazy = options.lazy ?? `very`;\n    const signal = options.signal;\n    const internalAbort = new AbortController();\n    const internalAbortCallback = (reason) => { internalAbort.abort(reason); };\n    let sentResults = 0;\n    let enabled = false;\n    const done = (reason) => {\n        events.dispose(reason);\n        enabled = false;\n        if (run)\n            run.cancel();\n    };\n    const ping = async () => {\n        if (!enabled)\n            return false;\n        if (predelay)\n            await sleep(predelay);\n        if (sentResults >= maximumRepeats) {\n            done(`Maximum repeats reached ${maximumRepeats.toString()}`);\n            return false;\n        }\n        //console.log(`sent: ${ sentResults } max: ${ maximumRepeats }`);\n        try {\n            if (signal?.aborted) {\n                done(`Signal (${signal.aborted})`);\n                return false;\n            }\n            const value = await callback(internalAbortCallback);\n            sentResults++;\n            events.set(value);\n            return true;\n        }\n        catch (error) {\n            if (closeOnError) {\n                done(`Function error: ${getErrorMessage(error)}`);\n                return false;\n            }\n            else {\n                events.signal(`warn`, getErrorMessage(error));\n                return true;\n            }\n        }\n    };\n    const run = manual ? undefined : continuously(async () => {\n        const pingResult = await ping();\n        if (!pingResult)\n            return false;\n        // if (!loop) {\n        //   done(`fromFunction done`);\n        //   return false; // Stop loop\n        // }\n        if (internalAbort.signal.aborted) {\n            done(`callback function aborted (${internalAbort.signal.reason})`);\n            return false;\n        }\n    }, intervalMs);\n    const events = initLazyStream({\n        lazy,\n        onStart() {\n            enabled = true;\n            if (run)\n                run.start();\n        },\n        onStop() {\n            enabled = false;\n            if (run)\n                run.cancel();\n        },\n    });\n    if (lazy === `never` && run)\n        run.start();\n    return { ...events, ping };\n}\n","import { nextWithTimeout } from \"@ixfx/iterables/async\";\nimport { intervalToMs } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\nimport { isAsyncIterable } from \"@ixfx/iterables\";\nimport * as StateMachine from \"@ixfx/flow/state-machine\";\n/**\n * Creates a Reactive from an AsyncGenerator or Generator\n * @param gen\n * @returns\n */\n// export function readFromGenerator<V>(gen: AsyncGenerator<V> | Generator<V>) {\n//   const rx = initStream<V>();\n//   // eslint-disable-next-line @typescript-eslint/no-misused-promises\n//   setTimeout(async () => {\n//     try {\n//       for await (const value of gen) {\n//         rx.set(value);\n//       }\n//       rx.dispose(`Source generator complete`);\n//     } catch (error) {\n//       console.error(error);\n//       rx.dispose(`Error while iterating`);\n//     }\n//   }, 1);\n//   return rx;\n// }\n/**\n * Creates a readable reactive based on a (async)generator or iterator\n * ```js\n * // Generator a random value every 5 seconds\n * const valuesOverTime = Flow.interval(() => Math.random(), 5000);\n * // Wrap the generator\n * const r = Rx.From.iterator(time);\n * // Get notified when there is a new value\n * r.onValue(v => {\n *   console.log(v);\n * });\n * ```\n *\n * Awaiting values could potentially hang code. Thus there is a `readTimeout`, the maximum time to wait for a value from the generator. Default: 5 minutes.\n * If `signal` is given, this will also cancel waiting for the value.\n * @param source\n */\nexport function iterator(source, options = {}) {\n    const lazy = options.lazy ?? `very`;\n    const log = options.traceLifecycle ? (message) => { console.log(`Rx.From.iterator ${message}`); } : (_) => { };\n    const readIntervalMs = intervalToMs(options.readInterval, 5);\n    const readTimeoutMs = intervalToMs(options.readTimeout, 5 * 60 * 1000);\n    const whenStopped = options.whenStopped ?? `continue`;\n    let iterator;\n    //let reading = false;\n    let ourAc;\n    let sm = StateMachine.init({\n        idle: [`wait_for_next`],\n        wait_for_next: [`processing_result`, `stopping`, `disposed`],\n        processing_result: [`queued`, `disposed`, `stopping`],\n        queued: [`wait_for_next`, `disposed`, `stopping`],\n        stopping: `idle`,\n        disposed: null\n    }, `idle`);\n    const onExternalSignal = () => {\n        log(`onExternalSignal`);\n        ourAc?.abort(options.signal?.reason);\n    };\n    if (options.signal) {\n        options.signal.addEventListener(`abort`, onExternalSignal, { once: true });\n    }\n    ;\n    const read = async () => {\n        log(`read. State: ${sm.value}`);\n        ourAc = new AbortController();\n        try {\n            sm = StateMachine.to(sm, `wait_for_next`);\n            const v = await nextWithTimeout(iterator, { signal: ourAc.signal, millis: readTimeoutMs });\n            sm = StateMachine.to(sm, `processing_result`);\n            ourAc.abort(`nextWithTimeout completed`);\n            if (v.done) {\n                log(`read v.done true`);\n                events.dispose(`Generator complete`);\n                //reading = false;\n                sm = StateMachine.to(sm, `disposed`);\n            }\n            //if (!reading) return;\n            if (sm.value === `stopping`) {\n                log(`read. sm.value = stopping`);\n                sm = StateMachine.to(sm, `idle`);\n                return;\n            }\n            if (sm.value === `disposed`) {\n                log(`read. sm.value = disposed`);\n                return;\n            }\n            events.set(v.value);\n        }\n        catch (error) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            events.dispose(`Generator error: ${error.toString()}`);\n            return;\n        }\n        //if (events.isDisposed()) return;\n        //if (!reading) return;\n        if (sm.value === `processing_result`) {\n            sm = StateMachine.to(sm, `queued`);\n            log(`scheduling read. State: ${sm.value}`);\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            setTimeout(read, readIntervalMs);\n        }\n        else {\n            sm = StateMachine.to(sm, `idle`);\n        }\n    };\n    const events = initLazyStream({\n        ...options,\n        lazy,\n        onStart() {\n            log(`onStart state: ${sm.value} whenStopped: ${whenStopped}`);\n            if (sm.value !== `idle`)\n                return;\n            if ((sm.value === `idle` && whenStopped === `reset`) || iterator === undefined) {\n                iterator = isAsyncIterable(source) ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();\n            }\n            //reading = true;\n            void read();\n        },\n        onStop() {\n            log(`onStop state: ${sm.value} whenStopped: ${whenStopped}`);\n            //reading = false;\n            sm = StateMachine.to(sm, `stopping`);\n            if (whenStopped === `reset`) {\n                log(`onStop reiniting iterator`);\n                iterator = isAsyncIterable(source) ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();\n            }\n        },\n        onDispose(reason) {\n            log(`onDispose (${reason})`);\n            ourAc?.abort(`Rx.From.iterator disposed (${reason})`);\n            if (options.signal)\n                options.signal.removeEventListener(`abort`, onExternalSignal);\n        },\n    });\n    // const readingStart = () => {\n    // }\n    //if (!lazy) readingStart();\n    // return {\n    //   on: events.on,\n    //   value: events.value,\n    //   dispose: events.dispose,\n    //   isDisposed: events.isDisposed\n    // }\n    return events;\n}\n","import { isAsyncIterable, isIterable } from \"@ixfx/iterables\";\nimport { func } from \"./from/function.js\";\nimport { iterator } from \"./from/iterator.js\";\nimport { isReactive, isWrapped } from \"./util.js\";\n/**\n * Resolves various kinds of sources into a Reactive.\n * If `source` is an iterable/generator, it gets wrapped via `generator()`.\n *\n * Default options:\n * * generator: `{ lazy: true, interval: 5 }`\n * @param source\n * @returns\n */\nexport const resolveSource = (source, options = {}) => {\n    if (isReactive(source))\n        return source;\n    const generatorOptions = options.generator ?? { lazy: `initial`, interval: 5 };\n    const functionOptions = options.function ?? { lazy: `very` };\n    if (Array.isArray(source)) {\n        return iterator(source.values(), generatorOptions);\n    }\n    else if (typeof source === `function`) {\n        return func(source, functionOptions);\n    }\n    else if (typeof source === `object`) {\n        //console.log(`resolveSource is object`);\n        if (isWrapped(source)) {\n            //console.log(`resolveSource is object - wrapped`);\n            return source.source;\n        }\n        if (isIterable(source) || isAsyncIterable(source)) {\n            //console.log(`resolveSource is object - iterable`);\n            return iterator(source, generatorOptions);\n        }\n    }\n    throw new TypeError(`Unable to resolve source. Supports: array, Reactive, Async/Iterable. Got type: ${typeof source}`);\n};\n","/**\n * Wrapes an input stream to cache values, optionally providing an initial value\n * @param r\n * @param initialValue\n * @returns\n */\nexport function cache(r, initialValue) {\n    let lastValue = initialValue;\n    r.onValue(value => {\n        lastValue = value;\n    });\n    return {\n        ...r,\n        last() {\n            return lastValue;\n        },\n        resetCachedValue() {\n            lastValue = undefined;\n        }\n    };\n}\n","import { DispatchList } from \"@ixfx/flow\";\nimport { resolveSource } from \"./resolve-source.js\";\nimport { messageHasValue, messageIsSignal } from \"./util.js\";\nimport { cache } from \"./cache.js\";\n/**\n * Initialise a stream based on an upstream source.\n * Calls initLazyStream under the hood.\n *\n * Options:\n * * onValue: called when upstream emits a value (default: does nothing with upstream value)\n * * lazy: laziness of stream (default: 'initial')\n * * disposeIfSourceDone: disposes stream if upstream disposes (default: true)\n * @ignore\n * @param upstreamSource\n * @param options\n * @returns\n */\nexport function initUpstream(upstreamSource, options) {\n    const lazy = options.lazy ?? `initial`;\n    const disposeIfSourceDone = options.disposeIfSourceDone ?? true;\n    const onValue = options.onValue ?? ((_v) => { });\n    const source = resolveSource(upstreamSource);\n    let unsub;\n    const debugLabel = options.debugLabel ? `[${options.debugLabel}]` : ``;\n    //console.log(`initUpstream${ debugLabel } creating`);\n    const onStop = () => {\n        //console.log(`Rx.initStream${ debugLabel } stop`);\n        if (unsub === undefined)\n            return;\n        unsub();\n        unsub = undefined;\n        if (options.onStop)\n            options.onStop();\n    };\n    const onStart = () => {\n        //console.log(`Rx.initStream${ debugLabel } start unsub ${ unsub !== undefined }`);\n        if (unsub !== undefined)\n            return;\n        if (options.onStart)\n            options.onStart();\n        unsub = source.on(value => {\n            //console.log(`Rx.initStream${ debugLabel } onValue`, value);\n            if (messageIsSignal(value)) {\n                if (value.signal === `done`) {\n                    onStop();\n                    events.signal(value.signal, value.context);\n                    if (disposeIfSourceDone)\n                        events.dispose(`Upstream source ${debugLabel} has completed (${value.context ?? ``})`);\n                }\n                else {\n                    //events.through_(value);\n                    events.signal(value.signal, value.context);\n                }\n            }\n            else if (messageHasValue(value)) {\n                //lastValue = value.value;\n                onValue(value.value);\n            }\n        });\n    };\n    //const initOpts = \n    // const events:ReactiveInitialStream<Out>|ReactiveStream<Out> = ((`initialValue` in options) && options.initialValue !== undefined) ?\n    //   initLazyStreamWithInitial<Out>({ ...initOpts, initialValue: options.initialValue }) :\n    //   initLazyStream<Out>(initOpts);\n    //console.log(`initUpstream${ debugLabel } creating initLazyStream`);\n    const events = initLazyStream({\n        ...options,\n        lazy,\n        onStart,\n        onStop\n    });\n    return events;\n}\n/**\n * Initialises a lazy stream with an initial value.\n * Uses {@link initLazyStream} and {@link cache} together.\n * @param options\n * @returns\n */\nexport function initLazyStreamWithInitial(options) {\n    const r = initLazyStream(options);\n    const c = cache(r, options.initialValue);\n    return c;\n}\n/**\n * Initialises a lazy stream\n * Consider also: {@link initLazyStreamWithInitial}\n *\n * Uses {@link lazyStream} internally.\n * @param options\n * @returns\n */\nexport function initLazyStream(options) {\n    const lazy = options.lazy ?? `initial`;\n    const onStop = options.onStop ?? (() => { });\n    const onStart = options.onStart ?? (() => { });\n    const debugLabel = options.debugLabel ? `[${options.debugLabel}]` : ``;\n    const events = initStream({\n        ...options,\n        onFirstSubscribe() {\n            if (lazy !== `never`) {\n                //console.log(`initLazyStream${ debugLabel } onFirstSubscribe, lazy: ${ lazy }. Calling onStart`);\n                onStart();\n            }\n        },\n        onNoSubscribers() {\n            if (lazy === `very`) {\n                //console.log(`initLazyStream${ debugLabel } onNoSubscribers, lazy: ${ lazy }. Calling onStop`);\n                onStop();\n            }\n        },\n    });\n    if (lazy === `never`)\n        onStart();\n    return events;\n}\n/**\n * Initialises a new stream.\n *\n * Options:\n * * onFirstSubscribe: Called when there is a subscriber after there have been no subscribers.\n * * onNoSubscribers: Called when there are no more subscribers. 'onFirstSubscriber' will be called next time a subscriber is added.\n *\n * Alternatives:\n * * {@link initLazyStream} - a stream with callbacks for when there is some/none subscribers\n * @ignore\n * @param options\n * @returns\n */\nexport function initStream(options = {}) {\n    let dispatcher;\n    let disposed = false;\n    let firstSubscribe = false;\n    let emptySubscriptions = true;\n    const onFirstSubscribe = options.onFirstSubscribe ?? undefined;\n    const onNoSubscribers = options.onNoSubscribers ?? undefined;\n    const debugLabel = options.debugLabel ? `[${options.debugLabel}]` : ``;\n    const isEmpty = () => {\n        if (dispatcher === undefined)\n            return;\n        if (!dispatcher.isEmpty)\n            return;\n        if (!emptySubscriptions) {\n            emptySubscriptions = true;\n            firstSubscribe = false;\n            if (onNoSubscribers)\n                onNoSubscribers();\n        }\n    };\n    const subscribe = (handler) => {\n        if (disposed)\n            throw new Error(`Disposed, cannot subscribe ${debugLabel}`);\n        if (dispatcher === undefined)\n            dispatcher = new DispatchList();\n        //console.log(`initStream${ debugLabel } subscribe handler:`, handler);\n        const id = dispatcher.add(handler);\n        emptySubscriptions = false;\n        if (!firstSubscribe) {\n            firstSubscribe = true;\n            //if (onFirstSubscribe) setTimeout(() => { onFirstSubscribe() }, 10);\n            if (onFirstSubscribe)\n                onFirstSubscribe();\n        }\n        return () => {\n            dispatcher?.remove(id);\n            isEmpty();\n        };\n    };\n    return {\n        dispose: (reason) => {\n            if (disposed)\n                return;\n            dispatcher?.notify({ value: undefined, signal: `done`, context: `Disposed: ${reason}` });\n            disposed = true;\n            if (options.onDispose)\n                options.onDispose(reason);\n        },\n        isDisposed: () => {\n            return disposed;\n        },\n        removeAllSubscribers: () => {\n            dispatcher?.clear();\n            isEmpty();\n        },\n        set: (v) => {\n            if (disposed)\n                throw new Error(`${debugLabel} Disposed, cannot set`);\n            dispatcher?.notify({ value: v });\n        },\n        // through: (pass: Passed<V>) => {\n        //   if (disposed) throw new Error(`Disposed, cannot through`);\n        //   dispatcher?.notify(pass)\n        // },\n        signal: (signal, context) => {\n            if (disposed)\n                throw new Error(`${debugLabel} Disposed, cannot signal`);\n            dispatcher?.notify({ signal, value: undefined, context });\n        },\n        on: (handler) => subscribe(handler),\n        onValue: (handler) => {\n            const unsub = subscribe(message => {\n                //console.log(`initStream${ debugLabel } onValue wrapper`, message);\n                if (messageHasValue(message)) {\n                    handler(message.value);\n                }\n            });\n            return unsub;\n        }\n    };\n}\n","import { setProperty } from \"@ixfx/dom\";\nimport { resolveSource } from \"../resolve-source.js\";\n/**\n * Values from `input` are set to the textContent/innerHTML of an element.\n * ```js\n * const rxSource = Rx.From.string('hello');\n * const rxSet = Rx.Sinks.setHtmlText(rxSource, { query: })\n * ```\n * @param rxOrSource\n * @param optionsOrElementOrQuery\n */\nexport const setHtmlText = (rxOrSource, optionsOrElementOrQuery) => {\n    let el;\n    let options;\n    if (typeof optionsOrElementOrQuery === `string`) {\n        options = { query: optionsOrElementOrQuery };\n    }\n    if (typeof optionsOrElementOrQuery === `object`) {\n        if (`nodeName` in optionsOrElementOrQuery) {\n            options = { el: optionsOrElementOrQuery };\n        }\n        else {\n            options = optionsOrElementOrQuery;\n        }\n    }\n    if (options === undefined)\n        throw new TypeError(`Missing element as second parameter or option`);\n    if (`el` in options) {\n        el = options.el;\n    }\n    else if (`query` in options) {\n        el = document.querySelector(options.query);\n    }\n    else {\n        throw new TypeError(`Options does not include 'el' or 'query' fields`);\n    }\n    if (el === null || el === undefined)\n        throw new Error(`Element could not be resolved.`);\n    const stream = resolveSource(rxOrSource);\n    const setter = setProperty(options.asHtml ? `innerHTML` : `textContent`, el);\n    const off = stream.onValue(value => {\n        setter(value);\n    });\n    return off;\n};\n","/***\n * Returns a read-only version of `stream`\n */\nexport const toReadable = (stream) => ({\n    on: stream.on,\n    dispose: stream.dispose,\n    isDisposed: stream.isDisposed,\n    onValue: stream.onValue\n});\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport { resolveSource, syncToObject } from \"../index.js\";\n/**\n * Annotates values from `source`. Output values will be\n * in the form `{ value: TIn, annotation: TAnnotation }`.\n * Where `TIn` is the type of the input, and `TAnnotation` is\n * the return type of the annotator function.\n *\n * Example calculating area from width & height:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const annotated = Rx.Ops.annotate(data, v => {\n *  return { area: v.w * v.h }\n * });\n * const data = await Rx.toArray(annotated);\n * // Data =  [ { value: { w:1, h:3 }, annotation: { area:3 } } ...]\n * ```\n *\n * If you would rather annotate and have values merge with the input,\n * use `transform`:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const withArea = Rx.Ops.transform(data, v => {\n *  return { ...v, area: v.w * v.h }\n * });\n * const data = await Rx.toArray(withArea);\n * // Data =  [ { w:1, h:3, area:3 }, ...]\n * ```\n */\nexport function annotate(input, annotator, options = {}) {\n    const upstream = initUpstream(input, {\n        ...options,\n        onValue(value) {\n            const annotation = annotator(value);\n            upstream.set({ value, annotation });\n        },\n    });\n    return toReadable(upstream);\n}\n/**\n * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n *\n * ```js\n * const data = Rx.From.array([ 1, 2, 3 ]);\n * const annotated = Rx.Ops.annotateWithOp(data, Rx.Ops.sum());\n * const data = await annotated.toArray(annotated);\n * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n * ```\n * @param annotatorOp Operator to generate annotations\n * @param input Input stream\n * @returns\n */\nexport function annotateWithOp(input, annotatorOp) {\n    const inputStream = resolveSource(input);\n    // Create annotations from input\n    const stream = annotatorOp(inputStream);\n    const synced = syncToObject({\n        value: inputStream,\n        annotation: stream\n    });\n    return synced;\n}\n","import { QueueMutable } from \"@ixfx/collections\";\nimport { timeout } from \"@ixfx/flow\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Queue from `source`, emitting when thresholds are reached.\n * The resulting Reactive produces arrays.\n *\n * Can use a combination of elapsed time or number of data items.\n *\n * By default options are OR'ed together.\n *\n * ```js\n * // Emit data in chunks of 5 items\n * chunk(source, { quantity: 5 });\n * // Emit a chunk of data every second\n * chunk(source, { elapsed: 1000 });\n * ```\n * @param source\n * @param options\n * @returns\n */\nexport function chunk(source, options = {}) {\n    const queue = new QueueMutable();\n    const quantity = options.quantity ?? 0;\n    const returnRemainder = options.returnRemainder ?? true;\n    const upstreamOpts = {\n        ...options,\n        onStop() {\n            if (returnRemainder && !queue.isEmpty) {\n                const data = queue.toArray();\n                queue.clear();\n                upstream.set(data);\n            }\n        },\n        onValue(value) {\n            queue.enqueue(value);\n            if (quantity > 0 && queue.length >= quantity) {\n                // Reached quantity limit\n                send();\n            }\n            // Start timer\n            if (timer !== undefined && timer.runState === `idle`) {\n                timer.start();\n            }\n        },\n    };\n    const upstream = initUpstream(source, upstreamOpts);\n    //let testElapsed = performance.now();\n    const send = () => {\n        //console.log(`Elapsed: ${ performance.now() - testElapsed }`);\n        //testElapsed = performance.now();\n        if (queue.isEmpty)\n            return;\n        // Reset timer\n        if (timer !== undefined)\n            timer.start();\n        // Fire queued data\n        const data = queue.toArray();\n        queue.clear();\n        setTimeout(() => { upstream.set(data); });\n    };\n    const timer = options.elapsed ? timeout(send, options.elapsed) : undefined;\n    // const trigger = () => {\n    //   const now = performance.now();\n    //   let byElapsed = false;\n    //   let byLimit = false;\n    //   if (elapsed > 0 && (now - lastFire > elapsed)) {\n    //     lastFire = now;\n    //     byElapsed = true;\n    //   }\n    //   if (limit > 0 && queue.length >= limit) {\n    //     byLimit = true;\n    //   }\n    //   if (logic === `or` && (!byElapsed && !byLimit)) return;\n    //   if (logic === `and` && (!byElapsed || !byLimit)) return;\n    //   send();\n    // }\n    return toReadable(upstream);\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Transforms values from `source` using the `transformer` function.\n * @param transformer\n * @returns\n */\nexport function transform(input, transformer, options = {}) {\n    const traceInput = options.traceInput ?? false;\n    const traceOutput = options.traceOutput ?? false;\n    const upstream = initUpstream(input, {\n        lazy: `initial`,\n        ...options,\n        onValue(value) {\n            const t = transformer(value);\n            if (traceInput && traceOutput) {\n                console.log(`Rx.Ops.transform input: ${JSON.stringify(value)} output: ${JSON.stringify(t)}`);\n            }\n            else if (traceInput) {\n                console.log(`Rx.Ops.transform input: ${JSON.stringify(value)}`);\n            }\n            else if (traceOutput) {\n                console.log(`Rx.Ops.transform output: ${JSON.stringify(t)}`);\n            }\n            upstream.set(t);\n        },\n    });\n    return toReadable(upstream);\n}\n","import { isPlainObjectOrPrimitive } from \"@ixfx/guards\";\nimport { transform } from \"./transform.js\";\n/**\n * Create a new object from input, based on cloning fields rather than a destructured copy.\n * This is useful for event args.\n * @param source\n * @returns\n */\nexport const cloneFromFields = (source) => {\n    return transform(source, (v) => {\n        const entries = [];\n        for (const field in v) {\n            const value = (v)[field];\n            if (isPlainObjectOrPrimitive(value)) {\n                entries.push([field, value]);\n            }\n        }\n        return Object.fromEntries(entries);\n    });\n};\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { messageIsDoneSignal, messageHasValue } from \"../util.js\";\n/**\n * Monitors input reactive values, storing values as they happen to an array.\n * Whenever a new value is emitted, the whole array is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n *\n * See {@link combineLatestToObject} to combine streams by name into an object, rather than array.\n *\n * ```\n * const sources = [\n *  Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToArray(sources);\n * r.onValue(value => {\n *  // Value will be an array of last value from each source:\n *  // [number,number]\n * });\n * ```\n *\n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToArray} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n *\n * Set `onSourceDone` to choose behaviour if a source stops. By default it\n * is 'break', meaning the whole merged stream stops.\n *\n * Note: unlike RxJS's `combineLatest`, does not wait for each source to emit once\n * before emitting first value.\n * @param reactiveSources Sources to merge\n * @param options Options for merging\n * @returns\n */\nexport function combineLatestToArray(reactiveSources, options = {}) {\n    const event = initStream();\n    const onSourceDone = options.onSourceDone ?? `break`;\n    const data = [];\n    const sources = reactiveSources.map(source => resolveSource(source));\n    const noop = () => { };\n    const sourceOff = sources.map(_ => noop);\n    const doneSources = sources.map(_ => false);\n    const unsub = () => {\n        for (const v of sourceOff) {\n            v();\n        }\n    };\n    for (const [index, v] of sources.entries()) {\n        data[index] = undefined;\n        sourceOff[index] = v.on(message => {\n            if (messageIsDoneSignal(message)) {\n                doneSources[index] = true;\n                sourceOff[index]();\n                sourceOff[index] = noop;\n                if (onSourceDone === `break`) {\n                    unsub();\n                    event.dispose(`Source has completed and 'break' is set`);\n                    return;\n                }\n                if (!doneSources.includes(false)) {\n                    // All sources are done\n                    unsub();\n                    event.dispose(`All sources completed`);\n                }\n            }\n            else if (messageHasValue(message)) {\n                data[index] = message.value;\n                event.set([...data]);\n            }\n        });\n    }\n    return {\n        dispose: event.dispose,\n        isDisposed: event.isDisposed,\n        on: event.on,\n        onValue: event.onValue\n    };\n}\n","import { DispatchList } from \"@ixfx/flow\";\nimport * as Pathed from \"@ixfx/core/records\";\nimport { initStream } from \"../init-stream.js\";\nimport { throwResult, isEqualContextString } from \"@ixfx/core\";\nimport { wildcard } from \"@ixfx/core/text\";\n/**\n * Creates a Reactive wrapper with the shape of the input object.\n *\n * Changing the wrapped object directly does not update the Reactive.\n * Instead, to update values use:\n * * `set()`, 'resets' the whole object\n * * `update()` changes a particular field\n *\n * Consider using {@link Rx.From.objectProxy} to return a object with properties that can be\n * set in the usual way yet is also Reactive.\n *\n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onValue(changed => {\n * });\n * o.set({ name: `mary`, level: 3 });\n *\n * // `onValue` will get called, with `changed` having a value of:\n * // { name: `mary`, level: 3 }\n * ```\n *\n * Use `last()` to get the most recently set value.\n *\n * `onDiff` subscribes to a rough diff of the object.\n *\n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onDiff(diffValue => {\n *  const diff = diffValue.value;\n * })\n * o.set({ name: `mary`, level: 3 });\n *\n * // onDiff would fire with `diff` of:\n * [\n *  { path: `name`, previous: `bob`, value: `mary` },\n *  { path: `level`, previous: 2, value: 3 }\n * ]\n * ```\n *\n * You can also listen to updates on a field via `onField`.\n * ```js\n * o.onField(`name`, value => {\n *  // Called whenever the 'name' field is updated\n * });\n * ```\n * @param initialValue  Initial value\n * @param options Options\n * @returns\n */\nexport function object(initialValue, options = {}) {\n    const eq = options.eq ?? isEqualContextString;\n    const setEvent = initStream();\n    const diffEvent = initStream();\n    //const fieldChangeEvents = new Map<string, DispatchList<ObjectFieldHandler>>;\n    const fieldChangeEvents = [];\n    let value = initialValue;\n    let disposed = false;\n    const set = (v) => {\n        const diff = [...Pathed.compareData(value ?? {}, v, { ...options, includeMissingFromA: true })];\n        if (diff.length === 0)\n            return;\n        value = v;\n        setEvent.set(v);\n        diffEvent.set(diff);\n    };\n    const fireFieldUpdate = (field, value) => {\n        for (const [matcher, pattern, list] of fieldChangeEvents) {\n            if (matcher(field)) {\n                list.notify({ fieldName: field, pattern, value });\n            }\n        }\n        //const l = fieldChangeEvents.get(field.toLowerCase());\n        //if (l === undefined) return;\n        //l.notify(value);\n    };\n    const updateCompareOptions = {\n        asPartial: true,\n        includeParents: true\n    };\n    const update = (toMerge) => {\n        //console.log(`Rx.From.object update: toMerge: ${ JSON.stringify(toMerge) } value: ${ JSON.stringify(value) }`);\n        if (value === undefined) {\n            value = toMerge;\n            setEvent.set(value);\n            for (const [k, v] of Object.entries(toMerge)) {\n                fireFieldUpdate(k, v);\n            }\n            return value;\n        }\n        else {\n            const diff = [...Pathed.compareData(value, toMerge, updateCompareOptions)];\n            //const diffWithoutRemoved = diff.filter(d => d.state !== `removed`);\n            if (diff.length === 0)\n                return value; // No changes\n            value = {\n                ...value,\n                ...toMerge\n            };\n            setEvent.set(value);\n            diffEvent.set(diff);\n            //console.log(`diff`, diff);\n            for (const d of diff) {\n                fireFieldUpdate(d.path, d.value);\n            }\n            return value;\n        }\n    };\n    const updateField = (path, valueForField) => {\n        if (value === undefined)\n            throw new Error(`Cannot update value when it has not already been set`);\n        //console.log(`Rx.Sources.Object.updateField path: ${ path } value: ${ JSON.stringify(valueForField) }`);\n        const existing = Pathed.getField(value, path);\n        if (!throwResult(existing))\n            return; // Eg if path not found\n        //console.log(`Rx.fromObject.updateField path: ${ path } existing: ${ JSON.stringify(existing) }`);\n        if (eq(existing.value, valueForField, path)) {\n            //console.log(`Rx.object.updateField identical existing: ${ existing } value: ${ valueForField } path: ${ path }`);\n            return;\n        }\n        let diff = [...Pathed.compareData(existing.value, valueForField, { ...options, includeMissingFromA: true })];\n        diff = diff.map(d => {\n            if (d.path.length > 0)\n                return { ...d, path: path + `.` + d.path };\n            return { ...d, path };\n        });\n        //console.log(`Rx.fromObject.updateField diff path: ${ path }`, diff);\n        const o = Pathed.updateByPath(value, path, valueForField, true);\n        value = o;\n        //diffEvent.set([ { path, value: valueForField, previous: existing } ]);\n        setEvent.set(o);\n        diffEvent.set(diff);\n        fireFieldUpdate(path, valueForField);\n        //console.log(`Rx.fromObject.updateField: path: '${ path }' value: '${ JSON.stringify(valueForField) }' o: ${ JSON.stringify(o) }`);\n    };\n    const dispose = (reason) => {\n        if (disposed)\n            return;\n        diffEvent.dispose(reason);\n        setEvent.dispose(reason);\n        disposed = true;\n    };\n    return {\n        dispose,\n        isDisposed() {\n            return disposed;\n        },\n        /**\n         * Update a field.\n         * Exception is thrown if field does not exist\n         */\n        updateField,\n        last: () => value,\n        on: setEvent.on,\n        onValue: setEvent.onValue,\n        onDiff: diffEvent.onValue,\n        onField(fieldPattern, handler) {\n            const matcher = wildcard(fieldPattern);\n            const listeners = new DispatchList();\n            fieldChangeEvents.push([matcher, fieldPattern, listeners]);\n            const id = listeners.add(handler);\n            return () => listeners.remove(id);\n            // let listeners = fieldChangeEvents.get(fieldName.toLowerCase());\n            // if (listeners === undefined) {\n            //   listeners = new DispatchList();\n            //   fieldChangeEvents.set(fieldName.toLowerCase(), listeners);\n            // }\n            // const id = listeners.add((value) => {\n            //   setTimeout(() => { handler(value, fieldName) }, 1);\n            // });\n            // return () => listeners.remove(id);\n        },\n        /**\n         * Set the whole object\n         */\n        set,\n        /**\n         * Update the object with a partial set of fields and values\n         */\n        update\n    };\n}\n","import * as MapFns from \"@ixfx/core/maps\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { messageIsDoneSignal, messageHasValue, isWritable } from \"../util.js\";\nimport { object } from \"../from/object.js\";\n/**\n * Monitors input reactive values, storing values as they happen to an object.\n * Whenever a new value is emitted, the whole object is sent out, containing current\n * values from each source (or _undefined_ if not yet emitted)\n *\n * See {@link combineLatestToArray} to combine streams by name into an array instead.\n *\n * ```\n * const sources = {\n *  fast: Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  slow: Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToObject(sources);\n * r.onValue(value => {\n *  // 'value' will be an object containing the labelled latest\n *  // values from each source.\n *  // { fast: number, slow: number }\n * });\n * ```\n *\n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToObject} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n *\n * This source ends if all source streams end.\n * @param reactiveSources Sources to merge\n * @param options Options for merging\n * @returns\n */\nexport function combineLatestToObject(reactiveSources, options = {}) {\n    const disposeSources = options.disposeSources ?? true;\n    const event = object(undefined);\n    const onSourceDone = options.onSourceDone ?? `break`;\n    const emitInitial = options.emitInitial ?? true;\n    let emitInitialDone = false;\n    const states = new Map();\n    for (const [key, source] of Object.entries(reactiveSources)) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        const initialData = (`last` in source) ? source.last() : undefined;\n        //console.log(`initialData: ${ initialData } src: ${ (source as any).last() }`);\n        const s = {\n            source: resolveSource(source),\n            done: false,\n            data: initialData,\n            off: () => { }\n        };\n        states.set(key, s);\n    }\n    const sources = Object.fromEntries(Object.entries(states).map(entry => [entry[0], entry[1].source]));\n    const someUnfinished = () => MapFns.some(states, v => !v.done);\n    const unsub = () => {\n        //console.log(`Rx.MergeToObject.unsub states: ${ [ ...states.keys() ].join(`,`) }`);\n        for (const state of states.values())\n            state.off();\n    };\n    const getData = () => {\n        const r = {};\n        for (const [key, state] of states) {\n            const d = state.data;\n            if (d !== undefined) {\n                r[key] = state.data;\n            }\n        }\n        //console.log(`Rx.Ops.CombineLatestToObject getData`, r);\n        return r;\n    };\n    const trigger = () => {\n        emitInitialDone = true;\n        const d = getData();\n        //console.log(`Rx.Ops.combineLatestToObject trigger`, d);\n        event.set(d);\n    };\n    const wireUpState = (state) => {\n        state.off = state.source.on(message => {\n            if (messageIsDoneSignal(message)) {\n                state.done = true;\n                state.off();\n                state.off = () => { };\n                if (onSourceDone === `break`) {\n                    unsub();\n                    event.dispose(`Source has completed and 'break' is behaviour`);\n                    return;\n                }\n                if (!someUnfinished()) {\n                    // All sources are done\n                    unsub();\n                    event.dispose(`All sources completed`);\n                }\n            }\n            else if (messageHasValue(message)) {\n                state.data = message.value;\n                trigger();\n            }\n        });\n    };\n    for (const state of states.values()) {\n        wireUpState(state);\n    }\n    if (!emitInitialDone && emitInitial) {\n        //console.log(`Rx.Ops.CombineLatestToObject emitting initial`);\n        trigger();\n    }\n    return {\n        ...event,\n        hasSource(field) {\n            return states.has(field);\n        },\n        replaceSource(field, source) {\n            const state = states.get(field);\n            if (state === undefined)\n                throw new Error(`Field does not exist: '${field}'`);\n            state.off();\n            const s = resolveSource(source);\n            state.source = s;\n            wireUpState(state);\n        },\n        setWith(data) {\n            const written = {};\n            for (const [key, value] of Object.entries(data)) {\n                const state = states.get(key);\n                if (state !== undefined) {\n                    if (isWritable(state.source)) {\n                        state.source.set(value);\n                        written[key] = value;\n                    }\n                    state.data = value;\n                }\n            }\n            return written;\n        },\n        sources,\n        last() {\n            return getData();\n        },\n        dispose(reason) {\n            unsub();\n            event.dispose(reason);\n            if (disposeSources) {\n                for (const v of states.values()) {\n                    v.source.dispose(`Part of disposed mergeToObject`);\n                }\n            }\n        }\n    };\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport { hasLast } from \"../util.js\";\n/**\n * When there is a value from `input`, or the reactive is pinged,\n * this reactive emits the result of `fn`.\n *\n * `fn` is provided the previous value as well as the most recent value.\n *\n * If no previous value is available, the current value is emitted and `fn` is not called.\n * @param input\n * @param fn\n * @returns\n */\nexport function computeWithPrevious(input, fn) {\n    let previousValue;\n    let currentValue;\n    if (hasLast(input)) {\n        currentValue = previousValue = input.last();\n    }\n    const trigger = () => {\n        if (previousValue === undefined && currentValue !== undefined) {\n            previousValue = currentValue;\n            upstream.set(previousValue);\n        }\n        else if (previousValue !== undefined && currentValue !== undefined) {\n            const vv = fn(previousValue, currentValue);\n            //console.log(`vv: ${ vv } prev: ${ previousValue } target: ${ target }`)\n            previousValue = vv;\n            upstream.set(vv);\n        }\n    };\n    const upstream = initUpstream(input, {\n        lazy: \"very\",\n        debugLabel: `computeWithPrevious`,\n        onValue(value) {\n            //console.log(`onValue ${ value }`);\n            currentValue = value;\n            trigger();\n        },\n    });\n    if (currentValue)\n        trigger();\n    return {\n        ...toReadable(upstream),\n        ping: () => {\n            if (currentValue !== undefined)\n                trigger();\n        }\n    };\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { timeout } from \"@ixfx/flow\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Debounce waits for `elapsed` time after the last received value before emitting it.\n *\n * If a flurry of values are received that are within the interval, it won't emit anything. But then\n * as soon as there is a gap in the messages that meets the interval, the last received value is sent out.\n *\n * `debounce` always emits with at least `elapsed` as a delay after a value received. While {@link throttle} potentially\n * sends immediately, if it's outside of the elapsed period.\n *\n * This is a subtly different logic to {@link throttle}. `throttle` more eagerly sends the first value, potentially\n * not sending later values. `debouce` however will send later values, potentially ignoring earlier ones.\n * @param source\n * @param options\n * @returns\n */\nexport function debounce(source, options = {}) {\n    const elapsed = intervalToMs(options.elapsed, 50);\n    let lastValue;\n    const timer = timeout(() => {\n        const v = lastValue;\n        if (v) {\n            upstream.set(v);\n            lastValue = undefined;\n        }\n    }, elapsed);\n    const upstream = initUpstream(source, {\n        ...options,\n        onValue(value) {\n            lastValue = value;\n            timer.start();\n        }\n    });\n    return toReadable(upstream);\n}\n","import { debounce as debounceReactive } from \"../reactives/debounce.js\";\nexport function debounce(options) {\n    return (source) => {\n        return debounceReactive(source, options);\n    };\n}\n","import { transform } from \"./transform.js\";\n/**\n * Emits time in milliseconds since last message.\n * If it is the first value, 0 is used.\n * @param input\n * @returns\n */\nexport const elapsed = (input) => {\n    let last = 0;\n    return transform(input, (_ignored) => {\n        const elapsed = last === 0 ? 0 : Date.now() - last;\n        last = Date.now();\n        return elapsed;\n    });\n};\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * From a source value, yields a field from it. Only works\n * if stream values are objects.\n *\n * If a source value doesn't have that field, it is skipped.\n *\n * @returns\n */\nexport function field(fieldSource, fieldName, options = {}) {\n    const fallbackFieldValue = options.fallbackFieldValue;\n    const fallbackObject = options.fallbackObject;\n    const upstream = initUpstream(fieldSource, {\n        disposeIfSourceDone: true,\n        ...options,\n        onValue(value) {\n            let v;\n            // 1. Try to read from value\n            if (fieldName in value) {\n                v = value[fieldName];\n            }\n            else if (fallbackObject && fieldName in fallbackObject) {\n                // 2. Read from fallback object\n                v = fallbackObject[fieldName];\n            }\n            // 3. Use fallback value\n            if (v === undefined) {\n                v = fallbackFieldValue;\n            }\n            if (v !== undefined) {\n                upstream.set(v);\n            }\n        },\n    });\n    return toReadable(upstream);\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Passes all values where `predicate` function returns _true_.\n */\nexport function filter(input, predicate, options) {\n    const upstream = initUpstream(input, {\n        ...options,\n        onValue(value) {\n            if (predicate(value)) {\n                upstream.set(value);\n            }\n        },\n    });\n    return toReadable(upstream);\n}\n/**\n * Drops all values where `predicate` function returns _true_.\n */\nexport function drop(input, predicate, options) {\n    const upstream = initUpstream(input, {\n        ...options,\n        onValue(value) {\n            if (!predicate(value)) {\n                upstream.set(value);\n            }\n        },\n    });\n    return toReadable(upstream);\n}\n","//const sqrt = Math.sqrt;\nconst pow = Math.pow;\n//const pi = Math.PI;\n//const piPi = Math.PI*2;\nconst gaussianA = 1 / Math.sqrt(2 * Math.PI);\n\n/**\n * Returns a roughly gaussian easing function\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = Easings.gaussian();\n * ```\n *\n * Try different positive and negative values for `stdDev` to pinch\n * or flatten the bell shape.\n * @param standardDeviation\n * @returns\n */\nexport const gaussian = (standardDeviation = 0.4) => {\n  //const a = 1 / sqrt(2 * pi);\n  const mean = 0.5;\n\n  return (t: number) => {\n    const f = gaussianA / standardDeviation;\n    // p:-8 pinched\n    let p = -2.5; // -1/1.25;\n    let c = (t - mean) / standardDeviation;\n    c *= c;\n    p *= c;\n    const v = f * pow(Math.E, p); // * (2/pi);//0.62;\n    if (v > 1) return 1;\n    if (v < 0) return 0;\n    return v;\n  };\n};","import { gaussian } from \"../gaussian.js\";\n// Easings from https://easings.net/\n\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst cos = Math.cos;\nconst pi = Math.PI;\nconst sin = Math.sin;\n\n\nexport const bounceOut = (x: number) => {\n  const n1 = 7.5625;\n  const d1 = 2.75;\n\n  if (x < 1 / d1) {\n    return n1 * x * x;\n  } else if (x < 2 / d1) {\n    return n1 * (x -= 1.5 / d1) * x + 0.75;\n  } else if (x < 2.5 / d1) {\n    return n1 * (x -= 2.25 / d1) * x + 0.9375;\n  } else {\n    return n1 * (x -= 2.625 / d1) * x + 0.984_375;\n  }\n};\n\nexport const quintIn = (x: number) => x * x * x * x * x;\nexport const quintOut = (x: number) => 1 - pow(1 - x, 5);\nexport const arch = (x: number) => x * (1 - x) * 4;\n\nexport const smoothstep = (x: number) => x * x * (3 - 2 * x);\nexport const smootherstep = (x: number) => (x * (x * 6 - 15) + 10) * x * x * x;\nexport const sineIn = (x: number) => 1 - cos((x * pi) / 2);\nexport const sineOut = (x: number) => sin((x * pi) / 2);\nexport const quadIn = (x: number) => x * x;\nexport const quadOut = (x: number) => 1 - (1 - x) * (1 - x);\nexport const sineInOut = (x: number) => -(cos(pi * x) - 1) / 2;\nexport const quadInOut = (x: number) => x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2;\nexport const cubicIn = (x: number) => x * x * x;\nexport const cubicOut = (x: number) => 1 - pow(1 - x, 3);\nexport const quartIn = (x: number) => x * x * x * x;\nexport const quartOut = (x: number) => 1 - pow(1 - x, 4);\nexport const expoIn = (x: number) => (x === 0 ? 0 : pow(2, 10 * x - 10));\nexport const expoOut = (x: number) => (x === 1 ? 1 : 1 - pow(2, -10 * x));\nexport const quintInOut = (x: number) =>\n  x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2;\nexport const expoInOut = (x: number) =>\n  x === 0\n    ? 0\n    : x === 1\n      ? 1\n      // eslint-disable-next-line unicorn/no-nested-ternary\n      : x < 0.5\n        ? pow(2, 20 * x - 10) / 2\n        : (2 - pow(2, -20 * x + 10)) / 2;\nexport const circIn = (x: number) => 1 - sqrt(1 - pow(x, 2));\nexport const circOut = (x: number) => sqrt(1 - pow(x - 1, 2));\nexport const backIn = (x: number) => {\n  const c1 = 1.701_58;\n  const c3 = c1 + 1;\n\n  return c3 * x * x * x - c1 * x * x;\n};\nexport const backOut = (x: number) => {\n  const c1 = 1.701_58;\n  const c3 = c1 + 1;\n\n  return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\n};\nexport const circInOut = (x: number) =>\n  x < 0.5\n    ? (1 - sqrt(1 - pow(2 * x, 2))) / 2\n    : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;\n\nexport const backInOut = (x: number) => {\n  const c1 = 1.701_58;\n  const c2 = c1 * 1.525;\n\n  return x < 0.5\n    ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\n    : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n};\nexport const elasticIn = (x: number) => {\n  const c4 = (2 * pi) / 3;\n\n  return x === 0\n    ? 0\n    : (x === 1\n      ? 1\n      : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4));\n};\nexport const elasticOut = (x: number) => {\n  const c4 = (2 * pi) / 3;\n\n  return x === 0\n    ? 0\n    : (x === 1\n      ? 1\n      : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1);\n};\n\nexport const bounceIn = (x: number) => 1 - bounceOut(1 - x);\n\nexport const bell = gaussian();\n\nexport const elasticInOut = (x: number) => {\n  const c5 = (2 * pi) / 4.5;\n\n  return x === 0\n    ? 0\n    : x === 1\n      ? 1\n      // eslint-disable-next-line unicorn/no-nested-ternary\n      : x < 0.5\n        ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2\n        : (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\n};\nexport const bounceInOut = (x: number) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2;\n","import * as Named from './easings-named.js';\nimport { throwStringTest } from '@ixfx/guards';\nimport { type Interval } from '@ixfx/core';\nimport type { ModulationFunction, ModulatorTimed } from '../types.js';\nexport * as Named from './easings-named.js';\nexport * from './line.js';\nexport type * from './types.js';\nimport * as ModuleTimed from '../modulator-timed.js';\nimport type { EasingName, EasingOptions } from './types.js';\n\n\n/**\n * Creates an easing function\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const e = Easings.create({ duration: 1000, name: `quadIn` });\n * const e = Easings.create({ ticks: 100, name: `sineOut` });\n * const e = Easings.create({ \n *  duration: 1000, \n *  fn: (v) => {\n *    // v will be 0..1 based on time\n *    return Math.random() * v\n *  }\n * });\n * ```\n * @param options \n * @returns \n */\nexport const create = (options: EasingOptions): () => number => {\n  const name = resolveEasingName(options.name ?? `quintIn`);\n  const fn = name ?? options.fn;\n  if (typeof fn === `undefined`) throw new Error(`Either 'name' or 'fn' must be set`);\n\n  if (`duration` in options) {\n    return time(fn, options.duration);\n  } else if (`ticks` in options) {\n    return ticks(fn, options.ticks);\n  } else {\n    throw new Error(`Expected 'duration' or 'ticks' in options`);\n  }\n}\n\n/**\n * Creates an easing based on clock time. Time\n * starts being counted when easing function is created.\n * \n * `timeEasing` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n * \n * @example Time based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.timeEasing(`quintIn`, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of easing\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * \n * Thisi function is just a wrapper around Modulator.timedModulator.\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration\n * @returns Easing\n */\nexport const timeEasing = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  duration: Interval\n): ModulatorTimed => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModuleTimed.timeModulator(fn, duration);\n  // const timer = Timer.elapsedMillisecondsAbsolute();\n  // const durationMs = intervalToMs(duration);\n  // if (durationMs === undefined) throw new Error(`Param 'duration' not provided`);\n  // const relativeTimer = Timer.relative(\n  //   durationMs,\n  //   {\n  //     timer,\n  //     clampValue: true\n  //   });\n  // return Timer.timerWithFunction(fn, relativeTimer);\n};\n\n/**\n * Produce easing values over time. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * If you need to check if an easing is done or reset it, consider {@link timeEasing}.\n * \n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Quad-in easing over one second\n * const e = Easings.time(`quadIn`, 1000);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * \n * This function is just a wrapper around Modulate.time\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param duration Duration\n * @returns \n */\nexport const time = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  duration: Interval\n): () => number => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModuleTimed.time(fn, duration);\n  // let relative: undefined | (() => number);\n  // return () => {\n  //   if (relative === undefined) relative = Timer.ofTotal(duration, { clampValue: true });\n  //   return fn(relative());\n  // }\n}\n\n\n/**\n * Produce easing values with each invocation. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * If you need to check if an easing is done or reset it, consider {@link tickEasing}.\n * \n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Quad-in easing over 100 ticks\n * const e = Easings.ticks(`quadIn`, 100);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * \n * This is just a wrapper around Modulator.ticks\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns \n */\nexport const ticks = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  totalTicks: number\n): () => number => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModuleTimed.ticks(fn, totalTicks);\n  // let relative: undefined | (() => number);\n  // return () => {\n  //   if (relative === undefined) relative = Timer.ofTotalTicks(totalTicks, { clampValue: true });\n  //   return fn(relative());\n  // }\n}\n/**\n * Creates an easing based on ticks. \n * \n * `tickEasing` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.tickEasing(`sineIn`, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param durationTicks Duration in ticks\n * @returns Easing\n */\nexport const tickEasing = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  durationTicks: number\n): ModulatorTimed => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModuleTimed.tickModulator(fn, durationTicks);\n  // const timer = Timer.elapsedTicksAbsolute();\n  // const relativeTimer = Timer.relative(\n  //   durationTicks,\n  //   {\n  //     timer,\n  //     clampValue: true\n  //   });\n  // return Timer.timerWithFunction(fn, relativeTimer);\n};\n\nconst resolveEasingName = (nameOrFunction: EasingName | ((v: number) => number)): ModulationFunction => {\n  const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n  if (typeof fn === `undefined`) {\n    const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${ nameOrFunction }'`) : new Error(`Easing function not found`);\n    throw error;\n  }\n  return fn;\n}\n\n\n/**\n * Creates a new easing by name\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const e = Easings.create(`circInOut`, 1000, elapsedMillisecondsAbsolute);\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration (meaning depends on timer source)\n * @param timerSource Timer source\n * @returns\n */\n// const create = function (\n//   nameOrFunction: EasingName | ((v: number) => number),\n//   duration: number,\n//   timerSource: TimerSource\n// ): Easing {\n//   const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n//   if (fn === undefined) {\n//     const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${ nameOrFunction }'`) : new Error(`Easing function not found`);\n//     throw error;\n//   }\n\n//   // Get a relative version of timer\n//   const timer = relativeTimer(duration, {\n//     timer: timerSource(),\n//     clampValue: true,\n//   });\n//   let startCount = 1;\n\n//   return {\n//     get isDone() {\n//       return timer.isDone;\n//     },\n//     get runState() {\n//       if (timer.isDone) return `idle`;\n//       return `scheduled`;\n//     },\n//     /**\n//      * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n//      */\n//     get startCount() {\n//       return startCount;\n//     },\n//     get startCountTotal() {\n//       return startCount;\n//     },\n//     compute: () => {\n//       const relative = timer.elapsed;\n//       return fn(relative);\n//     },\n//     reset: () => {\n//       timer.reset();\n//       startCount++;\n//     },\n//   };\n// };\n\n\nlet easingsMap: Map<string, ((v: number) => number)> | undefined;\n\n/**\n * Returns an easing function by name. Throws an error if\n * easing is not found.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = Easings.get(`sineIn`);\n * // Returns 'eased' transformation of 0.5\n * fn(0.5);\n * ```\n * @param easingName eg `sineIn`\n * @returns Easing function\n */\nexport const get = function (easingName: EasingName): ModulationFunction {\n  throwStringTest(easingName, `non-empty`, `easingName`);\n\n  const found = cacheEasings().get(easingName.toLowerCase());\n  if (found === undefined) throw new Error(`Easing not found: '${ easingName }'`);\n  return found;\n};\n\n// Cache named easings\nfunction cacheEasings() {\n  if (easingsMap === undefined) {\n    easingsMap = new Map();\n    for (const [ k, v ] of Object.entries(Named)) {\n      easingsMap.set(k.toLowerCase(), v);\n    }\n    return easingsMap\n  } else return easingsMap;\n}\n\n/**\n * Iterate over available easings.\n * @private\n * @returns Returns list of available easing names\n */\nexport function* getEasingNames(): Iterable<string> {\n  const map = cacheEasings();\n  yield* map.keys();\n};\n\n","import { clamp, wrap, type BasicInterpolateOptions } from \"@ixfx/numbers\";\nimport { ofTotal } from \"@ixfx/flow\";\nimport { throwNumberTest } from '@ixfx/guards';\n\nimport { get as getEasing, type EasingName } from './easing/index.js';\nimport type { Interval } from \"@ixfx/core\";\nimport { piPi } from \"./util/pi-pi.js\";\n\n\n/**\n * Interpolation options.\n * \n * Limit: What to do if interpolation amount exceeds 0..1 range\n * * clamp: lock to A & B (inclusive) Default.\n * * wrap: wrap from end to start again\n * * ignore: allow return values outside of A..B range\n * \n * Easing: name of easing function for non-linear interpolation\n * \n * Transform: name of function to transform `amount` prior to interpolate. This is useful for creating non-linear interpolation results.\n * \n * For example:\n * ```js\n * // Divide interpolation amount in half\n * const interpolatorInterval({ mins: 1 }, 10, 100, {\n *  transform: (amount) => amount * Math.random()\n * });\n * ```\n * In the above example, the results would get more random over time.\n * `interpolatorInterval` will still step through the interpolation range of 0..1 in an orderly fashion, but we're transforming that range using a custom function before producing the result. \n * \n */\nexport type InterpolateOptions = BasicInterpolateOptions & {\n  easing: EasingName,\n}\n\n/**\n * Returns an interpolation function with a fixed interpolation amount. This\n * function will need the A and B values to interpolate between (ie start and end)\n * \n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * \n * // Create function\n * const fn = interpolate(0.1);\n * \n * // Later, use to interpolate between a and b\n * fn(50, 100); // 10% of 50..100 range\n * ```\n * \n * This is useful if you have a fixed interpolation amount, but varying A and B values.\n * @param amount Interpolation value (0..1 usually)\n * @param options Options\n */\nexport function interpolate(amount: number, options?: Partial<InterpolateOptions>): (a: number, b: number) => number;\n\n/**\n * Interpolates between `a` and `b` by `amount`.\n * \n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * \n * // Get the value at 10% of range between 50-100\n * const fn = interpolate(0.1, 50, 100);\n * ```\n * \n * This is useful if you have dynamic interpolation amount as well as A & B values.\n * Consider using `interpolate(amount)` if you have a fixed interpolation amount.\n * @param amount Interpolation value (0..1 usually)\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport function interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n\n/**\n * Returns an interpolation function with a fixed A and B values.\n * The returned function requires an interpolation amount. This is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * \n * // Create function to interpolate between 50..100\n * const fn = interpolate(50, 100);\n * \n * // Later, use to interpolate\n * fn(0.1); // 10% of 50..100 range\n * ```\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport function interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide on Interpolation](https://ixfx.fun/data/interpolation/overview/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * interpolate(0.5, 30, 60);\n * ```\n *\n * See also {@link interpolatorStepped} and {@link interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n * \n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n * \n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n * \n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * To interpolate certain types: {@link Visual.Colour.interpolator | Visual.Colour.interpolator }, {@link Geometry.Points.interpolate | Points.interpolate}.\n * \n * There are a few variations when calling `interpolate`, depending on what parameters are fixed.\n * * `interpolate(amount)`: returns a function that needs a & b \n * * `interpolate(a, b)`:  returns a function that needs the interpolation amount\n */\nexport function interpolate(pos1: number, pos2?: number | Partial<InterpolateOptions>, pos3?: number | Partial<InterpolateOptions>, pos4?: Partial<InterpolateOptions>) {\n  let amountProcess: undefined | ((v: number) => number);\n  let limits: InterpolateOptions[ 'limits' ] = `clamp`;\n\n  const handleAmount = (amount: number) => {\n    if (amountProcess) amount = amountProcess(amount);\n    if (limits === undefined || limits === `clamp`) {\n      amount = clamp(amount);\n    } else if (limits === `wrap`) {\n      if (amount > 1) amount = amount % 1;\n      else if (amount < 0) {\n        amount = 1 + (amount % 1);\n      }\n    }\n    return amount;\n  }\n\n  const doTheEase = (_amt: number, _a: number, _b: number) => {\n    throwNumberTest(_a, ``, `a`);\n    throwNumberTest(_b, ``, `b`);\n    throwNumberTest(_amt, ``, `amount`);\n    _amt = handleAmount(_amt);\n    return (1 - _amt) * _a + _amt * _b\n  }\n\n\n  const readOpts = (o: Partial<InterpolateOptions> = {}) => {\n    if (o.easing) {\n      const easer = getEasing(o.easing);\n      if (!easer) throw new Error(`Easing function '${ o.easing }' not found`);\n      amountProcess = easer;\n    } else if (o.transform) {\n      if (typeof o.transform !== `function`) throw new Error(`Param 'transform' is expected to be a function. Got: ${ typeof o.transform }`);\n      amountProcess = o.transform;\n    }\n    limits = o.limits ?? `clamp`;\n  }\n\n  const rawEase = (_amt: number, _a: number, _b: number) => (1 - _amt) * _a + _amt * _b\n\n  if (typeof pos1 !== `number`) throw new TypeError(`First param is expected to be a number. Got: ${ typeof pos1 }`);\n  if (typeof pos2 === `number`) {\n    let a: number;\n    let b: number;\n    if (pos3 === undefined || typeof pos3 === `object`) {\n      //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n      a = pos1;\n      b = pos2;\n      readOpts(pos3);\n      return (amount: number) => doTheEase(amount, a, b);\n    } else if (typeof pos3 === `number`) {\n      //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n      a = pos2;\n      b = pos3;\n      readOpts(pos4);\n      return doTheEase(pos1, a, b);\n    } else {\n      throw new Error(`Values for 'a' and 'b' not defined`);\n    }\n  } else if (pos2 === undefined || typeof pos2 === `object`) {\n    //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n    const amount = handleAmount(pos1);\n    readOpts(pos2);\n    throwNumberTest(amount, ``, `amount`);\n    return (aValue: number, bValue: number) => rawEase(amount, aValue, bValue);\n  }\n};\n\n\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link interpolatorInterval}\n * which steps on the basis of clock time.\n * \n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n * \n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n * \n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n * \n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n * \n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorStepped = (incrementAmount: number, a = 0, b = 1, startInterpolationAt = 0, options?: Partial<InterpolateOptions>) => {\n  let amount = startInterpolationAt;\n  return (retargetB?: number, retargetA?: number) => {\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    amount += incrementAmount;\n    return value;\n  }\n}\n\n\n\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (\n  amount: number,\n  aRadians: number,\n  bRadians: number,\n  options?: Partial<InterpolateOptions>\n): number => {\n  const t = wrap(bRadians - aRadians, 0, piPi);\n  return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n\n\n/**\n * Interpolates between A->B over `duration`.\n * Given the same A & B values, steps will be larger if it's a longer\n * duration, and shorter if it's a smaller duration.\n * \n * A function is returned, which when invoked yields a value between A..B.\n * \n * Alternatively to step through by the same amount regardless\n * of time, use {@link interpolatorStepped}.\n * \n * ```js\n * // Interpolate from 0..1 over one minute\n * const v = interpolatorInterval({mins:1});\n * v(); // Compute current value\n * ```\n * \n * Use start and end points:\n * ```js\n * // Interpolate from 100-200 over 10 seconds\n * const v = interpolatorInterval({secs:10}, 100, 200);\n * v(); // Compute current value\n * ```\n * @param duration Duration for interpolation\n * @param a Start point\n * @param b End point\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorInterval = (duration: Interval, a = 0, b = 1, options?: Partial<InterpolateOptions>) => {\n  const durationProgression = ofTotal(duration, { clampValue: true });\n  return (retargetB?: number, retargetA?: number) => {\n    const amount = durationProgression();\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    return value;\n  }\n}","import { interpolate as interpolateFunction } from \"@ixfx/modulation\";\nimport { computeWithPrevious } from \"./compute-with-previous.js\";\n/**\n * Interpolates to the source value.\n *\n * Outputs one value for every input value. Thus, to interpolation\n * over time, it's necessary to get the source to emit values at the desired rate.\n *\n * Options can specify an easing name or custom transform of easing progress.\n * @param input\n * @param options\n * @returns\n */\nexport function interpolate(input, options = {}) {\n    const amount = options.amount ?? 0.1;\n    const snapAt = options.snapAt ?? 0.99;\n    const index = interpolateFunction(amount, options);\n    return computeWithPrevious(input, (previous, target) => {\n        const v = index(previous, target);\n        if (target > previous) {\n            if (v / target >= snapAt)\n                return target;\n        }\n        return v;\n    });\n}\n/**\n * From the basis of an input stream of values, run a function over\n * each value. The function takes in the last value from the stream as well as the current.\n * @param input\n * @param fn\n * @returns\n */\n// export function interpolateToTarget<TIn>(input: ReactiveOrSource<TIn>, fn: (previous: TIn, target: TIn) => TIn): ReactivePingable<TIn> {\n//   let previousValue: TIn | undefined;\n//   let target: TIn | undefined;\n//   if (hasLast(input)) {\n//     target = previousValue = input.last();\n//   }\n//   const ping = () => {\n//     if (previousValue === undefined && target !== undefined) {\n//       previousValue = target;\n//     } else if (previousValue !== undefined && target !== undefined) {\n//       previousValue = fn(previousValue, target);\n//     }\n//     upstream.set(previousValue!);\n//   }\n//   const upstream = initUpstream<TIn, TIn>(input, {\n//     lazy: \"very\",\n//     debugLabel: `computeWithPrevious`,\n//     onValue(value) {\n//       target = value;\n//       ping();\n//     },\n//   })\n//   if (target) ping();\n//   return {\n//     ...toReadable(upstream),\n//     ping: () => {\n//       if (target !== undefined) ping()\n//     }\n//   }\n// }\n","import type { Process, RankFunction, RankOptions } from \"./types.js\";\nexport type { Process } from \"./types.js\";\n/**\n * Outputs the current largest-seen value\n * @returns \n */\nexport const max = (): Process<number | number[], number> => {\n  let max = Number.MIN_SAFE_INTEGER;\n  const compute = (value: number | number[]) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) break;\n      max = Math.max(subValue, max);\n    }\n    return max;\n  }\n  return compute;\n}\n\n/**\n * Outputs the current smallest-seen value\n * @returns\n */\nexport const min = (): Process<number | number[], number> => {\n  let min = Number.MAX_SAFE_INTEGER;\n  const compute = (value: number | number[]) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) break;\n      min = Math.min(subValue, min);\n    }\n    return min;\n  }\n  return compute;\n}\n\n/**\n * Returns a sum of values\n * @returns \n */\nexport const sum = (): Process<number | number[], number> => {\n  let t = 0;\n  const compute = (value: number | number[]) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) continue;\n      t += subValue;\n    }\n    return t;\n  }\n  return compute;\n}\n\n/**\n * Returns the current average of input values\n * @returns \n */\nexport const average = (): Process<number | number[], number> => {\n  let total = 0;\n  let tally = 0;\n  const compute = (value: number | number[]) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) continue;\n      tally++;\n      total += subValue;\n    }\n    return total / tally;\n  }\n  return compute;\n}\n\n/**\n * Returns the tally (ie number of) values\n * @param countArrayItems \n * @returns \n */\nexport const tally = (countArrayItems: boolean): Process<any, number> => {\n  let t = 0;\n  const compute = (value: number | number[]) => {\n    if (countArrayItems) {\n      if (Array.isArray(value)) t += value.length;\n      else t++;\n    } else {\n      t++;\n    }\n    return t;\n  }\n  return compute;\n}\n\n\n\n/**\n * Returns the 'best' value seen so far as determined by a ranking function.\n * This is similar to min/max but usable for objects.\n * @param r \n * @param options \n * @returns \n */\nexport function rank<In>(r: RankFunction<In>, options: Partial<RankOptions> = {}) {\n  const includeType = options.includeType;\n  const emitEqualRanked = options.emitEqualRanked ?? false;\n  const emitRepeatHighest = options.emitRepeatHighest ?? false;\n  let best: In | undefined;\n  return (value: In) => {\n    if (includeType && typeof value !== includeType) return;\n    if (best === undefined) {\n      best = value;\n      return best;\n    } else {\n      const result = r(value, best);\n      //console.log(`result: ${ result } value: ${ JSON.stringify(value) } best: ${ JSON.stringify(best) }`);\n      if (result == `a`) {\n        // New value is the current best\n        best = value;\n        return best;\n      } else if (result === `eq` && emitEqualRanked) {\n        // New value is same rank as previous, but we have flag on\n        return best;\n      } else if (emitRepeatHighest) {\n        // Emit current highest due to flag\n        return best;\n      }\n    }\n  }\n}\n\n\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport * as Proc from '@ixfx/process';\nexport function max(input, options) {\n    const p = Proc.max();\n    return process(p, `max`, input, options);\n}\nexport function min(input, options) {\n    const p = Proc.min();\n    return process(p, `min`, input, options);\n}\nexport function average(input, options) {\n    const p = Proc.average();\n    return process(p, `average`, input, options);\n}\nexport function sum(input, options) {\n    const p = Proc.sum();\n    return process(p, `sum`, input, options);\n}\nexport function tally(input, options = {}) {\n    const countArrayItems = options.countArrayItems ?? true;\n    const p = Proc.tally(countArrayItems);\n    return process(p, `tally`, input, options);\n}\nexport function rank(input, rank, options) {\n    const p = Proc.rank(rank, options);\n    return process(p, `rank`, input, options);\n}\nfunction process(processor, annotationField, input, options = {}) {\n    const annotate = options.annotate;\n    let previous;\n    const skipUndefined = options.skipUndefined ?? true;\n    const skipIdentical = options.skipIdentical ?? true;\n    const upstream = initUpstream(input, {\n        ...options,\n        onValue(value) {\n            const x = processor(value);\n            if (x === undefined && skipUndefined)\n                return;\n            if (skipIdentical && x === previous)\n                return;\n            previous = x;\n            if (annotate) {\n                // eslint-disable-next-line unicorn/prevent-abbreviations\n                const ret = { value };\n                ret[annotationField] = x;\n                upstream.set(ret);\n            }\n            else {\n                upstream.set(x);\n            }\n        },\n    });\n    return toReadable(upstream);\n}\n//todo testing for annotation and non - annotated\n// rankArray\n// chunk, reduce\n// debounce, delay\n// duration, take\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../util.js\";\n/**\n * Pipes the output of one stream into another, in order.\n * The stream returned is a new stream which captures the final output.\n *\n * If any stream in the pipe closes the whole pipe is closed.\n * @param streams\n * @returns\n */\nexport const pipe = (...streams) => {\n    const event = initStream();\n    const unsubs = [];\n    const performDispose = (reason) => {\n        for (const s of streams) {\n            if (!s.isDisposed)\n                s.dispose(reason);\n        }\n        for (const s of unsubs) {\n            s();\n        }\n        event.dispose(reason);\n    };\n    for (let index = 0; index < streams.length; index++) {\n        unsubs.push(streams[index].on((message) => {\n            const isLast = index === streams.length - 1;\n            if (messageHasValue(message)) {\n                if (isLast) {\n                    // Last stream, send to output\n                    event.set(message.value);\n                }\n                else {\n                    // @ts-expect-error\n                    streams[index + 1].set(message.value);\n                }\n            }\n            else if (messageIsDoneSignal(message)) {\n                performDispose(`Upstream disposed`);\n            }\n        }));\n    }\n    return {\n        on: event.on,\n        onValue: event.onValue,\n        dispose(reason) {\n            performDispose(reason);\n        },\n        isDisposed() {\n            return event.isDisposed();\n        },\n    };\n};\n","import { shuffle } from \"@ixfx/arrays\";\nimport { initUpstream } from \"../init-stream.js\";\n/**\n * For a stream that emits arrays of values, this op will select a single value.\n *\n * Can select based on:\n * * predicate: a function that returns _true_ for a value\n * * at: selection based on array index (can be combined with random ordering to select a random value)\n *\n * ```js\n * // If source is Reactive<Array<number>>, picks the first even number\n * singleFromArray(source, {\n *  predicate: v => v % 2 === 0\n * });\n *\n * // Selects a random value from source\n * singleFromArray(source, {\n *  order: `random`,\n *  at: 0\n * });\n * ```\n *\n * If neither `predicate` or `at` options are given, exception is thrown.\n * @param source Source to read from\n * @param options Options for selection\n * @returns\n */\nexport function singleFromArray(source, options = {}) {\n    const order = options.order ?? `default`;\n    if (!options.at && !options.predicate)\n        throw new Error(`Options must have 'predicate' or 'at' fields`);\n    let preprocess = (values) => values;\n    if (order === `random`)\n        preprocess = shuffle;\n    else if (typeof order === `function`)\n        preprocess = (values) => values.toSorted(order);\n    const upstream = initUpstream(source, {\n        onValue(values) {\n            values = preprocess(values);\n            if (options.predicate) {\n                for (const v of values) {\n                    if (options.predicate(v)) {\n                        upstream.set(v);\n                    }\n                }\n            }\n            else if (options.at) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                upstream.set(values.at(options.at));\n            }\n        },\n    });\n    return upstream;\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\n/**\n * Creates a set of streams each of which receives data from `source`.\n * By default these are lazy and dispose if the upstream source closes.\n *\n * See also {@link splitLabelled} to split into named streams.\n * @param rxOrSource\n * @param options\n * @returns\n */\nexport const split = (rxOrSource, options = {}) => {\n    const quantity = options.quantity ?? 2;\n    const outputs = [];\n    const source = resolveSource(rxOrSource);\n    for (let index = 0; index < quantity; index++) {\n        outputs.push(initUpstream(source, { disposeIfSourceDone: true, lazy: `initial` }));\n    }\n    return outputs;\n};\n/**\n * Splits `source` into several duplicated streams.\n * Returns an object with keys according to `labels`.\n * Each value is a stream which echos the values from `source`.\n * ```js\n * const { a, b, c} = splitLabelled(source, `a`, `b`, `c`);\n * // a, b, c are Reactive types\n * ```\n *\n * See also {@link split} to get an unlabelled split\n * @param rxOrSource\n * @param labels\n * @returns\n */\nexport const splitLabelled = (rxOrSource, labels) => {\n    const source = resolveSource(rxOrSource);\n    const t = {};\n    for (const label of labels) {\n        t[label] = initUpstream(source, { lazy: `initial`, disposeIfSourceDone: true });\n    }\n    return t;\n};\n","import { initStream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../util.js\";\n/**\n * Switcher generates several output streams, labelled according to the values of `cases`.\n * Values from `source` are fed to the output streams if their associated predicate function returns _true_.\n *\n * In this way, we can split one input stream into several output streams, each potentially getting a different\n * subset of the input.\n *\n * With `options`, you can specify whether to send to multiple outputs if several match, or just the first (default behaviour).\n *\n * The below example shows setting up a switcher and consuming the output streams.\n * @example\n * ```js\n * // Initialise a reactive number, starting at 0\n * const switcherSource = Reactive.number(0);\n * // Set up the switcher\n * const x = Reactive.switcher(switcherSource, {\n *  even: v => v % 2 === 0,\n *  odd: v => v % 2 !== 0\n * });\n * // Listen for outputs from each of the resulting streams\n * x.even.on(msg => {\n *   log(`even: ${msg.value}`);\n * });\n * x.odd.on(msg => {\n *   log(`odd: ${msg.value}`);\n * })\n * // Set new values to the number source, counting upwards\n * // ...this will in turn trigger the outputs above\n * setInterval(() => {\n *   switcherSource.set(switcherSource.last() + 1);\n * }, 1000);\n * ```\n *\n * If `source` closes, all the output streams will be closed as well.\n * @param reactiveOrSource\n * @param cases\n * @param options\n * @returns\n */\nexport const switcher = (reactiveOrSource, cases, options = {}) => {\n    // return (r: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n    const match = options.match ?? `first`;\n    const source = resolveSource(reactiveOrSource);\n    let disposed = false;\n    // Setup output streams\n    const t = {};\n    for (const label of Object.keys(cases)) {\n        t[label] = initStream();\n    }\n    const performDispose = () => {\n        if (disposed)\n            return;\n        unsub();\n        disposed = true;\n        for (const stream of Object.values(t)) {\n            stream.dispose(`switcher source dispose`);\n        }\n    };\n    // Listen to source\n    const unsub = source.on(message => {\n        // Got a value\n        if (messageHasValue(message)) {\n            for (const [lbl, pred] of Object.entries(cases)) {\n                if (pred(message.value)) {\n                    t[lbl].set(message.value);\n                    if (match === `first`)\n                        break;\n                }\n            }\n        }\n        else if (messageIsDoneSignal(message)) {\n            performDispose();\n        }\n    });\n    return t;\n    // }\n};\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { intervalToMs } from \"@ixfx/core\";\nimport { initStream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { messageIsSignal } from \"../util.js\";\n/**\n * Waits for all sources to produce a value, sending the combined results as an array.\n * After sending, it waits again for each source to send at least one value.\n *\n * Use {@link syncToObject} to output objects based on labelled sources rather than an array of values.\n *\n * Pace will be set by the slowest source. Alternatively, use {@link combineLatestToArray} where the rate is determined by fastest source.\n *\n * Only complete results are sent. For example if source A & B finish and source C is still producing values,\n * synchronisation is not possible because A & B stopped producing values. Thus the stream will self-terminate\n * after `maximumWait` (2 seconds). The newer values from C are lost.\n */\nexport function syncToArray(reactiveSources, options = {}) {\n    const onSourceDone = options.onSourceDone ?? `break`;\n    const finalValue = options.finalValue ?? `undefined`;\n    const maximumWait = intervalToMs(options.maximumWait, 2000);\n    let watchdog;\n    const data = [];\n    //const finalData: Array<RxValueTypes<T> | undefined> = [];\n    // Resolve sources\n    //const sources = reactiveSources.map(source => resolveSource(source));\n    //const noop = () => {/*no-op*/ }\n    //const sourcesUnsub: Array<Unsubscriber> = sources.map(_ => noop);\n    const states = reactiveSources.map(source => ({\n        finalData: undefined,\n        done: false,\n        source: resolveSource(source),\n        unsub: () => { }\n    }));\n    const unsubscribe = () => {\n        for (const s of states) {\n            s.unsub();\n            s.unsub = () => { };\n        }\n    };\n    const isDataSetComplete = () => {\n        for (let index = 0; index < data.length; index++) {\n            if (onSourceDone === `allow` && states[index].done)\n                continue;\n            if (data[index] === undefined)\n                return false;\n        }\n        return true;\n    };\n    const hasIncompleteSource = () => states.some(s => !s.done);\n    const resetDataSet = () => {\n        for (let index = 0; index < data.length; index++) {\n            if (finalValue === `last` && states[index].done)\n                continue; // Don't overwrite\n            data[index] = undefined;\n        }\n    };\n    const onWatchdog = () => {\n        done(`Sync timeout exceeded (${maximumWait.toString()})`);\n    };\n    const done = (reason) => {\n        if (watchdog)\n            clearTimeout(watchdog);\n        unsubscribe();\n        event.dispose(reason);\n    };\n    const init = () => {\n        watchdog = setTimeout(onWatchdog, maximumWait);\n        for (const [index, state] of states.entries()) {\n            data[index] = undefined; // init array positions to be undefined\n            state.unsub = state.source.on(valueChanged => {\n                if (messageIsSignal(valueChanged)) {\n                    if (valueChanged.signal === `done`) {\n                        state.finalData = data[index];\n                        state.unsub();\n                        state.done = true;\n                        state.unsub = () => { };\n                        if (finalValue === `undefined`)\n                            data[index] = undefined;\n                        if (onSourceDone === `break`) {\n                            done(`Source '${index.toString()}' done, and onSourceDone:'break' is set`);\n                            return;\n                        }\n                        if (!hasIncompleteSource()) {\n                            done(`All sources done`);\n                            return;\n                        }\n                    }\n                    return;\n                }\n                data[index] = valueChanged.value;\n                if (isDataSetComplete()) {\n                    // All array elements contain values\n                    // Emit data and reset\n                    event.set([...data]);\n                    resetDataSet();\n                    if (watchdog)\n                        clearTimeout(watchdog);\n                    watchdog = setTimeout(onWatchdog, maximumWait);\n                }\n            });\n        }\n    };\n    const event = initStream({\n        onFirstSubscribe() {\n            unsubscribe();\n            init();\n        },\n        onNoSubscribers() {\n            if (watchdog)\n                clearTimeout(watchdog);\n            unsubscribe();\n        },\n    });\n    return {\n        dispose: event.dispose,\n        isDisposed: event.isDisposed,\n        on: event.on,\n        onValue: event.onValue\n    };\n}\n","import { zipKeyValue } from \"@ixfx/core/maps\";\nimport { syncToArray } from \"./sync-to-array.js\";\nimport { transform } from \"./transform.js\";\nexport function syncToObject(reactiveSources, options = {}) {\n    const keys = Object.keys(reactiveSources);\n    const values = Object.values(reactiveSources);\n    const s = syncToArray(values, options);\n    const st = transform(s, (streamValues) => {\n        return zipKeyValue(keys, streamValues);\n    });\n    return st;\n}\n","import { resolveSource } from \"../resolve-source.js\";\n/**\n * 'Taps' the values from 'input', passing them to the 'process' function.\n * Return stream is the input stream, unaffected by what 'process' does.\n * @param input Input stream\n * @param processors List of processors\n * @returns\n */\nexport function tapProcess(input, ...processors) {\n    const inputStream = resolveSource(input);\n    // @ts-expect-error\n    const chain = Process.flow(...processors);\n    inputStream.onValue(value => {\n        chain(value);\n    });\n    return inputStream;\n}\n/**\n * 'Taps' the values from 'input', passing them to 'diverged'\n * Returns the original input stream, unaffected by what 'diverged' does.\n * @param input Input stream\n * @param diverged Stream to write to\n * @returns\n */\nexport function tapStream(input, diverged) {\n    const inputStream = resolveSource(input);\n    inputStream.onValue(value => {\n        diverged.set(value);\n    });\n    return inputStream;\n}\n/**\n * Create a parallel 'tap' of processing\n * @param input Input stream\n * @param ops Series of ops to process data\n * @returns\n */\nexport const tapOps = (input, ...ops) => {\n    for (const op of ops) {\n        // @ts-expect-error\n        input = op(input);\n    }\n    return input;\n};\n","import { intervalToMs } from \"@ixfx/core\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Only allow a value through if a minimum amount of time has elapsed.\n * since the last value. This effectively slows down a source to a given number\n * of values/ms. Values emitted by the source which are too fast are discarded.\n *\n * Throttle will fire on the first value received.\n *\n * In more detail:\n * Every time throttle passes a value, it records the time it allowed something through. For every\n * value received, it checks the elapsed time against this timestamp, throwing away values if\n * the period hasn't elapsed.\n *\n * With this logic, a fury of values of the source might be discarded if they fall within the elapsed time\n * window. But then if there is not a new value for a while, the actual duration between values can be longer\n * than expected. This is in contrast to {@link debounce}, which will emit the last value received after a duration,\n * even if the source stops sending.\n * @param options\n * @returns\n */\nexport function throttle(throttleSource, options = {}) {\n    const elapsed = intervalToMs(options.elapsed, 0);\n    let lastFire = performance.now();\n    let lastValue;\n    const upstream = initUpstream(throttleSource, {\n        ...options,\n        onValue(value) {\n            lastValue = value;\n            trigger();\n        },\n    });\n    const trigger = () => {\n        const now = performance.now();\n        if (elapsed > 0 && (now - lastFire > elapsed)) {\n            lastFire = now;\n            if (lastValue !== undefined) {\n                upstream.set(lastValue);\n            }\n        }\n    };\n    return toReadable(upstream);\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { isTrigger, resolveTriggerValue } from \"../util.js\";\n/**\n * Emits a value if `source` does not emit a value after `interval`\n * has elapsed. This can be useful to reset a reactive to some\n * 'zero' state if nothing is going on.\n *\n * If `source` emits faster than the `interval`, it won't get triggered.\n *\n * Default for 'timeout': 1000s.\n *\n * ```js\n * // Emit 'hello' if 'source' doesn't emit a value after 1 minute\n * const r = Rx.timeoutValue(source, { value: 'hello', interval: { mins: 1 } });\n * ```\n *\n * Can also emit results from a function or generator\n * ```js\n * // Emits a random number if 'source' doesn't emit a value after 500ms\n * const r = Rx.timeoutValue(source, { fn: Math.random, interval: 500 });\n * ```\n *\n * If `immediate` option is _true_ (default), the timer starts from stream initialisation.\n * Otherwise it won't start until it observes the first value from `source`.\n * @param source\n * @param options\n */\nexport function timeoutValue(source, options) {\n    let timer;\n    const immediate = options.immediate ?? true;\n    const repeat = options.repeat ?? false;\n    const timeoutMs = intervalToMs(options.interval, 1000);\n    if (!isTrigger(options)) {\n        throw new Error(`Param 'options' does not contain trigger 'value' or 'fn' fields`);\n    }\n    // Send value from trigger\n    const sendFallback = () => {\n        const [value, done] = resolveTriggerValue(options);\n        if (done) {\n            events.dispose(`Trigger completed`);\n        }\n        else {\n            if (events.isDisposed())\n                return;\n            events.set(value);\n            if (repeat) {\n                timer = setTimeout(sendFallback, timeoutMs);\n            }\n        }\n    };\n    const events = initUpstream(source, {\n        disposeIfSourceDone: true,\n        // Received a value from upstream source\n        onValue(v) {\n            // Reset timeout\n            if (timer)\n                clearTimeout(timer);\n            timer = setTimeout(sendFallback, timeoutMs);\n            // Emit value\n            events.set(v);\n        },\n        onDispose() {\n            if (timer)\n                clearTimeout(timer);\n        },\n    });\n    if (immediate && !timer) {\n        timer = setTimeout(sendFallback, timeoutMs);\n    }\n    return events;\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { isPingable, isTrigger, messageHasValue, messageIsDoneSignal, resolveTriggerValue } from \"../util.js\";\n/**\n * Pings a reactive if no value is emitted at after `interval`.\n * Returns `source`.\n *\n * ```js\n * // Ping `source` if no value is emitted after one minute\n * const r = Rx.timeoutPing(source, { mins: 1 });\n * ```\n *\n * Behavior can be stopped using an abort signal.\n * @see {@link ReactivePingable}\n * @param source\n * @param options\n */\nexport function timeoutPing(source, options) {\n    let timer;\n    const rx = resolveSource(source);\n    const abort = options.abort;\n    const timeoutMs = intervalToMs(options, 1000);\n    // Send ping\n    const sendPing = () => {\n        if (abort?.aborted || rx.isDisposed()) {\n            off();\n            return;\n        }\n        if (isPingable(rx))\n            rx.ping(); // ignore if not pingable\n        timer = setTimeout(sendPing, timeoutMs);\n    };\n    const cancel = () => {\n        if (timer)\n            clearTimeout(timer);\n    };\n    const off = rx.on(message => {\n        if (messageHasValue(message)) {\n            // Reset timeout\n            cancel();\n            timer = setTimeout(sendPing, timeoutMs);\n        }\n        else if (messageIsDoneSignal(message)) {\n            off();\n            cancel();\n        }\n    });\n    timer = setTimeout(sendPing, timeoutMs);\n    return rx;\n}\n","import { initStream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { messageHasValue, messageIsDoneSignal, messageIsSignal } from \"../util.js\";\n/**\n * Pings `target` whenever `source` emits a value. The value itself is ignored, it just\n * acts as a trigger.\n *\n * Returns a new stream capturing the output of `target`.\n *\n * It `source` or `target` closes, output stream closes too.\n *\n * @returns\n */\nexport function valueToPing(source, target, options = {}) {\n    const lazy = options.lazy ?? `initial`;\n    const signal = options.signal;\n    const sourceRx = resolveSource(source);\n    const gate = options.gate ?? ((value) => true);\n    let upstreamOff;\n    let downstreamOff;\n    if (signal) {\n        signal.addEventListener(`abort`, () => {\n            done(`Abort signal ${signal.reason}`);\n        }, { once: true });\n    }\n    const events = initStream({\n        onFirstSubscribe() {\n            if (lazy !== `never` && upstreamOff === undefined)\n                start();\n        },\n        onNoSubscribers() {\n            // Unsubscribe from source if we're very lazy\n            // Stay subscribed if we're only initially lazy or not lazy at all\n            if (lazy === `very` && upstreamOff !== undefined) {\n                upstreamOff();\n                upstreamOff = undefined;\n            }\n        },\n    });\n    const start = () => {\n        //console.log(`Rx.valueToPing  start`);\n        upstreamOff = sourceRx.on(message => {\n            if (messageIsDoneSignal(message)) {\n                done(`Upstream closed`);\n            }\n            else if (messageIsSignal(message)) {\n                events.signal(message.signal);\n            }\n            else if (messageHasValue(message)) {\n                //console.log(`Rx.valueToPing got value: ${ message.value }`);\n                if (gate(message.value)) {\n                    target.ping();\n                }\n            }\n        });\n        downstreamOff = target.on(message => {\n            if (messageIsDoneSignal(message)) {\n                done(`Downstream closed`);\n            }\n            else if (messageIsSignal(message)) {\n                events.signal(message.signal, message.context);\n            }\n            else if (messageHasValue(message)) {\n                events.set(message.value);\n            }\n        });\n    };\n    const done = (reason) => {\n        events.dispose(reason);\n        if (upstreamOff)\n            upstreamOff();\n        if (downstreamOff)\n            downstreamOff();\n    };\n    if (lazy === `never`)\n        start();\n    return events;\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * A reactive where the last value can be read at any time.\n * An initial value must be provided.\n * ```js\n * const r = Rx.withValue(source, { initial: `hello` });\n * r.last(); // Read last value\n * ```\n *\n * Warning: Since most reactives only active when subscribed to, it's important to also subscribe\n * to the results of `r` for this flow to happen. Alternatively, use `lazy: 'never'` as an option.\n * @param input\n * @param options\n * @returns\n */\nexport function withValue(input, options) {\n    let lastValue = options.initial;\n    const upstream = initUpstream(input, {\n        ...options,\n        onValue(value) {\n            //console.log(`Rx.Ops.WithValue onValue: ${ value }`);\n            lastValue = value;\n            upstream.set(value);\n        },\n    });\n    const readable = toReadable(upstream);\n    return {\n        ...readable,\n        last() {\n            return lastValue;\n        },\n    };\n}\n","import { Directed } from \"@ixfx/collections/graph\";\nimport { initStream } from \"./init-stream.js\";\nimport { isReactive } from \"./util.js\";\n// function isReactive(o: object): o is Reactive<any> {\n//   if (typeof o !== `object`) return false;\n//   if (`on` in o) {\n//     return (typeof o.on === `function`);\n//   }\n//   return false;\n// }\n/**\n * Build a graph of reactive dependencies for `rx`\n * @param _rx\n */\nexport function prepare(_rx) {\n    let g = Directed.graph();\n    const nodes = new Map();\n    const events = initStream();\n    const process = (o, path) => {\n        for (const [key, value] of Object.entries(o)) {\n            const subPath = path + `.` + key;\n            g = Directed.connect(g, {\n                from: path,\n                to: subPath\n            });\n            if (isReactive(value)) {\n                nodes.set(subPath, { value, type: `rx` });\n                value.on(v => {\n                    console.log(`Rx.prepare value: ${JSON.stringify(v)} path: ${subPath}`);\n                });\n            }\n            else {\n                const valueType = typeof value;\n                if (valueType === `bigint` || valueType === `boolean` || valueType === `number` || valueType === `string`) {\n                    nodes.set(subPath, { type: `primitive`, value });\n                }\n                else if (valueType === `object`) {\n                    process(value, subPath);\n                }\n                else if (valueType === `function`) {\n                    console.log(`Rx.process - not handling functions`);\n                }\n            }\n        }\n    };\n    // const produce = () => {\n    //   Object.fromEntries(entries);\n    // }\n    // process(rx, `_root`);\n    // console.log(DiGraph.dumpGraph(g));\n    // console.log(`--- Map ---`);\n    // for (const entries of nodes.entries()) {\n    //   console.log(entries[ 0 ]);\n    //   console.log(entries[ 1 ]);\n    //   console.log(``)\n    // }\n    const returnValue = {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        dispose: events.dispose,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        isDisposed: events.isDisposed,\n        graph: g,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        on: events.on,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        onValue: events.onValue\n    };\n    return returnValue;\n}\n","export const symbol = Symbol(`Rx`);\n","import { intervalToMs } from \"@ixfx/core\";\nimport { resolveSource } from \"./resolve-source.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./util.js\";\n/**\n * Reads a set number of values from `source`, returning as an array. May contain\n * empty values if desired values is not reached.\n *\n * After the limit is reached (or `source` completes), `source` is unsubscribed from.\n *\n * If no limit is set, it will read until `source` completes or `maximumWait` is reached.\n * `maximumWait` is 10 seconds by default.\n *\n * Use {@link toArrayOrThrow} to throw if desired limit is not reached.\n *\n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArray()(source);\n * // Read 5 items from `source`\n * const data = await toArray({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArray({ maximumWait: 10_1000 })(source);\n * ```\n * @param source\n * @param options\n * @returns\n */\nexport async function toArray(source, options = {}) {\n    const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n    const maximumWait = intervalToMs(options.maximumWait, 10 * 1000);\n    const underThreshold = options.underThreshold ?? `partial`;\n    const read = [];\n    const rx = resolveSource(source);\n    const promise = new Promise((resolve, reject) => {\n        const done = () => {\n            clearTimeout(maxWait);\n            unsub();\n            if (read.length < limit && underThreshold === `throw`) {\n                reject(new Error(`Threshold not reached. Wanted: ${limit} got: ${read.length}. Maximum wait: ${maximumWait}`));\n                return;\n            }\n            if (read.length < limit && underThreshold === `fill`) {\n                for (let index = 0; index < limit; index++) {\n                    if (read[index] === undefined) {\n                        //console.log(`Rx.toArray filling at index: ${ index }`);\n                        read[index] = options.fillValue;\n                    }\n                }\n            }\n            resolve(read);\n        };\n        const maxWait = setTimeout(() => {\n            done();\n        }, maximumWait);\n        const unsub = rx.on(message => {\n            //console.log(`Rx.toArray: ${ JSON.stringify(message) }`);\n            if (messageIsDoneSignal(message)) {\n                done();\n            }\n            else if (messageHasValue(message)) {\n                read.push(message.value);\n                //console.log(`Rx.toArray read buffer: ${ JSON.stringify(read) }`);\n                if (read.length === limit) {\n                    done();\n                }\n            }\n        });\n    });\n    return promise;\n}\n/**\n * By default, reads all the values from `source`, or until 5 seconds has elapsed.\n *\n * If `limit` is provided as an option, it will exit early, or throw if that number of values was not acheived.\n *\n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArrayOrThrow()(source);\n * // Read 5 items from `source`\n * const data = await toArrayOrThrow({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArrayOrThrow({ maximumWait: 10_1000 })(source);\n * ```\n * @param source\n * @param options\n * @returns\n */\nexport async function toArrayOrThrow(source, options = {}) {\n    const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n    const maximumWait = options.maximumWait ?? 5 * 1000;\n    const v = await toArray(source, { limit, maximumWait, underThreshold: `partial` });\n    // There was a limit, but it wasn't reached\n    if (options.limit && v.length < options.limit)\n        throw new Error(`Threshold not reached. Wanted: ${options.limit}, got ${v.length}`);\n    // Otherwise, we may have been reading for a specified duration\n    return v;\n}\n","import { resolveSource } from \"./resolve-source.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./util.js\";\n/**\n * Returns an AsyncGenerator wrapper around Reactive.\n * This allows values to be iterated over using a `for await` loop,\n * like Chains.\n *\n * ```js\n * // Reactive numerical value\n * const number = Reactive.number(10);\n *\n * const g = Reactive.toGenerator(number);\n * for await (const v of g) {\n *  console.log(v); // Prints out whenever the reactive value changes\n * }\n * // Execution doesn't continue until Reactive finishes\n * ```\n *\n * When/if `source` closes, an exception is thrown.\n * To catch this, wrap the calling `for await` in a try-catch block\n * ```js\n * try {\n *  for await (const v of g) {\n *  }\n * } catch (error) {\n * }\n * // Completed\n * ```\n *\n * Use something like `setTimeout` to loop over the generator\n * without impeding the rest of your code flow. For example:\n * ```js\n * // Listen for every pointerup event\n * const ptr = Reactive.fromEvent(document.body, `pointerup`);\n * // Start iterating\n * setTimeout(async () => {\n *  const gen = Reactive.toGenerator(ptr);\n *  try {\n *    for await (const v of gen) {\n *      // Prints out whenever there is a click\n *      console.log(v);\n *    }\n *  } catch (e) { }\n *  console.log(`Iteration done`);\n * });\n *\n * // Execution continues here immediately\n * ```\n * @param source\n */\nexport async function* toGenerator(source) {\n    const s = resolveSource(source);\n    let promiseResolve = (_) => { };\n    let promiseReject = (_) => { };\n    const promiseInit = () => (new Promise((resolve, reject) => {\n        promiseResolve = resolve;\n        promiseReject = reject;\n    }));\n    let promise = promiseInit();\n    let keepRunning = true;\n    s.on(message => {\n        if (messageHasValue(message)) {\n            promiseResolve(message.value);\n            promise = promiseInit();\n        }\n        else if (messageIsDoneSignal(message)) {\n            keepRunning = false;\n            promiseReject(`Source has completed`);\n        }\n    });\n    while (keepRunning) {\n        yield await promise;\n    }\n}\n","import * as Ops from \"./ops/index.js\";\nimport * as Reactives from './reactives/index.js';\nimport { resolveSource } from \"./resolve-source.js\";\nimport { toArray, toArrayOrThrow } from \"./to-array.js\";\nimport { messageHasValue } from \"./util.js\";\nimport { mapObjectShallow } from '@ixfx/core/records';\nimport * as Enacts from './sinks/index.js';\n/**\n * Wrap a reactive source to allow for chained\n * function calls.\n *\n * Example:\n * For every `pointerup` event on the body, chunk the events over\n * periods of 200ms, get the number of events in that period,\n * and print it out.\n *\n * eg. detecting single or double-clicks\n * ```js\n * wrap(Rx.fromEvent<{ x: number, y: number }>(document.body, `pointerup`))\n *  .chunk({ elapsed: 200 })\n *  .transform(v => v.length)\n *  .onValue(v => { console.log(v) });\n * ```\n * @param source\n * @returns\n */\nexport function wrap(source) {\n    return {\n        source: resolveSource(source),\n        enacts: {\n            setHtmlText: (options) => {\n                return Enacts.setHtmlText(source, options);\n            },\n        },\n        annotate: (transformer) => {\n            const a = Ops.annotate(source, transformer);\n            return wrap(a);\n        },\n        annotateWithOp: (op) => {\n            const a = Ops.annotateWithOp(source, op);\n            return wrap(a);\n        },\n        chunk: (options) => {\n            const w = wrap(Ops.chunk(source, options));\n            return w;\n        },\n        // debounce: (options: Partial<DebounceOptions> = {}) => {\n        //   return wrap(Ops.debounce<TIn>(source, options));\n        // },\n        debounce: (options = {}) => {\n            return wrap(Reactives.debounce(source, options));\n        },\n        field: (fieldName, options = {}) => {\n            // Ops.field requires TIn extends object\n            // Would be good if `wrap` returns different versions depending on TIn, so .field\n            // would not be present at all if we had Reactive<number>, for example\n            // @ts-expect-error\n            const f = Ops.field(source, fieldName, options);\n            return wrap(f);\n        },\n        filter: (predicate, options) => {\n            return wrap(Ops.filter(source, predicate, options));\n        },\n        combineLatestToArray: (sources, options = {}) => {\n            const srcs = [source, ...sources];\n            return wrap(Ops.combineLatestToArray(srcs, options));\n        },\n        combineLatestToObject: (sources, options) => {\n            const name = options.name ?? `source`;\n            const o = { ...sources };\n            o[name] = source;\n            return wrap(Ops.combineLatestToObject(o, options));\n        },\n        min: (options = {}) => {\n            return wrap(Ops.min(source, options));\n        },\n        max: (options = {}) => {\n            return wrap(Ops.max(source, options));\n        },\n        average: (options = {}) => {\n            return wrap(Ops.average(source, options));\n        },\n        sum: (options = {}) => {\n            return wrap(Ops.sum(source, options));\n        },\n        tally: (options = {}) => {\n            return wrap(Ops.tally(source, options));\n        },\n        split: (options = {}) => {\n            const streams = Ops.split(source, options).map(v => wrap(v));\n            return streams;\n        },\n        splitLabelled: (...labels) => {\n            const l = Ops.splitLabelled(source, labels);\n            const m = mapObjectShallow(l, args => wrap(args.value));\n            return m;\n        },\n        switcher: (cases, options = {}) => {\n            const s = Ops.switcher(source, cases, options);\n            const m = mapObjectShallow(s, args => wrap(args.value));\n            return m;\n        },\n        syncToArray: (additionalSources, options = {}) => {\n            const unwrapped = [source, ...additionalSources].map(v => resolveSource(v));\n            const x = Ops.syncToArray(unwrapped, options);\n            return wrap(x); //synchronise<TIn>([ source, ...unwrapped ] as const));\n        },\n        syncToObject: (sources, options = {}) => {\n            const name = options.name ?? `source`;\n            const o = { ...sources };\n            o[name] = source;\n            return wrap(Ops.syncToObject(o, options));\n        },\n        tapProcess: (...processors) => {\n            Ops.tapProcess(source, ...processors);\n            return wrap(source);\n        },\n        tapStream: (divergedStream) => {\n            Ops.tapStream(source, divergedStream);\n            return wrap(source);\n        },\n        tapOps: (source, ...ops) => {\n            Ops.tapOps(source, ...ops);\n            return wrap(source);\n        },\n        throttle: (options = {}) => {\n            return wrap(Ops.throttle(source, options));\n        },\n        transform: (transformer, options = {}) => {\n            return wrap(Ops.transform(source, transformer, options));\n        },\n        timeoutValue: (options) => {\n            return wrap(Ops.timeoutValue(source, options));\n        },\n        timeoutPing: (options) => {\n            return wrap(Ops.timeoutPing(source, options));\n        },\n        toArray: (options) => {\n            return toArray(source, options);\n        },\n        toArrayOrThrow: (options) => {\n            return toArrayOrThrow(source, options);\n        },\n        onValue: (callback) => {\n            const s = resolveSource(source);\n            s.on(message => {\n                if (messageHasValue(message))\n                    callback(message.value);\n            });\n        }\n    };\n}\n","import { continuously } from \"@ixfx/core\";\nimport { intervalToMs } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\nexport const of = (source, options = {}) => {\n    if (Array.isArray(source)) {\n        return array(source, options);\n    }\n    else { }\n};\n/**\n * Reads the contents of `array` into a Reactive, with optional time interval\n * between values. A copy of the array is used, so changes will not\n * affect the reactive.\n *\n * See also {@link arrayObject} which monitors changes to array values.\n *\n * Reads items from an array with a given interval, by default 5ms\n *\n * ```js\n * const data = [`apples`, `oranges`, `pears` ];\n * const rx = Rx.From.array(data);\n * rx.onValue(v => {\n *  // v will be each fruit in turn\n * })\n * ```\n *\n * Note that there is the possibility of missing values since there is delay between subscribing and when items start getting emitted.\n * If a new subscriber connects to the reactive, they won't get values already emitted.\n * @param sourceArray\n * @param options\n * @returns\n */\nexport const array = (sourceArray, options = {}) => {\n    const lazy = options.lazy ?? `initial`;\n    const signal = options.signal;\n    const whenStopped = options.whenStopped ?? `continue`;\n    const debugLifecycle = options.debugLifecycle ?? false;\n    const array = [...sourceArray];\n    if (lazy !== `very` && whenStopped === `reset`)\n        throw new Error(`whenStopped:'reset' has no effect with 'lazy:${lazy}'. Use lazy:'very' instead.`);\n    const intervalMs = intervalToMs(options.interval, 5);\n    let index = 0;\n    let lastValue = array[0];\n    const s = initLazyStream({\n        ...options,\n        lazy,\n        onStart() {\n            if (debugLifecycle)\n                console.log(`Rx.readFromArray:onStart`);\n            c.start();\n        },\n        onStop() {\n            if (debugLifecycle)\n                console.log(`Rx.readFromArray:onStop. whenStopped: ${whenStopped} index: ${index}`);\n            c.cancel();\n            if (whenStopped === `reset`)\n                index = 0;\n        },\n        // onFirstSubscribe() {\n        //   if (debugLifecycle) console.log(`Rx.readFromArray:onFirstSubscribe lazy: ${ lazy } runState: '${ c.runState }'`);\n        //   // Start if in lazy mode and not running\n        //   if (lazy !== `never` && c.runState === `idle`) c.start();\n        // },\n        // onNoSubscribers() {\n        //   if (debugLifecycle) console.log(`Rx.readFromArray:onNoSubscribers lazy: ${ lazy } runState: '${ c.runState }' whenStopped: '${ whenStopped }'`);\n        //   if (lazy === `very`) {\n        //     c.cancel();\n        //     if (whenStopped === `reset`) {\n        //       index = 0;\n        //     }\n        //   }\n        // }\n    });\n    const c = continuously(() => {\n        if (signal?.aborted) {\n            s.dispose(`Signalled (${signal.reason})`);\n            return false; // stop looping\n        }\n        lastValue = array[index];\n        index++;\n        s.set(lastValue);\n        if (index === array.length) {\n            s.dispose(`Source array complete`);\n            return false; // stop loop\n        }\n    }, intervalMs);\n    if (!lazy)\n        c.start();\n    return {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        dispose: s.dispose,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        isDisposed: s.isDisposed,\n        isDone() {\n            return index === array.length;\n        },\n        last() {\n            return lastValue;\n        },\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        on: s.on,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        onValue: s.onValue\n    };\n};\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { isEqualValueDefault } from \"@ixfx/core\";\nimport { initStream } from \"../init-stream.js\";\nimport { compareArrays } from \"@ixfx/core/records\";\nimport { remove as ArraysRemove, insertAt as ArraysInsertAt } from '@ixfx/arrays';\n/**\n * Wraps an array object.\n *\n * It returns an reactive along with some array-ish functions to manipulating it.\n * @param initialValue\n * @param options\n * @returns\n */\nexport function arrayObject(initialValue = [], options = {}) {\n    const eq = options.eq ?? isEqualValueDefault;\n    const setEvent = initStream();\n    //const diffEvent = initStream<Array<Immutable.Change<any>>>();\n    const arrayEvent = initStream();\n    let value = initialValue;\n    let disposed = false;\n    const set = (replacement) => {\n        const diff = compareArrays(value, replacement, eq);\n        //console.log(`Rx.fromArray.set diff`, diff);\n        //if (diff.length === 0) return;\n        //diffEvent.set(diff);\n        value = replacement;\n        setEvent.set([...replacement]);\n    };\n    const setAt = (index, v) => {\n        value[index] = v;\n        setEvent.set([...value]);\n    };\n    const push = (v) => {\n        value = [...value, v];\n        setEvent.set([...value]);\n        const cr = [`add`, value.length - 1, v];\n        arrayEvent.set([cr]);\n    };\n    const deleteAt = (index) => {\n        const valueChanged = ArraysRemove(value, index);\n        if (valueChanged.length === value.length)\n            return; // no change\n        const diff = compareArrays(value, valueChanged, eq);\n        //console.log(diff.summary);\n        value = valueChanged;\n        setEvent.set([...value]);\n        arrayEvent.set(diff.summary);\n    };\n    const deleteWhere = (filter) => {\n        const valueChanged = value.filter(v => !filter(v));\n        const count = value.length - valueChanged.length;\n        const diff = compareArrays(value, valueChanged, eq);\n        value = valueChanged;\n        setEvent.set([...value]);\n        arrayEvent.set(diff.summary);\n        return count;\n    };\n    const insertAt = (index, v) => {\n        const valueChanged = ArraysInsertAt(value, index, v);\n        const diff = compareArrays(value, valueChanged, eq);\n        value = valueChanged;\n        setEvent.set([...value]);\n        arrayEvent.set(diff.summary);\n    };\n    // const update = (toMerge: Partial<V>) => {\n    //   // eslint-disable-next-line unicorn/prefer-ternary\n    //   if (value === undefined) {\n    //     value = toMerge as V;\n    //   } else {\n    //     const diff = Immutable.compareData(toMerge, value);\n    //     // console.log(`Rx.fromObject.update value: ${ JSON.stringify(value) }`);\n    //     // console.log(`Rx.fromObject.update  diff: ${ JSON.stringify(diff) }`);\n    //     if (diff.length === 0) return; // No changes\n    //     value = {\n    //       ...value,\n    //       ...toMerge\n    //     }\n    //     diffEvent.set(diff);\n    //   }\n    //   setEvent.set(value);\n    // }\n    const dispose = (reason) => {\n        if (disposed)\n            return;\n        //diffEvent.dispose(reason);\n        setEvent.dispose(reason);\n        disposed = true;\n    };\n    const r = {\n        dispose,\n        isDisposed() {\n            return disposed;\n        },\n        last: () => value,\n        on: setEvent.on,\n        onArray: arrayEvent.on,\n        onValue: setEvent.onValue,\n        setAt,\n        push,\n        deleteAt,\n        deleteWhere,\n        insertAt,\n        /**\n         * Set the whole object\n         */\n        set\n    };\n    return r;\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nexport function boolean(initialValue) {\n    let value = initialValue;\n    const events = initStream();\n    const set = (v) => {\n        value = v;\n        events.set(v);\n    };\n    return {\n        dispose: events.dispose,\n        isDisposed: events.isDisposed,\n        last: () => value,\n        on: events.on,\n        onValue: events.onValue,\n        set\n    };\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { continuously } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\n/**\n * Produces an incrementing value. By default starts at 0 and counts\n * forever, incrementing every second.\n *\n * ```js\n * const r = Rx.From.count();\n * r.onValue(c => {\n *  // 0, 1, 2, 3 ... every second\n * });\n * ```\n *\n * The `limit` is exclusive\n * ```js\n * const r = Rx.From.count({limit:5});\n * // Yields 0,1,2,3,4\n * ```\n *\n * If limit is less than start, it will count down instead.\n * ```js\n * const r = Rx.count({start:5, limit: 0});\n * // Yie:ds 5,4,3,2,1\n * ```\n *\n * ```js\n * // Count 10, 12, 14 ... every 500ms\n * const r = Rx.From.count({ start: 10, amount: 2, interval: 500 });\n * ```\n *\n * In addition to setting `limit` (which is exclusive), you can stop with an abort signal\n * ```js\n * const ac = new AbortController();\n * const r = Rx.From.count({signal:ac.signal});\n * ...\n * ac.abort(`stop`);\n * ```\n * @param options\n */\nexport function count(options = {}) {\n    const lazy = options.lazy ?? `initial`;\n    const interval = intervalToMs(options.interval, 1000);\n    const amount = options.amount ?? 1;\n    const offset = options.offset ?? 0;\n    let produced = 0;\n    let value = offset;\n    const done = (reason) => {\n        events.dispose(reason);\n    };\n    const timer = continuously(() => {\n        if (options.signal?.aborted) {\n            done(`Aborted (${options.signal.reason})`);\n            return false;\n        }\n        events.set(value);\n        value += 1;\n        produced++;\n        if (produced >= amount) {\n            done(`Limit reached`);\n            return false;\n        }\n    }, interval);\n    const events = initLazyStream({\n        onStart() {\n            timer.start();\n        },\n        onStop() {\n            timer.cancel();\n        },\n        onDispose() {\n            timer.cancel();\n        },\n        lazy\n    });\n    return events;\n}\n","import { isEqualValueDefault } from \"@ixfx/core\";\nimport { cache } from \"../cache.js\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { combineLatestToObject } from \"../ops/combine-latest-to-object.js\";\nexport function derived(fn, reactiveSources, options = {}) {\n    const ignoreIdentical = options.ignoreIdentical ?? true;\n    const eq = options.eq ?? (isEqualValueDefault);\n    const sources = combineLatestToObject(reactiveSources);\n    const handle = (v) => {\n        const last = output.last();\n        const vv = fn(v);\n        if (vv !== undefined) {\n            if (ignoreIdentical && last !== undefined) {\n                if (eq(vv, last))\n                    return vv;\n            }\n            output.set(vv);\n        }\n        return vv;\n    };\n    // When the combined stream emits a value, output it\n    const s = initUpstream(sources, {\n        ...options,\n        onValue(v) {\n            handle(v);\n        },\n    });\n    const output = cache(s, fn(sources.last()));\n    return output;\n}\n","import { field } from \"../ops/field.js\";\nimport { object } from \"./object.js\";\nimport { initLazyStream } from \"../init-stream.js\";\nimport { elapsedInterval } from \"@ixfx/core/elapsed\";\n/**\n * Fired when `eventName` fires on `target`.\n *\n * Rather than whole event args being emitted on the stream,\n * it plucks a field from the event args, or if that's missing, from the target.\n *\n * ```js\n * // Emits the the value of a field named 'x'\n * // on the change event args\n * eventField(el, `pointermove`, `x`);\n * ```\n * @param targetOrQuery Event target, HTML element or HTML query (eg '#someId')\n * @param eventName Name of event, eg. 'pointermove'\n * @param fieldName Name of field, eg 'x'\n * @param initialValue Initial data\n * @param options Options for source\n */\nexport function eventField(targetOrQuery, eventName, fieldName, initialValue, options = {}) {\n    const initial = {};\n    initial[fieldName] = initialValue;\n    const rxField = field(event(targetOrQuery, eventName, initial, options), fieldName, options);\n    return rxField;\n}\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options: EventOptions<V>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options?: Optional<EventOptions<V>, `transform`>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n/**\n * Subscribes to an event, emitting data\n *\n * @example Print x,y position of mouse as it moves\n * ```js\n * const r = Rx.From.event(document, `pointermove`);\n * r.onValue(event => {\n *  const { x, y } = event;\n * });\n * ```\n *\n * If `options.lazy` is _true_ (default: _false_), event will only be subscribed to when the stream\n * itself has a subscriber.\n *\n * `options.debugFiring` and `options.debugLifecycle` can be turned on to troubleshoot behaviour\n * of the stream if necessary.\n * @param targetOrQuery Event emitter, HTML element or string. If a string, it will be queryed as a selector.\n * @param name Event name\n * @param options Options\n * @returns\n */\nexport function event(targetOrQuery, name, initialValue, options = {}) {\n    let target;\n    if (typeof targetOrQuery === `string`) {\n        target = document.querySelector(targetOrQuery);\n        if (target === null)\n            throw new Error(`Target query did not resolve to an element. Query: '${targetOrQuery}'`);\n    }\n    else {\n        target = targetOrQuery;\n    }\n    if (target === null)\n        throw new Error(`Param 'targetOrQuery' is null`);\n    const debugLifecycle = options.debugLifecycle ?? false;\n    const debugFiring = options.debugFiring ?? false;\n    const lazy = options.lazy ?? false;\n    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n    if (initialValue === undefined)\n        initialValue = {};\n    const rxObject = object(initialValue, { deepEntries: true });\n    let eventAdded = false;\n    let disposed = false;\n    const callback = (args) => {\n        if (debugFiring)\n            console.log(`Reactive.event '${name}' firing '${JSON.stringify(args)}`);\n        rxObject.set(args);\n    };\n    const remove = () => {\n        if (!eventAdded)\n            return;\n        eventAdded = false;\n        target.removeEventListener(name, callback);\n        if (debugLifecycle) {\n            console.log(`Rx.From.event remove '${name}'`);\n        }\n    };\n    const add = () => {\n        if (eventAdded)\n            return;\n        eventAdded = true;\n        target.addEventListener(name, callback);\n        if (debugLifecycle) {\n            console.log(`Rx.From.event add '${name}'`);\n        }\n    };\n    if (!lazy)\n        add();\n    return {\n        last: () => {\n            if (lazy)\n                add();\n            return rxObject.last();\n        },\n        dispose: (reason) => {\n            if (disposed)\n                return;\n            disposed = true;\n            remove();\n            rxObject.dispose(reason);\n        },\n        isDisposed() {\n            return disposed;\n        },\n        on: (handler) => {\n            if (lazy)\n                add();\n            return rxObject.on(handler);\n        },\n        onValue: (handler) => {\n            if (lazy)\n                add();\n            return rxObject.onValue(handler);\n        }\n    };\n}\n/**\n * Emits a value whenever event happens.\n * Data emitted is `{ sinceLast, total }`, where 'sinceLast'\n * is milliseconds since last event and 'total' is total number of\n * times event has been fired.\n * @param targetOrQuery\n * @param name\n * @param options\n * @returns\n */\nexport function eventTrigger(targetOrQuery, name, options = {}) {\n    let target;\n    if (typeof targetOrQuery === `string`) {\n        target = document.querySelector(targetOrQuery);\n        if (target === null)\n            throw new Error(`Target query did not resolve to an element. Query: '${targetOrQuery}'`);\n    }\n    else {\n        target = targetOrQuery;\n    }\n    if (target === null)\n        throw new Error(`Param 'targetOrQuery' is null`);\n    const debugLifecycle = options.debugLifecycle ?? false;\n    const debugFiring = options.debugFiring ?? false;\n    const fireInitial = options.fireInitial ?? false;\n    let count = 0;\n    const elapsed = elapsedInterval();\n    const stream = initLazyStream({\n        lazy: options.lazy ?? `very`,\n        onStart() {\n            target.addEventListener(name, callback);\n            if (debugLifecycle) {\n                console.log(`Rx.From.eventTrigger add '${name}'`);\n            }\n            if (fireInitial && count === 0) {\n                if (debugLifecycle || debugFiring)\n                    console.log(`Rx.From.eventTrigger: firing initial`);\n                callback();\n            }\n        },\n        onStop() {\n            target.removeEventListener(name, callback);\n            if (debugLifecycle) {\n                console.log(`Rx.From.eventTrigger remove '${name}'`);\n            }\n        },\n    });\n    const callback = (_args) => {\n        if (debugFiring)\n            console.log(`Rx.From.eventTrigger '${name}' triggered'`);\n        stream.set({\n            sinceLast: elapsed(),\n            total: ++count\n        });\n    };\n    return stream;\n}\n","import { initLazyStream } from \"../init-stream.js\";\n/**\n * Returns a stream that merges the output of a list of homogenous streams.\n * Use {@link mergedWithOptions} to specify additional options.\n * @param sources\n * @returns\n */\nexport function merged(...sources) {\n    return mergedWithOptions(sources);\n}\n/**\n * Returns a stream that merges the output of a list of homogenous streams.\n *\n * @param sources\n * @param options\n * @returns\n */\nexport function mergedWithOptions(sources, options = {}) {\n    let unsubs = [];\n    const stream = initLazyStream({\n        ...options,\n        onStart() {\n            for (const s of sources) {\n                unsubs.push(s.onValue(v => {\n                    stream.set(v);\n                }));\n            }\n        },\n        onStop() {\n            for (const un of unsubs) {\n                un();\n            }\n            unsubs = [];\n        },\n    });\n    return stream;\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nexport function number(initialValue) {\n    let value = initialValue;\n    const events = initStream();\n    const set = (v) => {\n        value = v;\n        events.set(v);\n    };\n    return {\n        dispose: events.dispose,\n        isDisposed: events.isDisposed,\n        last: () => value,\n        on: events.on,\n        onValue: events.onValue,\n        set\n    };\n}\n","import { object } from \"./object.js\";\nimport { symbol } from \"../types.js\";\nimport { array } from \"./array.js\";\nimport { arrayObject } from \"./array-object.js\";\n/**\n * Creates a proxy of `target` object (or array), so that regular property setting will be intercepted and output\n * on a {@link Reactive} object as well.\n *\n * ```js\n * const { proxy, rx } = Rx.From.objectProxy({ colour: `red`, x: 10, y: 20 });\n *\n * rx.onValue(v => {\n *  // Get notified when proxy is changed\n * });\n *\n * // Get and set properties as usual\n * console.log(proxy.x);\n * proxy.x = 20; // Triggers Reactive\n * ```\n *\n * Keep in mind that changing `target` directly won't affect the proxied object or Reactive. Thus,\n * only update the proxied object after calling `fromProxy`.\n *\n * The benefit of `objectProxy` instead of {@link Rx.From.object} is because the proxied object can be passed to other code that doesn't need\n * to know anything about Reactive objects.\n *\n * You can assign the return values to more meaningful names using\n * JS syntax.\n * ```js\n * const { proxy:colour, rx:colourRx } = Rx.From.objectProxy({ colour: `red` });\n * ```\n *\n * If `target` is an array, it's not possible to change the shape of the array by adding or removing\n * elements, only by updating existing ones. This follows the same behaviour of objects. Alternatively, use {@link arrayProxy}.\n *\n * See also:\n * * {@link objectProxySymbol}: Instead of {proxy,rx} return result, puts the `rx` under a symbol on the proxy.\n * * {@link arrayProxy}: Proxy an array, allowing inserts and deletes.\n * @param target\n * @returns\n */\nexport const objectProxy = (target) => {\n    const rx = object(target);\n    const proxy = new Proxy(target, {\n        set(target, p, newValue, _receiver) {\n            const isArray = Array.isArray(target);\n            //console.log(`Rx.Sources.object set. Target: ${ JSON.stringify(target) } (${ typeof target } array: ${ Array.isArray(target) }) p: ${ JSON.stringify(p) } (${ typeof p }) newValue: ${ JSON.stringify(newValue) } recv: ${ _receiver }`);\n            // Ignore length if target is array\n            if (isArray && p === `length`)\n                return true;\n            if (typeof p === `string`) {\n                rx.updateField(p, newValue);\n            }\n            // If target is array and field looks like an array index...\n            if (isArray && typeof p === `string`) {\n                const pAsNumber = Number.parseInt(p);\n                if (!Number.isNaN(pAsNumber)) {\n                    target[pAsNumber] = newValue;\n                    return true;\n                }\n            }\n            target[p] = newValue;\n            return true;\n        }\n    });\n    return { proxy, rx };\n};\nexport const arrayProxy = (target) => {\n    const rx = arrayObject(target);\n    const proxy = new Proxy(target, {\n        set(target, p, newValue, _receiver) {\n            //console.log(`Rx.Sources.arrayProxy set. Target: ${ JSON.stringify(target) } (${ typeof target } array: ${ Array.isArray(target) }) p: ${ JSON.stringify(p) } (${ typeof p }) newValue: ${ JSON.stringify(newValue) } recv: ${ _receiver }`);\n            // Ignore length if target is array\n            if (p === `length`)\n                return true;\n            if (typeof p !== `string`)\n                throw new Error(`Expected numeric index, got type: ${typeof p} value: ${JSON.stringify(p)}`);\n            const pAsNumber = Number.parseInt(p);\n            if (!Number.isNaN(pAsNumber)) {\n                rx.setAt(pAsNumber, newValue);\n                target[pAsNumber] = newValue;\n                return true;\n            }\n            else {\n                throw new Error(`Expected numeric index, got: '${p}'`);\n            }\n        }\n    });\n    return { proxy, rx };\n};\n/**\n * Same as {@link proxy}, but the return value is the proxied object along with\n * the Reactive wrapped as symbol property.\n *\n * ```js\n * const person = Rx.fromProxySymbol({name: `marie` });\n * person.name = `blah`;\n * person[Rx.symbol].on(msg => {\n *  // Value changed...\n * });\n * ```\n *\n * This means of access can be useful as the return result\n * is a bit neater, being a single object instead of two.\n * @param target\n * @returns\n */\nexport const objectProxySymbol = (target) => {\n    const { proxy, rx } = objectProxy(target);\n    const p = proxy;\n    p[symbol] = rx;\n    return p;\n};\n","import { messageHasValue } from \"../util.js\";\nimport { manual } from \"../index.js\";\n/**\n * Creates a RxJs style observable\n * ```js\n * const o = observable(stream => {\n *  // Code to run for initialisation when we go from idle to at least one subscriber\n *  // Won't run again for additional subscribers, but WILL run again if we lose\n *  // all subscribers and then get one\n *\n *  // To send a value:\n *  stream.set(someValue);\n *\n *   // Optional: return function to call when all subscribers are removed\n *   return () => {\n *     // Code to run when all subscribers are removed\n *   }\n * });\n * ```\n *\n * For example:\n * ```js\n * const xy = observable<(stream => {\n *  // Send x,y coords from PointerEvent\n *  const send = (event) => {\n *    stream.set({ x: event.x, y: event.y });\n *  }\n *  window.addEventListener(`pointermove`, send);\n *  return () => {\n *    // Unsubscribe\n *    window.removeEventListener(`pointermove`, send);\n *  }\n * });\n *\n * xy.onValue(value => {\n *  console.log(value);\n * });\n * ```\n * @param init\n * @returns\n */\nexport function observable(init) {\n    const ow = observableWritable(init);\n    return {\n        dispose: ow.dispose,\n        isDisposed: ow.isDisposed,\n        on: ow.on,\n        onValue: ow.onValue\n    };\n}\n/**\n * As {@link observable}, but returns a Reactive that allows writing\n * @param init\n * @returns\n */\nexport function observableWritable(init) {\n    let onCleanup = () => { };\n    const ow = manual({\n        onFirstSubscribe() {\n            onCleanup = init(ow);\n        },\n        onNoSubscribers() {\n            if (onCleanup)\n                onCleanup();\n        },\n    });\n    return {\n        ...ow,\n        onValue: (callback) => {\n            return ow.on(message => {\n                if (messageHasValue(message)) {\n                    callback(message.value);\n                }\n            });\n        }\n    };\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nexport function string(initialValue) {\n    let value = initialValue;\n    const events = initStream();\n    const set = (v) => {\n        value = v;\n        events.set(v);\n    };\n    return {\n        dispose: events.dispose,\n        isDisposed: events.isDisposed,\n        last: () => value,\n        on: events.on,\n        onValue: events.onValue,\n        set\n    };\n}\n","export * from './array.js';\nexport * from './array-object.js';\nexport * from './boolean.js';\nexport * from './count.js';\nexport * from './derived.js';\nexport * from './event.js';\nexport * from './function.js';\nexport * from './iterator.js';\nexport * from './merged.js';\nexport * from './number.js';\nexport * from './object.js';\nexport * from './object-proxy.js';\nexport * from './observable.js';\nexport * from './string.js';\nexport * from './types.js';\n","import { intervalToMs } from '@ixfx/core';\nimport { isWritable, messageHasValue, messageIsDoneSignal, opify } from \"./util.js\";\nimport { initStream } from \"./init-stream.js\";\nimport { resolveSource } from './resolve-source.js';\nimport * as SinkFns from './sinks/index.js';\nimport * as OpFns from './ops/index.js';\nexport * from './ops/index.js';\nexport * from './sinks/index.js';\nexport * from './graph.js';\nexport * from './types.js';\nexport * from './to-array.js';\nexport * from './to-generator.js';\nexport * from './util.js';\nexport * from './wrap.js';\nexport * from './resolve-source.js';\nexport * from './cache.js';\nexport * as From from './from/index.js';\nexport * from './init-stream.js';\nexport function run(source, ...ops) {\n    let s = resolveSource(source);\n    for (const op of ops) {\n        // @ts-ignore\n        s = op(s);\n    }\n    return s;\n}\nexport function writable(source, ...ops) {\n    let s = resolveSource(source);\n    const head = s;\n    for (const op of ops) {\n        // @ts-ignore\n        s = op(s);\n    }\n    const ss = s;\n    return {\n        ...ss,\n        set(value) {\n            if (isWritable(head)) {\n                head.set(value);\n            }\n            else\n                throw new Error(`Original source is not writable`);\n        }\n    };\n    //return s as Reactive<T2 | T3 | T4 | T5 | T6>;\n    //const raw = chainer<T1, T2, T3, T4, T5, T6>(...ops);\n    //return raw(source);\n}\n/**\n * Initialises a reactive that pipes values to listeners directly.\n * @returns\n */\nexport function manual(options = {}) {\n    const events = initStream(options);\n    return {\n        dispose: events.dispose,\n        isDisposed: events.isDisposed,\n        set(value) {\n            events.set(value);\n        },\n        on: events.on,\n        onValue: events.onValue\n    };\n}\nexport const Sinks = {\n    setHtmlText: (options) => {\n        return (source) => {\n            SinkFns.setHtmlText(source, options);\n        };\n    }\n};\nexport const Ops = {\n    /**\n   * Annotates values with the result of a function.\n   * The input value needs to be an object.\n   *\n   * For every value `input` emits, run it through `annotator`, which should\n   * return the original value with additional fields.\n   *\n   * Conceptually the same as `transform`, just with typing to enforce result\n   * values are V & TAnnotation\n   * @param annotator\n   * @returns\n   */\n    annotate: (annotator) => opify(OpFns.annotate, annotator),\n    /**\n     * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n     * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n     * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n     *\n     * ```js\n     * // Emit values from an array\n     * const r1 = Rx.run(\n     *  Rx.From.array([ 1, 2, 3 ]),\n     *  Rx.Ops.annotateWithOp(\n     *    // Add the 'max' operator to emit the largest-seen value\n     *    Rx.Ops.sum()\n     *  )\n     * );\n     * const data = await Rx.toArray(r1);\n     * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n     * ```\n     * @param annotatorOp\n     * @returns\n     */\n    annotateWithOp: (annotatorOp) => opify(OpFns.annotateWithOp, annotatorOp),\n    /**\n     * Takes a stream of values and chunks them up (by quantity or time elapsed),\n     * emitting them as an array.\n     * @param options\n     * @returns\n     */\n    chunk: (options) => {\n        return (source) => {\n            return OpFns.chunk(source, options);\n        };\n    },\n    cloneFromFields: () => {\n        return (source) => {\n            return OpFns.cloneFromFields(source);\n        };\n    },\n    /**\n   * Merges values from several sources into a single source that emits values as an array.\n   * @param options\n   * @returns\n   */\n    combineLatestToArray: (options = {}) => {\n        return (sources) => {\n            return OpFns.combineLatestToArray(sources, options);\n        };\n    },\n    /**\n     * Merges values from several sources into a single source that emits values as an object.\n     * @param options\n     * @returns\n     */\n    combineLatestToObject: (options = {}) => {\n        return (reactiveSources) => {\n            return OpFns.combineLatestToObject(reactiveSources, options);\n        };\n    },\n    /**\n   * Debounce values from the stream. It will wait until a certain time\n   * has elapsed before emitting latest value.\n   *\n   * Effect is that no values are emitted if input emits faster than the provided\n   * timeout.\n   *\n   * See also: throttle\n   * @param options\n   * @returns\n   */\n    // debounce: <V>(options: Partial<DebounceOptions>): ReactiveOp<V, V> => {\n    //   return (source: ReactiveOrSource<V>) => {\n    //     return OpFns.debounce(source, options);\n    //   }\n    // },\n    /**\n     * Drops values from the input stream that match `predicate`\n     * @param predicate If it returns _true_ value is ignored\n     * @returns\n     */\n    drop: (predicate) => opify(OpFns.drop, predicate),\n    /**\n     * Every upstream value is considered the target for interpolation.\n     * Output value interpolates by a given amount toward the target.\n     * @returns\n     */\n    elapsed: () => opify(OpFns.elapsed),\n    /**\n     * Yields the value of a field from an input stream of values.\n     * Eg if the source reactive emits `{ colour: string, size: number }`,\n     * we might use `field` to pluck out the `colour` field, thus returning\n     * a stream of string values.\n     * @param fieldName\n     * @param options\n     * @returns\n     */\n    field: (fieldName, options) => {\n        return (source) => {\n            return OpFns.field(source, fieldName, options);\n        };\n    },\n    /**\n     * Filters the input stream, only re-emitting values that pass the predicate\n     * @param predicate If it returns _true_ value is allowed through\n     * @returns\n     */\n    filter: (predicate) => opify(OpFns.filter, predicate),\n    /**\n     * Every upstream value is considered the target for interpolation.\n     * Output value interpolates by a given amount toward the target.\n     * @param options\n     * @returns\n     */\n    interpolate: (options) => opify(OpFns.interpolate, options),\n    /**\n   * Outputs the minimum numerical value of the stream.\n   * A value is only emitted when minimum decreases.\n   * @returns\n   */\n    min: (options) => opify(OpFns.min, options),\n    /**\n     * Outputs the maxium numerical value of the stream.\n     * A value is only emitted when maximum increases.\n     * @returns\n     */\n    max: (options) => opify(OpFns.max, options),\n    sum: (options) => opify(OpFns.sum, options),\n    average: (options) => opify(OpFns.average, options),\n    tally: (options) => opify(OpFns.tally, options),\n    rank: (rank, options) => opify(OpFns.rank, rank, options),\n    pipe: (...streams) => {\n        return (source) => {\n            const resolved = resolveSource(source);\n            const s = [resolved, ...streams];\n            return OpFns.pipe(...s);\n        };\n    },\n    singleFromArray: (options = {}) => {\n        return (source) => {\n            return OpFns.singleFromArray(source, options);\n        };\n    },\n    split: (options = {}) => {\n        return (source) => {\n            return OpFns.split(source, options);\n        };\n    },\n    splitLabelled: (labels) => {\n        return (source) => {\n            return OpFns.splitLabelled(source, labels);\n        };\n    },\n    switcher: (cases, options = {}) => {\n        return (source) => {\n            return OpFns.switcher(source, cases, options);\n        };\n    },\n    syncToArray: (options = {}) => {\n        return (reactiveSources) => {\n            return OpFns.syncToArray(reactiveSources, options);\n        };\n    },\n    syncToObject: (options = {}) => {\n        return (reactiveSources) => {\n            return OpFns.syncToObject(reactiveSources, options);\n        };\n    },\n    tapProcess: (processor) => {\n        return (source) => {\n            return OpFns.tapProcess(source, processor);\n        };\n    },\n    tapStream: (divergedStream) => {\n        return (source) => {\n            return OpFns.tapStream(source, divergedStream);\n        };\n    },\n    tapOps: (...ops) => {\n        return (source) => {\n            return OpFns.tapOps(source, ...ops);\n        };\n    },\n    /**\n   * Throttle values from the stream.\n   * Only emits a value if some minimum time has elapsed.\n   * @param options\n   * @returns\n   */\n    throttle: (options) => opify(OpFns.throttle, options),\n    /**\n     * Trigger a value if 'source' does not emit a value within an interval.\n     * Trigger value can be a fixed value, result of function, or step through an iterator.\n     * @param options\n     * @returns\n     */\n    timeoutValue: (options) => {\n        return (source) => {\n            return OpFns.timeoutValue(source, options);\n        };\n    },\n    timeoutPing: (options) => {\n        return (source) => {\n            return OpFns.timeoutPing(source, options);\n        };\n    },\n    transform: (transformer, options = {}) => {\n        return (source) => {\n            return OpFns.transform(source, transformer, options);\n        };\n    },\n    /**\n    * Reactive where last (or a given initial) value is available to read\n    * @param opts\n    * @returns\n    */\n    withValue: (opts) => {\n        return opify(OpFns.withValue, opts);\n    },\n};\n// export const chain = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       // @ts-expect-error\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n// export const chainStream = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>): ReactiveStream<TIn, TOut> => {\n//   const stream = manual<TIn>();\n//   const c = chain(...ops);\n//   const x = c(stream);\n//   return x;\n// }\n// function chainx<TIn, TOut>(...ops: Array<ReactiveOp<any, any>>) {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n// export function runWithInitial<TIn, TOut>(initial: TOut, source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<any, any>>): ReactiveInitial<TOut> & ReactiveDisposable<TOut> {\n//   let lastValue = initial;\n//   const raw = prepareOps<TIn, TOut>(...ops);\n//   const r = raw(source);\n//   let disposed = false;\n//   r.onValue(value => {\n//     lastValue = value;\n//   });\n//   return {\n//     ...r,\n//     isDisposed() {\n//       return disposed\n//     },\n//     dispose(reason) {\n//       if (disposed) return;\n//       if (isDisposable(r)) {\n//         r.dispose(reason);\n//       }\n//       disposed = true;\n//     },\n//     last() {\n//       return lastValue;\n//     },\n//   }\n// }\n/**\n * Grabs the next value emitted from `source`.\n * By default waits up to a maximum of one second.\n * Handles subscribing and unsubscribing.\n *\n * ```js\n * const value = await Rx.takeNextValue(source);\n * ```\n *\n * Throws an error if the source closes without\n * a value or the timeout is reached.\n *\n * @param source\n * @param maximumWait\n * @returns\n */\nexport async function takeNextValue(source, maximumWait = 1000) {\n    const rx = resolveSource(source);\n    let off = () => { };\n    let watchdog;\n    const p = new Promise((resolve, reject) => {\n        off = rx.on(message => {\n            if (watchdog)\n                clearTimeout(watchdog);\n            if (messageHasValue(message)) {\n                off();\n                resolve(message.value);\n            }\n            else {\n                if (messageIsDoneSignal(message)) {\n                    reject(new Error(`Source closed. ${message.context ?? ``}`));\n                    off();\n                }\n            }\n        });\n        watchdog = setTimeout(() => {\n            watchdog = undefined;\n            off();\n            reject(new Error(`Timeout waiting for value (${JSON.stringify(maximumWait)})`));\n        }, intervalToMs(maximumWait));\n    });\n    return p;\n}\n/**\n * Connects reactive A to B, optionally transforming the value as it does so.\n *\n * Returns a function to unsubcribe A->B\n * @param a\n * @param b\n * @param transform\n */\nexport const to = (a, b, transform, closeBonA = false) => {\n    const unsub = a.on(message => {\n        if (messageHasValue(message)) {\n            const value = transform ? transform(message.value) : message.value;\n            b.set(value);\n        }\n        else if (messageIsDoneSignal(message)) {\n            unsub();\n            if (closeBonA) {\n                b.dispose(`Source closed (${message.context ?? ``})`);\n            }\n        }\n        else {\n            // eslint-disable-nex Unsupported message: ${ JSON.stringify(message) }`);\n        }\n    });\n    return unsub;\n};\n","export * from '@ixfx/rx';","// Via Vuejs\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\nexport const isMap = (value) => toTypeString(value) === `[object Map]`;\nexport const isSet = (value) => toTypeString(value) === `[object Set]`;\n/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = (itemToMakeStringFor) => typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const defaultToString = (object) => {\n    //ECMA specification: http://www.ecma-international.org/ecma-262/6.0/#sec-tostring\n    if (object === null)\n        return `null`;\n    if (typeof object === `boolean` || typeof object === `number`) {\n        return object.toString();\n    }\n    if (typeof object === `string`)\n        return object;\n    if (typeof object === `symbol`)\n        throw new TypeError(`Symbol cannot be converted to string`);\n    return JSON.stringify(object);\n};\n","import { defaultToString } from \"./to-string.js\";\n/**\n * Sort numbers in ascending order.\n *\n * ```js\n * [10, 4, 5, 0].sort(numericComparer);\n * // Yields: [0, 4, 5, 10]\n * [10, 4, 5, 0].sort(comparerInverse(numericComparer));\n * // Yields: [ 10, 5, 4, 0]\n * ```\n * @param x\n * @param y\n * @returns\n */\nexport const numericComparer = (x, y) => {\n    // ✔️ Unit tested\n    if (x === y)\n        return 0;\n    if (x > y)\n        return 1;\n    return -1;\n};\n/**\n * Default sort comparer, following same sematics as Array.sort.\n * Consider using {@link defaultComparer} to get more logical sorting of numbers.\n *\n * Note: numbers are sorted in alphabetical order, eg:\n * ```js\n * [ 10, 20, 5, 100 ].sort(jsComparer); // same as .sort()\n * // Yields: [10, 100, 20, 5]\n * ```\n *\n * Returns -1 if x is less than y\n * Returns 1 if x is greater than y\n * Returns 0 if x is the same as y\n * @param x\n * @param y\n * @returns\n */\nexport const jsComparer = (x, y) => {\n    // ✔️ Unit tested\n    // Via https://stackoverflow.com/questions/47334234/how-to-implement-array-prototype-sort-default-compare-function\n    if (x === undefined && y === undefined)\n        return 0;\n    if (x === undefined)\n        return 1;\n    if (y === undefined)\n        return -1;\n    const xString = defaultToString(x);\n    const yString = defaultToString(y);\n    if (xString < yString)\n        return -1;\n    if (xString > yString)\n        return 1;\n    return 0;\n};\n/**\n * Inverts the source comparer.\n * @param comparer\n * @returns\n */\nexport const comparerInverse = (comparer) => {\n    return (x, y) => {\n        const v = comparer(x, y);\n        return v * -1;\n    };\n};\n/**\n * Compares numbers by numeric value, otherwise uses the default\n * logic of string comparison.\n *\n * Is an ascending sort:\n * * b, a, c -> a, b, c\n * * 10, 5, 100 -> 5, 10, 100\n *\n * Returns -1 if x is less than y\n * Returns 1 if x is greater than y\n * Returns 0 if x is the same as y\n * @param x\n * @param y\n * @see {@link comparerInverse} Inverted order\n * @returns\n */\nexport const defaultComparer = (x, y) => {\n    if (typeof x === `number` && typeof y === `number`) {\n        return numericComparer(x, y);\n    }\n    return jsComparer(x, y);\n};\n","import { throwIntegerTest } from \"@ixfx/guards\";\n/**\n * Yields `amount` integers, counting by one from zero. If a negative amount is used,\n * count decreases. If `offset` is provided, this is added to the return result.\n * @example\n * ```js\n * const a = [...count(5)]; // Yields five numbers: [0,1,2,3,4]\n * const b = [...count(-5)]; // Yields five numbers: [0,-1,-2,-3,-4]\n * for (const v of count(5, 5)) {\n *  // Yields: 5, 6, 7, 8, 9\n * }\n * const c = [...count(5,1)]; // Yields [1,2,3,4,5]\n * ```\n *\n * @example Used with forEach\n * ```js\n * // Prints `Hi` 5x\n * forEach(count(5), () => // do something);\n * ```\n *\n * If you want to accumulate return values, consider using Flow.repeat.\n *\n * @example Run some code every 100ms, 10 times:\n * ```js\n * import { interval } from 'https://unpkg.com/ixfx/dist/flow.js'\n * import { count } from 'https://unpkg.com/ixfx/dist/numbers.js'\n * const counter = count(10);\n * for await (const v of interval(counter, { fixedIntervalMs: 100 })) {\n *  // Do something\n * }\n * ```\n * @param amount Number of integers to yield\n * @param offset Added to result\n */\nexport function* count(amount, offset = 0) {\n    // Unit tested.\n    throwIntegerTest(amount, ``, `amount`);\n    throwIntegerTest(offset, ``, `offset`);\n    if (amount === 0)\n        return;\n    let index = 0;\n    do {\n        yield (amount < 0 ? -index + offset : index + offset);\n    } while (index++ < Math.abs(amount) - 1);\n}\n;\n","import { throwIntegerTest } from '@ixfx/guards';\nimport { intervalToMs } from '@ixfx/core';\n/**\n * Returns a {@link Continuously} that continually executes `callback` at `interval` rate.\n *\n * By default, first the sleep period happens and then the callback happens.\n *\n * Call `start` to begin/reset loop. The looping stops when `cancel` is called, or when `callback` returns _false_.\n *\n * @example\n * Animation loop\n * ```js\n * const draw = () => {\n *  // Draw on canvas\n * }\n *\n * // Run draw() synchronised with monitor refresh rate via `window.requestAnimationFrame`\n * continuously(draw).start();\n * ```\n *\n * @example\n * With delay\n * ```js\n * const fn = () => {\n *  // Runs after one minute\n * }\n * const c = continuously(fn, { mins: 1 } );\n * c.start(); // Runs `fn` every minute\n * ```\n *\n * @example\n * Control a 'continuously'\n * ```js\n * c.cancel();   // Stop the loop, cancelling any up-coming calls to `fn`\n * c.elapsedMs;  // How many milliseconds have elapsed since start\n * c.ticks;      // How many iterations of loop since start\n * c.interval;   // Get/set speed of loop. Change kicks-in at next loop.\n *               // Use .start() to reset to new interval immediately\n * ```\n *\n * Asynchronous callback functions are supported too:\n * ```js\n * continuously(async () => { ..});\n * ```\n *\n * The `callback` function can receive a few arguments:\n *\n * ```js\n * continuously( (ticks, elapsedMs) => {\n *  // ticks: how many times loop has run\n *  // elapsedMs:  how long since last loop\n * }).start();\n * ```\n *\n * If the callback explicitly returns _false_, the loop will be cancelled.\n *\n * ```js\n * continuously(ticks => {\n *  // Stop after 100 iterations\n *  if (ticks > 100) return false;\n * }).start();\n * ```\n *\n * You can intercept the logic for calls to `start()` with `onStartCalled`. It can determine\n * whether the `start()` proceeds, if the loop is cancelled, or the whole thing disposed,\n * so it can't run any longer.\n *\n * ```js\n * continuously(callback, intervalMs, {\n *  onStartCalled:(ticks, elapsedMs) => {\n *    // Cancel the loop after 1000ms has elapsed\n *    if (elapsedMs > 1000) return `cancel`;\n *  }\n * }).start();\n * ```\n *\n * To run `callback` *before* the sleep happens, set `fireBeforeWait`:\n * ```js\n * continuously(callback, intervalMs, { fireBeforeWait: true });\n * ```\n * @param callback - Function to run. If it returns _false_, loop exits.\n * @param options - {@link ContinuouslyOpts ContinuouslyOpts}\n * @param interval - Speed of loop (default: 0)\n * @returns Instance to control looping.\n * @see {@link Timeout} if you want to trigger something once.\n */\nexport const continuously = (callback, interval, options = {}) => {\n    let intervalMs = intervalToMs(interval, 0);\n    throwIntegerTest(intervalMs, `positive`, `interval`);\n    const fireBeforeWait = options.fireBeforeWait ?? false;\n    const onStartCalled = options.onStartCalled;\n    const signal = options.signal;\n    let disposed = false;\n    let runState = `idle`;\n    let startCount = 0;\n    let startCountTotal = 0;\n    let startedAt = performance.now();\n    let intervalUsed = interval ?? 0;\n    let cancelled = false;\n    let currentTimer;\n    const deschedule = () => {\n        if (currentTimer === undefined)\n            return;\n        globalThis.clearTimeout(currentTimer);\n        currentTimer = undefined;\n        startCount = 0;\n        startedAt = Number.NaN;\n    };\n    const schedule = (scheduledCallback) => {\n        if (intervalMs === 0) {\n            if (typeof requestAnimationFrame === `undefined`) {\n                currentTimer = globalThis.setTimeout(scheduledCallback, 0);\n            }\n            else {\n                currentTimer = undefined;\n                requestAnimationFrame(scheduledCallback);\n            }\n        }\n        else {\n            currentTimer = globalThis.setTimeout(scheduledCallback, intervalMs);\n        }\n    };\n    const cancel = () => {\n        if (cancelled)\n            return;\n        cancelled = true;\n        if (runState === `idle`)\n            return; // No need to cancel\n        runState = `idle`;\n        deschedule();\n    };\n    const loop = async () => {\n        if (signal?.aborted) {\n            runState = `idle`;\n        }\n        if (runState === `idle`)\n            return;\n        runState = `running`;\n        startCount++;\n        startCountTotal++;\n        const valueOrPromise = callback(startCount, performance.now() - startedAt);\n        const value = typeof valueOrPromise === `object` ? (await valueOrPromise) : valueOrPromise;\n        if (cancelled) {\n            return;\n        }\n        runState = `scheduled`;\n        // Didn't get a value, exit out\n        if (value !== undefined && !value) {\n            cancel();\n            return;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (cancelled)\n            return; // has been cancelled\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        schedule(loop);\n    };\n    const start = () => {\n        if (disposed)\n            throw new Error(`Disposed`);\n        cancelled = false;\n        if (onStartCalled !== undefined) {\n            // A function governs whether to allow .start() to go ahead\n            const doWhat = onStartCalled(startCount, performance.now() - startedAt);\n            switch (doWhat) {\n                case `cancel`: {\n                    cancel();\n                    return;\n                }\n                case `reset`: {\n                    reset();\n                    return;\n                }\n                case `dispose`: {\n                    disposed = true;\n                    cancel();\n                    return;\n                }\n                // No default\n            }\n        }\n        if (runState === `idle`) {\n            // Start running\n            startCount = 0;\n            startedAt = performance.now();\n            runState = `scheduled`;\n            if (fireBeforeWait) {\n                void loop(); // Exec first, then wait\n            }\n            else {\n                // eslint-disable-next-line @typescript-eslint/no-misused-promises\n                schedule(loop); // Wait first, then exec\n            }\n        } // else: already running, ignore\n    };\n    const reset = () => {\n        if (disposed)\n            throw new Error(`Disposed`);\n        cancelled = false;\n        startCount = 0;\n        startedAt = Number.NaN;\n        // Cancel scheduled iteration\n        if (runState !== `idle`) {\n            cancel();\n        }\n        start();\n    };\n    return {\n        start,\n        reset,\n        cancel,\n        get interval() {\n            return intervalUsed;\n        },\n        get runState() {\n            return runState;\n        },\n        get startCountTotal() {\n            return startCountTotal;\n        },\n        get startCount() {\n            return startCount;\n        },\n        set interval(interval) {\n            const ms = intervalToMs(interval, 0);\n            throwIntegerTest(ms, `positive`, `interval`);\n            intervalMs = ms;\n            intervalUsed = interval;\n        },\n        get isDisposed() {\n            return disposed;\n        },\n        get elapsedMs() {\n            return performance.now() - startedAt;\n        },\n    };\n};\n","const orderScore = (a, b) => {\n    if (a.score > b.score)\n        return -1;\n    else if (a.score < b.score)\n        return 1;\n    return 0;\n};\n/**\n * Attempts to align prior data with new data, based on a provided similarity function.\n *\n * See also `alignById` for a version which encloses parameters.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const newData = [\n *  { id:`2`, x:101, y:200 }\n * ]\n * const aligned = Correlate.align(fn, lastdata, newData, opts);\n *\n * // Result:\n * [\n *  { id:`1`, x:101, y:200 }\n * ]\n * ```\n * @param similarityFn Function to compute similarity\n * @param lastData Old data\n * @param newData New data\n * @param options Options\n * @returns\n */\nexport const align = (similarityFunction, lastData, newData, options = {}) => {\n    const matchThreshold = options.matchThreshold ?? 0;\n    const debug = options.debug ?? false;\n    const results = new Map();\n    const newThings = [];\n    const lastMap = new Map();\n    lastData?.forEach((d, index) => {\n        if (typeof d === `undefined`) {\n            throw new Error(`'lastData' contains undefined (index: ${index.toString()})`);\n        }\n        lastMap.set(d.id, d);\n    });\n    for (const newD of newData) { //let index = 0; index < newData.length; index++) {\n        //const newD = newData[ index ];\n        if (!lastData || lastData.length === 0) {\n            // No last data to compare to\n            if (debug)\n                console.debug(`Correlate.align() new id: ${newD.id}`);\n            newThings.push(newD);\n            continue;\n        }\n        // Which of the old data does the new data match up to best?\n        const scoredLastValues = Array.from(lastMap.values()).map((last) => ({\n            id: (last).id,\n            score: last === null ? -1 : similarityFunction(last, newD),\n            last,\n        }));\n        if (scoredLastValues.length === 0) {\n            if (debug) {\n                console.debug(`Correlate.align() no valid last values id: ${newD.id}`);\n            }\n            newThings.push(newD);\n            continue;\n        }\n        scoredLastValues.sort(orderScore);\n        // Top-ranked match is pretty low, must be something new\n        const top = scoredLastValues[0];\n        if (top.score < matchThreshold) {\n            if (debug) {\n                console.debug(`Correlate.align() new item does not reach threshold. Top score: ${top.score.toString()} id: ${newD.id}`);\n            }\n            newThings.push(newD);\n            continue;\n        }\n        // TODO: If there are close options to pick, need a pluggable\n        // function to determine which is the winner.\n        //    console.log(`updating prior ${top.score}. top: ${top.id} newD: ${newD.id}`);\n        // The new item is considered the same as top ranked\n        if (debug && top.id !== newD.id) {\n            console.log(`Correlate.align() Remapped ${newD.id} -> ${top.id} (score: ${top.score.toString()})`);\n        }\n        results.set(top.id, { ...newD, id: top.id });\n        // Remove that old one from the list\n        lastMap.delete(top.id);\n    }\n    newThings.forEach((t) => results.set(t.id, t));\n    return Array.from(results.values());\n};\n/**\n * Returns a function that attempts to align a series of data by its id.\n * See also {@link align} for a version with no internal storage.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const aligner = Correlate.alignById(fn, opts);\n *\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const aligned = aligner(lastData);\n *\n * ```\n * @param fn Function to compute similarity\n * @param options Options\n * @returns\n */\nexport const alignById = (fn, options = {}) => {\n    let lastData = [];\n    const compute = (newData) => {\n        lastData = align(fn, lastData, newData, options);\n        return [...lastData];\n    };\n    return compute;\n};\n","/**\n * If values are strings, uses that as the key.\n * Otherwise uses `JSON.stringify`.\n * @param a\n * @returns\n */\nexport const defaultKeyer = (a) => {\n    return typeof a === `string` ? a : JSON.stringify(a);\n};\n","//import { intervalToMs, type Interval } from './IntervalType.js';\n//import { elapsedMillisecondsAbsolute, relative } from './Timer.js';\n/**\n * Returns elapsed time since the initial call.\n * ```js\n * // Record start\n * const elapsed = elapsedSince();\n *\n * // Get elapsed time in millis\n * // since Elapsed.since()\n * elapsed(); // Yields number\n * ```\n *\n * If you want to initialise a stopwatch, but not yet start it, consider:\n * ```js\n * // Init\n * let state = {\n *  clicked: Stopwatch.infinity()\n * };\n *\n * state.click(); // Returns a giant value\n *\n * // Later, when click happens:\n * state = { click: elapsedSince() }\n * ```\n *\n * See also:\n * * {@link elapsedOnce} if you want to measure a single period, and stop it.\n * * {@link elapsedInterval} time _between_ calls\n * @returns\n */\nexport const elapsedSince = () => {\n    const start = performance.now();\n    return () => {\n        return performance.now() - start;\n    };\n};\n/**\n * Returns the interval between the start and each subsequent call.\n *\n * ```js\n * const interval = elapsedInterval();\n * interval(); // Time from elapsedInterval()\n * interval(); // Time since last interval() call\n * ```\n *\n * See also:\n * * {@link elapsedSince}: time since first call\n * * {@link elapsedOnce}: time between two events\n * @returns\n */\nexport const elapsedInterval = () => {\n    let start = performance.now();\n    return () => {\n        const now = performance.now();\n        const x = now - start;\n        start = now;\n        return x;\n    };\n};\n/**\n * Returns elapsed time since initial call, however\n * unlike {@link elapsedSince}, timer stops when first invoked.\n *\n * ```js\n * const elapsed = elapsedOnce();\n * // ...do stuff\n * elapsed(); // Yields time since elapsedOnce() was called\n * // ...do more stuff\n * elapsed(); // Is still the same number as above\n * ```\n *\n * See also:\n * * {@link elapsedSince}: elapsed time\n * * {@link elapsedInterval}: time _between_ calls\n * @returns\n */\nexport const elapsedOnce = () => {\n    const start = Date.now();\n    let stoppedAt = 0;\n    return () => {\n        if (stoppedAt === 0) {\n            stoppedAt = Date.now() - start;\n        }\n        return stoppedAt;\n    };\n};\n/**\n * Returns a function that reports an 'infinite' elapsed time.\n * this can be useful as an initialiser for `elapsedSince` et al.\n *\n * ```js\n * // Init clicked to be an infinite time\n * let clicked = elapsedInfinity();\n *\n * document.addEventListener('click', () => {\n *  // Now that click has happened, we can assign it properly\n *  clicked = Stopwatch.since();\n * });\n * ```\n * @returns\n */\nexport const elapsedInfinity = () => {\n    return () => {\n        return Number.POSITIVE_INFINITY;\n    };\n};\n","/**\n * Returns `v` if `predicate` returns _true_,\n * alternatively returning `skipValue`.\n *\n * ```js\n * // Return true if value is less than 10\n * const p = v => v < 10;\n *\n * filterValue(5, p, 0);   // 5\n * filterValue(20, p, 0);  // 0\n * ```\n * @param v Value to test\n * @param predicate Predicate\n * @param skipValue Value to return if predicate returns false\n * @returns Input value if predicate is _true_, or `skipValue` if not.\n */\nexport const filterValue = (v, predicate, skipValue) => {\n    if (predicate(v))\n        return v;\n    return skipValue;\n};\n","import { integerTest, throwFromResult } from '@ixfx/guards';\n//export { string as random } from './random/String.js';\n//import { afterMatch, beforeAfterMatch, beforeMatch } from '../Text.js';\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * Whittles down from whole string to last token.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsWholeToEnd(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `b.c.d`\n * // `c.d`\n * // `d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsWholeToEnd(source, delimiter = `.`) {\n    while (source.length > 0) {\n        yield source;\n        const trimmed = afterMatch(source, delimiter);\n        if (trimmed === source) {\n            // Delimiter not found\n            break;\n        }\n        source = trimmed;\n    }\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * Starts with last token, builds to whole.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ````js\n * stringSegmentsLastToWhole(`a.b.c.d`);\n * // Yields:\n * // `d`\n * // `c.d`\n * // `b.c.d`\n * // `a.b.c.d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsLastToWhole(source, delimiter = `.`) {\n    let accumulator = ``;\n    const orig = source;\n    while (source.length > 0) {\n        const ba = beforeAfterMatch(source, delimiter, { fromEnd: true, ifNoMatch: `original` });\n        if (ba[0] === ba[1] && ba[1] === source) {\n            // Delimiter not found\n            break;\n        }\n        const v = ba[1] + accumulator;\n        yield v;\n        accumulator = delimiter + v;\n        source = ba[0];\n    }\n    yield orig;\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * We start with the first token and build up until end.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsFirstToWhole(`a.b.c.d`);\n * // Yields:\n * // `a`\n * // `a.b`\n * // `a.b.c`\n * // `a.b.c.d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsFirstToWhole(source, delimiter = `.`) {\n    let accumulator = ``;\n    const orig = source;\n    while (source.length > 0) {\n        const ba = beforeAfterMatch(source, delimiter, { ifNoMatch: `original` });\n        if (ba[0] === source && ba[1] === source)\n            break;\n        accumulator += ba[0];\n        yield accumulator;\n        accumulator += delimiter;\n        source = ba[1];\n    }\n    yield orig;\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * We start with whole string and whittle down to starting token.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsWholeToFirst(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `a.b.c`,\n * // `a.b`,\n * // `a`,\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsWholeToFirst(source, delimiter = `.`) {\n    while (source.length > 0) {\n        yield source;\n        const b = beforeMatch(source, delimiter, { ifNoMatch: `original`, fromEnd: true });\n        if (b === source)\n            break;\n        source = b;\n    }\n}\n/**\n * Given a long string, abbreviates it with ...\n * ```js\n * abbreviate(`This is something`, 7); // `This is...`\n * ```\n *\n * If `source` is under `maxLength` the original is returned.\n * @param source\n * @param maxLength Maximum length. Defaults to 20\n * @returns\n */\nexport const abbreviate = (source, maxLength = 15) => {\n    // ✔️ Unit tested\n    throwFromResult(integerTest(maxLength, `aboveZero`, `maxLength`));\n    if (typeof source !== `string`)\n        throw new Error(`Parameter 'source' is not a string`);\n    if (source.length > maxLength && source.length > 3) {\n        if (maxLength > 15) {\n            const chunk = Math.round((maxLength - 2) / 2);\n            return source.slice(0, chunk) + `...` + source.slice(-chunk);\n        }\n        return source.slice(0, maxLength) + `...`;\n    }\n    return source;\n};\n/**\n * Uses JSON.toString() on `source`, but abbreviates result.\n * @param source Object to stringify\n * @param maxLength Default 20\n * @returns\n */\nexport const toStringAbbreviate = (source, maxLength = 20) => {\n    if (source === undefined)\n        return `(undefined)`;\n    if (source === null)\n        return `(null)`;\n    return abbreviate(JSON.stringify(source), maxLength);\n};\n/**\n * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.\n *\n * ```js\n * // Yields ` orange `;\n * between(`apple orange melon`, `apple`, `melon`);\n * ```\n * @param source Source text\n * @param start Start match\n * @param end If undefined, the `start` string will be looked for\n * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.\n * @returns\n */\nexport const between = (source, start, end, lastEndMatch = true) => {\n    // ✔ Unit tested\n    const startPos = source.indexOf(start);\n    if (startPos < 0)\n        return;\n    if (end === undefined)\n        end = start;\n    const endPos = lastEndMatch\n        ? source.lastIndexOf(end)\n        : source.indexOf(end, startPos + 1);\n    if (endPos < 0)\n        return;\n    return source.slice(startPos + 1, endPos);\n};\n/**\n * Like {@link between}, but also returns the source string without the start/end match and what's between.\n * ```js\n * const [src,between] = betweenChomp('hello [there] friend', '[', ']');\n * // src: 'hello  friend'\n * // between: 'there'\n * ```\n * @param source\n * @param start\n * @param end\n * @param lastEndMatch\n * @returns\n */\nexport const betweenChomp = (source, start, end, lastEndMatch = true) => {\n    // ✔ Unit tested\n    if (typeof source !== `string`)\n        throw new Error(`Parameter 'source' is not a string`);\n    if (typeof start !== `string`)\n        throw new Error(`Parameter 'start' is not a string`);\n    if (end !== undefined && typeof end !== `string`)\n        throw new Error(`Parameter 'end' is not a string`);\n    const startPos = source.indexOf(start);\n    if (startPos < 0)\n        return [source, undefined];\n    if (end === undefined)\n        end = start;\n    const endPos = lastEndMatch\n        ? source.lastIndexOf(end)\n        : source.indexOf(end, startPos + 1);\n    if (endPos < 0)\n        return [source, undefined];\n    const between = source.slice(startPos + 1, endPos);\n    const sourceResult = source.slice(0, startPos) + source.slice(endPos + 1);\n    return [sourceResult, between];\n};\n/**\n * Returns first position of the given character code, or -1 if not found.\n * @param source Source string\n * @param code Code to seek\n * @param start Start index, 0 by default\n * @param end End index (inclusive), source.length-1 by default\n * @returns Found position, or -1 if not found\n */\nexport const indexOfCharCode = (source, code, start = 0, end = source.length - 1) => {\n    //eslint-disable-next-line functional/no-let\n    for (let index = start; index <= end; index++) {\n        if (source.codePointAt(index) === code)\n            return index;\n    }\n    return -1;\n};\n/**\n * Returns `source` with a given number of characters removed from start position.\n *\n * ```js\n * // Remove three characters starting at position 1\n * omitChars(`hello there`, 1, 3); // ie. removes 'ell'\n * // Yields: `ho there`\n * ```\n * @param source\n * @param removeStart Start point to remove\n * @param removeLength Number of characters to remove\n * @returns\n */\nexport const omitChars = (source, removeStart, removeLength) => source.slice(0, removeStart) +\n    source.slice(removeStart + removeLength);\n/**\n * Splits a string into `length`-size chunks.\n *\n * If `length` is greater than the length of `source`, a single element array is returned with source.\n * The final array element may be smaller if we ran out of characters.\n *\n * ```js\n * splitByLength(`hello there`, 2);\n * // Yields:\n * // [`he`, `ll`, `o `, `th`, `er`, `e`]\n * ```\n * @param source Source string\n * @param length Length of each chunk\n * @returns\n */\nexport const splitByLength = (source, length) => {\n    throwFromResult(integerTest(length, `aboveZero`, `length`));\n    if (source === null)\n        throw new Error(`source parameter null`);\n    if (typeof source !== `string`) {\n        throw new TypeError(`source parameter not a string`);\n    }\n    // ✔ Unit tested\n    const chunks = Math.ceil(source.length / length);\n    const returnValue = [];\n    //eslint-disable-next-line functional/no-let\n    let start = 0;\n    //eslint-disable-next-line functional/no-let\n    for (let c = 0; c < chunks; c++) {\n        //eslint-disable-next-line functional/immutable-data\n        returnValue.push(source.slice(start, start + length));\n        start += length;\n    }\n    return returnValue;\n};\n// export const afterMatch = (\n//   source: string,\n//   match: string,\n//   options: MatchOptions = {}\n// ): string => {\n//   if (source === undefined) throw new Error(`Param 'source' is undefined`);\n//   //  ✔️ Unit tested\n//   const startPos = options.startPos ?? undefined;\n//   const fromEnd = options.fromEnd ?? false;\n//   const m = fromEnd\n//     ? source.lastIndexOf(match, startPos)\n//     : source.indexOf(match, startPos);\n//   if (m < 0) return source;\n//   return source.slice(Math.max(0, m + match.length));\n// };\n/**\n * Returns all the text in `source` that precedes (and does not include) `match`. If not found, `source` is returned.\n *\n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n *\n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n *\n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const beforeMatch = (source, match, options = {}) => {\n    const ba = beforeAfterMatch(source, match, options);\n    return ba[0];\n};\n/**\n * Returns all the text in `source` that follows `match`. If not found, `source` is returned.\n *\n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n *\n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n *\n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const afterMatch = (source, match, options = {}) => {\n    const ba = beforeAfterMatch(source, match, options);\n    return ba[1];\n};\n/**\n * Returns the text that is before and after `match`.\n *\n * See also: {@link beforeMatch}, {@link afterMatch}.\n *\n * If `match` is at the end of start of `source`, after or before might be an empty string.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const beforeAfterMatch = (source, match, options = {}) => {\n    if (source === undefined)\n        throw new Error(`Param 'source' is undefined`);\n    let fallback = options.fallback;\n    const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);\n    if (ifNoMatch === `original`)\n        fallback = source;\n    if (ifNoMatch === `fallback` && fallback === undefined)\n        throw new Error(`Fallback must be provided`);\n    const startPos = options.startPos ?? undefined;\n    const fromEnd = options.fromEnd ?? false;\n    const m = fromEnd\n        ? source.lastIndexOf(match, startPos)\n        : source.indexOf(match, startPos);\n    if (m < 0 && ifNoMatch === `throw`)\n        throw new Error(`Match '${match}' not found in source.`);\n    if (m < 0 && ifNoMatch === `original`)\n        return [source, source];\n    if (m < 0 && ifNoMatch === `fallback`) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return [fallback, fallback];\n    }\n    return [\n        source.slice(0, m),\n        source.slice(Math.max(0, m + match.length))\n    ];\n};\n/**\n * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.\n * Only removes when a matching end is found.\n * ```js\n * unwrap(\"'hello'\", \"'\");        // hello\n * // No mataching end 'a', so nothing happens\n * unwrap(\"apple\", \"a\");          // apple\n * unwrap(\"wow\", \"w\");            // o\n * unwrap(`\"'blah'\"`, '\"', \"'\");  // blah\n * ```\n * @param source\n * @param wrappers\n * @returns\n */\nexport const unwrap = (source, ...wrappers) => {\n    //eslint-disable-next-line functional/no-let\n    let matched = false;\n    do {\n        matched = false;\n        for (const w of wrappers) {\n            if (source.startsWith(w) && source.endsWith(w)) {\n                source = source.slice(w.length, source.length - w.length * 2 + 1);\n                matched = true;\n            }\n        }\n    } while (matched);\n    return source;\n};\n/**\n * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.\n *\n * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.\n *\n * @param ranges Ranges\n * @param start Start character position, in source text reference\n * @param end End character position, in source text reference\n * @returns Span\n */\nexport const lineSpan = (ranges, start, end) => {\n    //eslint-disable-next-line functional/no-let\n    let s = -1;\n    //eslint-disable-next-line functional/no-let\n    let endPos = -1;\n    //eslint-disable-next-line functional/no-let\n    for (const [index, r] of ranges.entries()) {\n        s = index;\n        if (r.text.length === 0)\n            continue;\n        if (start < r.end) {\n            break;\n        }\n    }\n    //eslint-disable-next-line functional/no-let\n    for (let index = s; index < ranges.length; index++) {\n        const r = ranges[index];\n        endPos = index;\n        if (end === r.end) {\n            endPos = index + 1;\n            break;\n        }\n        if (end < r.end) {\n            break;\n        }\n    }\n    return { length: endPos - s, start: s, end: endPos };\n};\n/**\n * Splits a source string into ranges:\n * ```js\n * const ranges = splitRanges(\"hello;there;fella\", \";\");\n * ```\n *\n * Each range consists of:\n * ```js\n * {\n *  text: string  - the text of range\n *  start: number - start pos of range, wrt to source\n *  end: number   - end pos of range, wrt to source\n *  index: number - index of range (starting at 0)\n * }\n * ```\n * @param source\n * @param split\n * @returns\n */\nexport const splitRanges = (source, split) => {\n    //eslint-disable-next-line functional/no-let\n    let start = 0;\n    //eslint-disable-next-line functional/no-let\n    let text = ``;\n    const ranges = [];\n    //eslint-disable-next-line functional/no-let\n    let index = 0;\n    //eslint-disable-next-line functional/no-let,unicorn/prevent-abbreviations\n    for (let i = 0; i < source.length; i++) {\n        if (source.indexOf(split, i) === i) {\n            //eslint-disable-next-line functional/no-let\n            const end = i;\n            //eslint-disable-next-line functional/immutable-data\n            ranges.push({\n                text,\n                start,\n                end,\n                index,\n            });\n            start = end + 1;\n            text = ``;\n            index++;\n        }\n        else {\n            text += source.charAt(i);\n        }\n    }\n    if (start < source.length) {\n        //eslint-disable-next-line functional/immutable-data\n        ranges.push({ text, start, index, end: source.length });\n    }\n    return ranges;\n};\n/**\n * Counts the number of times one of `chars` appears at the front of\n * a string, contiguously.\n *\n * ```js\n * countCharsFromStart(`  hi`, ` `); // 2\n * countCharsFromStart(`hi  `, ` `); // 0\n * countCharsFromStart(`  hi  `, ` `); // 2\n * ```\n * @param source\n * @param chars\n * @returns\n */\nexport const countCharsFromStart = (source, ...chars) => {\n    //eslint-disable-next-line functional/no-let\n    let counted = 0;\n    //eslint-disable-next-line functional/no-let\n    for (let index = 0; index < source.length; index++) {\n        if (chars.includes(source.charAt(index))) {\n            counted++;\n        }\n        else {\n            break;\n        }\n    }\n    return counted;\n};\n/**\n * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.\n * If _end_ is omitted, the the `start` value will be used.\n *\n * ```js\n * startsEnds(`This is a string`, `This`, `string`); // True\n * startsEnds(`This is a string`, `is`, `a`); // False\n * starsEnds(`test`, `t`); // True, starts and ends with 't'\n * ```\n * @param source String to search within\n * @param start Start\n * @param end End (if omitted, start will be looked for at end as well)\n * @returns True if source starts and ends with provided values.\n */\nexport const startsEnds = (source, start, end = start) => source.startsWith(start) && source.endsWith(end);\nexport const htmlEntities = (source) => source.replaceAll(/[&<>\\u00A0-\\u9999]/g, (index) => `&#${index.codePointAt(0)};`);\n/**\n * Simple wilcard matching. Use '*' in `pattern` to denote any number of characters.\n * ```js\n * // Must start with 'cat'\n * wildcard(`cat*`,`caterpillar`); // true\n * // Must end with 'cat'\n * wildcat(`*cat`, `bobcat`);  // true\n * // 'cat' anywhere in string\n * wildcard(`*cat*`, `see cat run`); // true\n * ```\n * @param pattern\n * @returns\n */\nexport const wildcard = (pattern) => {\n    // Based on source: https://stackoverflow.com/questions/26246601/wildcard-string-comparison-in-javascript\n    // for this solution to work on any string, no matter what characters it has\n    const escapeRegex = (value) => value.replaceAll(/([!$()*+./:=?[\\\\\\]^{|}])/g, `\\\\$1`);\n    // \".\"  => Find a single character, except newline or line terminator\n    // \".*\" => Matches any string that contains zero or more characters\n    pattern = pattern.split(`*`).map(m => escapeRegex(m)).join(`.*`);\n    // \"^\"  => Matches any string with the following at the beginning of it\n    // \"$\"  => Matches any string with that in front at the end of it\n    pattern = `^` + pattern + `$`;\n    // Create a regular expression object for matching string\n    const regex = new RegExp(pattern);\n    return (value) => {\n        // Returns true if it finds a match, otherwse it returns false\n        return regex.test(value);\n    };\n};\n","import { toStringAbbreviate } from \"./text.js\";\n/**\n * Wraps the `eq` function, tracing the input data result\n * ```js\n * // Init trace\n * const traceEq = isEqualTrace(isEqualValueDefault);\n * // Use it in some function that takes IsEqual<T>\n * compare(a, b, eq);\n * ```\n * @param eq\n * @returns\n */\nexport const isEqualTrace = (eq) => {\n    return (a, b) => {\n        const result = eq(a, b);\n        // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n        console.log(`isEqualTrace eq: ${result} a: ${toStringAbbreviate(a)} b: ${toStringAbbreviate(b)}`);\n        return result;\n    };\n};\n","import { toStringDefault } from \"./to-string.js\";\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n *\n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor\n * @returns\n */\nexport const toStringOrdered = (itemToMakeStringFor) => {\n    if (typeof itemToMakeStringFor === `string`)\n        return itemToMakeStringFor;\n    const allKeys = new Set();\n    JSON.stringify(itemToMakeStringFor, (key, value) => (allKeys.add(key), value));\n    return JSON.stringify(itemToMakeStringFor, [...allKeys].sort());\n};\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = (a, b) => a === b;\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n *\n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n *\n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n *\n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = (a, b) => {\n    // ✔ UNIT TESTED\n    if (a === b)\n        return true; // Object references are the same, or string values are the same\n    return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n *\n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n *\n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n *\n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a\n * @param b\n * @param fieldComparer\n * @returns\n */\nexport const isEqualValuePartial = (a, b, fieldComparer) => {\n    if (typeof a !== `object`)\n        throw new Error(`Param 'a' expected to be object`);\n    if (typeof b !== `object`)\n        throw new Error(`Param 'b' expected to be object`);\n    if (Object.is(a, b))\n        return true;\n    const comparer = fieldComparer ?? isEqualValuePartial;\n    for (const entryB of Object.entries(b)) {\n        const valueOnAKeyFromB = a[entryB[0]];\n        const valueB = entryB[1];\n        if (typeof valueOnAKeyFromB === `object` && typeof valueB === `object`) {\n            if (!comparer(valueOnAKeyFromB, valueB)) {\n                return false;\n            }\n        }\n        else {\n            if (valueOnAKeyFromB !== valueB) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n *\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n *\n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n * @typeParam T - Type of objects being compared\n */\nexport const isEqualValueIgnoreOrder = (a, b) => {\n    // ✔ UNIT TESTED\n    if (a === b)\n        return true; // Object references are the same, or string values are the same\n    return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n};\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value\n * @returns\n */\nexport const isEmptyEntries = (value) => [...Object.entries(value)].length === 0;\n/**\n * Returns _true_ if `a` and `b are equal based on their JSON representations.\n * `path` is ignored.\n * @param a\n * @param b\n * @param path\n * @returns\n */\nexport const isEqualContextString = (a, b, _path) => {\n    return JSON.stringify(a) === JSON.stringify(b);\n};\n","/**\n * Returns _true_ if `value` is an integer. Parses string input, but\n * all other data types return _false_.\n *\n * ```js\n * isInteger(1);      // true\n * isInteger(1.1);    // false\n * isInteger(`1`);    // true\n * isInteger(`1.1`);  // false\n * isInteger(true);   // false\n * isInteger(false);  // false\n * ```\n *\n * Returns _false_ for _undefined_, NaN, booleans and infinite numbers.\n * @param value\n * @returns\n */\nexport const isInteger = (value) => {\n    if (value === undefined)\n        return false;\n    if (typeof value === `string`) {\n        const v = Number.parseInt(value);\n        if (Number.isNaN(v))\n            return false;\n        if (v.toString() === value.toString())\n            return true;\n        return false;\n    }\n    if (typeof value === `number`) {\n        if (Number.isNaN(value))\n            return false;\n        if (!Number.isFinite(value))\n            return false;\n        if (Math.round(value) === value)\n            return true;\n        return false;\n    }\n    return false;\n};\n","/**\n * Returns _true_ if `value` is number, string, bigint or boolean.\n * Returns _false_ if `value` is an object, null, undefined\n *\n * Use {@link isPrimitiveOrObject} to also return true if `value` is an object.\n * @param value Value to check\n * @returns _True_ if value is number, string, bigint or boolean.\n */\nexport function isPrimitive(value) {\n    if (typeof value === `number`)\n        return true;\n    if (typeof value === `string`)\n        return true;\n    if (typeof value === `bigint`)\n        return true;\n    if (typeof value === `boolean`)\n        return true;\n    return false;\n}\n/**\n * Returns _true_ if `value` is number, string, bigint, boolean or an object\n *\n * Use {@link isPrimitive} to not include objects.\n * @param value\n * @returns\n */\nexport function isPrimitiveOrObject(value) {\n    if (isPrimitive(value))\n        return true;\n    if (typeof value === `object`)\n        return true;\n    return false;\n}\n","import { isEqualDefault } from \"./is-equal.js\";\n/**\n * Compares the values of two iterables, returning a list\n * of items they have in common and those unique in `a` or `b`.\n * Ignores ordering of values, and is NOT recursive.\n *\n * ```js\n * const a = ['apples', 'oranges', 'pears' ]\n * const b = ['pears', 'kiwis', 'bananas' ];\n *\n * const r = compareValuesShallow(a, b);\n * r.shared;  // [ 'pears' ]\n * r.a;       // [ 'apples', 'oranges' ]\n * r.b;       // [ 'kiwis', 'bananas' ]\n * ```\n *\n * By default uses === semantics for comparison.\n * @param a\n * @param b\n * @param eq\n * @returns\n */\nexport const compareIterableValuesShallow = (a, b, eq = (isEqualDefault)) => {\n    const shared = [];\n    const aUnique = [];\n    const bUnique = [];\n    for (const elementOfA of a) {\n        let seenInB = false;\n        // Does B contain this thing from A?\n        for (const elementOfB of b) {\n            if (eq(elementOfA, elementOfB)) {\n                seenInB = true;\n                break;\n            }\n        }\n        if (seenInB) {\n            // Common in A & B\n            shared.push(elementOfA);\n        }\n        else {\n            // No, it's only found in A\n            aUnique.push(elementOfA);\n        }\n    }\n    for (const elementOfB of b) {\n        let seenInA = false;\n        // Does A contain this thing from B?\n        for (const elementOfA of a) {\n            if (eq(elementOfB, elementOfA)) {\n                seenInA = true;\n            }\n        }\n        if (!seenInA) {\n            // No, something unique to B\n            bUnique.push(elementOfB);\n        }\n    }\n    // Are the two iterables the same?\n    const isSame = aUnique.length === 0 && bUnique.length === 0;\n    return {\n        shared,\n        isSame,\n        a: aUnique,\n        b: bUnique\n    };\n};\n","//import { minMaxAvg as arrayMinMaxAvg } from '../../ixfx/src/numbers-compute.js';\nimport { defaultComparer } from './comparers.js';\nconst sorterByValueIndex = (index, reverse = false) => {\n    return (values) => {\n        const s = values.toSorted((a, b) => {\n            return defaultComparer(a[index], b[index]);\n        });\n        if (reverse)\n            return s.reverse();\n        return s;\n    };\n};\nexport const keyValueSorter = (sortStyle) => {\n    switch (sortStyle) {\n        case `value`: {\n            return sorterByValueIndex(1, false);\n        }\n        case `value-reverse`: {\n            return sorterByValueIndex(1, true);\n        }\n        case `key`: {\n            return sorterByValueIndex(0, false);\n        }\n        case `key-reverse`: {\n            return sorterByValueIndex(0, true);\n        }\n        default: {\n            throw new Error(`Unknown sorting value '${sortStyle}'. Expecting: value, value-reverse, key or key-reverse`);\n        }\n    }\n};\n// export const minMaxAvg = (entries: readonly KeyValue[], conversionFunction?: (v: KeyValue) => number) => {\n//   const converter = conversionFunction ?? ((v: KeyValue) => v[ 1 ] as number);\n//   const values = entries.map<number>(entry => converter(entry));\n//   return arrayMinMaxAvg(values);\n// };\n","import { throwIntegerTest } from \"@ixfx/guards\";\n/**\n * Rounds a number.\n *\n * If one parameter is given, it's the decimal places,\n * and a rounding function is returned:\n * ```js\n * import { round } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * const r = round(2);\n * r(10.12355); // 10.12\n * ```\n *\n * If two parameters are given, the first is decimal places,\n * the second the value to round.\n * ```js\n * round(2, 10.12355); // 10.12\n * ```\n * @param decimalPlaces\n * @returns\n */\nexport function round(a, b, roundUp) {\n    throwIntegerTest(a, `positive`, `decimalPlaces`);\n    const up = (typeof b === `boolean`) ? b : (roundUp ?? false);\n    let rounder;\n    if (a === 0) {\n        rounder = Math.round;\n    }\n    else {\n        const p = Math.pow(10, a);\n        if (up) {\n            rounder = (v) => Math.ceil(v * p) / p;\n        }\n        else {\n            rounder = (v) => Math.floor(v * p) / p;\n        }\n    }\n    if (typeof b === `number`)\n        return rounder(b);\n    return rounder;\n}\n","import { numberTest } from '@ixfx/guards';\nimport { round } from './util/round.js';\n// export function intervalToMs(interval: Interval | undefined): number | undefined;\n// export function intervalToMs(\n//   interval: Interval | undefined,\n//   defaultNumber: number\n// ): number;\n/**\n * Return the millisecond value of an Interval.\n *\n * ```js\n * intervalToMs(100); // 100\n * intervalToMs({ millis: 100 }); // 100\n * ```\n *\n * Use `defaultNumber` to return a default in the case of\n * _undefined_ or invalid input.\n *\n * ```js\n * intervalToMs(undefined);      // throws error\n * intervalToMs(undefined, 100); // 100\n * ```\n *\n * If no default is provided, an exception is thrown.\n * @param interval Interval\n * @param defaultNumber Default value if `interval` is _undefined_ or invalid\n * @returns Milliseconds\n */\nexport function intervalToMs(interval, defaultNumber) {\n    if (isInterval(interval)) {\n        // Number given, must be millis?\n        if (typeof interval === `number`)\n            return interval;\n        let ms = interval.millis ?? 0;\n        ms += (interval.hours ?? 0) * 60 * 60 * 1000;\n        ms += (interval.mins ?? 0) * 60 * 1000;\n        ms += (interval.secs ?? 0) * 1000;\n        return ms;\n    }\n    else {\n        if (typeof defaultNumber !== `undefined`)\n            return defaultNumber;\n        throw new Error(`Not a valid interval: ${interval}`);\n    }\n}\n/**\n * Returns _true_ if `interval` matches the {@link Interval} type.\n * @param interval\n * @returns _True_ if `interval` is an {@link Interval}.\n */\nexport function isInterval(interval) {\n    if (interval === undefined)\n        return false;\n    if (interval === null)\n        return false;\n    if (typeof interval === `number`) {\n        if (Number.isNaN(interval))\n            return false;\n        if (!Number.isFinite(interval))\n            return false;\n        return true;\n    }\n    else if (typeof interval !== `object`)\n        return false;\n    const hasMillis = `millis` in interval;\n    const hasSecs = `secs` in interval;\n    const hasMins = `mins` in interval;\n    const hasHours = `hours` in interval;\n    if (hasMillis && !numberTest(interval.millis)[0])\n        return false;\n    if (hasSecs && !numberTest(interval.secs)[0])\n        return false;\n    if (hasMins && !numberTest(interval.mins)[0])\n        return false;\n    if (hasHours && !numberTest(interval.hours)[0])\n        return false;\n    if (hasMillis || hasSecs || hasHours || hasMins)\n        return true;\n    return false;\n}\n/**\n * Returns a human-readable representation\n * of some elapsed milliseconds\n *\n * @example\n * ```js\n * elapsedToHumanString(10);      // `10ms`\n * elapsedToHumanString(2000);    // `2s`\n * elapsedToHumanString(65*1000); // `1mins`\n * ```\n * @param millisOrFunction Milliseconds as a number, {@link Interval} or function that resolve to a number\n * @param rounding Rounding (default: 2)\n * @returns\n */\nexport const elapsedToHumanString = (millisOrFunction, rounding = 2) => {\n    let interval = {} = 0;\n    if (typeof millisOrFunction === `function`) {\n        const intervalResult = millisOrFunction();\n        return elapsedToHumanString(intervalResult);\n    }\n    else if (typeof millisOrFunction === `number`) {\n        interval = millisOrFunction;\n    }\n    else if (typeof millisOrFunction === `object`) {\n        interval = intervalToMs(interval);\n    }\n    let ms = intervalToMs(interval);\n    if (typeof ms === `undefined`)\n        return `(undefined)`;\n    if (ms < 1000)\n        return `${round(rounding, ms)}ms`;\n    ms /= 1000;\n    if (ms < 120)\n        return `${ms.toFixed(1)}secs`;\n    ms /= 60;\n    if (ms < 60)\n        return `${ms.toFixed(2)}mins`;\n    ms /= 60;\n    return `${ms.toFixed(2)}hrs`;\n};\n","import { toStringDefault } from \"@ixfx/core\";\n/**\n * Tracks unique values. Returns _true_ if value is unique.\n * Alternatively: {@link uniqueInstances}\n *\n * ```js\n * const t = unique();\n * t(`hello`); // true\n * t(`hello`); // false\n * ```\n *\n * Uses JSON.stringify to compare anything which is not a string.\n *\n * Provide a custom function to convert to string to track uniqueness\n * for more complicated objects.\n *\n * ```js\n * const t = unique(p => p.name);\n * t({ name:`John`, level:2 }); // true\n *\n * // Since we're judging uniques by name only\n * t({ name:`John`, level:3 }); // false\n * ```\n *\n * Return function throws an error if `value` is null or undefined.\n * @returns\n */\nexport const unique = (toString = toStringDefault) => {\n    const set = new Set();\n    return (value) => {\n        if (value === null)\n            throw new TypeError(`Param 'value' cannot be null`);\n        if (value === undefined)\n            throw new TypeError(`Param 'value' cannot be undefined`);\n        const asString = (typeof value === `string`) ? value : toString(value);\n        if (set.has(asString))\n            return false;\n        set.add(asString);\n        return true;\n    };\n};\n/**\n * Tracks unique object instances. Returns _true_ if value is unique.\n * Alternatively: {@link unique} to track by value.\n */\nexport const uniqueInstances = () => {\n    const set = new Set();\n    return (value) => {\n        if (value === null)\n            throw new TypeError(`Param 'value' cannot be null`);\n        if (value === undefined)\n            throw new TypeError(`Param 'value' cannot be undefined`);\n        if (set.has(value))\n            return false;\n        set.add(value);\n        return true;\n    };\n};\n","//eslint-disable-next-line functional/functional-parameters\nexport const runningiOS = () => [\n    `iPad Simulator`,\n    `iPhone Simulator`,\n    `iPod Simulator`,\n    `iPad`,\n    `iPhone`,\n    `iPod`,\n].includes(navigator.platform) ||\n    // iPad on iOS 13 detection\n    (navigator.userAgent.includes(`Mac`) && `ontouchend` in document);\n","export const promiseFromEvent = (target, name) => {\n    return new Promise(resolve => {\n        const handler = (...args) => {\n            target.removeEventListener(name, handler);\n            if (Array.isArray(args) && args.length === 1)\n                resolve(args[0]);\n            else\n                resolve(args);\n        };\n        target.addEventListener(name, handler);\n    });\n};\n","/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx\n * @returns\n */\nexport const isReactive = (rx) => {\n    if (typeof rx !== `object`)\n        return false;\n    if (rx === null)\n        return false;\n    return (`on` in rx && `onValue` in rx);\n};\nexport const hasLast = (rx) => {\n    if (!isReactive(rx))\n        return false;\n    if (`last` in rx) {\n        const v = rx.last();\n        if (v !== undefined)\n            return true;\n    }\n    return false;\n};\n","import { getErrorMessage } from \"@ixfx/debug\";\nimport { hasLast, isReactive } from \"./reactive-core.js\";\n/**\n * Resolves `r` to a value, where `r` is:\n * * primitive value\n * * a/sync function\n * * a/sync generator/iterator\n * * ReactiveNonInitial\n * ```js\n * await resolve(10);       // 10\n * await resolve(() => 10); // 10\n * await resole(async () => {\n *  sleep(100);\n *  return 10;\n * });                // 10\n * ```\n *\n * To resolve an object's properties, use {@link resolveFields}.\n *\n * Resolve is not recursive. So if `r` is an object, it will be returned, even\n * though its properties may be resolvable.\n * @param r\n * @param args\n * @returns\n */\nexport async function resolve(r, ...args) {\n    if (typeof r === `object`) {\n        if (`next` in r) {\n            const tag = r[Symbol.toStringTag];\n            if (tag === `Generator` || tag == `Array Iterator`) {\n                const v = r.next();\n                if (`done` in v && `value` in v)\n                    return v.value;\n                return v;\n            }\n            else if (tag === `AsyncGenerator`) {\n                const v = await r.next();\n                //console.log(`  hasDone: ${ `done` in v } value:`, v);\n                if (`done` in v && `value` in v)\n                    return v.value;\n                return v;\n            }\n            else {\n                throw new Error(`Object has 'next' prop, but does not have 'AsyncGenerator', 'Generator' or 'Array Iterator' string tag symbol. Got: '${tag}'`);\n            }\n        }\n        else if (isReactive(r)) {\n            if (hasLast(r))\n                return r.last();\n            throw new Error(`Reactive does not have last value`);\n        }\n        else {\n            // Some regular object\n            return r;\n        }\n    }\n    else if (typeof r === `function`) {\n        const v = await r(args);\n        return v;\n    }\n    else {\n        // Primitive value?\n        return r;\n    }\n}\nexport function resolveSync(r, ...args) {\n    if (typeof r === `object`) {\n        if (`next` in r) {\n            const tag = r[Symbol.toStringTag];\n            if (tag === `Generator` || tag == `Array Iterator`) {\n                const v = r.next();\n                if (`done` in v && `value` in v)\n                    return v.value;\n                return v;\n            }\n            else if (tag === `AsyncGenerator`) {\n                throw new Error(`resolveSync cannot work with an async generator`);\n            }\n            else {\n                throw new Error(`Object has 'next' prop, but does not have 'Generator' or 'Array Iterator' string tag symbol. Got: '${tag}'`);\n            }\n        }\n        else if (isReactive(r)) {\n            if (hasLast(r))\n                return r.last();\n            throw new Error(`Reactive does not have last value`);\n        }\n        else {\n            // Some regular object\n            return r;\n        }\n    }\n    else if (typeof r === `function`) {\n        return r(args);\n    }\n    else {\n        // Primitive value?\n        return r;\n    }\n}\n/**\n * Resolves a value as per {@link resolve}, however\n * If an error is thrown or the resolution results in _undefined_\n * or NaN, `fallbackValue` is returned instead.\n *\n * `null` is an allowed return value.\n *\n * ```js\n * // Function returns undefined 50% of the time or 0\n * const fn = () => {\n *  if (Math.random() >= 0.5) return; // undefined\n *  return 0;\n * }\n * const r = resolveWithFallback(fn, 1);\n * const value = r(); // Always 0 or 1\n * ```\n * @param p Thing to resolve\n * @param fallback Fallback value if an error happens, undefined or NaN\n * @param args\n * @returns\n */\nexport async function resolveWithFallback(p, fallback, ...args) {\n    let errored = false;\n    let fallbackValue = fallback.value;\n    const overrideWithLast = fallback.overrideWithLast ?? false;\n    if (fallbackValue === undefined)\n        throw new Error(`Needs a fallback value`);\n    try {\n        const r = await resolve(p, ...args);\n        if (typeof r === `undefined`)\n            return fallbackValue;\n        if (typeof r === `number` && Number.isNaN(r))\n            return fallbackValue;\n        if (overrideWithLast)\n            fallbackValue = r;\n        return r;\n    }\n    catch (error) {\n        if (!errored) {\n            errored = true;\n            console.warn(`resolveWithFallback swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n        }\n        return fallbackValue;\n    }\n}\nexport function resolveWithFallbackSync(p, fallback, ...args) {\n    let errored = false;\n    let fallbackValue = fallback.value;\n    const overrideWithLast = fallback.overrideWithLast ?? false;\n    if (fallbackValue === undefined)\n        throw new Error(`Needs a fallback value`);\n    try {\n        const r = resolveSync(p, ...args);\n        if (typeof r === `undefined`)\n            return fallbackValue;\n        if (typeof r === `number` && Number.isNaN(r))\n            return fallbackValue;\n        if (overrideWithLast)\n            fallbackValue = r;\n        return r;\n    }\n    catch (error) {\n        if (!errored) {\n            errored = true;\n            console.warn(`resolveWithFallbackSync swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n        }\n        return fallbackValue;\n    }\n}\n","export const zip = (...arrays) => {\n    if (arrays.some((a) => !Array.isArray(a))) {\n        throw new Error(`All parameters must be an array`);\n    }\n    const lengths = arrays.map((a) => a.length);\n    const returnValue = [];\n    const length = lengths[0];\n    for (let index = 0; index < length; index++) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n        returnValue.push(arrays.map((a) => a[index]));\n    }\n    return returnValue;\n};\n","import { resolve, resolveSync } from \"@ixfx/core\";\nimport { zip } from \"./util/zip.js\";\n/**\n * Returns a copy of `object`, with the same properties. For each property\n * that has a basic value (string, number, boolean, object), the value is set\n * for the return object. If the property is a function or generator, its value\n * is used instead. Async functions and generators are also usable.\n *\n * Use {@link resolveFieldsSync} for a synchronous version.\n *\n * Not recursive.\n *\n * In the below example, the function for the property `random` is invoked.\n * ```js\n * const state = {\n *  length: 10,\n *  random: () => Math.random();\n * }\n * const x = resolveFields(state);\n * // { length: 10, random: 0.1235 }\n * ```\n *\n * It also works with generators\n * ```js\n * import { count } from './numbers.js';\n *\n * const state = {\n *  length: 10,\n *  index: count(2) // Generator that yields: 0, 1 and then ends\n * }\n * resolveFields(state); // { length: 10, index: 0 }\n * resolveFields(state); // { length: 10, index: 1 }\n * // Generator finishes after counting twice:\n * resolveFields(state); // { length: 10, index: undefined }\n * ```\n * @param object\n * @returns\n */\nexport async function resolveFields(object) {\n    const resolvers = [];\n    const keys = [];\n    for (const entry of Object.entries(object)) {\n        const resolvable = entry[1];\n        resolvers.push(resolve(resolvable));\n        keys.push(entry[0]);\n    }\n    const results = await Promise.all(resolvers);\n    const entries = zip(keys, results);\n    return Object.fromEntries(entries);\n}\nexport function resolveFieldsSync(object) {\n    const entries = [];\n    for (const entry of Object.entries(object)) {\n        const resolvable = entry[1];\n        const value = resolveSync(resolvable);\n        entries.push([entry[0], value]);\n    }\n    return Object.fromEntries(entries);\n}\n/**\n * Returns a function that resolves `object`.\n *\n * Use {@link resolveFields} to resolve an object directly.\n * @param object\n * @returns\n */\n// export function resolverFields<V extends object>(object: V) {\n//   return () => resolveFields(object);\n// }\n","import { getErrorMessage } from \"@ixfx/debug\";\n/**\n * If `result` is an error, throws it, otherwise ignored.\n * @param result\n * @returns\n */\nexport function throwResult(result) {\n    if (result.success)\n        return true;\n    if (typeof result.error === `string`)\n        throw new Error(result.error);\n    throw result.error;\n}\nexport function resultToError(result) {\n    if (typeof result.error === `string`)\n        return new Error(result.error);\n    else\n        return result.error;\n}\nexport function resultToValue(result) {\n    if (result.success)\n        return result.value;\n    else\n        throw resultToError(result);\n}\nexport function resultErrorToString(result) {\n    if (typeof result.error === `string`)\n        return result.error;\n    else\n        return getErrorMessage(result.error);\n}\n","import { throwNumberTest } from '@ixfx/guards';\nimport { intervalToMs } from './interval-type.js';\nif (typeof window === `undefined` || !(`requestAnimationFrame` in window)) {\n    if (typeof window === `undefined`) {\n        // @ts-expect-error\n        globalThis.requestAnimationFrame = (callback) => {\n            setTimeout(callback, 1);\n        };\n    }\n}\n/**\n * Returns after timeout period.\n *\n * @example In an async function\n * ```js\n * console.log(`Hello`);\n * await sleep(1000);\n * console.log(`There`); // Prints one second after\n * ```\n *\n * @example As a promise\n * ```js\n * console.log(`Hello`);\n * sleep({ millis: 1000 })\n *  .then(() => console.log(`There`)); // Prints one second after\n * ```\n *\n * If a timeout of 0 is given, `requestAnimationFrame` is used instead of `setTimeout`.\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * A value can be provided, which is returned on awaking:\n * ```js\n * const v = await sleep({ seconds: 1, value: `hello`);\n * // v = `hello`\n * ```\n *\n * Provide an AbortSignal to cancel the sleep and throwing an exception\n * so code after the sleep doesn't happen.\n *\n * ```js\n * const ac = new AbortController();\n * setTimeout(() => { ac.abort(); }, 1000); // Abort after 1s\n *\n * // Sleep for 1min\n * await sleep({ minutes: 1, signal: ac.signal });\n * console.log(`Awake`); // This line doesn't get called because an exception is thrown when aborting\n * ```\n * @param optsOrMillis Milliseconds to sleep, or options\n * @return\n */\nexport const sleep = (optsOrMillis) => {\n    const timeoutMs = intervalToMs(optsOrMillis, 1);\n    const signal = optsOrMillis.signal;\n    const value = optsOrMillis.value;\n    throwNumberTest(timeoutMs, `positive`, `timeoutMs`);\n    if (timeoutMs === 0) {\n        return new Promise((resolve) => requestAnimationFrame((_) => {\n            resolve(value);\n        }));\n    }\n    else {\n        return new Promise((resolve, reject) => {\n            const onAbortSignal = () => {\n                clearTimeout(t);\n                if (signal) {\n                    signal.removeEventListener(`abort`, onAbortSignal);\n                    reject(new Error(signal.reason));\n                }\n                else {\n                    reject(new Error(`Cancelled`));\n                }\n            };\n            if (signal) {\n                signal.addEventListener(`abort`, onAbortSignal);\n            }\n            const t = setTimeout(() => {\n                signal?.removeEventListener(`abort`, onAbortSignal);\n                if (signal?.aborted) {\n                    reject(new Error(signal.reason));\n                    return;\n                }\n                resolve(value);\n            }, timeoutMs);\n        });\n    }\n};\n/**\n * Delays until `predicate` returns true.\n * Can be useful for synchronising with other async activities.\n * ```js\n * // Delay until 'count' reaches 5\n * await sleepWhile(() => count >= 5, 100);\n * ```\n * @param predicate\n * @param checkInterval\n */\nexport const sleepWhile = async (predicate, checkInterval = 100) => {\n    while (predicate()) {\n        await sleep(checkInterval);\n    }\n};\n"],"mappings":"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"}