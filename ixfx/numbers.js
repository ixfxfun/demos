import{n as e}from"./chunk-CVLEGGlw.js";import{a as t,u as n,y as r}from"./numbers-BlBexQl9.js";import{a as i,c as a,d as o,f as s,i as ee,l as te,n as c,o as l,r as u,s as d,t as ne,u as re}from"./numeric-arrays-CRg0aU_z.js";import{a as ie,c as f,i as ae,n as oe,o as se,r as ce,s as p,t as le}from"./moving-average-CQgRiq9V.js";import{i as ue,n as de,r as fe,t as pe}from"./clamp-dSm2UU4N.js";import{t as me}from"./bipolar-B_WKH-ep.js";import{n as he,r as ge,t as m}from"./wrap-BvLZW4rK.js";import{n as h,r as g,t as _}from"./interpolate-Dc-oL9YV.js";import{n as v,t as y}from"./quantise-BF6gOUEX.js";import{t as b}from"./linear-space-DuZicrUG.js";import{t as x}from"./number-array-compute-BHNf8OQn.js";import{a as S,c as C,i as w,n as T,o as E,r as D,s as O,t as k}from"./scale-DsFpif2S.js";const A=(e,t)=>{let n={...e};for(let[r,i]of Object.entries(e))typeof i==`number`?n[r]=t(i):n[r]=i;return n};function*j(e,n=0){if(r(t(e,``,`amount`),t(n,``,`offset`)),e===0)return;let i=0;do yield e<0?-i+n:i+n;while(i++<Math.abs(e)-1)}const M=(e,t=`absolute`)=>n=>P(t,n,e),N=(e=`absolute`,t=NaN)=>{let n=t;return t=>{let r=P(e,t,n);return n=t,r}},P=(e=`absolute`,t,n)=>{if(Number.isNaN(n))return 0;let r=t-n,i=0;if(e===`absolute`)i=Math.abs(r);else if(e===`numerical`)i=r;else if(e===`relative`)i=Math.abs(r/n);else if(e===`relativeSigned`)i=r/n;else throw TypeError(`Unknown kind: '${e}' Expected: 'absolute', 'relative', 'relativeSigned' or 'numerical'`);return i},F=e=>!(typeof e!=`number`||Number.isNaN(e));function*I(e){for(let t of e)F(t)&&(yield t)}const L=e=>t=>t>=e,_e=(e,t)=>n=>n>=e&&n<=t,ve=e=>(typeof e==`function`&&(e=e()),r(n(e,`percentage`,`v`)),1-e),ye=function*(e,t=0,n,r=!1){if(e<=0)throw Error(`Interval is expected to be above zero`);n===void 0&&(n=2**53-1);let i=t;do for(;i<=n;)yield i,i+=e;while(r)},R=function*(e,t=0,i,a=!1,o){r(n(e,`nonZero`));let s=e<0;if(i!==void 0&&(s&&t<i||!s&&t>i))throw Error(`Interval of ${e.toString()} will never go from ${t.toString()} to ${i.toString()}`);o??=1e3,i===void 0?i=2**53-1:i*=o,e*=o;do{let n=t*o;for(;!s&&n<=i||s&&n>=i;)yield n/o,n+=e}while(a)},be=function(e=.01,t=!1,i=0,a=1){return r(n(e,`percentage`,`interval`),n(i,`percentage`,`start`),n(a,`percentage`,`end`)),R(e,i,a,t)};function xe(e,t,i){r(n(e,`percentage`,`rangePercent`));let a=Math.floor(e*100),o=(e,t)=>{try{if(typeof t!=`number`||Number.isNaN(t)||!Number.isFinite(t))return!1;let n=Math.abs(t-e);return(e===0?Math.floor(n*100):Math.floor(n/e*100))<=a}catch{return!1}};return t===void 0?o:(r(n(t,``,`baseValue`)),i===void 0?e=>o(t,e):o(t,i))}const Se=(e,...t)=>{let n=t.map(t=>t-e),r=t.map(t=>t+e);return(...e)=>{for(let i of e)for(let e=0;e<t.length;e++)if(i>=n[e]&&i<=r[e])return!0;return!1}};var z=class{R;Q;A;C;B;cov;x;constructor(e={}){this.R=e.r??1,this.Q=e.q??1,this.A=e.a??1,this.C=e.c??1,this.B=e.b??0,this.cov=NaN,this.x=NaN}filter(e,t=0){if(isNaN(this.x))this.x=1/this.C*e,this.cov=1/this.C*this.Q*(1/this.C);else{let n=this.predict(t),r=this.uncertainty(),i=r*this.C*(1/(this.C*r*this.C+this.Q));this.x=n+i*(e-this.C*n),this.cov=r-i*this.C*r}return this.x}predict(e=0){return this.A*this.x+this.B*e}uncertainty(){return this.A*this.cov*this.A+this.R}lastMeasurement(){return this.x}setMeasurementNoise(e){this.Q=e}setProcessNoise(e){this.R=e}};const Ce=(e={})=>{let t=new z(e);return t.filter.bind(t)},B=(e,t)=>V(e,.75)-V(e,.25),we=(e,t=1.5)=>{if(e.length<4)return e=>!1;let n=e.toSorted((e,t)=>e-t),r=V(n,.25,!0),i=V(n,.75,!0),a=i-r,o=i+a*t,s=r-a*t;return e=>e<s||e>o},V=(e,t,n=!1)=>{if(t>1||t<0)throw TypeError(`Param 'quantile' is expected to be in 0..1 range. Got: '${t}'`);if(!Array.isArray(e))throw TypeError(`Param 'data' is expected to be an array. Got: ${typeof e}`);let r=t*(e.length-1);if(n||(e=e.toSorted((e,t)=>e-t)),t===0)return e[0];if(t===1)return e[e.length-1];if(r%1==0)return e[r];let i=Math.floor(r);return e[i+1]===void 0?e[i]:(e[i]+e[i+1])/2};var Te=e({array:()=>Ee,arrayWithContext:()=>U,compute:()=>H,stream:()=>G,streamWithContext:()=>W});const H=(e,t,n=!1)=>{let r=t-e;return i=>(n&&i<e&&(i=e),n&&i>t&&(i=t),(i-e)/r)},U=(e,t={})=>{if(!Array.isArray(e))throw TypeError(`Param 'values' should be an array. Got: ${typeof e}`);let i=!1,a=NaN,o=NaN;if(t.minForced===void 0||t.maxForced===void 0){let n=x(e);a=t.minForced??n.min,o=t.maxForced??n.max,i=t.clamp??!1}else i=t.clamp??!0,a=t.minForced,o=t.maxForced;r(n(a),n(o));let s=H(a,o,i);return{values:e.map(s),original:e,min:a,max:o,range:Math.abs(o-a)}},Ee=(e,t={})=>U(e,t).values,W=(e={})=>{let t=e.minDefault??2**53-1,i=e.maxDefault??-(2**53-1);return r(n(t),n(i)),{seen:e=>{if(r(n(e)),t=Math.min(t,e),i=Math.max(i,e),e===t&&e===i)return 1;let a=(e-t)/(i-t);if(Number.isNaN(a))throw Error(`Would return NaN. v: ${e} min: ${t} max: ${i}`);return a},reset:(e,n)=>{t=e??2**53-1,i=n??-(2**53-1)},get min(){return t},get max(){return i},get range(){return Math.abs(i-t)}}},G=e=>W(e).seen,K=(e,t=!1,n)=>{let r=n===void 0?p(e):n;return Math.sqrt(e.reduce((e,t)=>e.concat((t-r)**2),[]).reduce((e,t)=>e+t,0)/(e.length-(t?0:1)))};var De=e({array:()=>Oe,arrayWithContext:()=>J,compute:()=>q});const q=(e,t)=>n=>(n-e)/t,J=(e,t={})=>{let n=t.meanForced??p(e),r=t.standardDeviationForced??K(e),i=q(n,r);return{mean:n,standardDeviation:r,values:e.map(i),original:e}},Oe=(e,t={})=>J(e,t).values;var ke=e({array:()=>Ae,arrayWithContext:()=>X,compute:()=>Y});const Y=(e,t)=>n=>(n-e)/t,X=(e,t={})=>{if(!Array.isArray(e))throw TypeError(`Param 'array' is expected to be an array. Got: ${typeof e}`);let n=t.medianForced??f(e),r=t.iqrForced??B(e),i=Y(n,r);return{median:n,iqr:r,values:e.map(i),original:e}},Ae=(e,t={})=>X(e,t).values;var je=e({MinMax:()=>Te,Robust:()=>ke,ZScore:()=>De,array:()=>Pe,arrayWithContext:()=>Z,stream:()=>Ne,streamWithContext:()=>Me});const Me=(e,t={})=>{switch(e){case`minmax`:return W(t);default:throw Error(`Param 'strategy' has an unknown value: '${e}'. Expected: minmax`)}},Ne=(e=`minmax`,t={})=>{switch(e){case`minmax`:return G(t);default:throw Error(`Param 'strategy' has an unknown value: '${e}'. Expected: minmax`)}},Z=(e,t,n={})=>{switch(e){case`minmax`:return U(t,n);case`zscore`:return J(t,n);case`robust`:return X(t,n);default:throw Error(`Param 'strategy' has an unknown value: '${e}'. Expected: minmax|zscore`)}},Pe=(e,t,n={})=>Z(e,t,n).values,Fe=(e,t)=>(typeof e==`function`&&(e=e()),typeof t==`function`&&(t=t()),r(n(e,`percentage`,`v`),n(t,`percentage`,`t`)),e*t);function Q(e,t,n=`skip`){if(typeof e==`number`){if(Number.isNaN(e)||!Number.isFinite(e)){if(n===`error`)throw TypeError(`Param 'value' is NaN or infinite, and nonNumberHandling is set to 'error'`);return t}return e>=t.min&&e<=t.max?t:{min:Math.min(e,t.min),max:Math.max(e,t.max)}}else if(n===`error`)throw TypeError(`Param 'value' is not a number (type: '${typeof e}') and nonNumberHandling is set to 'error'`);return t}function Ie(e,t=1,n=0,r,i=!0){return S(e.min,e.max,n,t,r,i)}function Le(e,t){return e.max<=t.max&&e.min>=t.min?t:{min:Math.min(e.min,t.min),max:Math.max(e.max,t.max)}}const $=()=>({min:2**53-1,max:-(2**53-1)}),Re=(e,t)=>e===void 0||t===void 0?!1:e.max===t.max&&e.min===t.min,ze=(e,t)=>e===void 0||t===void 0?!1:e.min>=t.min&&e.max<=t.max,Be=(e=$())=>{let{min:t,max:n}=e;return{seen:e=>(typeof e==`number`&&!Number.isNaN(e)&&Number.isFinite(e)&&(t=Math.min(t,e),n=Math.max(n,e)),{min:t,max:n}),reset:()=>{t=2**53-1,n=-(2**53-1)},get range(){return{min:t,max:n}},get min(){return t},get max(){return n}}};function Ve(e,t=`skip`){let n=2**53-1,r=-(2**53-1),i=0;for(let a of e){if(typeof a==`number`){if(Number.isNaN(a)||!Number.isFinite(a)){if(t===`error`)throw Error(`Value NaN or infinite at position: ${i}`);continue}}else{if(t===`error`)throw Error(`Contains non number value. Type: '${typeof a}' Position: ${i}`);continue}a<n&&(n=a),a>r&&(r=a),i++}return{min:n,max:r}}const He=e=>{let t=e.reduce((e,t)=>Math.max(e,t),-1/0),n=e.map(e=>Math.exp(e-t)),r=n.reduce((e,t)=>e+t);return n.map(e=>e/r)},Ue=()=>{let e=0,t=2**53-1,n=-(2**53-1),r=0;return{seen:i=>{t=Math.min(i,t),n=Math.max(i,n),r+=i,e++},reset:()=>{e=0,t=2**53-1,n=-(2**53-1),r=0},rangeToString:(e=2)=>`${t.toFixed(2)} - ${n.toFixed(2)}`,get avg(){return r/e},get min(){return t},get max(){return n},get total(){return r},get count(){return e}}};export{me as Bipolar,z as Kalman1dFilter,je as Normalise,A as applyToValues,ne as average,ie as averageWeigher,se as averageWeighted,pe as clamp,de as clampIndex,fe as clamper,we as computeIsOutlier,j as count,M as differenceFromFixed,N as differenceFromLast,c as dotProduct,I as filterIterable,ve as flip,V as getQuantile,_ as interpolate,h as interpolateAngle,g as interpolatorStepped,B as interquartileRange,xe as isApprox,Se as isCloseToAny,F as isValid,Ce as kalman1dFilter,b as linearSpace,u as max,ue as maxAbs,ee as maxFast,i as maxIndex,p as mean,f as median,l as min,d as minFast,a as minIndex,le as movingAverage,oe as movingAverageLight,ce as movingAverageWithContext,ae as noiseFilter,x as numberArrayCompute,be as numericPercent,R as numericRange,ye as numericRangeRaw,Fe as proportion,y as quantiseEvery,Ve as rangeCompute,_e as rangeInclusive,$ as rangeInit,Re as rangeIsEqual,ze as rangeIsWithin,Le as rangeMergeRange,Q as rangeMergeValue,Ie as rangeScaler,Be as rangeStream,v as round,k as scale,T as scaleClamped,D as scalePercent,w as scalePercentages,S as scaler,E as scalerNull,O as scalerPercent,C as scalerTwoWay,He as softmax,K as standardDeviation,L as thresholdAtLeast,te as total,re as totalFast,Ue as trackSimple,o as validNumbers,s as weight,m as wrap,he as wrapInteger,ge as wrapRange};