{"version":3,"file":"continuously-DpXGnxOo.js","names":["callback: ContinuouslyAsyncCallback | ContinuouslySyncCallback","interval?: Interval","options: Partial<ContinuouslyOpts>","runState: HasCompletionRunStates","currentTimer: ReturnType<typeof globalThis.setTimeout> | undefined","scheduledCallback: () => void","interval: Interval","interval"],"sources":["../../packages/core/src/continuously.ts"],"sourcesContent":["import { integerTest, resultThrow } from '@ixfx/guards';\nimport { intervalToMs, type Interval } from '@ixfx/core';\n\nexport type HasCompletionRunStates = `idle` | `scheduled` | `running`;\nexport type HasCompletion = {\n  /**\n   * Gets the current run state\n   * idle: not yet started or completed with no future run scheduled\n   * scheduled: waiting to run\n   * running: currently executing its callback\n   */\n  get runState(): HasCompletionRunStates\n  /**\n   * Returns the number of times the scheduled function\n   * has been executed.\n   * \n   * This number will be reset in some conditions.\n   * For example `continuously` resets it when the loop stops.\n   * \n   * Use {@link startCountTotal} to track total number.\n   */\n  get startCount(): number\n\n  /**\n   * Total number of times scheduled function has been\n   * executed.\n   */\n  get startCountTotal(): number\n};\n\n/**\n * Runs a function continuously, returned by {@link continuously}\n */\nexport type Continuously = HasCompletion & {\n  /**\n   * Starts loop. If already running, does nothing\n   */\n  start(): void;\n\n  /**\n   * (Re-)starts the loop. If an existing iteration has been\n   * scheduled, this is cancelled and started again.\n   *\n   * This can be useful when adjusting the interval\n   */\n  reset(): void;\n  /**\n   * How many milliseconds since loop was started after being stopped.\n   */\n  get elapsedMs(): number;\n  /**\n   * If disposed, the continuously instance won't be re-startable\n   */\n  get isDisposed(): boolean;\n  /**\n   * Stops loop. It can be restarted using .start()\n   */\n  cancel(): void;\n  /**\n   * Sets the interval speed of loop. Change will take effect on next loop. For it to kick\n   * in earlier, call .reset() after changing the value.\n   */\n  set interval(interval: Interval);\n  /**\n   * Gets the current interval, ie. speed of loop.\n   */\n  get interval(): Interval;\n};\n\nexport type ContinuouslySyncCallback = (\n  /**\n   * Number of times loop\n   * Ticks is reset when loop exits.\n   */\n  ticks?: number,\n  /**\n   * Elapsed milliseconds.\n   * Reset when loop exits\n   */\n  elapsedMs?: number\n  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n) => boolean | void;\n\nexport type ContinuouslyAsyncCallback = (\n  /**\n   * Number of times loop has run\n   * Reset when loop exits.\n   */\n  ticks?: number,\n  /**\n   * Elapsed milliseconds.\n   * Reset when loop exits.\n   */\n  elapsedMs?: number\n  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n) => Promise<boolean | void>;\n\nexport type OnStartCalled = `continue` | `cancel` | `reset` | `dispose`;\n\n/**\n * Options for {@link continuously}\n */\nexport type ContinuouslyOpts = Readonly<{\n  /**\n   * Abort signal to exit loop\n   */\n  signal: AbortSignal;\n  /**\n   * If _true_, callback runs before waiting period.\n   * @defaultValue false\n   */\n  fireBeforeWait: boolean;\n  /**\n   * Called whenever .start() is invoked.\n   * If this function returns:\n   *  - `continue`: the loop starts if it hasn't started yet, or continues if already started\n   *  - `cancel`: loop stops, but can be re-started if .start() is called again\n   *  - `dispose`: loop stops and will throw an error if .start() is attempted to be called\n   *  - `reset`: loop resets (ie. existing scheduled task is cancelled)\n   *\n   */\n  onStartCalled: (\n    /**\n     * Number of times loop has run\n     * Reset when loop is exits.\n     */\n    ticks?: number,\n    /**\n     * Elapsed milliseconds.\n     * Reset when loop is exits.\n     */\n    elapsedMs?: number\n  ) => OnStartCalled;\n}>;\n\n/**\n * Returns a {@link Continuously} that continually executes `callback` at `interval` rate.\n * \n * By default, first the sleep period happens and then the callback happens.\n *\n * Call `start` to begin/reset loop. The looping stops when `cancel` is called, or when `callback` returns _false_.\n *\n * @example\n * Animation loop\n * ```js\n * const draw = () => {\n *  // Draw on canvas\n * }\n *\n * // Run draw() synchronised with monitor refresh rate via `window.requestAnimationFrame`\n * continuously(draw).start();\n * ```\n *\n * @example\n * With delay\n * ```js\n * const fn = () => {\n *  // Runs after one minute\n * }\n * const c = continuously(fn, { mins: 1 } );\n * c.start(); // Runs `fn` every minute\n * ```\n *\n * @example\n * Control a 'continuously'\n * ```js\n * c.cancel();   // Stop the loop, cancelling any up-coming calls to `fn`\n * c.elapsedMs;  // How many milliseconds have elapsed since start\n * c.ticks;      // How many iterations of loop since start\n * c.interval;   // Get/set speed of loop. Change kicks-in at next loop.\n *               // Use .start() to reset to new interval immediately\n * ```\n *\n * Asynchronous callback functions are supported too:\n * ```js\n * continuously(async () => { ..});\n * ```\n *\n * The `callback` function can receive a few arguments:\n * \n * ```js\n * continuously( (ticks, elapsedMs) => {\n *  // ticks: how many times loop has run\n *  // elapsedMs:  how long since last loop\n * }).start();\n * ```\n *\n * If the callback explicitly returns _false_, the loop will be cancelled.\n * \n * ```js\n * continuously(ticks => {\n *  // Stop after 100 iterations\n *  if (ticks > 100) return false;\n * }).start();\n * ```\n *\n * You can intercept the logic for calls to `start()` with `onStartCalled`. It can determine\n * whether the `start()` proceeds, if the loop is cancelled, or the whole thing disposed,\n * so it can't run any longer.\n * \n * ```js\n * continuously(callback, intervalMs, {\n *  onStartCalled:(ticks, elapsedMs) => {\n *    // Cancel the loop after 1000ms has elapsed\n *    if (elapsedMs > 1000) return `cancel`;\n *  }\n * }).start();\n * ```\n *\n * To run `callback` *before* the sleep happens, set `fireBeforeWait`:\n * ```js\n * continuously(callback, intervalMs, { fireBeforeWait: true });\n * ```\n * @param callback - Function to run. If it returns _false_, loop exits.\n * @param options - {@link ContinuouslyOpts ContinuouslyOpts}\n * @param interval - Speed of loop (default: 0)\n * @returns Instance to control looping.\n * @see {@link Timeout} if you want to trigger something once.\n */\nexport const continuously = (\n  callback: ContinuouslyAsyncCallback | ContinuouslySyncCallback,\n  interval?: Interval,\n  options: Partial<ContinuouslyOpts> = {}\n): Continuously => {\n  let intervalMs = intervalToMs(interval, 0);\n  resultThrow(integerTest(intervalMs, `positive`, `interval`));\n  const fireBeforeWait = options.fireBeforeWait ?? false;\n  const onStartCalled = options.onStartCalled;\n  const signal = options.signal;\n\n  let disposed = false;\n  let runState: HasCompletionRunStates = `idle`;\n  let startCount = 0;\n  let startCountTotal = 0;\n  let startedAt = performance.now();\n  let intervalUsed = interval ?? 0;\n  let cancelled = false;\n  let currentTimer: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  const deschedule = () => {\n    if (currentTimer === undefined) return;\n    globalThis.clearTimeout(currentTimer);\n    currentTimer = undefined;\n    startCount = 0;\n    startedAt = Number.NaN;\n  }\n\n  const schedule = (scheduledCallback: () => void) => {\n    if (intervalMs === 0) {\n      if (typeof requestAnimationFrame === `undefined`) {\n        currentTimer = globalThis.setTimeout(scheduledCallback, 0);\n      } else {\n        currentTimer = undefined;\n        requestAnimationFrame(scheduledCallback);\n      }\n    } else {\n      currentTimer = globalThis.setTimeout(scheduledCallback, intervalMs);\n    }\n  }\n\n  const cancel = () => {\n    if (cancelled) return;\n    cancelled = true;\n\n    if (runState === `idle`) return; // No need to cancel\n    runState = `idle`;\n    deschedule();\n  };\n\n  const loop = async () => {\n    if (signal?.aborted) {\n      runState = `idle`;\n    }\n    if (runState === `idle`) return;\n\n    runState = `running`\n    startCount++;\n    startCountTotal++;\n    const valueOrPromise = callback(startCount, performance.now() - startedAt);\n    const value = typeof valueOrPromise === `object` ? (await valueOrPromise) : valueOrPromise;\n    if (cancelled) {\n      return;\n    }\n    runState = `scheduled`;\n\n    // Didn't get a value, exit out\n    if (value !== undefined && !value) {\n      cancel();\n      return;\n    }\n\n    if (cancelled) return; // has been cancelled\n    // eslint-disable-next-line @typescript-eslint/no-misused-promises\n    schedule(loop);\n  };\n\n  const start = () => {\n    if (disposed) throw new Error(`Disposed`);\n    cancelled = false;\n\n    if (onStartCalled !== undefined) {\n      // A function governs whether to allow .start() to go ahead\n      const doWhat = onStartCalled(startCount, performance.now() - startedAt);\n      switch (doWhat) {\n        case `cancel`: {\n          cancel();\n          return;\n        }\n        case `reset`: {\n          reset();\n          return;\n        }\n        case `dispose`: {\n          disposed = true;\n          cancel();\n          return;\n        }\n        // No default\n      }\n    }\n\n    if (runState === `idle`) {\n      // Start running\n      startCount = 0;\n      startedAt = performance.now();\n      runState = `scheduled`;\n      if (fireBeforeWait) {\n        void loop(); // Exec first, then wait\n      } else {\n        // eslint-disable-next-line @typescript-eslint/no-misused-promises\n        schedule(loop); // Wait first, then exec\n      }\n    } // else: already running, ignore\n  };\n\n  const reset = () => {\n    if (disposed) throw new Error(`Disposed`);\n    cancelled = false;\n    startCount = 0;\n    startedAt = Number.NaN;\n\n    // Cancel scheduled iteration\n    if (runState !== `idle`) {\n      cancel();\n    }\n    start();\n  };\n\n  return {\n    start,\n    reset,\n    cancel,\n    get interval() {\n      return intervalUsed;\n    },\n    get runState() {\n      return runState;\n    },\n    get startCountTotal() {\n      return startCountTotal;\n    },\n    get startCount() {\n      return startCount;\n    },\n    set interval(interval: Interval) {\n      const ms = intervalToMs(interval, 0);\n      resultThrow(integerTest(ms, `positive`, `interval`));\n      intervalMs = ms;\n      intervalUsed = interval;\n    },\n    get isDisposed() {\n      return disposed;\n    },\n    get elapsedMs() {\n      return performance.now() - startedAt;\n    },\n  };\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2NA,MAAa,eAAe,CAC1BA,UACAC,UACAC,UAAqC,CAAE,MACtB;CACjB,IAAI,aAAa,aAAa,UAAU,EAAE;AAC1C,aAAY,YAAY,aAAa,YAAY,UAAU,CAAC;CAC5D,MAAM,iBAAiB,QAAQ,kBAAkB;CACjD,MAAM,gBAAgB,QAAQ;CAC9B,MAAM,SAAS,QAAQ;CAEvB,IAAI,WAAW;CACf,IAAIC,YAAoC;CACxC,IAAI,aAAa;CACjB,IAAI,kBAAkB;CACtB,IAAI,YAAY,YAAY,KAAK;CACjC,IAAI,eAAe,YAAY;CAC/B,IAAI,YAAY;CAChB,IAAIC;CAEJ,MAAM,aAAa,MAAM;AACvB,MAAI,wBAA4B;AAChC,aAAW,aAAa,aAAa;AACrC;AACA,eAAa;AACb,cAAY,OAAO;CACpB;CAED,MAAM,WAAW,CAACC,sBAAkC;AAClD,MAAI,eAAe,EACjB,YAAW,2BAA2B,WACpC,gBAAe,WAAW,WAAW,mBAAmB,EAAE;OACrD;AACL;AACA,yBAAsB,kBAAkB;EACzC;MAED,gBAAe,WAAW,WAAW,mBAAmB,WAAW;CAEtE;CAED,MAAM,SAAS,MAAM;AACnB,MAAI,UAAW;AACf,cAAY;AAEZ,MAAI,cAAc,MAAO;AACzB,cAAY;AACZ,cAAY;CACb;CAED,MAAM,OAAO,YAAY;AACvB,MAAI,QAAQ,QACV,aAAY;AAEd,MAAI,cAAc,MAAO;AAEzB,cAAY;AACZ;AACA;EACA,MAAM,iBAAiB,SAAS,YAAY,YAAY,KAAK,GAAG,UAAU;EAC1E,MAAM,eAAe,oBAAoB,UAAW,MAAM,iBAAkB;AAC5E,MAAI,UACF;AAEF,cAAY;AAGZ,MAAI,qBAAwB,OAAO;AACjC,WAAQ;AACR;EACD;AAED,MAAI,UAAW;AAEf,WAAS,KAAK;CACf;CAED,MAAM,QAAQ,MAAM;AAClB,MAAI,SAAU,OAAM,IAAI,OAAO;AAC/B,cAAY;AAEZ,MAAI,0BAA6B;GAE/B,MAAM,SAAS,cAAc,YAAY,YAAY,KAAK,GAAG,UAAU;AACvE,WAAQ,QAAR;IACE,MAAM,SAAS;AACb,aAAQ;AACR;IACD;IACD,MAAM,QAAQ;AACZ,YAAO;AACP;IACD;IACD,MAAM,UAAU;AACd,gBAAW;AACX,aAAQ;AACR;IACD;GAEF;EACF;AAED,MAAI,cAAc,OAAO;AAEvB,gBAAa;AACb,eAAY,YAAY,KAAK;AAC7B,eAAY;AACZ,OAAI,eACF,CAAK,MAAM;OAGX,UAAS,KAAK;EAEjB;CACF;CAED,MAAM,QAAQ,MAAM;AAClB,MAAI,SAAU,OAAM,IAAI,OAAO;AAC/B,cAAY;AACZ,eAAa;AACb,cAAY,OAAO;AAGnB,MAAI,cAAc,MAChB,SAAQ;AAEV,SAAO;CACR;AAED,QAAO;EACL;EACA;EACA;EACA,IAAI,WAAW;AACb,UAAO;EACR;EACD,IAAI,WAAW;AACb,UAAO;EACR;EACD,IAAI,kBAAkB;AACpB,UAAO;EACR;EACD,IAAI,aAAa;AACf,UAAO;EACR;EACD,IAAI,SAASC,YAAoB;GAC/B,MAAM,KAAK,aAAaC,YAAU,EAAE;AACpC,eAAY,YAAY,KAAK,YAAY,UAAU,CAAC;AACpD,gBAAa;AACb,kBAAeA;EAChB;EACD,IAAI,aAAa;AACf,UAAO;EACR;EACD,IAAI,YAAY;AACd,UAAO,YAAY,KAAK,GAAG;EAC5B;CACF;AACF"}