{"version":3,"file":"numbers.js","names":["object: T","apply: (v: number) => number","o: T","data: number[] | readonly number[]","fn?: (relativePos: number) => number","x: number","value: number","index: number","data: readonly number[]","values: readonly (readonly number[])[]","total","array","data: readonly number[] | Float32Array","data: number[] | readonly number[]","weightings: number[] | readonly number[] | ((value: number) => number)","accumulator: number[]","v: number[]","value: number","min","max","v: number","arrayOrLength: number | readonly any[]","amount: number","initial: number","kind: DifferenceKind","value: number","from: number","possibleNumber: unknown","it: Iterable<unknown>","threshold: number","v: number","min: number","max: number","min","max","v: number | (() => number)","interval: number","end?: number","rounding?: number","a: number","b?: number | boolean","roundUp?: boolean","rounder: ((v: number) => number) | undefined","v: number","rangePercent: number","baseValue?: number","v?: number","base: number","value: number","allowedRangeAbsolute: number","startingValueOrBipolar: number | BipolarWrapper","hint: string","amt: number","clamp","b: number","max","min","bipolarValue: number","numberScale","scalarValue: number","scale","inputValue: number","inMin: number","inMax: number","numberScaler","amount: number","v: number","min","max","min: number","max: number","fn: (distance: number) => number","a: number","b: number","interpolate","pos1: number","pos2?: number | Partial<BasicInterpolateOptions>","pos3?: number | Partial<BasicInterpolateOptions>","pos4?: Partial<BasicInterpolateOptions>","amountProcess: undefined | ((v: number) => number)","limits: BasicInterpolateOptions[ 'limits' ]","amount: number","_amt: number","_a: number","_b: number","o: Partial<BasicInterpolateOptions>","a: number","b: number","aValue: number","bValue: number","incrementAmount: number","options?: Partial<BasicInterpolateOptions>","retargetB?: number","retargetA?: number","aRadians: number","bRadians: number","start: number","end: number","steps: number","precision?: number","v: number","data: V","#store","average","count","v?: number","weighter?: (v: number) => number","timeDelta: number","cutoff: number","smoothingFactor: number","value: number","previous: number","smoothingFactor","timestamp?: number","scale","v: number","inMin: number","inMax: number","outMin?: number","outMax?: number","easing?: (v: number) => number","scaler","clamped?: boolean","percentage: number","outMin: number","outMax: number","data: number[] | readonly number[]","opts: NumbersComputeOptions","total","min","max","count","minDefault?: number","maxDefault?: number","min","max","v: number","scale","values: readonly number[]","minForced?: number","maxForced?: number","v: number | (() => number)","t: number | (() => number)","v: number","every: number","logits: number[]"],"sources":["../packages/numbers/src/apply-to-values.ts","../packages/numbers/src/numeric-arrays.ts","../packages/numbers/src/average-weighted.ts","../packages/numbers/src/clamp.ts","../packages/numbers/src/count.ts","../packages/numbers/src/difference.ts","../packages/numbers/src/guard.ts","../packages/numbers/src/filter.ts","../packages/numbers/src/flip.ts","../packages/numbers/src/generate.ts","../packages/numbers/src/round.ts","../packages/numbers/src/is-approx.ts","../packages/numbers/src/bipolar.ts","../packages/numbers/src/wrap.ts","../packages/numbers/src/pi-pi.ts","../packages/numbers/src/interpolate.ts","../packages/numbers/src/linear-space.ts","../packages/numbers/src/util/queue-mutable.ts","../packages/numbers/src/moving-average.ts","../packages/numbers/src/scale.ts","../packages/numbers/src/number-array-compute.ts","../packages/numbers/src/normalise.ts","../packages/numbers/src/proportion.ts","../packages/numbers/src/quantise.ts","../packages/numbers/src/softmax.ts"],"sourcesContent":["/**\n * Apples `fn` to every key of `obj` which is numeric.\n * ```js\n * const o = {\n *  name: 'john',\n *  x: 10,\n *  y: 20\n * };\n * const o2 = applyToValues(o, (v) => v * 2);\n * \n * // Yields: { name: 'john', x: 20, y: 40 }\n * ```\n * @param object \n * @param apply \n * @returns \n */\nexport const applyToValues = <T extends Record<string, any>>(object: T, apply: (v: number) => number): T => {\n  const o: T = { ...object };\n  for (const [ key, value ] of Object.entries(object)) {\n    if (typeof value === `number`) {\n      // Run number through function\n      //eslint-disable-next-line functional/immutable-data\n      (o as any)[ key ] = apply(value);\n    } else {\n      // Copy value\n      //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-unsafe-assignment\n      (o as any)[ key ] = value;\n    }\n  }\n  return o;\n}","/**\n * Applies a function `fn` to the elements of an array, weighting them based on their relative position.\n *\n * ```js\n * // Six items\n * weight([1,1,1,1,1,1], Modulation.gaussian());\n *\n * // Yields:\n * // [0.02, 0.244, 0.85, 0.85, 0.244, 0.02]\n * ```\n *\n * `fn` is expected to map (0..1) => (0..1), such as an easing function. The input to the\n * `fn` is the relative position of an element. Thus the first element will be 0, the middle 0.5 and so on.\n * The output of `fn` is then multiplied by the original value.\n *\n * In the below example (which is also the default if `fn` is not specified), the relative position is\n * how values are weighted:\n *\n * ```js\n * weight([1,1,1,1,1,1], (relativePos) => relativePos);\n * // Yields:\n * // [0, 0.2, 0.4, 0.6, 0.8, 1]\n * ```\n *\n * Throws TypeError if `data` is not an array or for any element not a number.\n * @param data Array of numbers\n * @param fn Returns a weighting based on the given relative position. If unspecified, `(x) => x` is used.\n */\nexport const weight = (\n  data: number[] | readonly number[],\n  fn?: (relativePos: number) => number\n): number[] => {\n  if (!Array.isArray(data)) throw new TypeError(`Param 'data' is expected to be an array. Got type: ${ typeof data }`);\n  const weightingFunction = fn ?? ((x: number) => x);\n  return data.map(\n    (value: number, index: number) => {\n      if (typeof value !== `number`) throw new TypeError(`Param 'data' contains non-number at index: '${ index }'. Type: '${ typeof value }' value: '${ value }'`);\n      const relativePos = index / (data.length - 1);\n      const weightForPosition = weightingFunction(relativePos);\n      if (typeof weightForPosition !== `number`) throw new TypeError(`Weighting function returned type '${ typeof weightForPosition }' rather than number for input: '${ relativePos }'`);\n      const finalResult = value * weightForPosition;\n      //console.log(`finalResult: ${ finalResult.toFixed(2) } rel: ${ relativePos.toFixed(2) } weightForPosition: ${ weightForPosition.toFixed(2) } input: ${ value } index: ${ index }`);\n      return finalResult;\n    }\n  );\n};\n\n/**\n * Returns an array of all valid numbers from `data`\n *\n * @param data\n * @returns\n */\nexport const validNumbers = (data: readonly number[]) =>\n  data.filter((d) => typeof d === `number` && !Number.isNaN(d));\n\n/**\n * Returns the dot product of arbitrary-sized arrays. Assumed they are of the same length.\n * @param values\n * @returns\n */\nexport const dotProduct = (\n  values: readonly (readonly number[])[]\n): number => {\n  let r = 0;\n  const length = values[ 0 ].length;\n\n  for (let index = 0; index < length; index++) {\n    let t = 0;\n    for (const [ p, value ] of values.entries()) {\n      if (p === 0) t = value[ index ];\n      else {\n        t *= value[ index ];\n      }\n    }\n    r += t;\n  }\n  return r;\n};\n\n/**\n * Calculates the average of all numbers in an array.\n * Array items which aren't a valid number are ignored and do not factor into averaging.\n *\n * Use {@link numberArrayCompute} if you want min, max and total as well.\n *\n * @example\n * ```js\n * // Average of a list\n * const avg = Numbers.average([1, 1.4, 0.9, 0.1]);\n *\n * // Average of a variable\n * const data = [100,200];\n * Numbers.average(data);\n * ```\n *\n * @see {@link averageWeighted} To weight items based on position in array\n * @param data Data to average.\n * @returns Average of array\n */\nexport const average = (data: readonly number[]): number => {\n  // ✔ UNIT TESTED\n  if (data === undefined) throw new Error(`data parameter is undefined`);\n  const valid = validNumbers(data);\n  const total = valid.reduce((accumulator, v) => accumulator + v, 0);\n  return total / valid.length;\n};\n\n/**\n * Returns the minimum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * Numbers.min([10, 20, 0]); // Yields 0\n * ```\n * @param data\n * @returns Minimum number\n */\nexport const min = (data: readonly number[]): number =>\n  Math.min(...validNumbers(data));\n\n/**\n * Returns the index of the largest value.\n * ```js\n * const v = [ 10, 40, 5 ];\n * Numbers.maxIndex(v); // Yields 1\n * ```\n * @param data Array of numbers\n * @returns Index of largest value\n */\nexport const maxIndex = (data: readonly number[]): number =>\n\n  data.reduce(\n    (bestIndex, value, index, array) =>\n      value > array[ bestIndex ] ? index : bestIndex,\n    0\n  );\n\n/**\n * Returns the index of the smallest value.\n *\n * ```js\n * const v = [ 10, 40, 5 ];\n * Numbers.minIndex(v); // Yields 2\n * ```\n * @param data Array of numbers\n * @returns Index of smallest value\n */\nexport const minIndex = (...data: readonly number[]): number =>\n\n  data.reduce(\n    (bestIndex, value, index, array) =>\n      value < array[ bestIndex ] ? index : bestIndex,\n    0\n  );\n\n/**\n * Returns the maximum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * Numbers.max(100, 200, 50); // 200\n * ```\n * @param data List of numbers\n * @returns Maximum number\n */\nexport const max = (data: readonly number[]): number =>\n  Math.max(...validNumbers(data));\n\n/**\n * Returns the total of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * Numbers.total([1, 2, 3]); // 6\n * ```\n * @param data Array of numbers\n * @returns Total\n */\nexport const total = (data: readonly number[]): number =>\n  data.reduce((previous, current) => {\n    if (typeof current !== `number`) return previous;\n    if (Number.isNaN(current)) return previous;\n    if (!Number.isFinite(current)) return previous;\n    return previous + current;\n  }, 0);\n\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * Numbers.maxFast([ 10, 0, 4 ]); // 10\n * ```\n * @param data\n * @returns Maximum\n */\nexport const maxFast = (data: readonly number[] | Float32Array): number => {\n  let m = Number.MIN_SAFE_INTEGER;\n  for (const datum of data) {\n    m = Math.max(m, datum);\n  }\n  return m;\n};\n\n/**\n * Returns the total of `data` without pre-filtering for speed.\n *\n * For most uses, {@link total} should suffice.\n *\n * ```js\n * Numbers.totalFast([ 10, 0, 4 ]); // 14\n * ```\n * @param data\n * @returns Maximum\n */\nexport const totalFast = (data: readonly number[] | Float32Array): number => {\n  let m = 0;\n  for (const datum of data) {\n    m += datum;\n  }\n  return m;\n};\n\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * Numbers.minFast([ 10, 0, 100 ]); // 0\n * ```\n * @param data\n * @returns Maximum\n */\nexport const minFast = (data: readonly number[] | Float32Array): number => {\n  let m = Number.MIN_SAFE_INTEGER;\n  for (const datum of data) {\n    m = Math.min(m, datum);\n  }\n  return m;\n};\n","import { zip } from '@ixfx/arrays';\nimport { weight } from './numeric-arrays.js';\n/**\n * Computes an average of an array with a set of weights applied.\n *\n * Weights can be provided as an array, expected to be on 0..1 scale, with indexes\n * matched up to input data. Ie. data at index 2 will be weighed by index 2 in the weightings array.\n *\n * ```js\n * // All items weighted evenly\n * averageWeighted([1,2,3], [1,1,1]); // 2\n *\n * // First item has full weight, second half, third quarter\n * averageWeighted([1,2,3], [1, 0.5, 0.25]); // 1.57\n *\n * // With reversed weighting of [0.25,0.5,1] value is 2.42\n * ```\n *\n * A function can alternatively be provided to compute the weighting based on array index, via {@link weight}.\n *\n * ```js\n * averageWeighted[1,2,3], Random.gaussian()); // 2.0\n * ```\n *\n * This is the same as:\n *\n * ```js\n * const data = [1,2,3];\n * const w = weight(data, Random.gaussian());\n * const avg = averageWeighted(data, w); // 2.0\n * ```\n * @param data Data to average\n * @param weightings Array of weightings that match up to data array, or an easing function\n * @see {@link average} Compute averages without weighting.\n */\nexport const averageWeighted = (\n  data: number[] | readonly number[],\n  weightings: number[] | readonly number[] | ((value: number) => number)\n): number => {\n  if (typeof weightings === `function`) weightings = weight(data, weightings);\n  const ww = zip(data, weightings);\n  const [ totalV, totalW ] = ww.reduce(\n    (accumulator: number[], v: number[]) => [ accumulator[ 0 ] + v[ 0 ] * v[ 1 ], accumulator[ 1 ] + v[ 1 ] ],\n    [ 0, 0 ]\n  );\n  return totalV / totalW;\n};","/**\n * Clamps a value between min and max (both inclusive)\n * Defaults to a 0-1 range, useful for percentages.\n *\n * @example Usage\n * ```js\n * // 0.5 - just fine, within default of 0 to 1\n * clamp(0.5);\n * // 1 - above default max of 1\n * clamp(1.5);\n * // 0 - below range\n * clamp(-50, 0, 100);\n * // 50 - within range\n * clamp(50, 0, 50);\n * ```\n *\n * For clamping integer ranges, consider {@link clampIndex }\n * For clamping `{ x, y }` points, consider {@link @ixfx/geometry.Points.clamp}.\n * For clamping bipolar values: {@link Bipolar.clamp}\n * @param value Value to clamp\n * @param min value (inclusive)\n * @param max value (inclusive)\n * @returns Clamped value\n */\nexport const clamp = (value: number, min = 0, max = 1) => {\n  // ✔ UNIT TESTED\n  if (Number.isNaN(value)) throw new Error(`Param 'value' is NaN`);\n  if (Number.isNaN(min)) throw new Error(`Param 'min' is NaN`);\n  if (Number.isNaN(max)) throw new Error(`Param 'max' is NaN`);\n\n  if (value < min) return min;\n  if (value > max) return max;\n  return value;\n};\n\n/**\n * Returns a function that clamps values.\n * \n * ```js\n * const c = clamper(0,100);\n * c(50);   // 50\n * c(101); // 100\n * c(-5);  // 0\n * ```\n * @param min Minimum value. Default: 0\n * @param max Maximum value. Default: 1\n */\nexport const clamper = (min = 0, max = 1) => {\n  if (Number.isNaN(min)) throw new Error(`Param 'min' is NaN`);\n  if (Number.isNaN(max)) throw new Error(`Param 'max' is NaN`);\n  return (v: number) => {\n    if (v > max) return max;\n    if (v < min) return min;\n    return v;\n  }\n}\n\n/**\n * Clamps integer `v` between 0 (inclusive) and array length or length (exclusive).\n * Returns value then will always be at least zero, and a valid array index.\n *\n * @example Usage\n * ```js\n * // Array of length 4\n * const myArray = [`a`, `b`, `c`, `d`];\n * clampIndex(0, myArray);    // 0\n * clampIndex(5, 3); // 2\n * ```\n *\n * Throws an error if `v` is not an integer.\n *\n * For some data it makes sense that data might 'wrap around' if it exceeds the\n * range. For example rotation angle. Consider using {@link wrap} for this.\n *\n * @param v Value to clamp (must be an interger)\n * @param arrayOrLength Array, or length of bounds (must be an integer)\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\n */\nexport const clampIndex = (\n  v: number,\n  arrayOrLength: number | readonly any[]\n): number => {\n  // ✔ UNIT TESTED\n  if (!Number.isInteger(v)) {\n    throw new TypeError(`v parameter must be an integer (${ v })`);\n  }\n  const length = Array.isArray(arrayOrLength)\n    ? arrayOrLength.length\n    : (arrayOrLength as number);\n\n  if (!Number.isInteger(length)) {\n    throw new TypeError(\n      `length parameter must be an integer (${ length }, ${ typeof length })`\n    );\n  }\n  v = Math.round(v);\n  if (v < 0) return 0;\n  if (v >= length) return length - 1;\n  return v;\n};\n\n\n/**\n * Returns the largest value, ignoring the sign of numbers\n * \n * ```js\n * maxAbs(1, 5);    // 5\n * maxAbs(-10, 5);  // -10 (since sign is ignored)\n * ```\n * @param values \n * @returns \n */\nexport const maxAbs = (...values: number[]) => {\n  let index = -1;\n  let maxA = Number.MIN_SAFE_INTEGER;\n  for (let index_ = 0; index_ < values.length; index_++) {\n    const vA = Math.abs(values[ index_ ]);\n    if (vA > maxA) {\n      maxA = vA;\n      index = index_;\n    }\n  }\n  return values[ index ];\n}","import { integerTest, resultThrow } from \"@ixfx/guards\"\n\n/**\n * Yields `amount` integers, counting by one from zero. If a negative amount is used,\n * count decreases. If `offset` is provided, this is added to the return result.\n * @example\n * ```js\n * const a = [...count(5)]; // Yields five numbers: [0,1,2,3,4]\n * const b = [...count(-5)]; // Yields five numbers: [0,-1,-2,-3,-4]\n * for (const v of count(5, 5)) {\n *  // Yields: 5, 6, 7, 8, 9\n * }\n * const c = [...count(5,1)]; // Yields [1,2,3,4,5]\n * ```\n *\n * @example Used with forEach\n * ```js\n * // Prints `Hi` 5x\n * forEach(count(5), () => // do something);\n * ```\n *\n * If you want to accumulate return values, consider using Flow.repeat.\n *\n * @example Run some code every 100ms, 10 times:\n * ```js\n * import { interval } from '@ixfx/flow.js'\n * import { count } from '@ixfx/numbers.js'\n * const counter = count(10);\n * for await (const v of interval(counter, { fixedIntervalMs: 100 })) {\n *  // Do something\n * }\n * ```\n * @param amount Number of integers to yield\n * @param offset Added to result\n */\nexport function* count(amount: number, offset = 0): Generator<number, void, void> {\n  resultThrow(\n    integerTest(amount, ``, `amount`),\n    integerTest(offset, ``, `offset`)\n  )\n  if (amount === 0) return;\n\n  let index = 0;\n  do {\n    yield (amount < 0 ? -index + offset : index + offset);\n  } while (index++ < Math.abs(amount) - 1);\n};","export type DifferenceKind = `numerical` | `relative` | `relativeSigned` | `absolute`\n\n/**\n * Returns the difference from the `initial` value. Defaults to absolute difference.\n * ```js\n * const rel = differenceFromFixed(100);\n * rel(100); // 0\n * rel(150); // 50\n * rel(50);  // 50\n * ```\n *\n * 'numerical' gives sign:\n * ```js\n * const rel = differenceFromFixed(100, `numerical`);\n * rel(100); // 0\n * rel(150); // 50\n * rel(50); // -50\n * ```\n * \n * 'relative' gives proportion to initial\n * ```js\n * const rel = differenceFromFixed(100, `relative`);\n * rel(100); // 0\n * rel(150); // 0.5\n * rel(10);  // 0.90\n * ```\n * \n * Using 'relativeSigned', we get negative relative result\n * when value is below the initial value.\n * \n * Use {@link differenceFromLast} to compare against the last value,\n * rather than the same fixed value.\n * @param {number} initial Value to compare against\n * @returns Difference from initial value\n */\nexport const differenceFromFixed = (initial: number, kind: DifferenceKind = `absolute`) => (value: number) => differenceFrom(kind, value, initial);\n\n\n/**\n * Returns a function which yields difference compared to last value.\n * \n * If no initial value is provided, the first difference will be returned as 0.\n * \n * Difference can be returned in various formats:\n * * 'absolute': numerical difference, without sign\n * * 'numerical': numerical difference, with sign, so you can see if difference is higher or lower\n * * 'relative': difference divided by last value, giving a proportional difference. Unsigned.\n * * 'relativeSigned': as above, but with sign\n * \n * Use {@link differenceFromFixed} to compare against a fixed value instead of the last value.\n * \n * ```js\n * let d = differenceFromLast(`absolute`);\n * d(10); // 0\n * d(11); // 1\n * d(10); // 1\n * ```\n * \n * ```js\n * let d = differenceFromLast(`numerical`);\n * d(10); // 0\n * d(11); // 1\n * d(10); // -1\n * ```\n * \n * ```js\n * let d = differenceFromLast(`relative`);\n * d(10); // 0\n * d(11); // 0.1\n * d(10); // 0.1\n * ```\n * ```js\n * let d = differenceFromLast(`relativeSigned`);\n * d(10); // 0\n * d(11); // 0.1\n * d(10); // -0.1\n * ```\n * \n * An initial value can be provided, eg:\n * ```js\n * let d = differenceFromLast(`absolute`, 10);\n * d(11); // 1\n * ```\n * @param kind Kind of output value\n * @param initialValue Optional initial value \n * @returns \n */\nexport const differenceFromLast = (kind: DifferenceKind = `absolute`, initialValue = Number.NaN): (v: number) => number => {\n  let lastValue = initialValue;\n  return (value: number) => {\n    const x = differenceFrom(kind, value, lastValue);\n    lastValue = value;\n    return x;\n  }\n}\n//   const compute = (v: number) => {\n//     if (Number.isNaN(lastValue)) {\n//       lastValue = v;\n//       return 0;\n//     }\n//     const d = v - lastValue;\n//     let r = 0;\n//     if (kind === `absolute`) {\n//       r = Math.abs(d);\n//     } else if (kind === `numerical`) {\n//       r = d;\n//     } else if (kind === `relative`) {\n//       r = Math.abs(d / lastValue);\n//     } else if (kind === `relativeSigned`) {\n//       r = d / lastValue;\n//     } else throw new TypeError(`Unknown kind: '${ kind }' Expected: 'absolute', 'relative', 'relativeSigned' or 'numerical'`);\n//     lastValue = v;\n//     return r;\n//   }\n//   return compute;\n// }\n\nconst differenceFrom = (kind: DifferenceKind = `absolute`, value: number, from: number) => {\n  if (Number.isNaN(from)) {\n    return 0;\n  }\n  const d = value - from;\n  let r = 0;\n  if (kind === `absolute`) {\n    r = Math.abs(d);\n  } else if (kind === `numerical`) {\n    r = d;\n  } else if (kind === `relative`) {\n    r = Math.abs(d / from);\n  } else if (kind === `relativeSigned`) {\n    r = d / from;\n  } else throw new TypeError(`Unknown kind: '${ kind }' Expected: 'absolute', 'relative', 'relativeSigned' or 'numerical'`);\n  return r;\n}","/**\n * Returns true if `possibleNumber` is a number and not NaN\n * @param possibleNumber\n * @returns\n */\nexport const isValid = (possibleNumber: unknown) => {\n  if (typeof possibleNumber !== `number`) return false;\n  if (Number.isNaN(possibleNumber)) return false;\n  return true;\n};","import { isValid } from './guard.js';\n/**\n * Filters an iterator of values, only yielding\n * those that are valid numbers\n *\n * ```js\n * const data = [true, 10, '5', { x: 5 }];\n * for (const n of Numbers.filterIterable(data)) {\n *  // 10\n * }\n * ```\n * @param it\n */\nexport function* filterIterable(it: Iterable<unknown>) {\n  for (const v of it) {\n    if (isValid(v)) yield v;\n  }\n}\n\n/**\n * Returns a function that yields _true_ if a value\n * is at least `threshold`\n * ```js\n * const t = thresholdAtLeast(50);\n * t(50); // true\n * t(0);  // false\n * t(55); // true\n * ```\n * @param threshold \n * @returns \n */\nexport const thresholdAtLeast = (threshold: number) => {\n  return (v: number) => {\n    return v >= threshold;\n  };\n};\n\n/**\n * Returns a function that yields _true_\n * if a number is at least _min_ and no greater than _max_\n * \n * ```js\n * const t = rangeInclusive(50, 100);\n * t(40); // false\n * t(50); // true\n * t(60); // true\n * t(100); // true\n * t(101);  // false\n * ```\n * @param min \n * @param max \n * @returns \n */\nexport const rangeInclusive = (min: number, max: number) => {\n  return (v: number) => {\n    return v >= min && v <= max;\n  };\n};","import { numberTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Flips a percentage-scale number: `1 - v`.\n *\n * The utility of this function is that it sanity-checks\n * that `v` is in 0..1 scale.\n *\n * ```js\n * flip(1);   // 0\n * flip(0.5); // 0.5\n * flip(0);   // 1\n * ```\n * @param v\n * @returns\n */\nexport const flip = (v: number | (() => number)) => {\n  if (typeof v === `function`) v = v();\n  resultThrow(numberTest(v, `percentage`, `v`));\n  return 1 - v;\n};\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Generates a range of numbers, starting from `start` and counting by `interval`.\n * If `end` is provided, generator stops when reached.\n *\n * Unlike {@link numericRange}, numbers might contain rounding errors\n *\n * ```js\n * for (const c of numericRangeRaw(10, 100)) {\n *  // 100, 110, 120 ...\n * }\n * ```\n * @param interval Interval between numbers\n * @param start Start\n * @param end End (if undefined, range never ends)\n */\nexport const numericRangeRaw = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false\n) {\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\n  if (typeof end === `undefined`) end = Number.MAX_SAFE_INTEGER;\n  let v = start;\n  do {\n    while (v < end) {\n      yield v;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n/**\n * Generates a range of numbers, with a given interval.\n *\n * @example For-loop\n * ```\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\n * for (v of loopForever) {\n *  console.log(v);\n * }\n * ```\n *\n * @example If you want more control over when/where incrementing happens...\n * ```js\n * let percent = numericRange(0.1, 0, 1);\n *\n * let percentResult = percent.next().value;\n * ```\n *\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\n * number.\n *\n * @param interval Interval between numbers\n * @param start Start. Defaults to 0\n * @param end End (if undefined, range never ends)\n * @param repeating Range loops from start indefinately. Default _false_\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\n */\nexport const numericRange = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false,\n  rounding?: number\n) {\n  resultThrow(numberTest(interval, `nonZero`));\n\n  const negativeInterval = interval < 0;\n  if (end === undefined) {\n    /* no op */\n  } else {\n    if (negativeInterval && start < end) {\n      throw new Error(\n        `Interval of ${ interval.toString() } will never go from ${ start.toString() } to ${ end.toString() }`\n      );\n    }\n    if (!negativeInterval && start > end) {\n      throw new Error(\n        `Interval of ${ interval.toString() } will never go from ${ start.toString() } to ${ end.toString() }`\n      );\n    }\n  }\n\n  rounding = rounding ?? 1000;\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  else end *= rounding;\n  interval = interval * rounding;\n\n  do {\n    let v = start * rounding;\n    while ((!negativeInterval && v <= end) || (negativeInterval && v >= end)) {\n      yield v / rounding;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n\n\n/**\n * Yields numeric range between 0.0-1.0.\n *\n * ```\n * // Yields: [0, 0.2, 0.4, 0.6, 0.8, 1]\n * const a = [...numericPercent(0.2)];\n *\n * // Repeating flag set to true:\n * for (const v of numericPercent(0.2, true)) {\n *  // Infinite loop. V loops back to 0 after hitting 1\n * }\n * ```\n *\n * If `repeating` is true, it loops back to 0 after reaching 1\n * @param interval Interval (default: 0.01, ie. 1%)\n * @param repeating Whether generator should loop (default: false)\n * @param start Start (default: 0)\n * @param end End (default: 1)\n * @returns\n */\nexport const numericPercent = function (\n  interval = 0.01,\n  repeating = false,\n  start = 0,\n  end = 1\n) {\n  resultThrow(\n    numberTest(interval, `percentage`, `interval`),\n    numberTest(start, `percentage`, `start`),\n    numberTest(end, `percentage`, `end`)\n  );\n  return numericRange(interval, start, end, repeating);\n};","import { integerTest, resultThrow } from \"@ixfx/guards\";\n\nexport function round(decimalPlaces: number, v: number, roundUp?: boolean): number;\nexport function round(decimalPlaces: number, roundUp?: boolean): (v: number) => number;\n\n/**\n * Rounds a number.\n *\n * If one parameter is given, it's the decimal places,\n * and a rounding function is returned:\n * ```js\n * const r = round(2);\n * r(10.12355); // 10.12\n * ```\n *\n * If two parameters are given, the first is decimal places,\n * the second the value to round.\n * ```js\n * round(2, 10.12355); // 10.12\n * ```\n * @param decimalPlaces\n * @returns\n */\nexport function round(a: number, b?: number | boolean, roundUp?: boolean) {\n  resultThrow(integerTest(a, `positive`, `decimalPlaces`));\n\n  const up = (typeof b === `boolean`) ? b : (roundUp ?? false)\n  let rounder: ((v: number) => number) | undefined;\n  if (a === 0) {\n    rounder = Math.round;\n  } else {\n    const p = Math.pow(10, a);\n    if (up) {\n      rounder = (v: number) => Math.ceil(v * p) / p;\n    } else {\n      rounder = (v: number) => Math.floor(v * p) / p;\n    }\n  }\n  if (typeof b === `number`) return rounder(b);\n  return rounder;\n}\n\n","import { numberTest, resultThrow, type Result } from \"@ixfx/guards\";\nimport { round } from \"./round.js\";\n\n/**\n * Returns a function that checks if a value is within range of a base value\n * ```js\n * const tenPercent = isApprox(0.1);\n * // Check if 101 is within 10% range of 100\n * tenPercent(100, 101); \n * ```\n * @param rangePercent \n */\nexport function isApprox(\n  rangePercent: number\n): (baseValue: number, value: number) => boolean;\n\n/**\n * Returns a function to check if a value is within range of a base value\n * ```js\n * const close = isApprox(0.1, 100);\n * // Check if 101 is within 10% range of 100\n * close(101);\n * ```\n * @param rangePercent \n * @param baseValue \n */\nexport function isApprox(\n  rangePercent: number,\n  baseValue: number,\n): (value: number) => boolean;\n\n/**\n * Returns _true/false_ if `value` is within `rangePercent` of `baseValue`.\n * \n * ```js\n * isApprox(0.1, 100, 101);\n * ```\n * @param rangePercent \n * @param baseValue \n * @param value \n */\nexport function isApprox(\n  rangePercent: number,\n  baseValue: number,\n  value: number\n): boolean;\n\n\n/**\n * Checks if a value is within range of a base value\n * \n * ```js\n * // Check if 101 is within 10% of 100\n * isApprox(0.1, 100, 101);\n * \n * // Gets a function to compare some value of 10% range to 100\n * const c = isApprox(0.1,100);\n * c(101);\n * \n * // Gets a function to compare some base value and value to 10% range\n * const c = isApprox(0.1);\n * c(100, 101);\n * ```\n * \n * Throws an error if range or base values are NaN.\n * If value being checked is NaN or infinity, _false_ is returned.\n * @param rangePercent \n * @param baseValue \n * @param v \n * @returns \n */\nexport function isApprox(\n  rangePercent: number,\n  baseValue?: number,\n  v?: number\n) {\n  resultThrow(numberTest(rangePercent, `percentage`, `rangePercent`));\n\n  // Round percentages to avoid floating point nonsense\n  const range = Math.floor(rangePercent * 100);\n  const test = (base: number, value: number): boolean => {\n    try {\n      if (typeof value !== `number`) return false;\n      if (Number.isNaN(value)) return false;\n      if (!Number.isFinite(value)) return false;\n\n      // Round value\n      const diff = Math.abs(value - base)\n      const relative = base === 0 ? Math.floor(diff * 100) : Math.floor((diff / base) * 100);\n      //console.log(`v: ${ value } base: ${ base } rel: ${ relative } range: ${ range } diff: ${ diff }`);\n      return relative <= range;\n    } catch {\n      return false;\n    }\n  };\n\n  if (baseValue === undefined) return test;\n  resultThrow(numberTest(baseValue, ``, `baseValue`));\n  if (v === undefined) {\n    return (value: number) => test(baseValue, value);\n  } else {\n    return test(baseValue, v);\n  }\n}\n\n// export const isCloseTo = (a: number, b: number, precision = 3):Result<number,string> => {\n//   const aa = a.toPrecision(precision);\n//   const bb = b.toPrecision(precision);\n//   if (aa !== bb) return [ false, `A is not close enough to B. A: ${ a } B: ${ b } Precision: ${ precision }` ];\n//   else return [ true ];\n// }\n\n/**\n * Yields a function that checks if a value is close to any target value\n * ```js\n * const c = isCloseToAny(1, 10, 20, 30, 40);\n * c(11); // True - within 1 range of 10\n * c(19); // True - within 1 range of 20\n * c(0);  // False\n * ```\n * \n * Returned function accepts multiple values, returning\n * _true_ if any of them are within range\n * ```js\n * c(0, 1, 11); // Would return true based on 11\n * ```\n * @param allowedRangeAbsolute \n * @param targets \n * @returns \n */\nexport const isCloseToAny = (allowedRangeAbsolute: number, ...targets: number[]) => {\n  const targetsMin = targets.map(t => t - allowedRangeAbsolute);\n  const targetsMax = targets.map(t => t + allowedRangeAbsolute);\n\n  return (...values: number[]) => {\n    for (const v of values) {\n      for (let index = 0; index < targets.length; index++) {\n        if (v >= targetsMin[ index ] && v <= targetsMax[ index ]) return true;\n      }\n    }\n    return false;\n  }\n}","//import { floatSource,type RandomOptions, type RandomSource } from '@ixfx/random';\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport { interpolate, scaler as numberScaler, scale as numberScale } from '@ixfx/numbers';\nimport type { BipolarWrapper } from './types.js';\n\n/**\n * Wrapper for bipolar-based values. Immutable.\n * All functions will clamp to keep it in legal range.\n * \n * ```js\n * let v = immutable(); // Starts with 0 by default\n * v = v.add(0.1);      // v.value is 0.1\n * v = v.inverse();     // v.value is -0.1\n * v = v.multiply(0.2); // v.value is -0.02\n * \n * v = immutable(1);\n * v = v.towardZero(0.1); // 0.9\n * v = v.interpolate(0.1, 1);\n * ```\n * \n * Wrapped values can be coerced into number:\n * ```js\n * const v = immutable(1);\n * const x = +v+10;\n * // x = 11\n * ```\n * @param startingValueOrBipolar Initial numeric value or BipolarWrapper instance\n * @returns \n */\nexport const immutable = (startingValueOrBipolar: number | BipolarWrapper = 0): BipolarWrapper => {\n  if (typeof startingValueOrBipolar === `undefined`) throw new Error(`Start value is undefined`)\n  const startingValue = (typeof startingValueOrBipolar === `number`) ? startingValueOrBipolar : startingValueOrBipolar.value;\n\n  if (startingValue > 1) throw new Error(`Start value cannot be larger than 1`);\n  if (startingValue < -1) throw new Error(`Start value cannot be smaller than -1`);\n  if (Number.isNaN(startingValue)) throw new Error(`Start value is NaN`);\n\n  const v = startingValue;\n  return {\n    [ Symbol.toPrimitive ](hint: string) {\n      if (hint === `number`) return v;\n      else if (hint === `string`) return v.toString();\n      return true;\n    },\n    value: v,\n    towardZero: (amt: number) => {\n      return immutable(towardZero(v, amt));\n    },\n    add: (amt: number) => {\n      return immutable(clamp(v + amt));\n    },\n    multiply: (amt: number) => {\n      return immutable(clamp(v * amt));\n    },\n    inverse: () => {\n      return immutable(-v);\n    },\n    interpolate: (amt: number, b: number) => {\n      return immutable(clamp(interpolate(amt, v, b)));\n    },\n    asScalar: (max = 1, min = 0) => {\n      return toScalar(v, max, min);\n    }\n  }\n}\n\n/**\n * Converts bipolar value to a scalar. That is, converts from\n * -1..1 range to 0..1.\n * \n * ```js\n * Bipolar.toScalar(-1); // 0.0\n * Bipolar.toScalar( 0); // 0.5\n * Bipolar.toScalar( 1); // 1.0\n * ```\n * \n * Range can be changed:\n * ```js\n * Bipolar.toScalar(0, 100); // Uses 0..100 scale, so output is 50\n * Bipolar.toScalar(0, 100, 50); // Uses 50..1000 scale, so output is 75\n * ```\n * \n * Throws an error if `bipolarValue` is not a number or NaN\n * @param bipolarValue Value to convert to scalar\n * @returns Scalar value on 0..1 range.\n */\nexport const toScalar = (bipolarValue: number, max = 1, min = 0) => {\n  if (typeof bipolarValue !== `number`) throw new Error(`Expected v to be a number. Got: ${ typeof bipolarValue }`);\n  if (Number.isNaN(bipolarValue)) throw new Error(`Parameter is NaN`);\n  return numberScale(bipolarValue, -1, 1, min, max);\n}\n\n/**\n * Makes a scalar into a bipolar value.\n * \n * That is, input range is 0..1, output range is -1...1\n *\n * ```js\n * Bipolar.fromScalar(1);   // 1\n * Bipolar.fromScalar(0);   // -1\n * Bipolar.fromScalar(0.5); // 0\n * ```\n * \n * Throws an error if `scalarValue` is outside 0..1 scale.\n * @param scalarValue Scalar value to convert\n * @returns Bipolar value on -1..1 scale\n */\nexport const fromScalar = (scalarValue: number) => {\n  resultThrow(numberTest(scalarValue, `percentage`, `v`));\n  return (scalarValue * 2) - 1;\n};\n\n/**\n * Scale & clamp value to bipolar range (-1..1).\n * ```js\n * // Scale 100 on 0..100 scale\n * Bipolar.scale(100, 0, 100); // 1\n * Bipolar.scale(50, 0, 100);  // 0\n * Bipolar.scale(0, 0, 100);   // -1\n * ```\n * \n * Return value is clamped.\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scale = (inputValue: number, inMin: number, inMax: number) => {\n  return clamp(numberScaler(inMin, inMax, -1, 1)(inputValue));\n}\n\n/**\n * Scale a number to bipolar range (-1..1). Not clamped, so we might exceed range.\n * \n * ```js\n * // Scale 100 on 0..100 scale\n * Bipolar.scaleUnclamped(100, 0, 100); // 1\n * Bipolar.scaleUnclamped(50, 0, 100);  // 0\n * Bipolar.scaleUnclamped(0, 0, 100);   // -1\n * ```\n * \n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scaleUnclamped = (inputValue: number, inMin: number, inMax: number) => {\n  return numberScaler(inMin, inMax, -1, 1)(inputValue);\n}\n\n\n/**\n * Clamp a bipolar value\n * ```js\n * Bipolar.clamp(-1);   // -1\n * Bipolar.clamp(-1.1); // -1\n * ```\n * \n * Throws an error if `bipolarValue` is not a number or NaN.\n * @param bipolarValue Value to clamp\n * @returns Clamped value on -1..1 scale\n */\nexport const clamp = (bipolarValue: number): number => {\n  if (typeof bipolarValue !== `number`) throw new Error(`Param 'bipolarValue' must be a number. Got: ${ typeof bipolarValue }`);\n  if (Number.isNaN(bipolarValue)) throw new Error(`Param 'bipolarValue' is NaN`);\n  if (bipolarValue > 1) return 1;\n  if (bipolarValue < -1) return -1;\n  return bipolarValue;\n}\n\n/**\n * Pushes a bipolar value toward zero by `amount`.\n * Return value is clamped on bipolar range of -1..1\n * \n * ```js\n * Bipolar.towardZero(-1, 0.1); // -0.9\n * Bipolar.towardZero( 1, 0.1); //  0.9\n * Bipolar.towardZero( 0, 0.1); //  0.0\n * Bipolar.towardZero( 1, 1.1); //  0.0\n * ```\n * \n * If `amount` is greater than 1, 0 is returned.\n * Throws an error if `bipolarValue` or `amount` are not numbers.\n * Throws an error if `amount` is below zero.\n * @param bipolarValue Bipolar value to nudge toward zero\n * @param amount Amount to nudge by\n * @returns Bipolar value -1...1\n */\nexport const towardZero = (bipolarValue: number, amount: number): number => {\n  if (typeof bipolarValue !== `number`) throw new Error(`Parameter 'v' must be a number. Got: ${ typeof bipolarValue }`);\n  if (typeof amount !== `number`) throw new Error(`Parameter 'amt' must be a number. Got: ${ typeof amount }`);\n  if (amount < 0) throw new Error(`Parameter 'amt' must be positive`);\n  if (bipolarValue < 0) {\n    bipolarValue += amount;\n    if (bipolarValue > 0) bipolarValue = 0;\n  } else if (bipolarValue > 0) {\n    bipolarValue -= amount;\n    if (bipolarValue < 0) bipolarValue = 0;\n  }\n  return bipolarValue;\n}","/* eslint-disable unicorn/prevent-abbreviations */\nimport { numberTest, integerTest, resultThrow } from '@ixfx/guards';\n\n/**\n * Wraps an integer number within a specified range, defaulting to degrees (0-360). Use {@link wrap} for floating-point wrapping.\n *\n * This is useful for calculations involving degree angles and hue, which wrap from 0-360.\n * Eg: to add 200 to 200, we don't want 400, but 40.\n *\n * ```js\n * const v = wrapInteger(200+200, 0, 360); // 40\n * ```\n *\n * Or if we minus 100 from 10, we don't want -90 but 270\n * ```js\n * const v = wrapInteger(10-100, 0, 360); // 270\n * ```\n *\n * `wrapInteger` uses 0-360 as a default range, so both of these\n * examples could just as well be:\n *\n * ```js\n * wrapInteger(200+200);  // 40\n * wrapInteger(10-100);  // 270\n * ```\n *\n * Non-zero starting points can be used. A range of 20-70:\n * ```js\n * const v = wrapInteger(-20, 20, 70); // 50\n * ```\n *\n * Note that the minimum value is inclusive, while the maximum is _exclusive_.\n * So with the default range of 0-360, 360 is never reached:\n *\n * ```js\n * wrapInteger(360); // 0\n * wrapInteger(361); // 1\n * ```\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * @param v Value to wrap\n * @param min Integer minimum of range (default: 0). Inclusive\n * @param max Integer maximum of range (default: 360). Exlusive\n * @returns\n */\nexport const wrapInteger = (v: number, min = 0, max = 360) => {\n  resultThrow(\n    integerTest(v, undefined, `v`),\n    integerTest(min, undefined, `min`),\n    integerTest(max, undefined, `max`)\n  );\n\n  if (v === min) return min;\n  if (v === max) return min; // Wraps\n  if (v > 0 && v < min) v += min;\n\n  v -= min;\n  max -= min;\n  v = v % max;\n\n  if (v < 0) v = max - Math.abs(v) + min;\n  return v + min;\n};\n\n/**\n * Wraps floating point numbers to be within a range (default: 0..1). Use {@link wrapInteger} if you want to wrap integer values.\n *\n * This logic makes sense for some things like rotation angle.\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * ```js\n * wrap(1.2);   // 0.2\n * wrap(2);     // 1.0\n * wrap(-0.2); // 0.8\n * ```\n *\n * A range can be provided too:\n * ```js\n * wrap(30, 20, 50);  \t // 30\n * wrap(60, 20, 50);    //  30\n * ```\n * @param v\n * @param min\n * @param max\n * @returns\n */\nexport const wrap = (v: number, min = 0, max = 1) => {\n  resultThrow(\n    numberTest(v, ``, `min`),\n    numberTest(min, ``, `min`),\n    numberTest(max, ``, `max`)\n  );\n  if (v === min) return min;\n  if (v === max) return min; // Wraps\n\n  while (v <= min || v >= max) {\n    if (v === max) break;\n    if (v === min) break;\n    if (v > max) {\n      v = min + (v - max);\n    } else if (v < min) {\n      v = max - (min - v);\n    }\n  }\n  return v;\n};\n\n/**\n * Performs a calculation within a wrapping number range. This is a lower-level function.\n * See also: {@link wrapInteger} for simple wrapping within a range.\n *\n * `min` and `max` define the start and end of the valid range, inclusive. Eg for hue degrees it'd be 0, 360.\n * `a` and `b` is the range you want to work in.\n *\n * For example, let's say you want to get the middle point between a hue of 30 and a hue of 330 (ie warmer colours):\n * ```js\n * wrapRange(0,360, (distance) => {\n *  // for a:0 and b:330, distance would be 90 from 30 degrees to 330 (via zero)\n *  return distance * 0.5; // eg return middle point\n * }, 30, 330);\n * ```\n *\n * The return value of the callback should be in the range of 0-distance. `wrapRange` will subsequently\n * conform it to the `min` and `max` range before it's returned to the caller.\n *\n * @param a Output start (eg. 60)\n * @param b Output end (eg 300)\n * @param min Range start (eg 0)\n * @param max Range end (eg 360)\n * @param fn Returns a computed value from 0 to `distance`.\n * @returns\n */\nexport const wrapRange = (\n  min: number,\n  max: number,\n  fn: (distance: number) => number,\n  a: number,\n  b: number\n) => {\n  let r = 0;\n  const distF = Math.abs(b - a);\n  // When b is wrapped forwards\n  const distFwrap = Math.abs(max - a + b);\n  // When b is wrapped backwards (10, 300)\n  const distBWrap = Math.abs(a + (360 - b));\n\n  const distMin = Math.min(distF, distFwrap, distBWrap);\n  if (distMin === distBWrap) {\n    // (10, 300) = 70\n    r = a - fn(distMin);\n  } else if (distMin === distFwrap) {\n    // (300, 60) = 120\n    r = a + fn(distMin);\n  } else {\n    // Forwards or backwards without wrapping\n\n    if (a > b) {\n      // (240,120) -- backwards\n      r = a - fn(distMin);\n    } else {\n      // (120,240) -- forwards\n      r = a + fn(distMin);\n    }\n  }\n  return wrapInteger(r, min, max);\n};\n","export const piPi= Math.PI*2;","import { wrap } from './wrap.js';\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport { clamp } from './clamp.js';\nimport { piPi } from './pi-pi.js';\n\n/**\n * Interpolation options.\n * \n * Limit: What to do if interpolation amount exceeds 0..1 range\n * * clamp: lock to A & B (inclusive) Default.\n * * wrap: wrap from end to start again\n * * ignore: allow return values outside of A..B range\n * \n * Transform: name of function to transform `amount` prior to interpolate. This is useful for creating non-linear interpolation results.\n * \n * For example:\n * ```js\n * // Divide interpolation amount in half\n * const interpolatorInterval({ mins: 1 }, 10, 100, {\n *  transform: (amount) => amount * Math.random()\n * });\n * ```\n * In the above example, the results would get more random over time.\n * `interpolatorInterval` will still step through the interpolation range of 0..1 in an orderly fashion, but we're transforming that range using a custom function before producing the result. \n * \n */\nexport type BasicInterpolateOptions = {\n  limits: `clamp` | `wrap` | `ignore`\n  transform: (v: number) => number\n}\n\n/**\n * Returns an interpolation function with a fixed interpolation amount. This\n * function will need the A and B values to interpolate between (ie start and end)\n * \n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * // Create function\n * const fn = interpolate(0.1);\n * \n * // Later, use to interpolate between a and b\n * fn(50, 100); // 10% of 50..100 range\n * ```\n * \n * This is useful if you have a fixed interpolation amount, but varying A and B values.\n * @param amount Interpolation value (0..1 usually)\n * @param options Options\n */\nexport function interpolate(amount: number, options?: Partial<BasicInterpolateOptions>): (a: number, b: number) => number;\n\n/**\n * Interpolates between `a` and `b` by `amount`.\n * \n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * // Get the value at 10% of range between 50-100\n * const fn = interpolate(0.1, 50, 100);\n * ```\n * \n * This is useful if you have dynamic interpolation amount as well as A & B values.\n * Consider using `interpolate(amount)` if you have a fixed interpolation amount.\n * @param amount Interpolation value (0..1 usually)\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport function interpolate(amount: number, a: number, b: number, options?: Partial<BasicInterpolateOptions>): number;\n\n/**\n * Returns an interpolation function with a fixed A and B values.\n * The returned function requires an interpolation amount. This is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * // Create function to interpolate between 50..100\n * const fn = interpolate(50, 100);\n * \n * // Later, use to interpolate\n * fn(0.1); // 10% of 50..100 range\n * ```\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport function interpolate(a: number, b: number, options?: Partial<BasicInterpolateOptions>): (amount: number) => number;\n\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide on Interpolation](https://ixfx.fun/data/interpolation/overview/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * interpolate(0.5, 30, 60);\n * ```\n *\n * See also {@link interpolatorStepped} and {@link @ixfx/modulation.interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n * \n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n * \n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n * \n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * There are a few variations when calling `interpolate`, depending on what parameters are fixed.\n * * `interpolate(amount)`: returns a function that needs a & b \n * * `interpolate(a, b)`:  returns a function that needs the interpolation amount\n */\nexport function interpolate(pos1: number, pos2?: number | Partial<BasicInterpolateOptions>, pos3?: number | Partial<BasicInterpolateOptions>, pos4?: Partial<BasicInterpolateOptions>) {\n  let amountProcess: undefined | ((v: number) => number);\n  let limits: BasicInterpolateOptions[ 'limits' ] = `clamp`;\n\n  const handleAmount = (amount: number) => {\n    if (amountProcess) amount = amountProcess(amount);\n    if (limits === undefined || limits === `clamp`) {\n      amount = clamp(amount);\n    } else if (limits === `wrap`) {\n      if (amount > 1) amount = amount % 1;\n      else if (amount < 0) {\n        amount = 1 + (amount % 1);\n      }\n    }\n    return amount;\n  }\n\n  const doTheEase = (_amt: number, _a: number, _b: number) => {\n    resultThrow(\n      numberTest(_a, ``, `a`),\n      numberTest(_b, ``, `b`),\n      numberTest(_amt, ``, `amount`)\n    );\n    _amt = handleAmount(_amt);\n    return (1 - _amt) * _a + _amt * _b\n  }\n\n\n  const readOpts = (o: Partial<BasicInterpolateOptions> = {}) => {\n    if (o.transform) {\n      if (typeof o.transform !== `function`) throw new Error(`Param 'transform' is expected to be a function. Got: ${ typeof o.transform }`);\n      amountProcess = o.transform;\n    }\n    limits = o.limits ?? `clamp`;\n  }\n\n  const rawEase = (_amt: number, _a: number, _b: number) => (1 - _amt) * _a + _amt * _b\n\n  if (typeof pos1 !== `number`) throw new TypeError(`First param is expected to be a number. Got: ${ typeof pos1 }`);\n  if (typeof pos2 === `number`) {\n    let a: number;\n    let b: number;\n    if (pos3 === undefined || typeof pos3 === `object`) {\n      //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n      a = pos1;\n      b = pos2;\n      readOpts(pos3);\n      return (amount: number) => doTheEase(amount, a, b);\n    } else if (typeof pos3 === `number`) {\n      //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n      a = pos2;\n      b = pos3;\n      readOpts(pos4);\n      return doTheEase(pos1, a, b);\n    } else {\n      throw new Error(`Values for 'a' and 'b' not defined`);\n    }\n  } else if (pos2 === undefined || typeof pos2 === `object`) {\n    //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n    const amount = handleAmount(pos1);\n    readOpts(pos2);\n    resultThrow(numberTest(amount, ``, `amount`));\n    return (aValue: number, bValue: number) => rawEase(amount, aValue, bValue);\n  }\n};\n\n\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link @ixfx/numbers.interpolatorInterval}\n * which steps on the basis of clock time.\n * \n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n * \n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n * \n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n * \n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n * \n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorStepped = (incrementAmount: number, a = 0, b = 1, startInterpolationAt = 0, options?: Partial<BasicInterpolateOptions>) => {\n  let amount = startInterpolationAt;\n  return (retargetB?: number, retargetA?: number) => {\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    amount += incrementAmount;\n    return value;\n  }\n}\n\n\n\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (\n  amount: number,\n  aRadians: number,\n  bRadians: number,\n  options?: Partial<BasicInterpolateOptions>\n): number => {\n  const t = wrap(bRadians - aRadians, 0, piPi);\n  return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { round } from \"./round.js\";\n\n/**\n * Generates a `step`-length series of values between `start` and `end` (inclusive).\n * Each value will be equally spaced.\n *\n * ```js\n * for (const v of linearSpace(1, 5, 6)) {\n *  // Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]\n * }\n * ```\n *\n * Numbers can be produced from large to small as well\n * ```js\n * const values = [...linearSpace(10, 5, 3)];\n * // Yields: [10, 7.5, 5]\n * ```\n * @param start Start number (inclusive)\n * @param end  End number (inclusive)\n * @param steps How many steps to make from start -> end\n * @param precision Number of decimal points to round to\n */\nexport function* linearSpace(\n  start: number,\n  end: number,\n  steps: number,\n  precision?: number\n): IterableIterator<number> {\n\n  resultThrow(\n    numberTest(start, ``, `start`),\n    numberTest(end, ``, `end`),\n    numberTest(steps, ``, `steps`)\n  );\n  const r = precision ? round(precision) : (v: number) => v;\n  const step = (end - start) / (steps - 1);\n\n  resultThrow(numberTest(step, ``, `step`));\n  if (!Number.isFinite(step)) {\n    throw new TypeError(`Calculated step value is infinite`);\n  }\n\n  for (let index = 0; index < steps; index++) {\n    const v = start + step * index;\n    yield r(v);\n  }\n}\n","export class BasicQueueMutable<V> {\n  #store: V[] = [];\n\n  enqueue(data: V) {\n    this.#store.push(data);\n  }\n\n  dequeue(): V | undefined {\n    return this.#store.shift();\n  }\n\n  get data() {\n    return this.#store;\n  }\n  get size() {\n    return this.#store.length;\n  }\n}","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { BasicQueueMutable } from \"./util/queue-mutable.js\";\nimport { averageWeighted } from \"./average-weighted.js\";\nimport { average } from \"./numeric-arrays.js\";\nconst PiPi = Math.PI * 2;\n\n/**\n * A moving average calculator (exponential weighted moving average) which does not keep track of\n * previous samples. Less accurate, but uses less system resources.\n *\n * The `scaling` parameter determines smoothing. A value of `1` means that\n * the latest value is used as the average - that is, no smoothing. Higher numbers\n * introduce progressively more smoothing by weighting the accumulated prior average more heavily.\n *\n * ```\n * const ma = movingAverageLight(); // default scaling of 3\n * ma(50);  // 50\n * ma(100); // 75\n * ma(75);  // 75\n * ma(0);   // 50\n * ```\n *\n * Note that the final average of 50 is pretty far from the last value of 0. To make it more responsive,\n * we could use a lower scaling factor: `movingAverageLight(2)`. This yields a final average of `37.5` instead.\n *\n * @param scaling Scaling factor. 1 is no smoothing. Default: 3\n * @returns Function that adds to average.\n */\nexport const movingAverageLight = (scaling = 3): (value?: number) => number => {\n  resultThrow(numberTest(scaling, `aboveZero`, `scaling`));\n  let average = 0;\n  let count = 0;\n\n  return (v?: number) => {\n    const r = numberTest(v, ``, `v`);\n    if (r.success && v !== undefined) {\n      // Valid number\n      count++;\n      average = average + (v - average) / Math.min(count, scaling);\n    }\n    return average;\n  }\n};\n\n/**\n * Creates a moving average for a set number of `samples`.\n * It returns a function which in turn yields an average value.\n * \n * Moving average are useful for computing the average over a recent set of numbers.\n * A lower number of samples produces a computed value that is lower-latency yet more jittery.\n * A higher number of samples produces a smoother computed value which takes longer to respond to\n * changes in data.\n *\n * Sample size is considered with respect to the level of latency/smoothness trade-off, and also\n * the rate at which new data is added to the moving average.\n *\n *\n * ```js\n * const ma = movingAverage(10);\n * ma(10); // 10\n * ma(5);  // 7.5\n * ```\n *\n * A weighting function can be provided to shape how the average is\n * calculated - eg privileging the most recent data over older data.\n * It uses `Arrays.averageWeighted` under the hood.\n *\n * ```js\n * import { movingAverage } from '@ixfx/numbers.js';\n * import { gaussian } from '@ixfx/modulation.js';\n * \n * // Give more weight to data in middle of sampling window\n * const ma = movingAverage(100, gaussian());\n * ```\n *\n * Because it keeps track of `samples` previous data, there is a memory impact. A lighter version is {@link movingAverageLight} which does not keep a buffer of prior data, but can't be as easily fine-tuned.\n * @param samples Number of samples to compute average from\n * @param weighter Optional weighting function\n * @returns\n */\nexport const movingAverage = (\n  samples = 100,\n  weighter?: (v: number) => number\n): (value?: number) => number => {\n  const q = new BasicQueueMutable<number>();\n  return (v?: number) => {\n    const r = numberTest(v);\n    if (r.success && v !== undefined) {\n      q.enqueue(v);\n      while (q.size > samples) {\n        q.dequeue();\n      }\n    }\n    return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n  }\n};\n\n\n// export const movingAverageTimed = (\n//   updateRateMs = 200,\n//   value = 0,\n//   scaling = 3\n// ): MovingAverage => {\n//   throwNumberTest(scaling, `aboveZero`, `scaling`);\n//   throwNumberTest(updateRateMs, `aboveZero`, `decayRateMs`);\n\n//   const mal = movingAverageLight(scaling);\n\n//   //eslint-disable-next-line functional/no-let\n//   let timer = 0;\n\n//   const reschedule = () => {\n//     if (timer !== 0) clearTimeout(timer);\n//     // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n//     // @ts-ignore\n//     timer = setTimeout(decay, updateRateMs) as number;\n//   };\n\n//   const decay = () => {\n//     mal.add(value);\n//     if (!mal.isDisposed) setTimeout(decay, updateRateMs);\n//   };\n\n//   const ma: MovingAverage = {\n//     add(v: number) {\n//       reschedule();\n//       return mal.add(v);\n//     },\n\n//     dispose() {\n//       mal.dispose();\n//     },\n//     clear: function (): void {\n//       mal.clear();\n//     },\n//     compute: function (): number {\n//       return mal.compute();\n//     },\n//     isDisposed: false,\n//   };\n\n//   return ma;\n// };\n\n\n\nconst smoothingFactor = (timeDelta: number, cutoff: number): number => {\n  const r = PiPi * cutoff * timeDelta;\n  return r / (r + 1);\n}\n\nconst exponentialSmoothing = (smoothingFactor: number, value: number, previous: number): number => {\n  return smoothingFactor * value + (1 - smoothingFactor) * previous\n}\n\n/**\n * Noise filtering\n * \n * Algorithm: https://gery.casiez.net/1euro/\n * \n * Based on [Jaan Tollander de Balsch's implementation](https://jaantollander.com/post/noise-filtering-using-one-euro-filter/)\n * @param cutoffMin Default: 1\n * @param speedCoefficient Default: 0\n * @param cutoffDefault Default: 1\n */\nexport const noiseFilter = (cutoffMin = 1, speedCoefficient = 0, cutoffDefault = 1) => {\n  let previousValue = 0;\n  let derivativeLast = 0;\n  let timestampLast = 0;\n\n  const compute = (value: number, timestamp?: number) => {\n    timestamp ??= performance.now();\n    const timeDelta = timestamp - timestampLast;\n\n    // Filtered derivative\n    const s = smoothingFactor(timeDelta, cutoffDefault);\n    const valueDelta = (value - previousValue) / timeDelta;\n    const derivative = exponentialSmoothing(s, valueDelta, derivativeLast);\n\n    // Filtered signal\n    const cutoff = cutoffMin + speedCoefficient * Math.abs(derivative);\n    const a = smoothingFactor(timeDelta, cutoff);\n    const smoothed = exponentialSmoothing(a, value, previousValue);\n\n    previousValue = smoothed;\n    derivativeLast = derivative;\n    timestampLast = timestamp;\n\n    return smoothed;\n  }\n  return compute;\n}","import { clamp, clamper } from './clamp.js';\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport type { NumberScaler, NumberScalerTwoWay } from './types.js';\n\n/**\n * Scales `v` from an input range to an output range (aka `map`)\n *\n * For example, if a sensor's useful range is 100-500, scale it to a percentage:\n *\n * ```js\n *\n * scale(sensorReading, 100, 500, 0, 1);\n * ```\n *\n * `scale` defaults to a percentage-range output, so you can get away with:\n * ```js\n * scale(sensorReading, 100, 500);\n * ```\n *\n * If `v` is outside of the input range, it will likewise be outside of the output range.\n * Use {@link scaleClamped} to clip value to range.\n *\n * If inMin and inMax are equal, outMax will be returned.\n *\n * An easing function can be provided for non-linear scaling. In this case\n * the input value is 'pre scaled' using the function before it is applied to the\n * output range.\n *\n * ```js\n * scale(sensorReading, 100, 500, 0, 1, Easings.gaussian());\n * ```\n * @param v Value to scale\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @returns Scaled value\n */\nexport const scale = (\n  v: number,\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number\n): number => scaler(inMin, inMax, outMin, outMax, easing)(v);\n\n/**\n * Returns a scaling function\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @param clamped If true, value is clamped. Default: false\n * @returns\n */\nexport const scaler = (\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number,\n  clamped?: boolean\n): NumberScaler => {\n\n  resultThrow(\n    numberTest(inMin, `finite`, `inMin`),\n    numberTest(inMax, `finite`, `inMax`)\n  );\n  const oMax = outMax ?? 1;\n  const oMin = outMin ?? 0;\n  const clampFunction = clamped ? clamper(outMin, outMax) : undefined;\n\n  return (v: number): number => {\n    if (inMin === inMax) return oMax;\n\n    let a = (v - inMin) / (inMax - inMin);\n    if (easing !== undefined) a = easing(a);\n    const x = a * (oMax - oMin) + oMin;\n    if (clampFunction) return clampFunction(x);\n    return x;\n  };\n};\n\n/**\n * Returns a 'null' scaler that does nothing - the input value is returned as output.\n * @returns \n */\nexport const scalerNull = (): NumberScaler => (v: number) => v;\n\n/**\n * As {@link scale}, but result is clamped to be\n * within `outMin` and `outMax`.\n *\n * @param v\n * @param inMin\n * @param inMax\n * @param outMin 1 by default\n * @param outMax 0 by default d\n * @param easing\n * @returns\n */\nexport const scaleClamped = (\n  v: number,\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number\n): number => {\n  if (typeof outMax === `undefined`) outMax = 1;\n  if (typeof outMin === `undefined`) outMin = 0;\n  if (inMin === inMax) return outMax;\n\n  const x = scale(v, inMin, inMax, outMin, outMax, easing);\n  return clamp(x, outMin, outMax);\n};\n\n/**\n * Scales an input percentage to a new percentage range.\n *\n * If you have an input percentage (0-1), `scalePercentageOutput` maps it to an\n * _output_ percentage of `outMin`-`outMax`.\n *\n * ```js\n * // Scales 50% to a range of 0-10%\n * scalePercentages(0.5, 0, 0.10); // 0.05 - 5%\n * ```\n *\n * An error is thrown if any parameter is outside of percentage range. This added\n * safety is useful for catching bugs. Otherwise, you could just as well call\n * `scale(percentage, 0, 1, outMin, outMax)`.\n *\n * If you want to scale some input range to percentage output range, just use `scale`:\n * ```js\n * // Yields 0.5\n * scale(2.5, 0, 5);\n * ```\n * @param percentage Input value, within percentage range\n * @param outMin Output minimum, between 0-1\n * @param outMax Output maximum, between 0-1\n * @returns Scaled value between outMin-outMax.\n */\nexport const scalePercentages = (\n  percentage: number,\n  outMin: number,\n  outMax = 1\n): number => {\n  resultThrow(\n    numberTest(percentage, `percentage`, `v`),\n    numberTest(outMin, `percentage`, `outMin`),\n    numberTest(outMax, `percentage`, `outMax`)\n  );\n  return scale(percentage, 0, 1, outMin, outMax);\n};\n\n/**\n * Scales an input percentage value to an output range\n * If you have an input percentage (0-1), `scalePercent` maps it to an output range of `outMin`-`outMax`.\n * ```js\n * scalePercent(0.5, 10, 20); // 15\n * ```\n *\n * @see {@link scalerPercent} Returns a function\n * @param v Value to scale\n * @param outMin Minimum for output\n * @param outMax Maximum for output\n * @returns\n */\nexport const scalePercent = (\n  v: number,\n  outMin: number,\n  outMax: number\n): number => scalerPercent(outMin, outMax)(v);\n\n/**\n * Returns a function that scales an input percentage value to an output range\n * @see {@link scalePercent} Calculates value\n * @param outMin\n * @param outMax\n * @returns Function that takes a single argument\n */\nexport const scalerPercent = (outMin: number, outMax: number) => {\n  return (v: number) => {\n    resultThrow(numberTest(v, `percentage`, `v`));\n    return scale(v, 0, 1, outMin, outMax);\n  };\n};\n\n\n\n/**\n * Returns a two-way scaler\n * ```js\n * // Input range 0..100, output range 0..1\n * const s = scalerTwoWay(0,100,0,1);\n * \n * // Scale from input to output\n * s.out(50); // 0.5\n * \n * // Scale from output range to input\n * s.in(1); // 100\n * ```\n * @param inMin \n * @param inMax \n * @param outMin \n * @param outMax \n * @returns \n */\nexport const scalerTwoWay = (inMin: number, inMax: number, outMin = 0, outMax = 1, clamped = false, easing?: (v: number) => number): NumberScalerTwoWay => {\n  const toOut = scaler(inMin, inMax, outMin, outMax, easing, clamped);\n  const toIn = scaler(outMin, outMax, inMin, inMax, easing, clamped);\n  return { out: toOut, in: toIn };\n}","import type { NumbersComputeOptions, NumbersComputeResult } from \"./types.js\";\n\n/**\n * Calculate the min, max, total, average and count of input array `data`.\n * ```js\n * const { total, min, max, avg, count } = numberArrayCompute([ 1, 2, 3 ]);\n * ```\n * @param data \n * @param opts \n * @returns \n */\nexport const numberArrayCompute = (data: number[] | readonly number[], opts: NumbersComputeOptions = {}): NumbersComputeResult => {\n  if (data.length === 0) {\n    return {\n      total: Number.NaN,\n      min: Number.NaN,\n      max: Number.NaN,\n      avg: Number.NaN,\n      count: Number.NaN\n    };\n  }\n  const nonNumbers = opts.nonNumbers ?? `throw`;\n\n  let total = 0;\n  let min = Number.MAX_SAFE_INTEGER;\n  let max = Number.MIN_SAFE_INTEGER;\n  let count = 0;\n  for (let index = 0; index < data.length; index++) {\n    let value = data[ index ];\n    if (typeof value !== `number`) {\n      if (nonNumbers === `ignore`) continue;\n      if (nonNumbers === `throw`) throw new Error(`Param 'data' contains a non-number at index: ${ index.toString() }`);\n      if (nonNumbers === `nan`) value = Number.NaN;\n    }\n    if (Number.isNaN(value)) continue;\n    min = Math.min(min, value);\n    max = Math.max(max, value);\n    total += value;\n    count++;\n  }\n  return {\n    total, max, min, count,\n    avg: total / count\n  }\n}","\nimport { scale } from './scale.js';\nimport { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { clamp } from './clamp.js';\nimport { numberArrayCompute } from './number-array-compute.js';\n/**\n * Normalises numbers, adjusting min/max as new values are processed.\n * Normalised return values will be in the range of 0-1 (inclusive).\n *\n * [ixfx Guide on Normalising](https://ixfx.fun/cleaning/normal/)\n *\n * @example\n * ```js\n * const s = Normalise.stream();\n * s(2);    // 1 (because 2 is highest seen)\n * s(1);    // 0 (because 1 is the lowest so far)\n * s(1.5);  // 0.5 (50% of range 1-2)\n * s(0.5);  // 0 (because it's the new lowest)\n * ```\n *\n * Since normalisation is being adjusted as new min/max are encountered, it might\n * be that value normalised to 1 at one time is different to what normalises to 1\n * at a later time.\n *\n * If you already know what to expect of the number range, passing in `minDefault`\n * and `maxDefault` primes the normalisation.\n * ```js\n * const s = Normalise.stream();\n * s(5); // 1, because it's the highest seen\n *\n * // With priming:\n * const s = Normalise.stream(0, 10);\n * s(5); // 0.5, because we're expecting range 0-10\n * ```\n *\n * If a value exceeds the default range, normalisation adjusts.\n * Errors are thrown if min/max defaults are NaN or if one attempts to\n * normalise NaN.\n * @returns\n */\nexport const stream = (minDefault?: number, maxDefault?: number) => {\n  let min = minDefault ?? Number.MAX_SAFE_INTEGER;\n  let max = maxDefault ?? Number.MIN_SAFE_INTEGER;\n\n  resultThrow(\n    numberTest(min),\n    numberTest(max)\n  );\n  return (v: number): number => {\n    resultThrow(numberTest(v));\n    min = Math.min(min, v);\n    max = Math.max(max, v);\n    return scale(v, min, max);\n  };\n};\n\n/**\n * Normalises an array. By default uses the actual min/max of the array\n * as the normalisation range. [ixfx Guide on Normalising](https://ixfx.fun/cleaning/normal/)\n *\n * ```js\n * // Yields: [0.5, 0.1, 0.0, 0.9, 1]\n * Normalise.array([5,1,0,9,10]);\n * ```\n *\n * `minForced` and/or `maxForced` can\n * be provided to use an arbitrary range.\n * ```js\n * // Forced range 0-100\n * // Yields: [0.05, 0.01, 0.0, 0.09, 0.10]\n * Normalise.array([5,1,0,9,10], 0, 100);\n * ```\n *\n * Return values are clamped to always be 0-1, inclusive.\n *\n * @param values Values\n * @param minForced If provided, this will be min value used\n * @param maxForced If provided, this will be the max value used\n */\nexport const array = (values: readonly number[],\n  minForced?: number,\n  maxForced?: number\n) => {\n  if (!Array.isArray(values)) {\n    throw new TypeError(`Param 'values' should be an array. Got: ${ typeof values }`);\n  }\n  const mma = numberArrayCompute(values);\n\n  const min = minForced ?? mma.min;\n  const max = maxForced ?? mma.max;\n\n  return values.map((v) => clamp(scale(v, min, max)));\n};\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Scales a percentage-scale number, ie: `v * t`.\n * \n * The utility of this function is that it sanity-checks that\n * both parameters are in the 0..1 scale.\n * \n * Parameters can also be a function that takes no parameters\n * and returns a number. It will be invoked when `proportion` is called.\n * @param v Value\n * @param t Scale amount\n * @returns Scaled value\n */\nexport const proportion = (\n  v: number | (() => number),\n  t: number | (() => number)\n) => {\n  if (typeof v === `function`) v = v();\n  if (typeof t === `function`) t = t();\n\n  resultThrow(\n    numberTest(v, `percentage`, `v`),\n    numberTest(t, `percentage`, `t`)\n  );\n  return v * t;\n};\n","import { integerTest, numberTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Rounds `v` by `every`. Middle values are rounded up by default.\n *\n * ```js\n * quantiseEvery(11, 10);  // 10\n * quantiseEvery(25, 10);  // 30\n * quantiseEvery(0, 10);   // 0\n * quantiseEvery(4, 10);   // 0\n * quantiseEvery(100, 10); // 100\n * ```\n * \n * Also works with decimals\n * ```js\n * quantiseEvery(1.123, 0.1); // 1.1\n * quantiseEvery(1.21, 0.1);  // 1.2\n * ```\n *\n * @param v Value to quantise\n * @param every Number to quantise to\n * @param middleRoundsUp If _true_ (default), the exact middle rounds up to next step.\n * @returns\n */\nexport const quantiseEvery = (\n  v: number,\n  every: number,\n  middleRoundsUp = true\n) => {\n\n  const everyString = every.toString();\n  const decimal = everyString.indexOf(`.`);\n  let multiplier = 1;\n  if (decimal >= 0) {\n    const d = everyString.substring(decimal + 1).length;\n    multiplier = 10 * d;\n    every = Math.floor(multiplier * every);\n    v = v * multiplier;\n  }\n\n  resultThrow(\n    numberTest(v, ``, `v`),\n    integerTest(every, ``, `every`)\n  );\n\n  let div = v / every;\n  const divModule = div % 1;\n  div = Math.floor(div);\n  if ((divModule === 0.5 && middleRoundsUp) || divModule > 0.5) div++;\n  const vv = (every * div) / multiplier;\n  return vv;\n};","/**\n * Via: https://gist.github.com/cyphunk/6c255fa05dd30e69f438a930faeb53fe\n * @param logits \n * @returns \n */\nexport const softmax = (logits: number[]) => {\n\n  const maxLogit = logits.reduce((a, b) => Math.max(a, b), Number.NEGATIVE_INFINITY);\n  const scores = logits.map((l) => Math.exp(l - maxLogit));\n  const denom = scores.reduce((a, b) => a + b);\n  return scores.map((s) => s / denom);\n}"],"mappings":"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"}