{"version":3,"file":"src-Dz1O3AVz.js","names":["ticks","bpm","min","max","clamp","elapsed","piPi","pow","max","time","relative","ticks","Named","#sm","#holdingInitial","#timer","#timeSource","#holding","#disposed","elapsed","relative","#triggered","adsr","max","mass","pipeline","distance","elapsed","interpolate","getEasing","interpolateAngle","abs","relative","randomFloatFunction","randomFloat","distance","invert"],"sources":["../packages/core/dist/src/pathed.js","../packages/modulation/dist/src/source/ticks.js","../packages/modulation/dist/src/source/time.js","../packages/modulation/dist/src/source/per-second.js","../packages/modulation/dist/src/source/index.js","../packages/modulation/dist/src/oscillator.js","../packages/modulation/dist/src/gaussian.js","../packages/modulation/dist/src/easing/easings-named.js","../packages/modulation/dist/src/easing/line.js","../packages/modulation/dist/src/modulator-timed.js","../packages/modulation/dist/src/easing/index.js","../packages/modulation/dist/src/envelope/Types.js","../packages/modulation/dist/src/envelope/AdsrBase.js","../packages/modulation/dist/src/envelope/Adsr.js","../packages/modulation/dist/src/envelope/index.js","../packages/modulation/dist/src/forces.js","../packages/modulation/dist/src/cubic-bezier.js","../packages/modulation/dist/src/drift.js","../packages/modulation/dist/src/util/pi-pi.js","../packages/modulation/dist/src/interpolate.js","../packages/modulation/dist/src/jitter.js","../packages/modulation/dist/src/mix.js","../packages/modulation/dist/src/no-op.js","../packages/modulation/dist/src/ping-pong.js","../packages/modulation/dist/src/spring.js","../packages/modulation/dist/src/timing-source-factory.js","../packages/modulation/dist/src/waveforms.js","../packages/modulation/dist/src/weighted-average.js","../packages/modulation/dist/src/weighted-random.js","../packages/modulation/dist/src/index.js","../packages/process/dist/src/cancel-error.js","../packages/process/dist/src/flow.js","../packages/process/dist/src/if-undefined.js","../packages/process/dist/src/util.js","../packages/process/dist/src/seen.js","../packages/process/dist/src/index.js"],"sourcesContent":["import { recordEntriesDepthFirst } from \"@ixfx/core/records\";\nimport { isPrimitive, isInteger, isEqualContextString, defaultToString } from '@ixfx/core';\nimport { testPlainObjectOrPrimitive } from '@ixfx/guards';\nimport { compareObjectKeys } from './records/compare.js';\n/**\n * Get the entries for `target`.\n *\n * 'deep probe' uses alternative means to get entries of object, since `Object.entries`\n * can fail for some objects.\n * @param target Object to get entries from\n * @param deepProbe If true\n * @returns\n */\nconst getEntries = (target, deepProbe) => {\n    if (target === undefined)\n        throw new Error(`Param 'target' is undefined`);\n    if (target === null)\n        throw new Error(`Param 'target' is null`);\n    if (typeof target !== `object`)\n        throw new Error(`Param 'target' is not an object (got: ${typeof target})`);\n    if (deepProbe) {\n        const entries = [];\n        for (const field in target) {\n            const value = target[field];\n            if (testPlainObjectOrPrimitive(value)) {\n                entries.push([field, value]);\n            }\n        }\n        return entries;\n    }\n    else {\n        return Object.entries(target);\n    }\n};\n/**\n * Scans object, producing a list of changed fields where B's value (newer) differs from A (older).\n *\n * Options:\n * - `deepEntries` (_false_): If _false_ Object.entries are used to scan the object. However this won't work for some objects, eg event args, thus _true_ is needed.\n * - `eq` (JSON.stringify): By-value comparison function\n * - `includeMissingFromA` (_false): If _true_ includes fields present on B but missing on A.\n * - `asPartial` (_false): If _true_, treats B as a partial update to B. This means that things missing from B are not considered removals.\n * @param a 'Old' value\n * @param b 'New' value\n * @param options Options for comparison\n * @returns\n */\nexport function* compareData(a, b, options = {}) {\n    //console.log(`compareData a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) } opts: ${ options }`)\n    if (typeof a === `undefined`) {\n        yield {\n            path: options.pathPrefix ?? ``,\n            value: b,\n            state: `added`\n        };\n        return;\n    }\n    if (typeof b === `undefined`) {\n        yield { path: options.pathPrefix ?? ``, previous: a, value: undefined, state: `removed` };\n        return;\n    }\n    const asPartial = options.asPartial ?? false;\n    const skipInstances = options.skipInstances ?? new WeakSet();\n    const undefinedValueMeansRemoved = options.undefinedValueMeansRemoved ?? false;\n    const pathPrefix = options.pathPrefix ?? ``;\n    const deepEntries = options.deepEntries ?? false;\n    const eq = options.eq ?? isEqualContextString;\n    const includeMissingFromA = options.includeMissingFromA ?? false;\n    const includeParents = options.includeParents ?? false;\n    //console.log(`Pathed.compareData: a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) } prefix: ${ pathPrefix }`);\n    if (isPrimitive(a) && isPrimitive(b)) {\n        if (a !== b)\n            yield { path: pathPrefix, value: b, previous: a, state: `change` };\n        return;\n    }\n    if (isPrimitive(b)) {\n        yield { path: pathPrefix, value: b, previous: a, state: `change` };\n        return;\n    }\n    const entriesA = getEntries(a, deepEntries);\n    const entriesAKeys = new Set();\n    for (const [key, valueA] of entriesA) {\n        entriesAKeys.add(key);\n        const keyOfAInB = key in b;\n        const valueOfKeyInB = b[key];\n        //console.log(`Pathed.compareData Pathed.compareDataA key: ${ key } valueA: ${ defaultToString(valueA) }  valueAType: ${ typeof valueA } entriesCount: ${ entriesA.length }`);\n        if (typeof valueA === `object` && valueA !== null) {\n            if (skipInstances.has(valueA))\n                continue; // Already seen\n            skipInstances.add(valueA);\n            if (keyOfAInB) {\n                //console.log(`Pathed.compareData key ${ key } exists in B. value:`, valueOfKeyInB);\n                if (valueOfKeyInB === undefined) {\n                    throw new Error(`Pathed.compareData Value for key ${key} is undefined`);\n                }\n                else {\n                    const sub = [...compareData(valueA, valueOfKeyInB, {\n                            ...options,\n                            skipInstances,\n                            pathPrefix: pathPrefix + key + `.`\n                        })];\n                    if (sub.length > 0) {\n                        for (const s of sub)\n                            yield s;\n                        if (includeParents) {\n                            yield { path: pathPrefix + key, value: b[key], previous: valueA, state: `change` };\n                        }\n                    }\n                }\n            }\n            else {\n                if (asPartial)\n                    continue;\n                //throw new Error(`Key does not exist in B. Key: '${ key }'. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n                yield { path: pathPrefix + key, value: undefined, previous: valueA, state: `removed` };\n            }\n        }\n        else {\n            const subPath = pathPrefix + key;\n            if (keyOfAInB) {\n                // B contains key from A\n                if (valueOfKeyInB === undefined && undefinedValueMeansRemoved) {\n                    //console.error(`Pathed.compareData (2) value for B is undefined. key: ${ key }. B: ${ defaultToString(b) } A: ${ defaultToString(a) }`);\n                    yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n                }\n                else {\n                    if (!eq(valueA, valueOfKeyInB, subPath)) {\n                        //console.log(`Pathed.compareData  value changed. A: ${ valueA } B: ${ valueOfKeyInB } subPath: ${ subPath }`)\n                        yield { path: subPath, previous: valueA, value: valueOfKeyInB, state: `change` };\n                    }\n                }\n            }\n            else {\n                // B does not contain key from A\n                if (asPartial)\n                    continue; // Ignore\n                yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n            }\n        }\n    }\n    if (includeMissingFromA) {\n        const entriesB = getEntries(b, deepEntries);\n        for (const [key, valueB] of entriesB) {\n            if (entriesAKeys.has(key))\n                continue;\n            // Key in B that's not in A\n            //console.log(`Pathed.compareDataB key: ${ key } value: ${ valueB }`);\n            yield { path: pathPrefix + key, previous: undefined, value: valueB, state: `added` };\n        }\n    }\n}\n/**\n * Returns a copy of `source` with `changes` applied.\n * @param source\n * @param changes\n */\nexport const applyChanges = (source, changes) => {\n    for (const change of changes) {\n        source = updateByPath(source, change.path, change.value);\n    }\n    return source;\n};\n/**\n * Returns a copy of `target` object with a specified path changed to `value`.\n *\n * ```js\n * const a = {\n *  message: `Hello`,\n *  position: { x: 10, y: 20 }\n * }\n *\n * const a1 = updateByPath(a, `message`, `new message`);\n * // a1 = { message: `new message`, position: { x: 10, y: 20 }}\n * const a2 = updateByPath(a, `position.x`, 20);\n * // a2 = { message: `hello`, position: { x: 20, y: 20 }}\n * ```\n *\n * Paths can also be array indexes:\n * ```js\n * updateByPath([`a`,`b`,`c`], 2, `d`);\n * // Yields: [ `a`, `b`, `d` ]\n * ```\n *\n * By default, only existing array indexes can be updated. Use the `allowShapeChange` parameter\n * to allow setting arbitrary indexes.\n * ```js\n * // Throws because array index 3 is undefined\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`);\n *\n * // With allowShapeChange flag\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`, true);\n * // Returns: [ `a`, `b`, `c`, `d` ]\n * ```\n *\n * Throws an error if:\n * * `path` cannot be resolved (eg. `position.z` in the above example)\n * * `value` applied to `target` results in the object having a different shape (eg missing a field, field\n * changing type, or array index out of bounds). Use `allowShapeChange` to suppress this error.\n * * Path is undefined or not a string\n * * Target is undefined/null\n * @param target Object to update\n * @param path Path to set value\n * @param value Value to set\n * @param allowShapeChange By default _false_, throwing an error if an update change the shape of the original object.\n * @returns\n */\nexport const updateByPath = (target, path, value, allowShapeChange = false) => {\n    if (path === undefined)\n        throw new Error(`Parameter 'path' is undefined`);\n    if (typeof path !== `string`)\n        throw new Error(`Parameter 'path' should be a string. Got: ${typeof path}`);\n    if (target === undefined)\n        throw new Error(`Parameter 'target' is undefined`);\n    if (target === null)\n        throw new Error(`Parameter 'target' is null`);\n    const split = path.split(`.`);\n    const r = updateByPathImpl(target, split, value, allowShapeChange);\n    return r;\n};\nconst updateByPathImpl = (o, split, value, allowShapeChange) => {\n    if (split.length === 0) {\n        //console.log(`Pathed.updateByPathImpl o: ${ JSON.stringify(o) } value: ${ JSON.stringify(value) }`);\n        if (allowShapeChange)\n            return value; // yolo\n        if (Array.isArray(o) && !Array.isArray(value))\n            throw new Error(`Expected array value, got: '${JSON.stringify(value)}'. Set allowShapeChange=true to ignore.`);\n        if (!Array.isArray(o) && Array.isArray(value))\n            throw new Error(`Unexpected array value, got: '${JSON.stringify(value)}'. Set allowShapeChange=true to ignore.`);\n        if (typeof o !== typeof value)\n            throw new Error(`Cannot reassign object type. (${typeof o} -> ${typeof value}). Set allowShapeChange=true to ignore.`);\n        // Make sure new value has the same set of keys\n        if (typeof o === `object` && !Array.isArray(o)) {\n            const c = compareObjectKeys(o, value);\n            if (c.a.length > 0) {\n                throw new Error(`New value is missing key(s): ${c.a.join(`,`)}`);\n            }\n            if (c.b.length > 0) {\n                throw new Error(`New value cannot add new key(s): ${c.b.join(`,`)}`);\n            }\n        }\n        return value;\n    }\n    const start = split.shift();\n    if (!start)\n        return value;\n    const isInt = isInteger(start);\n    if (isInt && Array.isArray(o)) {\n        const index = Number.parseInt(start);\n        if (index >= o.length && !allowShapeChange)\n            throw new Error(`Array index ${index.toString()} is outside of the existing length of ${o.length.toString()}. Use allowShapeChange=true to permit this.`);\n        const copy = [...o];\n        copy[index] = updateByPathImpl(copy[index], split, value, allowShapeChange);\n        return copy;\n    }\n    else if (start in o) {\n        const copy = { ...o };\n        copy[start] = updateByPathImpl(copy[start], split, value, allowShapeChange);\n        return copy;\n    }\n    else {\n        throw new Error(`Path ${start} not found in data`);\n    }\n};\n/**\n * Gets the data at `path` in `object`. Assumes '.' separates each segment of path.\n *\n * ```js\n * getField({ name: { first: `Thom`, last: `Yorke` }}, `name.first`); // { value: `Thom`  success: true }\n * getField({ colours: [`red`, `green`, `blue` ]}, `colours.1`);      // { value: `green` success: true }\n * ```\n *\n * Returns an error result with more details, eg `{ success: false, error: 'Path could not be found' }`\n *\n * Throws if:\n * * `path` is not a string or empty\n * * `object` is _undefined_ or null\n * @param object Object to query\n * @param path Path\n * @param separator Separator of chunks of path. Defaults to '.'\n * @returns\n */\nexport const getField = (object, path, separator = `.`) => {\n    if (typeof path !== `string`)\n        throw new Error(`Param 'path' ought to be a string. Got: '${typeof path}'`);\n    if (path.length === 0)\n        throw new Error(`Param string 'path' is empty`);\n    if (object === undefined)\n        throw new Error(`Param 'object' is undefined`);\n    if (object === null)\n        throw new Error(`Param 'object' is null`);\n    const split = path.split(separator);\n    const v = getFieldImpl(object, split, path);\n    return v;\n};\nconst getFieldImpl = (object, split, position) => {\n    if (object === undefined)\n        return { success: false, error: `Param 'object' is undefined. Position: ${position}` };\n    if (split.length === 0)\n        return { success: false, error: `Path has been exhausted. position: ${position}` };\n    const start = split.shift();\n    if (!start)\n        return { success: false, error: `Unexpected empty split path. Position: ${position}` };\n    const isInt = isInteger(start);\n    if (isInt && Array.isArray(object)) { //(arrayStart === 0 && arrayEnd === start.length - 1 && Array.isArray(o)) {\n        const index = Number.parseInt(start); //start.slice(1, -1));\n        //console.log(`getFieldImpl index: ${ index } value: ${ object[ index ] }`);\n        if (typeof object[index] === `undefined`) {\n            return { success: false, error: `Index '${index}' does not exist. Length: ${object.length}. Position: ${position}` };\n        }\n        if (split.length === 0) {\n            return { value: object[index], success: true };\n        }\n        else {\n            return getFieldImpl(object[index], split, split.join(`.`));\n        }\n    }\n    else if (typeof object === `object` && start in object) {\n        //console.log(`start in object. Start: ${ start } Len: ${ split.length } Object`, object);\n        if (split.length === 0) {\n            return { value: object[start], success: true };\n        }\n        else {\n            return getFieldImpl(object[start], split, split.join(`.`));\n        }\n    }\n    else {\n        return { success: false, error: `Path '${start}' not found. Position: ${position}` };\n    }\n};\n/**\n * Iterates 'paths' for all the fields on `o`\n * ```\n * const d = {\n *  accel: { x: 1, y: 2, z: 3 },\n *  gyro: { x: 4, y: 5, z: 6 }\n * };\n * const paths = [...getFieldPaths(d)];\n * // Yields [ `accel`, `gyro`, `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * Use {@link getField} to fetch data based on a path\n *\n * If object is _null_ or _undefined_, no results are returned.\n *\n * If `onlyLeaves` is _true_ (default: _false_), only 'leaf' nodes are included.\n * Leaf nodes are those that contain a primitive value.\n * ```js\n * const paths = getFieldPaths(d, true);\n * // Yields [ `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * @param object Object to get paths for.\n * @param onlyLeaves If true, only paths with a primitive value are returned.\n * @returns\n */\nexport function* getPaths(object, onlyLeaves = false) {\n    if (object === undefined || object === null)\n        return;\n    const iter = recordEntriesDepthFirst(object);\n    for (const c of iter) {\n        if (c.nodeValue === undefined && onlyLeaves)\n            continue;\n        let path = c.name;\n        if (c.ancestors.length > 0)\n            path = c.ancestors.join(`.`) + `.` + path;\n        yield path;\n    }\n}\n;\n/**\n * Returns a representation of the object as a set of paths and data.\n * ```js\n * const o = { name: `hello`, size: 20, colour: { r:200, g:100, b:40 } }\n * const pd = [...getPathsAndData(o)];\n * // Yields:\n * // [\n * // { path: `name`, value: `hello` },\n * // { path: `size`, value: `20` },\n * // { path: `colour.r`, value: `200` },\n * // { path: `colour.g`, value: `100` },\n * // { path: `colour.b`, value: `40` }\n * //]\n * ```\n * @param o Object to get paths and data for\n * @param maxDepth Set maximum recursion depth. By default unlimited.\n * @param prefix Manually set a path prefix if it's necessary\n * @returns\n */\nexport function* getPathsAndData(o, onlyLeaves = false, maxDepth = Number.MAX_SAFE_INTEGER, prefix = ``) {\n    if (o === null)\n        return;\n    if (o === undefined)\n        return;\n    yield* getPathsAndDataImpl(o, prefix, onlyLeaves, maxDepth);\n}\nfunction* getPathsAndDataImpl(o, prefix, onlyLeaves = false, maxDepth) {\n    if (maxDepth <= 0)\n        return;\n    if (typeof o !== `object`)\n        return;\n    for (const entries of Object.entries(o)) {\n        const sub = (prefix.length > 0 ? prefix + `.` : ``) + entries[0];\n        const value = entries[1];\n        const leaf = (typeof value !== `object`);\n        if (onlyLeaves && leaf || !onlyLeaves) {\n            yield { path: sub, value };\n        }\n        yield* getPathsAndDataImpl(value, sub, onlyLeaves, maxDepth - 1);\n    }\n}\n","import { resultThrow, integerTest } from \"@ixfx/guards\";\n/**\n * Returns a function which cycles between 0..1 (inclusive of 0 and 1).\n * `totalTicks` is how many ticks it takes to get to 1. Since we want an inclusive 0 & 1,\n * the total ticks is actually +1.\n *\n * Ie. if totalTicks = 10, we get: 0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0\n *\n * Use 'exclusiveStart' and 'exclusiveEnd' flags to shift range. Eg, with `totalTicks` of 10:\n * * 'exclusiveStart:true': first value is 0.1, last value is 1.0 (10 values total)\n * * 'exclusiveEnd:true': first value is 0, last value is 0.9 (10 values total)\n * * If both are true, first value is 0.1, last value is 0.9 (9 values total)\n * * If both are false (or not set), we get the case described earlier, first value is 0, last value is 1 (11 values total)\n *\n * Other examples:\n * * totalTicks: 20, value goes up by 0.05\n * * totalTicks: 1, value goes up by 1\n * @param totalTicks Positive, integer value. How many ticks to complete a cycle\n * @param options\n * @returns\n */\nexport function ticks(totalTicks, options = {}) {\n    resultThrow(integerTest(totalTicks, `aboveZero`, `totalTicks`));\n    const exclusiveStart = options.exclusiveStart ?? false;\n    const exclusiveEnd = options.exclusiveEnd ?? false;\n    const cycleLimit = options.cycleLimit ?? Number.MAX_SAFE_INTEGER;\n    const startPoint = exclusiveStart ? 1 : 0;\n    const endPoint = exclusiveEnd ? totalTicks - 1 : totalTicks;\n    let cycleCount = 0;\n    let v = options.startAt ?? startPoint;\n    if (options.startAtRelative) {\n        let totalTicksForReal = totalTicks;\n        if (exclusiveStart)\n            totalTicksForReal--;\n        if (exclusiveEnd)\n            totalTicksForReal--;\n        v = Math.round(options.startAtRelative * totalTicksForReal);\n    }\n    return (feedback) => {\n        if (feedback) {\n            if (feedback.resetAt !== undefined) {\n                v = feedback.resetAt;\n            }\n            if (feedback.resetAtRelative !== undefined) {\n                v = Math.floor(feedback.resetAtRelative * totalTicks);\n            }\n        }\n        if (cycleCount >= cycleLimit)\n            return 1;\n        const current = v / totalTicks;\n        v++;\n        if (v > endPoint) {\n            cycleCount++;\n            v = startPoint;\n        }\n        return current;\n    };\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { numberTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Returns the percentage of time toward `interval`. See also: {@link bpm}, {@link hertz} which are the same but\n * using different units for time.\n *\n * By default, it continues forever, cycling from 0..1 repeatedly for each interval. Use\n * `cycleLimit` to restrict this. A value of 1 means it won't loop.\n *\n * The starting 'position' is `performance.now()`. If `startAt` option is provided, this will be used instead.\n * It probably should be an offset of `performance.now()`, eg: `{ startAt: performance.now() - 500 }` to shift\n * the cycle by 500ms.\n *\n * When using `startAtRelative`, the starting position will be set backward by the relative amount. A value\n * of 0.5, for example, will set the timer back 50% of the interval, meaning the cycle will start half way through.\n *\n * @param interval\n * @param options\n * @returns\n */\nexport function elapsed(interval, options = {}) {\n    const cycleLimit = options.cycleLimit ?? Number.MAX_SAFE_INTEGER;\n    const limitValue = 1;\n    let start = options.startAt ?? performance.now();\n    let cycleCount = 0;\n    const intervalMs = intervalToMs(interval, 1000);\n    if (options.startAtRelative) {\n        resultThrow(numberTest(options.startAtRelative, `percentage`, `startAtRelative`));\n        start = performance.now() - (intervalMs * options.startAtRelative);\n    }\n    //let stopAt = cycleLimit > 0 ? (intervalMs + start) : Number.MAX_SAFE_INTEGER;\n    return (feedback) => {\n        if (feedback) {\n            if (feedback.resetAt !== undefined) {\n                start = feedback.resetAt;\n                if (start === 0)\n                    start = performance.now();\n            }\n            if (feedback.resetAtRelative !== undefined) {\n                resultThrow(numberTest(feedback.resetAtRelative, `percentage`, `resetAtRelative`));\n                start = performance.now() - (intervalMs * feedback.resetAtRelative);\n            }\n        }\n        if (cycleCount >= cycleLimit)\n            return limitValue;\n        const now = performance.now();\n        const elapsedCycle = now - start;\n        if (elapsedCycle >= intervalMs) {\n            cycleCount += Math.floor(elapsedCycle / intervalMs);\n            start = now;\n            if (cycleCount >= cycleLimit)\n                return limitValue;\n        }\n        return (elapsedCycle % intervalMs) / intervalMs;\n    };\n    // } else {\n    //   return () => ((performance.now() - start) % intervalMs) / intervalMs;\n    // }\n}\n/**\n * Counts beats based on a BPM.\n * Uses {@link elapsed} internally.\n * @param bpm\n * @param options\n * @returns\n */\nexport function bpm(bpm, options = {}) {\n    const interval = (60 * 1000) / bpm; // milliseconds between beats.\n    return elapsed(interval, options);\n}\n/**\n * Counts based on hertz (oscillations per second).\n * Uses {@link elapsed} internally.\n * @param hz\n * @param options\n * @returns\n */\nexport function hertz(hz, options = {}) {\n    const interval = 1000 / hz;\n    return elapsed(interval, options);\n}\n","/**\n * Returns a proportion of `amount` depending on elapsed time.\n * Cumulatively, `amount` is yielded every second.\n *\n * ```js\n * // Calculate a proportion of 0.1 every second\n * const x = perSecond(0.1);\n * x();\n * ```\n *\n * The faster `x()` is called, the smaller the chunks of `amount` are returned.\n * Values accumulate. For example, `x()` isn't called for two seconds, 2*amount is returned.\n *\n * @example Usage\n * ```js\n * const settings = {\n *  ageMod: perSecond(0.1);\n * };\n *\n * let state = {\n *  age: 1\n * };\n *\n * // Update\n * setInterval(() => {\n *  let { age } = state;\n *  // Add 0.1 per second, regardless of\n *  // loop speed\n *  age += settings.ageMod();\n *  state = {\n *    ...state,\n *    age: clamp(age)\n *  }\n * });\n * ```\n *\n * Use the `clamp` option so the returned value never exceeds `amount`.\n * Alternatively, `min`/`max` options allow you to set arbitrary limits.\n * @param amount\n * @returns\n */\nexport const perSecond = (amount, options = {}) => {\n    const perMilli = amount / 1000;\n    let min = options.min ?? Number.MIN_SAFE_INTEGER;\n    let max = options.max ?? Number.MAX_SAFE_INTEGER;\n    const clamp = options.clamp ?? false;\n    if (clamp && options.max)\n        throw new Error(`Use either 'max' or 'clamp', not both.`);\n    if (clamp)\n        max = amount;\n    let called = performance.now();\n    return () => {\n        const now = performance.now();\n        const elapsed = now - called;\n        called = now;\n        const x = perMilli * elapsed;\n        if (x > max)\n            return max;\n        if (x < min)\n            return min;\n        return x;\n    };\n};\n/**\n * As {@link perSecond}, but per minute.\n * @param amount\n * @param options\n * @returns\n */\nexport const perMinute = (amount, options = {}) => {\n    return perSecond(amount / 60, options);\n};\n","export * from './ticks.js';\nexport * from './time.js';\nexport * from './per-second.js';\n","import * as Flow from '@ixfx/flow';\nconst piPi = Math.PI * 2;\n/**\n * Sine oscillator.\n *\n * ```js\n * import { Oscillators } from \"@ixfx/modulation.js\"\n * import { frequencyTimer } from \"@ixfx/flow.js\";\n * // Setup\n * const osc = Oscillators.sine(frequencyTimer(10));\n * const osc = Oscillators.sine(0.1);\n *\n * // Call whenever a value is needed\n * const v = osc.next().value;\n * ```\n *\n * @example Saw/tri pinch\n * ```js\n * const v = Math.pow(osc.value, 2);\n * ```\n *\n * @example Saw/tri bulge\n * ```js\n * const v = Math.pow(osc.value, 0.5);\n * ```\n *\n */\nexport function* sine(timerOrFreq) {\n    if (timerOrFreq === undefined)\n        throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n    if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    while (true) {\n        // Rather than -1 to 1, we want 0 to 1\n        yield (Math.sin(timerOrFreq.elapsed * piPi) + 1) / 2;\n    }\n}\n/**\n * Bipolar sine (-1 to 1)\n * @param timerOrFreq\n */\nexport function* sineBipolar(timerOrFreq) {\n    if (timerOrFreq === undefined)\n        throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n    if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    while (true) {\n        yield Math.sin(timerOrFreq.elapsed * piPi);\n    }\n}\n/**\n * Triangle oscillator\n *\n * ```js\n * // Setup\n * const osc = triangle(Timers.frequencyTimer(0.1));\n * const osc = triangle(0.1);\n *\n * // Call whenver a value is needed\n * const v = osc.next().value;\n * ```\n */\nexport function* triangle(timerOrFreq) {\n    if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    while (true) {\n        // elapsed is repeatedly 0->1\n        let v = timerOrFreq.elapsed;\n        // /2 = 0->0.5\n        if (v < 0.5) {\n            // Upward\n            v *= 2;\n        }\n        else {\n            // Downward\n            v = 2 - v * 2;\n        }\n        yield v;\n    }\n}\n/**\n * Saw oscillator\n *\n * ```js\n * import { Oscillators } from \"@ixfx/modulation.js\"\n * import { frequencyTimer } from \"@ixfx/flow.js\";\n * // Setup\n * const osc = Oscillators.saw(Timers.frequencyTimer(0.1));\n *\n * // Or\n * const osc = Oscillators.saw(0.1);\n *\n * // Call whenever a value is needed\n * const v = osc.next().value;\n * ```\n */\nexport function* saw(timerOrFreq) {\n    if (timerOrFreq === undefined)\n        throw new TypeError(`Parameter 'timerOrFreq' is undefined`);\n    if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    while (true) {\n        yield timerOrFreq.elapsed;\n    }\n}\n/**\n * Square oscillator\n *\n * ```js\n * import { Oscillators } from \"@ixfx/modulation.js\"\n *\n * // Setup\n * const osc = Oscillators.square(Timers.frequencyTimer(0.1));\n * const osc = Oscillators.square(0.1);\n *\n * // Call whenever a value is needed\n * osc.next().value;\n * ```\n */\nexport function* square(timerOrFreq) {\n    if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    while (true) {\n        yield timerOrFreq.elapsed < 0.5 ? 0 : 1;\n    }\n}\n","//const sqrt = Math.sqrt;\nconst pow = Math.pow;\n//const pi = Math.PI;\n//const piPi = Math.PI*2;\nconst gaussianA = 1 / Math.sqrt(2 * Math.PI);\n/**\n * Returns a roughly gaussian easing function\n * ```js\n * const fn = Easings.gaussian();\n * ```\n *\n * Try different positive and negative values for `stdDev` to pinch\n * or flatten the bell shape.\n * @param standardDeviation\n * @returns\n */\nexport const gaussian = (standardDeviation = 0.4) => {\n    //const a = 1 / sqrt(2 * pi);\n    const mean = 0.5;\n    return (t) => {\n        const f = gaussianA / standardDeviation;\n        // p:-8 pinched\n        let p = -2.5; // -1/1.25;\n        let c = (t - mean) / standardDeviation;\n        c *= c;\n        p *= c;\n        const v = f * pow(Math.E, p); // * (2/pi);//0.62;\n        if (v > 1)\n            return 1;\n        if (v < 0)\n            return 0;\n        return v;\n    };\n};\n","import { gaussian } from \"../gaussian.js\";\n// Easings from https://easings.net/\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst cos = Math.cos;\nconst pi = Math.PI;\nconst sin = Math.sin;\nexport const bounceOut = (x) => {\n    const n1 = 7.5625;\n    const d1 = 2.75;\n    if (x < 1 / d1) {\n        return n1 * x * x;\n    }\n    else if (x < 2 / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    }\n    else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    }\n    else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984_375;\n    }\n};\nexport const quintIn = (x) => x * x * x * x * x;\nexport const quintOut = (x) => 1 - pow(1 - x, 5);\nexport const arch = (x) => x * (1 - x) * 4;\nexport const smoothstep = (x) => x * x * (3 - 2 * x);\nexport const smootherstep = (x) => (x * (x * 6 - 15) + 10) * x * x * x;\nexport const sineIn = (x) => 1 - cos((x * pi) / 2);\nexport const sineOut = (x) => sin((x * pi) / 2);\nexport const quadIn = (x) => x * x;\nexport const quadOut = (x) => 1 - (1 - x) * (1 - x);\nexport const sineInOut = (x) => -(cos(pi * x) - 1) / 2;\nexport const quadInOut = (x) => x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2;\nexport const cubicIn = (x) => x * x * x;\nexport const cubicOut = (x) => 1 - pow(1 - x, 3);\nexport const quartIn = (x) => x * x * x * x;\nexport const quartOut = (x) => 1 - pow(1 - x, 4);\nexport const expoIn = (x) => (x === 0 ? 0 : pow(2, 10 * x - 10));\nexport const expoOut = (x) => (x === 1 ? 1 : 1 - pow(2, -10 * x));\nexport const quintInOut = (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2;\nexport const expoInOut = (x) => x === 0\n    ? 0\n    : x === 1\n        ? 1\n        // eslint-disable-next-line unicorn/no-nested-ternary\n        : x < 0.5\n            ? pow(2, 20 * x - 10) / 2\n            : (2 - pow(2, -20 * x + 10)) / 2;\nexport const circIn = (x) => 1 - sqrt(1 - pow(x, 2));\nexport const circOut = (x) => sqrt(1 - pow(x - 1, 2));\nexport const backIn = (x) => {\n    const c1 = 1.701_58;\n    const c3 = c1 + 1;\n    return c3 * x * x * x - c1 * x * x;\n};\nexport const backOut = (x) => {\n    const c1 = 1.701_58;\n    const c3 = c1 + 1;\n    return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\n};\nexport const circInOut = (x) => x < 0.5\n    ? (1 - sqrt(1 - pow(2 * x, 2))) / 2\n    : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;\nexport const backInOut = (x) => {\n    const c1 = 1.701_58;\n    const c2 = c1 * 1.525;\n    return x < 0.5\n        ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\n        : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n};\nexport const elasticIn = (x) => {\n    const c4 = (2 * pi) / 3;\n    return x === 0\n        ? 0\n        : (x === 1\n            ? 1\n            : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4));\n};\nexport const elasticOut = (x) => {\n    const c4 = (2 * pi) / 3;\n    return x === 0\n        ? 0\n        : (x === 1\n            ? 1\n            : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1);\n};\nexport const bounceIn = (x) => 1 - bounceOut(1 - x);\nexport const bell = gaussian();\nexport const elasticInOut = (x) => {\n    const c5 = (2 * pi) / 4.5;\n    return x === 0\n        ? 0\n        : x === 1\n            ? 1\n            // eslint-disable-next-line unicorn/no-nested-ternary\n            : x < 0.5\n                ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2\n                : (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\n};\nexport const bounceInOut = (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2;\n","import { Points, Beziers } from '@ixfx/geometry';\nimport { scale } from '@ixfx/numbers';\n/**\n * Interpolates points along a line.\n * By default it's a straight line, so use `bend` to make a non-linear curve.\n * @param bend -1...1. -1 will pull line up, 1 will push it down.\n * @returns\n */\nexport const line = (bend = 0, warp = 0) => {\n    const max = 1;\n    const cubicB = {\n        x: scale(bend, -1, 1, 0, max),\n        y: scale(bend, -1, 1, max, 0),\n    };\n    // Add in bend as 'drive'\n    let cubicA = Points.interpolate(Math.abs(bend), Points.Empty, cubicB);\n    // Warp\n    if (bend !== 0 && warp > 0) {\n        if (bend > 0) {\n            cubicA = Points.interpolate(warp, cubicA, { x: 0, y: cubicB.x * 2 });\n        }\n        else {\n            cubicA = Points.interpolate(warp, cubicA, { x: cubicB.y * 2, y: 0 });\n        }\n    }\n    const bzr = Beziers.cubic(Points.Empty, Points.Unit, cubicA, cubicB);\n    const inter = Beziers.interpolator(bzr);\n    return (value) => inter(value);\n};\n","import { intervalToMs } from \"@ixfx/core\";\nimport * as Flow from '@ixfx/flow';\nimport { functionTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Produce values over time. When the modulate function is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n *\n * ```js\n * const fn = (t) => {\n *  // 't' will be values 0..1 where 1 represents end of time period.\n *  // Return some computed value based on 't'\n *  return t*Math.random();\n * }\n * const e = Modulate.time(fn, 1000);\n *\n * // Keep calling e() to get the current value\n * e();\n * ```\n * @param fn Modulate function\n * @param duration Duration\n * @returns\n */\nexport const time = (fn, duration) => {\n    resultThrow(functionTest(fn, `fn`));\n    let relative;\n    return () => {\n        if (typeof relative === `undefined`)\n            relative = Flow.ofTotal(duration, { clampValue: true });\n        return fn(relative());\n    };\n};\n/**\n * Creates an modulator based on clock time. Time\n * starts being counted when modulate function is created.\n *\n * `timeModulator` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n * @example Time based easing\n * ```\n * import { timeModulator } from \"@ixfx/modulation.js\";\n * const fn = (t) => {\n *  // 't' will be a value 0..1 representing time elapsed. 1 being end of period.\n *  return t*Math.random();\n * }\n * const t = timeModulator(fn, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of modulator\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param fn Modulator\n * @param duration Duration\n * @returns ModulatorTimed\n */\nexport const timeModulator = (fn, duration) => {\n    resultThrow(functionTest(fn, `fn`));\n    const timer = Flow.elapsedMillisecondsAbsolute();\n    const durationMs = intervalToMs(duration);\n    if (durationMs === undefined)\n        throw new Error(`Param 'duration' not provided`);\n    const relativeTimer = Flow.relative(durationMs, {\n        timer,\n        clampValue: true\n    });\n    return Flow.timerWithFunction(fn, relativeTimer);\n};\n/**\n * Produce modulate values with each invocation. When the time is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n *\n * If you need to check if a modulator is done or reset it, consider {@link tickModulator}.\n *\n * ```js\n * const fn = (t) => {\n *  // 't' will be values 0..1 representing elapsed ticks toward totwal\n * }\n * const e = ticks(fn, 100);\n *\n * // Keep calling e() to get the current value\n * e();\n * ```\n * @param fn Function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns\n */\nexport const ticks = (fn, totalTicks) => {\n    resultThrow(functionTest(fn, `fn`));\n    let relative;\n    return () => {\n        if (typeof relative === `undefined`)\n            relative = Flow.ofTotalTicks(totalTicks, { clampValue: true });\n        return fn(relative());\n    };\n};\n/**\n * Creates an modulator based on ticks.\n *\n * `tickModulator` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based modulator\n * ```\n * import { tickModulator } from \"@ixfx/modulation.js\";\n * const fn = (t) => {\n *  // 't' will be values 0..1 based on completion\n *  return Math.random() * t;\n * }\n * const t = tickModulator(fn, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param fn Modulate function that returns 0..1\n * @param durationTicks Duration in ticks\n * @returns ModulatorTimed\n */\nexport const tickModulator = (fn, durationTicks) => {\n    resultThrow(functionTest(fn, `fn`));\n    const timer = Flow.elapsedTicksAbsolute();\n    const relativeTimer = Flow.relative(durationTicks, {\n        timer,\n        clampValue: true\n    });\n    return Flow.timerWithFunction(fn, relativeTimer);\n};\n","import * as Named from './easings-named.js';\nimport { stringTest, resultThrow } from '@ixfx/guards';\nimport {} from '@ixfx/core';\nexport * as Named from './easings-named.js';\nexport * from './line.js';\nimport * as ModuleTimed from '../modulator-timed.js';\n/**\n * Creates an easing function\n * ```js\n * const e = Easings.create({ duration: 1000, name: `quadIn` });\n * const e = Easings.create({ ticks: 100, name: `sineOut` });\n * const e = Easings.create({\n *  duration: 1000,\n *  fn: (v) => {\n *    // v will be 0..1 based on time\n *    return Math.random() * v\n *  }\n * });\n * ```\n * @param options\n * @returns\n */\nexport const create = (options) => {\n    const name = resolveEasingName(options.name ?? `quintIn`);\n    const fn = name ?? options.fn;\n    if (typeof fn === `undefined`)\n        throw new Error(`Either 'name' or 'fn' must be set`);\n    if (`duration` in options) {\n        return time(fn, options.duration);\n    }\n    else if (`ticks` in options) {\n        return ticks(fn, options.ticks);\n    }\n    else {\n        throw new Error(`Expected 'duration' or 'ticks' in options`);\n    }\n};\n/**\n * Creates an easing based on clock time. Time\n * starts being counted when easing function is created.\n *\n * `timeEasing` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n *\n * @example Time based easing\n * ```\n * const t = Easings.timeEasing(`quintIn`, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of easing\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n *\n * Thisi function is just a wrapper around Modulator.timedModulator.\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration\n * @returns Easing\n */\nexport const timeEasing = (nameOrFunction, duration) => {\n    const fn = resolveEasingName(nameOrFunction);\n    return ModuleTimed.timeModulator(fn, duration);\n    // const timer = Timer.elapsedMillisecondsAbsolute();\n    // const durationMs = intervalToMs(duration);\n    // if (durationMs === undefined) throw new Error(`Param 'duration' not provided`);\n    // const relativeTimer = Timer.relative(\n    //   durationMs,\n    //   {\n    //     timer,\n    //     clampValue: true\n    //   });\n    // return Timer.timerWithFunction(fn, relativeTimer);\n};\n/**\n * Produce easing values over time. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n *\n * If you need to check if an easing is done or reset it, consider {@link timeEasing}.\n *\n * ```js\n * // Quad-in easing over one second\n * const e = Easings.time(`quadIn`, 1000);\n *\n * // Keep calling e() to get the current value\n * e();\n * ```\n *\n * This function is just a wrapper around Modulate.time\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param duration Duration\n * @returns\n */\nexport const time = (nameOrFunction, duration) => {\n    const fn = resolveEasingName(nameOrFunction);\n    return ModuleTimed.time(fn, duration);\n    // let relative: undefined | (() => number);\n    // return () => {\n    //   if (relative === undefined) relative = Timer.ofTotal(duration, { clampValue: true });\n    //   return fn(relative());\n    // }\n};\n/**\n * Produce easing values with each invocation. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n *\n * If you need to check if an easing is done or reset it, consider {@link tickEasing}.\n *\n * ```js\n * // Quad-in easing over 100 ticks\n * const e = Easings.ticks(`quadIn`, 100);\n *\n * // Keep calling e() to get the current value\n * e();\n * ```\n *\n * This is just a wrapper around Modulator.ticks\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns\n */\nexport const ticks = (nameOrFunction, totalTicks) => {\n    const fn = resolveEasingName(nameOrFunction);\n    return ModuleTimed.ticks(fn, totalTicks);\n    // let relative: undefined | (() => number);\n    // return () => {\n    //   if (relative === undefined) relative = Timer.ofTotalTicks(totalTicks, { clampValue: true });\n    //   return fn(relative());\n    // }\n};\n/**\n * Creates an easing based on ticks.\n *\n * `tickEasing` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based easing\n * ```\n * const t = Easings.tickEasing(`sineIn`, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param durationTicks Duration in ticks\n * @returns Easing\n */\nexport const tickEasing = (nameOrFunction, durationTicks) => {\n    const fn = resolveEasingName(nameOrFunction);\n    return ModuleTimed.tickModulator(fn, durationTicks);\n    // const timer = Timer.elapsedTicksAbsolute();\n    // const relativeTimer = Timer.relative(\n    //   durationTicks,\n    //   {\n    //     timer,\n    //     clampValue: true\n    //   });\n    // return Timer.timerWithFunction(fn, relativeTimer);\n};\nconst resolveEasingName = (nameOrFunction) => {\n    const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n    if (typeof fn === `undefined`) {\n        const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${nameOrFunction}'`) : new Error(`Easing function not found`);\n        throw error;\n    }\n    return fn;\n};\n/**\n * Creates a new easing by name\n *\n * ```js\n * const e = Easings.create(`circInOut`, 1000, elapsedMillisecondsAbsolute);\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration (meaning depends on timer source)\n * @param timerSource Timer source\n * @returns\n */\n// const create = function (\n//   nameOrFunction: EasingName | ((v: number) => number),\n//   duration: number,\n//   timerSource: TimerSource\n// ): Easing {\n//   const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n//   if (fn === undefined) {\n//     const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${ nameOrFunction }'`) : new Error(`Easing function not found`);\n//     throw error;\n//   }\n//   // Get a relative version of timer\n//   const timer = relativeTimer(duration, {\n//     timer: timerSource(),\n//     clampValue: true,\n//   });\n//   let startCount = 1;\n//   return {\n//     get isDone() {\n//       return timer.isDone;\n//     },\n//     get runState() {\n//       if (timer.isDone) return `idle`;\n//       return `scheduled`;\n//     },\n//     /**\n//      * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n//      */\n//     get startCount() {\n//       return startCount;\n//     },\n//     get startCountTotal() {\n//       return startCount;\n//     },\n//     compute: () => {\n//       const relative = timer.elapsed;\n//       return fn(relative);\n//     },\n//     reset: () => {\n//       timer.reset();\n//       startCount++;\n//     },\n//   };\n// };\nlet easingsMap;\n/**\n * Returns an easing function by name. Throws an error if\n * easing is not found.\n *\n * ```js\n * const fn = Easings.get(`sineIn`);\n * // Returns 'eased' transformation of 0.5\n * fn(0.5);\n * ```\n * @param easingName eg `sineIn`\n * @returns Easing function\n */\nexport const get = function (easingName) {\n    resultThrow(stringTest(easingName, `non-empty`, `easingName`));\n    const found = cacheEasings().get(easingName.toLowerCase());\n    if (found === undefined)\n        throw new Error(`Easing not found: '${easingName}'`);\n    return found;\n};\n// Cache named easings\nfunction cacheEasings() {\n    if (easingsMap === undefined) {\n        easingsMap = new Map();\n        for (const [k, v] of Object.entries(Named)) {\n            easingsMap.set(k.toLowerCase(), v);\n        }\n        return easingsMap;\n    }\n    else\n        return easingsMap;\n}\n/**\n * Iterate over available easings.\n * @private\n * @returns Returns list of available easing names\n */\nexport function* getEasingNames() {\n    const map = cacheEasings();\n    yield* map.keys();\n}\n;\n","export const adsrStateTransitions = Object.freeze({\n    attack: [`decay`, `release`],\n    decay: [`sustain`, `release`],\n    sustain: [`release`],\n    release: [`complete`],\n    complete: null,\n});\n","import { SimpleEventEmitter } from '@ixfx/events';\nimport { elapsedMillisecondsAbsolute } from '@ixfx/flow';\nimport { adsrStateTransitions } from './Types.js';\nimport { StateMachineWithEvents } from '@ixfx/flow/state-machine';\nexport const defaultAdsrTimingOpts = Object.freeze({\n    attackDuration: 600,\n    decayDuration: 200,\n    releaseDuration: 800,\n    shouldLoop: false\n});\n/**\n * Base class for an ADSR envelope.\n *\n * It outputs values on a scale of 0..1 corresponding to each phase.\n */\nexport class AdsrBase extends SimpleEventEmitter {\n    #sm;\n    #timeSource;\n    #timer;\n    #holding;\n    #holdingInitial;\n    #disposed = false;\n    #triggered = false;\n    attackDuration;\n    decayDuration;\n    releaseDuration;\n    decayDurationTotal;\n    /**\n     * If _true_ envelope will loop\n     */\n    shouldLoop;\n    constructor(opts = {}) {\n        super();\n        this.attackDuration = opts.attackDuration ?? defaultAdsrTimingOpts.attackDuration;\n        this.decayDuration = opts.decayDuration ?? defaultAdsrTimingOpts.decayDuration;\n        this.releaseDuration = opts.releaseDuration ?? defaultAdsrTimingOpts.releaseDuration;\n        this.shouldLoop = opts.shouldLoop ?? defaultAdsrTimingOpts.shouldLoop;\n        this.#sm = new StateMachineWithEvents(adsrStateTransitions, { initial: `attack` });\n        this.#sm.addEventListener(`change`, (event) => {\n            // Reset timer on release\n            if (event.newState === `release` && this.#holdingInitial) {\n                this.#timer?.reset();\n            }\n            super.fireEvent(`change`, event);\n        });\n        this.#sm.addEventListener(`stop`, (event) => {\n            super.fireEvent(`complete`, event);\n        });\n        this.#timeSource = () => elapsedMillisecondsAbsolute();\n        this.#holding = this.#holdingInitial = false;\n        this.decayDurationTotal = this.attackDuration + this.decayDuration;\n    }\n    dispose() {\n        if (this.#disposed)\n            return;\n        this.#sm.dispose();\n    }\n    get isDisposed() {\n        return this.#disposed;\n    }\n    /**\n     * Changes state based on timer status\n     * @returns _True_ if state was changed\n     */\n    switchStateIfNeeded(allowLooping) {\n        if (this.#timer === undefined)\n            return false;\n        let elapsed = this.#timer.elapsed;\n        const wasHeld = this.#holdingInitial && !this.#holding;\n        // Change through states for as long as needed\n        let hasChanged = false;\n        //console.log(`AdsrBase.switchStateIfNeeded elapsed: ${ elapsed } wasHeld: ${ wasHeld }`);\n        let state = this.#sm.state;\n        do {\n            hasChanged = false;\n            state = this.#sm.state;\n            //console.log(`  AdsrBase.switchStateIfNeeded: ${ state }`);\n            switch (state) {\n                case `attack`: {\n                    if (elapsed > this.attackDuration || wasHeld) {\n                        this.#sm.next();\n                        hasChanged = true;\n                    }\n                    break;\n                }\n                case `decay`: {\n                    if (elapsed > this.decayDurationTotal || wasHeld) {\n                        this.#sm.next();\n                        hasChanged = true;\n                    }\n                    break;\n                }\n                case `sustain`: {\n                    if (!this.#holding || wasHeld) {\n                        elapsed = 0;\n                        this.#sm.next();\n                        this.#timer.reset();\n                        hasChanged = true;\n                    }\n                    break;\n                }\n                case `release`: {\n                    if (elapsed > this.releaseDuration) {\n                        this.#sm.next();\n                        hasChanged = true;\n                    }\n                    break;\n                }\n                case `complete`: {\n                    if (this.shouldLoop && allowLooping) {\n                        this.trigger(this.#holdingInitial);\n                    }\n                }\n            }\n        } while (hasChanged && state !== `complete`);\n        return hasChanged;\n    }\n    /**\n     * Computes a stage's progress from 0-1\n     * @param allowStateChange\n     * @returns\n     */\n    computeRaw(allowStateChange = true, allowLooping = true) {\n        if (this.#timer === undefined) {\n            return [undefined, 0, this.#sm.state];\n        }\n        // Change state if necessary based on elapsed time\n        if (allowStateChange)\n            this.switchStateIfNeeded(allowLooping);\n        const previousStage = this.#sm.state;\n        const elapsed = this.#timer.elapsed;\n        let relative = 0;\n        const state = this.#sm.state;\n        switch (state) {\n            case `attack`: {\n                relative = elapsed / this.attackDuration;\n                break;\n            }\n            case `decay`: {\n                relative = (elapsed - this.attackDuration) / this.decayDuration;\n                break;\n            }\n            case `sustain`: {\n                relative = 1;\n                break;\n            }\n            case `release`: {\n                relative = Math.min(elapsed / this.releaseDuration, 1);\n                break;\n            }\n            case `complete`: {\n                return [`complete`, 1, previousStage];\n            }\n            default: {\n                throw new Error(`State machine in unknown state: ${state}`);\n            }\n        }\n        return [state, relative, previousStage];\n    }\n    /**\n     * Returns _true_ if envelope has finished\n     */\n    get isDone() {\n        return this.#sm.isDone;\n    }\n    onTrigger() {\n        /* no op */\n    }\n    /**\n     * Triggers envelope, optionally _holding_ it.\n     *\n     * If `hold` is _false_ (default), envelope will run through all stages,\n     * but sustain stage won't have an affect.\n     *\n     * If `hold` is _true_, it will run to, and stay at the sustain stage.\n     * Use {@link release} to later release the envelope.\n     *\n     * If event is already trigged it will be _retriggered_.\n     * Initial value depends on `opts.retrigger`\n     * * _false_ (default): envelope continues at current value.\n     * * _true_: envelope value resets to `opts.initialValue`.\n     *\n     * @param hold If _true_ envelope will hold at sustain stage\n     */\n    trigger(hold = false) {\n        this.onTrigger();\n        this.#triggered = true;\n        this.#sm.reset();\n        this.#timer = this.#timeSource();\n        this.#holding = hold;\n        this.#holdingInitial = hold;\n    }\n    get hasTriggered() {\n        return this.#triggered;\n    }\n    compute() {\n        /* no-op */\n    }\n    /**\n     * Release if 'trigger(true)' was previouslly called.\n     * Has no effect if not triggered or held.\n     * @returns\n     */\n    release() {\n        if (this.isDone || !this.#holdingInitial)\n            return; // Was never holding or done\n        // Setting holding flag to false, computeRaw will change state\n        this.#holding = false;\n        this.compute();\n    }\n}\n","import { Paths, Beziers } from '@ixfx/geometry';\nimport { scale } from '@ixfx/numbers';\nimport { AdsrBase } from './AdsrBase.js';\nexport const defaultAdsrOpts = Object.freeze({\n    attackBend: -1,\n    decayBend: -0.3,\n    releaseBend: -0.3,\n    peakLevel: 1,\n    initialLevel: 0,\n    sustainLevel: 0.6,\n    releaseLevel: 0,\n    retrigger: false\n});\nexport class AdsrIterator {\n    adsr;\n    constructor(adsr) {\n        this.adsr = adsr;\n    }\n    next(...args) {\n        if (!this.adsr.hasTriggered) {\n            this.adsr.trigger();\n        }\n        const c = this.adsr.compute();\n        return {\n            value: c[1],\n            done: c[0] === `complete`\n        };\n    }\n    get [Symbol.toStringTag]() {\n        return `Generator`;\n    }\n}\n/**\n * ADSR (Attack Decay Sustain Release) envelope. An envelope is a value that changes over time,\n * usually in response to an intial trigger.\n *\n * [See the ixfx Guide on Envelopes](https://ixfx.fun/modulation/envelopes/introduction/).\n *\n * @example Setup\n * ```js\n * const env = new Envelopes.Adsr({\n *  attackDuration: 1000,\n *  decayDuration: 200,\n *  sustainDuration: 100\n * });\n * ```\n *\n * Options for envelope are as follows:\n *\n * ```js\n * initialLevel?: number\n * attackBend: number\n * attackDuration: number\n * decayBend: number\n * decayDuration:number\n * sustainLevel: number\n * releaseBend: number\n * releaseDuration: number\n * releaseLevel?: number\n * peakLevel: number\n * retrigger?: boolean\n * shouldLoop: boolean\n * ```\n *\n * If `retrigger` is _false_ (default), a re-triggered envelope continues at current value\n * rather than resetting to `initialLevel`.\n *\n * If `shouldLoop` is true, envelope loops until `release()` is called.\n *\n * @example Using\n * ```js\n * env.trigger(); // Start envelope\n * ...\n * // Get current value of envelope\n * const [state, scaled, raw] = env.compute();\n * ```\n *\n * * `state` is a string, one of the following: 'attack', 'decay', 'sustain', 'release', 'complete'\n * * `scaled` is a value scaled according to the stage's _levels_\n * * `raw` is the progress from 0 to 1 within a stage. ie. 0.5 means we're halfway through a stage.\n *\n * Instead of `compute()`, most usage of the envelope is just fetching the `value` property, which returns the same scaled value of `compute()`:\n *\n * ```js\n * const value = env.value; // Get scaled number\n * ```\n *\n * @example Hold & release\n * ```js\n * env.trigger(true);   // Pass in true to hold\n * ...envelope will stop at sustain stage...\n * env.release();      // Release into decay\n * ```\n *\n * Check if it's done:\n *\n * ```js\n * env.isDone; // True if envelope is completed\n * ```\n *\n * Envelope has events to track activity: 'change' and 'complete':\n *\n * ```\n * env.addEventListener(`change`, ev => {\n *  console.log(`Old: ${evt.oldState} new: ${ev.newState}`);\n * })\n * ```\n *\n * It's also possible to iterate over the values of the envelope:\n * ```js\n * const env = new Envelopes.Adsr();\n * for await (const v of env) {\n *  // v is the numeric value\n *  await Flow.sleep(100); // Want to pause a little to give envelope time to run\n * }\n * // Envelope has finished\n * ```\n */\nexport class Adsr extends AdsrBase {\n    attackPath;\n    decayPath;\n    releasePath;\n    initialLevel;\n    peakLevel;\n    releaseLevel;\n    sustainLevel;\n    attackBend;\n    decayBend;\n    releaseBend;\n    initialLevelOverride;\n    retrigger;\n    releasedAt;\n    constructor(opts = {}) {\n        super(opts);\n        this.retrigger = opts.retrigger ?? defaultAdsrOpts.retrigger;\n        this.initialLevel = opts.initialLevel ?? defaultAdsrOpts.initialLevel;\n        this.peakLevel = opts.peakLevel ?? defaultAdsrOpts.peakLevel;\n        this.releaseLevel = opts.releaseLevel ?? defaultAdsrOpts.releaseLevel;\n        this.sustainLevel = opts.sustainLevel ?? defaultAdsrOpts.sustainLevel;\n        this.attackBend = opts.attackBend ?? defaultAdsrOpts.attackBend;\n        this.releaseBend = opts.releaseBend ?? defaultAdsrOpts.releaseBend;\n        this.decayBend = opts.decayBend ?? defaultAdsrOpts.decayBend;\n        const max = 1;\n        this.attackPath = Beziers.toPath(Beziers.quadraticSimple({ x: 0, y: this.initialLevel }, { x: max, y: this.peakLevel }, -this.attackBend));\n        this.decayPath = Beziers.toPath(Beziers.quadraticSimple({ x: 0, y: this.peakLevel }, { x: max, y: this.sustainLevel }, -this.decayBend));\n        this.releasePath = Beziers.toPath(Beziers.quadraticSimple({ x: 0, y: this.sustainLevel }, { x: max, y: this.releaseLevel }, -this.releaseBend));\n    }\n    onTrigger() {\n        this.initialLevelOverride = undefined;\n        if (!this.retrigger) {\n            const [_stage, scaled, _raw] = this.compute(true, false);\n            //console.log(`Adsr stage: ${ _stage } scaled: ${ scaled } raw: ${ _raw }`);\n            if (!Number.isNaN(scaled) && scaled > 0) {\n                this.initialLevelOverride = scaled;\n            }\n        }\n    }\n    [Symbol.iterator]() {\n        return new AdsrIterator(this);\n    }\n    /**\n     * Returns the scaled value\n     * Same as .compute()[1]\n     */\n    get value() {\n        return this.compute(true)[1];\n    }\n    /**\n     * Compute value of envelope at this point in time.\n     *\n     * Returns an array of [stage, scaled, raw]. Most likely you want to use {@link value} to just get the scaled value.\n     * @param allowStateChange If true (default) envelope will be allowed to change state if necessary before returning value\n     */\n    compute(allowStateChange = true, allowLooping = true) {\n        const [stage, amt] = super.computeRaw(allowStateChange, allowLooping);\n        //console.log(`Adsr.compute: stage: ${ stage } amt: ${ amt }!`);\n        // Stage is undefined when envelope is complete or underlying timer is undefined\n        if (stage === undefined)\n            return [undefined, Number.NaN, Number.NaN];\n        let v;\n        switch (stage) {\n            case `attack`: {\n                v = this.attackPath.interpolate(amt).y;\n                if (this.initialLevelOverride !== undefined) {\n                    v = scale(v, 0, 1, this.initialLevelOverride, 1);\n                }\n                this.releasedAt = v;\n                break;\n            }\n            case `decay`: {\n                v = this.decayPath.interpolate(amt).y;\n                this.releasedAt = v;\n                break;\n            }\n            case `sustain`: {\n                v = this.sustainLevel;\n                this.releasedAt = v;\n                break;\n            }\n            case `release`: {\n                v = this.releasePath.interpolate(amt).y;\n                // Bound release level to the amp level that we released at.\n                // ie. when release happens before a stage completes\n                if (this.releasedAt !== undefined) {\n                    v = scale(v, 0, this.sustainLevel, 0, this.releasedAt);\n                }\n                break;\n            }\n            case `complete`: {\n                v = this.releaseLevel;\n                this.releasedAt = undefined;\n                break;\n            }\n            default: {\n                throw new Error(`Unknown state: ${stage}`);\n            }\n        }\n        return [stage, v, amt];\n    }\n}\n","import { Adsr } from './Adsr.js';\nimport { resolveWithFallbackSync } from '@ixfx/core';\nimport { repeat } from '@ixfx/flow';\nexport * from './Types.js';\nexport * from './Adsr.js';\nexport * from './AdsrBase.js';\n/**\n * Returns a function that iterates over an envelope\n * ```js\n * const e = Envelopes.adsr();\n *\n * e(); // Yields current value\n * ```\n *\n * Starts the envelope the first time the return function is called.\n * When the envelope finishes, it continues to return the `releaseLevel` of the envelope.\n *\n * Options can be provided to set the shape of the envelope as usual, eg:\n * ```js\n * const e = Envelopes.adsr({\n *  attackDuration: 1000,\n *  releaseDuration: 500\n * });\n * ```\n * @param opts\n * @returns\n */\nexport const adsr = (opts = {}) => {\n    const envelope = new Adsr(opts);\n    const finalValue = envelope.releaseLevel;\n    const iterator = envelope[Symbol.iterator]();\n    return () => resolveWithFallbackSync(iterator, { overrideWithLast: true, value: finalValue });\n};\n/**\n * Creates and runs an envelope, sampling its values at `sampleRateMs`.\n * Note that if the envelope loops, iterator never returns.\n *\n * @example Init\n * ```js\n * import { Envelopes } from '@ixfx/modulation.js';\n * import { IterableAsync } from  '@ixfx/iterable.js';\n *\n * const opts = {\n *  attackDuration: 1000,\n *  releaseDuration: 1000,\n *  sustainLevel: 1,\n *  attackBend: 1,\n *  decayBend: -1\n * };\n * ```\n *\n * ```js\n * //  Add data to array\n * // Sample an envelope every 20ms into an array\n * const data = await IterableAsync.toArray(Envelopes.adsrIterable(opts, 20));\n * ```\n *\n * ```js\n * // Iterate with `for await`\n * // Work with values as sampled\n * for await (const v of Envelopes.adsrIterable(opts, 5)) {\n *  // Work with envelope value `v`...\n * }\n * ```\n * @param opts Envelope options\n * @returns\n */\nexport async function* adsrIterable(opts) {\n    const envelope = new Adsr(opts.env);\n    const sampleRateMs = opts.sampleRateMs ?? 100;\n    envelope.trigger();\n    const r = repeat(() => envelope.value, {\n        while: () => !envelope.isDone,\n        delay: sampleRateMs,\n        signal: opts.signal,\n    });\n    for await (const v of r) {\n        yield v;\n    }\n}\n","/**\n * Acknowledgements: much of the work here is an adapation from Daniel Shiffman's excellent _The Nature of Code_ website.\n */\nimport { Points, Polar, Rects } from '@ixfx/geometry';\nimport { clamp } from '@ixfx/numbers';\nimport { interpolateAngle } from '@ixfx/numbers';\n/**\n * Throws an error if `t` is not of the `ForceAffected` shape.\n * @param t\n * @param name\n */\nexport const guard = (t, name = `t`) => {\n    if (t === undefined) {\n        throw new Error(`Parameter ${name} is undefined. Expected ForceAffected`);\n    }\n    if (t === null) {\n        throw new Error(`Parameter ${name} is null. Expected ForceAffected`);\n    }\n    if (typeof t !== `object`) {\n        throw new TypeError(`Parameter ${name} is type ${typeof t}. Expected object of shape ForceAffected`);\n    }\n};\n/**\n * `constrainBounce` yields a function that affects `t`'s position and velocity such that it\n * bounces within bounds.\n *\n * ```js\n * // Setup bounce with area constraints\n * // Reduce velocity by 10% with each impact\n * const b = constrainBounce({ width:200, height:500 }, 0.9);\n *\n * // Thing\n * const t = {\n *  position: { x: 50,  y: 50 },\n *  velocity: { x: 0.3, y: 0.01 }\n * };\n *\n * // `b` returns an altereted version of `t`, with the\n * // bounce logic applied.\n * const bounced = b(t);\n * ```\n *\n * `dampen` parameter allows velocity to be dampened with each bounce. A value\n * of 0.9 for example reduces velocity by 10%. A value of 1.1 will increase velocity by\n * 10% with each bounce.\n * @param bounds Constraints of area\n * @param dampen How much to dampen velocity by. Defaults to 1 meaning there is no damping.\n * @returns A function that can perform bounce logic\n */\nexport const constrainBounce = (bounds, dampen = 1) => {\n    if (!bounds)\n        bounds = { width: 1, height: 1 };\n    const minX = Rects.getEdgeX(bounds, `left`);\n    const maxX = Rects.getEdgeX(bounds, `right`);\n    const minY = Rects.getEdgeY(bounds, `top`);\n    const maxY = Rects.getEdgeY(bounds, `bottom`);\n    return (t) => {\n        const position = computePositionFromVelocity(t.position ?? Points.Empty, t.velocity ?? Points.Empty);\n        let velocity = t.velocity ?? Points.Empty;\n        let { x, y } = position;\n        if (x > maxX) {\n            x = maxX;\n            velocity = Points.invert(Points.multiplyScalar(velocity, dampen), `x`);\n        }\n        else if (x < minX) {\n            x = minX;\n            velocity = Points.invert(Points.multiplyScalar(velocity, dampen), `x`);\n        }\n        if (y > maxY) {\n            y = maxY;\n            velocity = Points.multiplyScalar(Points.invert(velocity, `y`), dampen);\n        }\n        else if (position.y < minY) {\n            y = minY;\n            velocity = Points.invert(Points.multiplyScalar(velocity, dampen), `y`);\n        }\n        return Object.freeze({\n            ...t,\n            position: { x, y },\n            velocity,\n        });\n    };\n};\n/**\n * For a given set of attractors, returns a function that a sets acceleration of attractee.\n * Keep note though that this bakes-in the values of the attractor, it won't reflect changes to their state. For dynamic\n * attractors, it might be easier to use `computeAttractionForce`.\n *\n * @example Force\n * ```js\n * const f = Forces.attractionForce(sun, gravity);\n * earth = Forces.apply(earth, f);\n * ```\n *\n * @example Everything mutually attracted\n * ```js\n * // Create a force with all things as attractors.\n * const f = Forces.attractionForce(things, gravity);\n * // Apply force to all things.\n * // The function returned by attractionForce will automatically ignore self-attraction\n * things = things.map(a => Forces.apply(a, f));\n * ```\n * @param attractors\n * @param gravity\n * @param distanceRange\n * @returns\n */\nexport const attractionForce = (attractors, gravity, distanceRange = {}) => (attractee) => {\n    let accel = attractee.acceleration ?? Points.Empty;\n    for (const a of attractors) {\n        if (a === attractee)\n            continue;\n        const f = computeAttractionForce(a, attractee, gravity, distanceRange);\n        accel = Points.sum(accel, f);\n    }\n    return {\n        ...attractee,\n        acceleration: accel,\n    };\n};\n/**\n * Computes the attraction force between two things.\n * Value for `gravity` will depend on what range is used for `mass`. It's probably a good idea\n * to keep mass to mean something relative - ie 1 is 'full' mass, and adjust the `gravity`\n * value until it behaves as you like. Keeping mass in 0..1 range makes it easier to apply to\n * visual properties later.\n *\n * @example Attractee and attractor, gravity 0.005\n * ```js\n * const attractor = { position: { x:0.5, y:0.5 }, mass: 1 };\n * const attractee = { position: Points.random(), mass: 0.01 };\n * attractee = Forces.apply(attractee, Forces.computeAttractionForce(attractor, attractee, 0.005));\n * ```\n *\n * @example Many attractees for one attractor, gravity 0.005\n * ```js\n * attractor =  { position: { x:0.5, y:0.5 }, mass: 1 };\n * attractees = attractees.map(a => Forces.apply(a, Forces.computeAttractionForce(attractor, a, 0.005)));\n * ```\n *\n * @example Everything mutually attracted\n * ```js\n * // Create a force with all things as attractors.\n * const f = Forces.attractionForce(things, gravity);\n * // Apply force to all things.\n * // The function returned by attractionForce will automatically ignore self-attraction\n * things = things.map(a => Forces.apply(a, f));\n * ```\n *\n * `attractor` thing attracting (eg, earth)\n * `attractee` thing being attracted (eg. satellite)\n *\n *\n * `gravity` will have to be tweaked to taste.\n * `distanceRange` clamps the computed distance. This affects how tightly the particles will orbit and can also determine speed. By default it is 0.001-0.7\n * @param attractor Attractor (eg earth)\n * @param attractee Attractee (eg satellite)\n * @param gravity Gravity constant\n * @param distanceRange Min/max that distance is clamped to.\n * @returns\n */\nexport const computeAttractionForce = (attractor, attractee, gravity, distanceRange = {}) => {\n    if (attractor.position === undefined) {\n        throw new Error(`attractor.position not set`);\n    }\n    if (attractee.position === undefined) {\n        throw new Error(`attractee.position not set`);\n    }\n    const distributionRangeMin = distanceRange.min ?? 0.01;\n    const distributionRangeMax = distanceRange.max ?? 0.7;\n    // Vector between objects\n    const f = Points.normalise(Points.subtract(attractor.position, attractee.position));\n    // Distance\n    const d = clamp(Points.distance(f), distributionRangeMin, distributionRangeMax);\n    // Multiply vector by gravity, scaled by mass of things and distance\n    return Points.multiplyScalar(f, (gravity * (attractor.mass ?? 1) * (attractee.mass ?? 1)) / (d * d));\n};\n/**\n * A force that moves a thing toward `targetPos`.\n *\n * ```js\n * const t = Forces.apply(t, Forces.targetForce(targetPos));\n * ```\n * @param targetPos\n * @param opts\n * @returns\n */\nexport const targetForce = (targetPos, opts = {}) => {\n    const fn = (t) => {\n        const accel = computeAccelerationToTarget(targetPos, t.position ?? { x: 0.5, y: 0.5 }, opts);\n        return {\n            ...t,\n            acceleration: Points.sum(t.acceleration ?? Points.Empty, accel),\n        };\n    };\n    return fn;\n};\n/**\n * Returns `pt` with x and y set to `setpoint` if either's absolute value is below `v`\n * @param pt\n * @param v\n * @returns\n */\n// const roundTo = (pt: Point, v: number, setpoint: number): Point => {\n//   const x = Math.abs(pt.x);\n//   const y = Math.abs(pt.y);\n//   if (x < v && y < v) return { x: setpoint, y: setpoint };\n//   if (x < v) return { x: setpoint, y: pt.y };\n//   if (y < v) return { x: pt.x, y: setpoint };\n//   return pt;\n// };\n/**\n * Apply a series of force functions or forces to `t`. Null/undefined entries are skipped silently.\n * It also updates the velocity and position of the returned version of `t`.\n *\n * ```js\n * // Wind adds acceleration. Force is dampened by mass\n * const wind = Forces.accelerationForce({ x: 0.00001, y: 0 }, `dampen`);\n *\n * // Gravity adds acceleration. Force is magnified by mass\n * const gravity = Forces.accelerationForce({ x: 0, y: 0.0001 }, `multiply`);\n *\n * // Friction is calculated based on velocity. Force is magnified by mass\n * const friction = Forces.velocityForce(0.00001, `multiply`);\n *\n *  // Flip movement velocity if we hit a wall. And dampen it by 10%\n * const bouncer = Forces.constrainBounce({ width: 1, height: 1 }, 0.9);\n *\n * let t = {\n *  position: Points.random(),\n *  mass: 0.1\n * };\n *\n * // Apply list of forces, returning a new version of the thing\n * t = Forces.apply(t,\n *   gravity,\n *   wind,\n *   friction,\n *   bouncer\n * );\n * ```\n */\nexport const apply = (t, ...accelForces) => {\n    if (t === undefined)\n        throw new Error(`t parameter is undefined`);\n    for (const f of accelForces) {\n        if (f === null || f === undefined)\n            continue;\n        t = typeof f === `function` ? f(t) : {\n            ...t,\n            acceleration: Points.sum(t.acceleration ?? Points.Empty, f),\n        };\n    }\n    // Integate velocity from acceleration\n    const velo = computeVelocity(t.acceleration ?? Points.Empty, t.velocity ?? Points.Empty);\n    // Compute position\n    const pos = computePositionFromVelocity(t.position ?? Points.Empty, velo);\n    const ff = {\n        ...t,\n        position: pos,\n        velocity: velo,\n        // Clear accel, because it has been integrated into velocity\n        acceleration: Points.Empty,\n    };\n    return ff;\n};\n/**\n * Apples `vector` to acceleration, scaling according to mass, based on the `mass` option.\n * It returns a function which can later be applied to a thing.\n *\n * ```js\n * // Acceleration vector of (0.1, 0), ie moving straight on horizontal axis\n * const f = Forces.accelerationForce({ x:0.1, y:0 }, `dampen`);\n *\n * // Thing to move\n * let t = { position: ..., acceleration: ... }\n *\n * // Apply force\n * t = f(t);\n * ```\n * @param vector\n * @returns Force function\n */\nexport const accelerationForce = (vector, mass = `ignored`) => (t) => Object.freeze({\n    ...t,\n    acceleration: massApplyAccel(vector, t, mass), //Points.sum(t.acceleration ?? Points.Empty, op(t.mass ?? 1))\n});\n/**\n * Returns an acceleration vector with mass either dampening or multiplying it.\n * The passed-in `thing` is not modified.\n *\n * ```js\n * // Initial acceleration vector\n * const accel = { x: 0.1, y: 0};\n *\n * // Thing being moved\n * const thing = { mass: 0.5, position: ..., acceleration: ... }\n *\n * // New acceleration vector, affected by mass of `thing`\n * const accelWithMass = massApplyAccel(accel, thing, `dampen`);\n * ```\n * Mass of thing can be factored in, according to `mass` setting. Use `dampen`\n * to reduce acceleration with greater mass of thing. Use `multiply` to increase\n * the effect of acceleration with a greater mass of thing. `ignored` means\n * mass is not taken into account.\n *\n * If `t` has no mass, the `mass` setting is ignored.\n *\n * This function is used internally by the predefined forces.\n *\n * @param vector Vector force\n * @param thing Thing being affected\n * @param mass How to factor in mass of thing (default ignored)\n * @returns Acceleration vector\n */\nconst massApplyAccel = (vector, thing, mass = `ignored`) => {\n    let op;\n    switch (mass) {\n        case `dampen`: {\n            op = (mass) => Points.divide(vector, mass, mass);\n            break;\n        }\n        case `multiply`: {\n            op = (mass) => Points.multiply(vector, mass, mass);\n            break;\n        }\n        case `ignored`: {\n            op = (_mass) => vector;\n            break;\n        }\n        default: {\n            throw new Error(`Unknown 'mass' parameter '${mass}. Expected 'dampen', 'multiply' or 'ignored'`);\n        }\n    }\n    return Points.sum(thing.acceleration ?? Points.Empty, op(thing.mass ?? 1));\n    // if (t.mass) {\n    //   if (dampen) return Points.sum(t.acceleration ?? Points.Empty, Points.divide(v, t.mass ?? 1));\n    //   else return Points.sum(t.acceleration ?? Points.Empty, Points.multiply(v, t.mass ?? 1));\n    // }\n    // return v;\n};\n/**\n * A force based on the square of the thing's velocity.\n * It's like {@link velocityForce}, but here the velocity has a bigger impact.\n *\n * ```js\n * const thing = {\n *  position: { x: 0.5, y:0.5 },\n *  velocity: { x: 0.001, y:0 }\n * };\n * const drag = magnitudeForce(0.1);\n *\n * // Apply drag force to thing, returning result\n * const t = Forces.apply(thing, drag);\n * ```\n * @param force Force value\n * @param mass How to factor in mass\n * @returns Function that computes force\n */\nexport const magnitudeForce = (force, mass = `ignored`) => (t) => {\n    if (t.velocity === undefined)\n        return t;\n    const mag = Points.distance(Points.normalise(t.velocity));\n    const magSq = force * mag * mag;\n    const vv = Points.multiplyScalar(Points.invert(t.velocity), magSq);\n    return Object.freeze({\n        ...t,\n        acceleration: massApplyAccel(vv, t, mass),\n    });\n};\n/**\n * Null force does nothing\n * @returns A force that does nothing\n */\nexport const nullForce = (t) => t;\n/**\n * Force calculated from velocity of object. Reads velocity and influences acceleration.\n *\n * ```js\n * let t = { position: Points.random(), mass: 0.1 };\n * const friction = velocityForce(0.1, `dampen`);\n *\n * // Apply force, updating position and velocity\n * t = Forces.apply(t, friction);\n * ```\n * @param force Force\n * @param mass How to factor in mass\n * @returns Function that computes force\n */\nexport const velocityForce = (force, mass) => {\n    // Invert velocity and then multiply by force\n    const pipeline = Points.pipeline(\n    // Points.normalise,\n    Points.invert, (v) => Points.multiplyScalar(v, force));\n    return (t) => {\n        if (t.velocity === undefined)\n            return t;\n        // Apply pipeline\n        const v = pipeline(t.velocity);\n        return Object.freeze({\n            ...t,\n            acceleration: massApplyAccel(v, t, mass),\n        });\n    };\n};\n/**\n * Sets angle, angularVelocity and angularAcceleration based on\n *  angularAcceleration, angularVelocity, angle\n * @returns\n */\nexport const angularForce = () => (t) => {\n    const accumulator = t.angularAcceleration ?? 0;\n    const vel = t.angularVelocity ?? 0;\n    const angle = t.angle ?? 0;\n    const v = vel + accumulator;\n    const a = angle + v;\n    return Object.freeze({\n        ...t,\n        angle: a,\n        angularVelocity: v,\n        angularAcceleration: 0,\n    });\n};\n// export const positionFromAngleForce = () => (t:ForceAffected) => {\n//   return Object.freeze({\n//     ...t,\n//     position: computePositionFromAngle()\n//   });\n// };\n/**\n * Yields a force function that applies the thing's acceleration.x to its angular acceleration.\n * @param scaling Use this to scale the accel.x value. Defaults to 20 (ie accel.x*20). Adjust if rotation is too much or too little\n * @returns\n */\nexport const angleFromAccelerationForce = (scaling = 20) => (t) => {\n    const accel = t.acceleration ?? Points.Empty;\n    return Object.freeze({\n        ...t,\n        angularAcceleration: accel.x * scaling,\n    });\n};\n/**\n * Yields a force function that applies the thing's velocity to its angle.\n * This will mean it points in the direction of travel.\n * @param interpolateAmt If provided, the angle will be interpolated toward by this amount. Defaults to 1, no interpolation\n * @returns\n */\nexport const angleFromVelocityForce = (interpolateAmt = 1) => (t) => {\n    const a = Points.angleRadian(t.velocity ?? Points.Empty);\n    return Object.freeze({\n        ...t,\n        angle: interpolateAmt < 1\n            ? interpolateAngle(interpolateAmt, t.angle ?? 0, a)\n            : a,\n    });\n};\n/**\n * Spring force\n *\n *  * ```js\n * // End of spring that moves\n * let thing = {\n *   position: { x: 1, y: 0.5 },\n *   mass: 0.1\n * };\n *\n * // Anchored other end of spring\n * const pinnedAt = {x: 0.5, y: 0.5};\n *\n * // Create force: length of 0.4\n * const springForce = Forces.springForce(pinnedAt, 0.4);\n *\n * continuously(() => {\n *  // Apply force\n *  thing = Forces.apply(thing, springForce);\n * }).start();\n * ```\n * [Read more](https://www.joshwcomeau.com/animation/a-friendly-introduction-to-spring-physics/)\n *\n * @param pinnedAt Anchored end of the spring\n * @param restingLength Length of spring-at-rest (default: 0.5)\n * @param k Spring stiffness (default: 0.0002)\n * @param damping Damping factor to apply, so spring slows over time. (default: 0.995)\n * @returns\n */\nexport const springForce = (pinnedAt, restingLength = 0.5, k = 0.0002, damping = 0.999) => (t) => {\n    const direction = Points.subtract(t.position ?? Points.Empty, pinnedAt);\n    const mag = Points.distance(direction);\n    const stretch = Math.abs(restingLength - mag);\n    const f = Points.pipelineApply(direction, Points.normalise, (p) => Points.multiplyScalar(p, -k * stretch));\n    const accel = massApplyAccel(f, t, `dampen`);\n    const velo = computeVelocity(accel ?? Points.Empty, t.velocity ?? Points.Empty);\n    const veloDamped = Points.multiply(velo, damping, damping);\n    return {\n        ...t,\n        velocity: veloDamped,\n        acceleration: Points.Empty,\n    };\n};\n/**\n * The pendulum force swings something back and forth.\n *\n * ```js\n * // Swinger\n * let thing = {\n *   position: { x: 1, y: 0.5 },\n *   mass: 0.1\n * };\n *\n * // Position thing swings from (middle of screen)\n * const pinnedAt = {x: 0.5, y: 0.5};\n *\n * // Create force: length of 0.4\n * const pendulumForce = Forces.pendulumForce(pinnedAt, { length: 0.4 });\n *\n * continuously(() => {\n *  // Apply force\n *  // Returns a new thing with recalculated angularVelocity, angle and position.\n *  thing = Forces.apply(thing, pendulumForce);\n * }).start();\n * ```\n *\n * [Read more](https://natureofcode.com/book/chapter-3-oscillation/)\n *\n * @param pinnedAt Location to swing from (x:0.5, y:0.5 default)\n * @param opts Options\n * @returns\n */\nexport const pendulumForce = (pinnedAt, opts = {}) => (t) => {\n    if (!pinnedAt)\n        pinnedAt = { x: 0, y: 0 };\n    const length = opts.length ?? Points.distance(pinnedAt, t.position ?? Points.Empty);\n    const speed = opts.speed ?? 0.001;\n    const damping = opts.damping ?? 0.995;\n    let angle = t.angle;\n    if (angle === undefined) {\n        if (t.position) {\n            angle = Points.angleRadian(pinnedAt, t.position) - Math.PI / 2;\n        }\n        else {\n            angle = 0; // Position wherever\n        }\n    }\n    const accel = ((-1 * speed) / length) * Math.sin(angle);\n    const v = (t.angularVelocity ?? 0) + accel;\n    angle += v;\n    return Object.freeze({\n        angularVelocity: v * damping,\n        angle,\n        position: computePositionFromAngle(length, angle + Math.PI / 2, pinnedAt),\n    });\n};\n/**\n * Compute velocity based on acceleration and current velocity\n * @param acceleration Acceleration\n * @param velocity Velocity\n * @param velocityMax If specified, velocity will be capped at this value\n * @returns\n */\nexport const computeVelocity = (acceleration, velocity, velocityMax) => {\n    const p = Points.sum(velocity, acceleration);\n    return velocityMax === undefined ? p : Points.clampMagnitude(p, velocityMax);\n};\n/**\n * Returns the acceleration to get from `currentPos` to `targetPos`.\n *\n * @example Barebones usage:\n * ```js\n * const accel = Forces.computeAccelerationToTarget(targetPos, currentPos);\n * const vel = Forces.computeVelocity(accel, currentVelocity);\n *\n * // New position:\n * const pos = Points.sum(currentPos, vel);\n * ```\n *\n * @example Implementation:\n * ```js\n * const direction = Points.subtract(targetPos, currentPos);\n * const accel = Points.multiply(direction, diminishBy);\n * ```\n * @param currentPos Current position\n * @param targetPos Target position\n * @param opts Options\n * @returns\n */\nexport const computeAccelerationToTarget = (targetPos, currentPos, opts = {}) => {\n    const diminishBy = opts.diminishBy ?? 0.001;\n    // Compare to current position of thing to get vector direction\n    const direction = Points.subtract(targetPos, currentPos);\n    if (opts.range && // If direction is less than range, return { x: 0, y: 0}\n        Points.compare(Points.abs(direction), opts.range) === -2) {\n        return Points.Empty;\n    }\n    // Diminish vector to make a meaningful acceleration\n    return Points.multiplyScalar(direction, diminishBy);\n};\n/**\n * Compute a new position based on existing position and velocity vector\n * @param position Position Current position\n * @param velocity Velocity vector\n * @returns Point\n */\nexport const computePositionFromVelocity = (position, velocity) => Points.sum(position, velocity);\n/**\n * Compute a position based on distance and angle from origin\n * @param distance Distance from origin\n * @param angleRadians Angle, in radians from origin\n * @param origin Origin point\n * @returns Point\n */\nexport const computePositionFromAngle = (distance, angleRadians, origin) => Polar.toCartesian(distance, angleRadians, origin);\nconst _angularForce = angularForce();\nconst _angleFromAccelerationForce = angleFromAccelerationForce();\n/**\n * A force that orients things according to direction of travel.\n *\n * Under the hood, it applies:\n * * angularForce,\n * * angleFromAccelerationForce, and\n * * angleFromVelocityForce\n * @param interpolationAmt\n * @returns\n */\nexport const orientationForce = (interpolationAmt = 0.5) => {\n    const angleFromVel = angleFromVelocityForce(interpolationAmt);\n    return (t) => {\n        t = _angularForce(t);\n        t = _angleFromAccelerationForce(t);\n        t = angleFromVel(t);\n        return t;\n    };\n};\n","/**\n * Creates an easing function using a simple cubic bezier defined by two points.\n *\n * Eg: https://cubic-bezier.com/#0,1.33,1,-1.25\n *  a:0, b: 1.33, c: 1, d: -1.25\n *\n * ```js\n * import { Easings } from \"@ixfx/modulation.js\";\n * // Time-based easing using bezier\n * const e = Easings.time(fromCubicBezier(1.33, -1.25), 1000);\n * e.compute();\n * ```\n * @param b\n * @param d\n * @returns Value\n */\nexport const cubicBezierShape = (b, d) => (t) => {\n    const s = 1 - t;\n    const s2 = s * s;\n    const t2 = t * t;\n    const t3 = t2 * t;\n    return 3 * b * s2 * t + 3 * d * s * t2 + t3;\n};\n","/**\n * WIP\n * Returns a {@link Drifter} that moves a value over time.\n *\n * It keeps track of how much time has elapsed, accumulating `driftAmtPerMs`.\n * The accumulated drift is wrapped on a 0..1 scale.\n * ```js\n * // Set up the drifer\n * const d = drif(0.001);\n *\n * d.update(1.0);\n * // Returns 1.0 + accumulated drift\n * ```\n * @param driftAmtPerMs\n * @returns\n */\nexport const drift = (driftAmtPerMs) => {\n    //eslint-disable-next-line functional/no-let\n    let lastChange = performance.now();\n    const update = (v = 1) => {\n        const elapsed = performance.now() - lastChange;\n        const amt = (driftAmtPerMs * elapsed) % 1;\n        lastChange = performance.now();\n        const calc = (v + amt) % 1;\n        return calc;\n    };\n    const reset = () => {\n        lastChange = performance.now();\n    };\n    return { update, reset };\n};\n","export const piPi = Math.PI * 2;\n","import { clamp, wrap } from \"@ixfx/numbers\";\nimport { ofTotal } from \"@ixfx/flow\";\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport { get as getEasing } from './easing/index.js';\nimport { piPi } from \"./util/pi-pi.js\";\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide on Interpolation](https://ixfx.fun/data/interpolation/overview/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * import { interpolate } from '@ixfx/numbers.js';\n * interpolate(0.5, 30, 60);\n * ```\n *\n * See also {@link interpolatorStepped} and {@link interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n *\n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n *\n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n *\n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * There are a few variations when calling `interpolate`, depending on what parameters are fixed.\n * * `interpolate(amount)`: returns a function that needs a & b\n * * `interpolate(a, b)`:  returns a function that needs the interpolation amount\n */\nexport function interpolate(pos1, pos2, pos3, pos4) {\n    let amountProcess;\n    let limits = `clamp`;\n    const handleAmount = (amount) => {\n        if (amountProcess)\n            amount = amountProcess(amount);\n        if (limits === undefined || limits === `clamp`) {\n            amount = clamp(amount);\n        }\n        else if (limits === `wrap`) {\n            if (amount > 1)\n                amount = amount % 1;\n            else if (amount < 0) {\n                amount = 1 + (amount % 1);\n            }\n        }\n        return amount;\n    };\n    const doTheEase = (_amt, _a, _b) => {\n        resultThrow(numberTest(_a, ``, `a`), numberTest(_b, ``, `b`), numberTest(_amt, ``, `amount`));\n        _amt = handleAmount(_amt);\n        return (1 - _amt) * _a + _amt * _b;\n    };\n    const readOpts = (o = {}) => {\n        if (o.easing) {\n            const easer = getEasing(o.easing);\n            if (!easer)\n                throw new Error(`Easing function '${o.easing}' not found`);\n            amountProcess = easer;\n        }\n        else if (o.transform) {\n            if (typeof o.transform !== `function`)\n                throw new Error(`Param 'transform' is expected to be a function. Got: ${typeof o.transform}`);\n            amountProcess = o.transform;\n        }\n        limits = o.limits ?? `clamp`;\n    };\n    const rawEase = (_amt, _a, _b) => (1 - _amt) * _a + _amt * _b;\n    if (typeof pos1 !== `number`)\n        throw new TypeError(`First param is expected to be a number. Got: ${typeof pos1}`);\n    if (typeof pos2 === `number`) {\n        let a;\n        let b;\n        if (pos3 === undefined || typeof pos3 === `object`) {\n            //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n            a = pos1;\n            b = pos2;\n            readOpts(pos3);\n            return (amount) => doTheEase(amount, a, b);\n        }\n        else if (typeof pos3 === `number`) {\n            //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n            a = pos2;\n            b = pos3;\n            readOpts(pos4);\n            return doTheEase(pos1, a, b);\n        }\n        else {\n            throw new Error(`Values for 'a' and 'b' not defined`);\n        }\n    }\n    else if (pos2 === undefined || typeof pos2 === `object`) {\n        //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n        const amount = handleAmount(pos1);\n        readOpts(pos2);\n        resultThrow(numberTest(amount, ``, `amount`));\n        return (aValue, bValue) => rawEase(amount, aValue, bValue);\n    }\n}\n;\n/**\n * Returns a function that interpolates from A to B.\n *\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link interpolatorInterval}\n * which steps on the basis of clock time.\n *\n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n *\n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n *\n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n *\n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n *\n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns\n */\nexport const interpolatorStepped = (incrementAmount, a = 0, b = 1, startInterpolationAt = 0, options) => {\n    let amount = startInterpolationAt;\n    return (retargetB, retargetA) => {\n        if (retargetB !== undefined)\n            b = retargetB;\n        if (retargetA !== undefined)\n            a = retargetA;\n        if (amount >= 1)\n            return b;\n        const value = interpolate(amount, a, b, options);\n        amount += incrementAmount;\n        return value;\n    };\n};\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from '@ixfx/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (amount, aRadians, bRadians, options) => {\n    const t = wrap(bRadians - aRadians, 0, piPi);\n    return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n/**\n * Interpolates between A->B over `duration`.\n * Given the same A & B values, steps will be larger if it's a longer\n * duration, and shorter if it's a smaller duration.\n *\n * A function is returned, which when invoked yields a value between A..B.\n *\n * Alternatively to step through by the same amount regardless\n * of time, use {@link interpolatorStepped}.\n *\n * ```js\n * // Interpolate from 0..1 over one minute\n * const v = interpolatorInterval({mins:1});\n * v(); // Compute current value\n * ```\n *\n * Use start and end points:\n * ```js\n * // Interpolate from 100-200 over 10 seconds\n * const v = interpolatorInterval({secs:10}, 100, 200);\n * v(); // Compute current value\n * ```\n * @param duration Duration for interpolation\n * @param a Start point\n * @param b End point\n * @param options Options for interpolation\n * @returns\n */\nexport const interpolatorInterval = (duration, a = 0, b = 1, options) => {\n    const durationProgression = ofTotal(duration, { clampValue: true });\n    return (retargetB, retargetA) => {\n        const amount = durationProgression();\n        if (retargetB !== undefined)\n            b = retargetB;\n        if (retargetA !== undefined)\n            a = retargetA;\n        if (amount >= 1)\n            return b;\n        const value = interpolate(amount, a, b, options);\n        return value;\n    };\n};\n","import { resultThrow, numberTest } from '@ixfx/guards';\nimport { clamp } from '@ixfx/numbers';\nimport { floatSource as randomFloatFunction, float as randomFloat } from '@ixfx/random';\n/**\n * Returns a {@link Jitterer} that works with absolute values,\n * ie. values outside of 0..1 range.\n *\n * Jitter amount is _absolute_, meaning a fixed value regardless of input value,\n * or _relative_, meaning it is scaled according to input value.\n *\n * ```js\n * // Jitter by -10 to +10 (absolute value: 10)\n * const j1 = jitterAbsolute({ absolute: 10 });\n * j1(100); // Produces range of 90...110\n *\n * // Jitter by -20 to +20 (relative value 20%)\n * const j2 = jitterAbsolute({ relative: 0.20 });\n * j2(100); // Produces a range of -80...120\n * ```\n *\n * The expected used case is calling `jitterAbsolute` to set up a jitterer\n * and then reusing it with different input values, as above with the `j1` and `j2`.\n *\n * However to use it 'one-off', just call the returned function immediately:\n * ```js\n * const v = jitterAbsolute({ absolute: 10 })(100); // v is in range of 90-110\n * ```\n *\n * When `clamped` is true, return value is clamped to 0...value.\n * That is, rather than the usual bipolar jittering, the jittering only goes below.\n * ```js\n * const j = jitterAbsolute({ absolute: 10, clamped: true })\n * j(100); // Produces range of 90-100\n * ```\n * @param options\n * @returns\n */\nexport const jitterAbsolute = (options) => {\n    const { relative, absolute } = options;\n    const clamped = options.clamped ?? false;\n    const source = options.source ?? Math.random;\n    if (absolute !== undefined) {\n        return (value) => {\n            const abs = (source() * absolute * 2) - absolute;\n            const valueNew = value + abs;\n            if (clamped)\n                return clamp(valueNew, 0, value);\n            return valueNew;\n        };\n    }\n    if (relative !== undefined) {\n        return (value) => {\n            const rel = value * relative;\n            const abs = (source() * rel * 2) - rel;\n            const valueNew = value + abs;\n            if (clamped)\n                return clamp(valueNew, 0, value);\n            return valueNew;\n        };\n    }\n    throw new Error(`Either absolute or relative fields expected`);\n};\n/**\n * Jitters `value` by the absolute `jitter` amount. Returns a function.\n *\n * All values should be on a 0..1 scale, and the return value is by default clamped to 0..1.\n * Pass `clamped:false` as an option to allow for arbitary ranges.\n *\n * `jitter` returns a function that calculates jitter. If you only need a one-off\n * jitter, you can immediately execute the returned function:\n * ```js\n * // Compute 10% jitter of input 0.5\n * const value = jitter({ relative: 0.1 })(0.5);\n * ```\n *\n * However, if the returned jitter function is to be used again,\n * assign it to a variable:\n * ```js\n * const myJitter = jitter({ absolute: 0.5 });\n *\n * // Jitter an input value 1.0\n * const value = myJitter(1);\n * ```\n *\n * A custom source for random numbers can be provided. Eg, use a weighted\n * random number generator:\n *\n * ```js\n * import { weighted } from '@ixfx/random.js';\n * jitter({ relative: 0.1, source: weighted });\n * ```\n *\n * Options\n * * clamped: If false, `value`s out of percentage range can be used and return value may be beyond percentage range. True by default\n * * random: Random source (default is Math.random)\n * @param options Options\n * @returns Function that performs jitter\n */\nexport const jitter = (options = {}) => {\n    const clamped = options.clamped ?? true;\n    let r = (_) => 0;\n    if (options.absolute !== undefined) {\n        resultThrow(numberTest(options.absolute, clamped ? `percentage` : `bipolar`, `opts.absolute`));\n        const absRand = randomFloatFunction({\n            min: -options.absolute,\n            max: options.absolute,\n            source: options.source,\n        });\n        r = (v) => v + absRand();\n    }\n    else if (options.relative === undefined) {\n        throw new TypeError(`Either absolute or relative jitter amount is required.`);\n    }\n    else {\n        const rel = options.relative ?? 0.1;\n        resultThrow(numberTest(rel, clamped ? `percentage` : `bipolar`, `opts.relative`));\n        r = (v) => v +\n            randomFloat({\n                min: -Math.abs(rel * v),\n                max: Math.abs(rel * v),\n                source: options.source,\n            });\n    }\n    const compute = (value) => {\n        resultThrow(numberTest(value, clamped ? `percentage` : `bipolar`, `value`));\n        let v = r(value);\n        if (clamped)\n            v = clamp(v);\n        return v;\n    };\n    return compute;\n};\n","import { interpolate } from \"@ixfx/numbers\";\n/**\n * Mixes in modulation. This is used when you want to\n * fold in a controllable amount of modulation.\n *\n * For example, we have a base value of 0.5 (50%) that we want to modulate\n * by 0.9 (90%). That is, reduce its value by 10%. `mix` allows us\n * to slowly ramp up to the fully modulated value.\n *\n * ```js\n * // When 'amt' is 0, modulation doesn't affect value at all,\n * // original is returned\n * mix(0, 0.5, 0.9); // 0.5\n * // Mixing in 50% of modulation\n * mix(0.5, 0.5, 0.9); // 0.475\n * // All modulation applied, so now we get 90% of 0.5\n * mix(1, 0.5, 0.9); // 0.45 (ie. 90% of 0.5)\n * ```\n * @param amount Amount of modulation (0..1). 0 means modulation value has no effect\n * @param original Original value to modulate\n * @param modulation Modulation amount (0..1)\n * @returns\n */\nexport const mix = (amount, original, modulation) => {\n    const m = modulation * amount;\n    const base = (1 - amount) * original;\n    return base + (original * m);\n};\n/**\n * Returns a modulator that mixes between two modulation functions.\n * Both modulators are given the same input value.\n *\n * ```js\n * import { Easings } from \"@ixfx/modulation.js\";\n * // Get a 50/50 mix of two easing functions\n * const mix = Easings.mix(0.5, Easings.Named.sineIn, Easings.Named.sineOut);\n *\n * // 10% of sineIn, 90% of sineOut\n * Easings.mix(0.90, 0.25, Easings.Named.sineIn, Easings.Named.sineOut);\n * ```\n * @param balance Mix between a and b\n * @param a\n * @param b\n * @returns Numeric value\n */\nexport const mixModulators = (balance, a, b) => (amt) => interpolate(balance, a(amt), b(amt));\n/**\n * Returns a 'crossfader` function of two easing functions, synchronised with the progress through the easing.\n *\n * Example `amt` values:\n * * 0.0 will yield 100% of easingA at its `easing(0)` value.\n * * 0.2 will yield 80% of easingA, 20% of easingB, both at their `easing(0.2)` values\n * * 0.5 will yield 50% of both functions both at their `easing(0.5)` values\n * * 0.8 will yield 20% of easingA, 80% of easingB, with both at their `easing(0.8)` values\n * * 1.0 will yield 100% of easingB at its `easing(1)` value.\n *\n * So easingB will only ever kick in at higher `amt` values and `easingA` will only be present in lower values.\n *\n * ```js\n * import { Easings } from \"@ixfx/modulation.js\";\n * Easings.crossFade(0.5, Easings.Named.sineIn, Easings.Named.sineOut);\n * ```\n * @param a Easing A\n * @param b Easing B\n * @returns Numeric value\n */\nexport const crossfade = (a, b) => {\n    return (amt) => {\n        const mixer = mixModulators(amt, a, b);\n        return mixer(amt);\n    };\n};\n","/**\n * A 'no-op' function. Returns the input value without modification.\n * Useful for when some default is needed\n * @param v\n * @returns\n */\nexport const noop = (v) => v;\n","import { resultThrow, numberTest } from '@ixfx/guards';\n/**\n * Continually loops up and down between 0 and 1 by a specified interval.\n * Looping returns start value, and is inclusive of 0 and 1.\n *\n * @example Usage\n * ```js\n * for (const v of percentPingPong(0.1)) {\n *  // v will go up and down. Make sure you have a break somewhere because it is infinite\n * }\n * ```\n *\n * @example Alternative:\n * ```js\n * const pp = pingPongPercent(0.1, 0.5); // Setup generator one time\n * const v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n *\n * Because limits are capped to -1 to 1, using large intervals can produce uneven distribution. Eg an interval of 0.8 yields 0, 0.8, 1\n *\n * `upper` and `lower` define the percentage range. Eg to ping pong between 40-60%:\n * ```\n * const pp = pingPongPercent(0.1, 0.4, 0.6);\n * ```\n * @param interval Amount to increment by. Defaults to 10%\n * @param start Starting point within range. Defaults to 0 using a positive interval or 1 for negative intervals\n * @param rounding Rounding to apply. This avoids floating-point rounding errors.\n */\nexport const pingPongPercent = function (interval = 0.1, lower, upper, start, rounding) {\n    if (typeof lower === `undefined`)\n        lower = 0;\n    if (typeof upper === `undefined`)\n        upper = 1;\n    if (typeof start === `undefined`)\n        start = lower;\n    resultThrow(numberTest(interval, `bipolar`, `interval`), numberTest(upper, `bipolar`, `end`), numberTest(start, `bipolar`, `offset`), numberTest(lower, `bipolar`, `start`));\n    return pingPong(interval, lower, upper, start, rounding);\n};\n/**\n * Ping-pongs continually back and forth a `lower` and `upper` value (both inclusive) by a given `interval`. Use `pingPongPercent` for 0-1 ping-ponging\n *\n * In a loop:\n * ```\n * for (const c of pingPong(10, 0, 100)) {\n *  // 0, 10, 20 .. 100, 90, 80, 70 ...\n * }\n * ```\n *\n * Manual:\n * ```\n * const pp = pingPong(10, 0, 100);\n * let v = pp.next().value; // Call .next().value whenever a new value is needed\n * ```\n * @param interval Amount to increment by. Use negative numbers to start counting down\n * @param lower Lower bound (inclusive)\n * @param upper Upper bound (inclusive, must be greater than start)\n * @param start Starting point within bounds (defaults to `lower`)\n * @param rounding Rounding is off by default. Use say 1000 if interval is a fractional amount to avoid rounding errors.\n */\nexport const pingPong = function* (interval, lower, upper, start, rounding) {\n    if (lower === undefined)\n        throw new Error(`Parameter 'lower' is undefined`);\n    if (interval === undefined) {\n        throw new Error(`Parameter 'interval' is undefined`);\n    }\n    if (upper === undefined)\n        throw new Error(`Parameter 'upper' is undefined`);\n    if (rounding === undefined && interval <= 1 && interval >= 0) {\n        rounding = 10 / interval;\n    }\n    else if (typeof rounding === `undefined`)\n        rounding = 1234;\n    if (Number.isNaN(interval))\n        throw new Error(`interval parameter is NaN`);\n    if (Number.isNaN(lower))\n        throw new Error(`lower parameter is NaN`);\n    if (Number.isNaN(upper))\n        throw new Error(`upper parameter is NaN`);\n    if (Number.isNaN(start))\n        throw new Error(`upper parameter is NaN`);\n    if (lower >= upper)\n        throw new Error(`lower must be less than upper`);\n    if (interval === 0)\n        throw new Error(`Interval cannot be zero`);\n    const distance = upper - lower;\n    if (Math.abs(interval) >= distance) {\n        throw new Error(`Interval should be between -${distance} and ${distance}`);\n    }\n    let incrementing = interval > 0;\n    // Scale up values by rounding factor\n    upper = Math.floor(upper * rounding);\n    lower = Math.floor(lower * rounding);\n    interval = Math.floor(Math.abs(interval * rounding));\n    if (interval === 0) {\n        throw new Error(`Interval is zero (rounding: ${rounding})`);\n    }\n    start = start === undefined ? lower : Math.floor(start * rounding);\n    if (start > upper || start < lower) {\n        throw new Error(`Start (${start / rounding}) must be within lower (${lower / rounding}) and upper (${upper / rounding})`);\n    }\n    let v = start;\n    yield v / rounding;\n    let firstLoop = true;\n    while (true) {\n        v = v + (incrementing ? interval : -interval);\n        if (incrementing && v >= upper) {\n            incrementing = false;\n            v = upper;\n            if (v === upper && firstLoop) {\n                // Edge case where we start at upper bound and increment\n                v = lower;\n                incrementing = true;\n            }\n        }\n        else if (!incrementing && v <= lower) {\n            incrementing = true;\n            v = lower;\n            if (v === lower && firstLoop) {\n                // Edge case where we start at lower bound and decrement\n                v = upper;\n                incrementing = false;\n            }\n        }\n        yield v / rounding;\n        firstLoop = false;\n    }\n};\n","import * as Flow from '@ixfx/flow';\n/**\n * Produces values according to rough spring physics.\n * å\n * ```js\n * import { continuously } from \"@ixfx/flow.js\"\n * import { spring } from \"@ixfx/modulation.js\"\n *\n * const s = spring();\n *\n * continuously(() => {\n *  const result = s.next();\n *  if (result.done) return false; // Exit loop\n *  const value = result.value;\n *  // Value is mostly within 0..1 range but will exceed these limits\n * }, 10).start();\n * ```\n *\n * Parameters to the spring can be provided.\n * ```js\n * import { spring } from \"@ixfx/modulation.js\"\n * const s = spring({\n *  mass: 5,\n *  damping: 10\n *  stiffness: 100\n * });\n * ```\n *\n * If you don't want to use a generator: {@link springValue}.\n *\n * Note that the generated value can exceed 0..1 range. This is by design, since\n * a spring can 'overshoot'. See Data.Normalise for functions to normalise.\n *\n * @param opts Options for spring\n * @param timerOrFreq Timer to use, or frequency\n */\nexport function* spring(opts = {}, timerOrFreq) {\n    if (timerOrFreq === undefined)\n        timerOrFreq = Flow.elapsedMillisecondsAbsolute();\n    else if (typeof timerOrFreq === `number`) {\n        timerOrFreq = Flow.frequencyTimer(timerOrFreq);\n    }\n    const fn = springShape(opts);\n    // Give it some iterations to settle\n    let doneCountdown = opts.countdown ?? 10;\n    while (doneCountdown > 0) {\n        const s = fn(timerOrFreq.elapsed / 1000);\n        yield s;\n        if (s === 1) {\n            doneCountdown--;\n        }\n        else {\n            doneCountdown = 100;\n        }\n    }\n}\n/**\n * The same as {@link spring} but instead of a generator we get\n * a value. When the spring is done, 1 is returned instead of undefined.\n *\n * ```js\n * import { springValue } from \"@ixfx/modulation.js\"\n * const s = springValue();\n * s(); // 0..1 (roughly - exceeding 1 is possible)\n * ```\n *\n * Options can be provided:\n * ```js\n * import { spring } from \"@ixfx/modulation.js\"\n * const s = springValue({\n *  stiffness: 100,\n *  damping: 10\n * })\n * ```\n * @example Applied\n * ```js\n * import { Modulation, Data } from  \"@ixfx/bundle.js\"\n * let state = {\n *  spring: Modulation.springValue()\n * }\n *\n * function loop() {\n *  const d = Data.resolveFields(state);\n *\n *  // Apply calculated spring value to compute x value\n *  const x = window.innerWidth * d.spring;\n *\n *\n *  window.requestAnimationFrame(loop);\n * }\n * loop();\n * ```\n * Note that the generated value can exceed 0..1 range. This is by design, since\n * a spring can 'overshoot'. See Data.Normalise for functions to normalise.\n *\n * @param opts\n * @param timerOrFreq\n * @returns\n */\nexport function springValue(opts = {}, timerOrFreq) {\n    const s = spring(opts, timerOrFreq);\n    return () => {\n        const v = s.next();\n        if (v.done)\n            return 1;\n        return v.value;\n    };\n}\n/**\n * Spring-dynamics modulator.\n * To have spring driven by time or ticks, use {@link spring} or {@link springValue}.\n * This is a lower-level function.\n * @param opts\n * @returns\n */\nexport const springShape = (opts = {}) => {\n    /** MIT License github.com/pushkine/ */\n    const from = 0;\n    const to = 1;\n    const mass = opts.mass ?? 1;\n    const stiffness = opts.stiffness ?? 100;\n    const soft = opts.soft ?? false;\n    const damping = opts.damping ?? 10;\n    const velocity = opts.velocity ?? 0.1;\n    const delta = to - from;\n    if (soft || 1 <= damping / (2 * Math.sqrt(stiffness * mass))) {\n        const angularFrequency = -Math.sqrt(stiffness / mass);\n        const leftover = -angularFrequency * delta - velocity;\n        return (t) => to - (delta + t * leftover) * Math.E ** (t * angularFrequency);\n    }\n    else {\n        const dampingFrequency = Math.sqrt(4 * mass * stiffness - damping ** 2);\n        const leftover = (damping * delta - 2 * mass * velocity) / dampingFrequency;\n        const dfm = (0.5 * dampingFrequency) / mass;\n        const dm = -(0.5 * damping) / mass;\n        return (t) => to -\n            (Math.cos(t * dfm) * delta + Math.sin(t * dfm) * leftover) *\n                Math.E ** (t * dm);\n    }\n};\n","import * as TimeSources from './source/time.js';\n/**\n * A factory function for creating a timing source. It returns\n * a function which creates a designated timer.\n *\n * This is useful in times where you need to recreate timers, eg for reset\n * type of behaviours because the options for the timer to be\n * consolidated in one place.\n *\n * ```js\n * // Get a factory for an elapsed timer\n * const factory = sources(`elapsed`, 1000);\n *\n * // Create the timer\n * let t = factory();\n *\n * // Get a value from the timer\n * const value = t();\n *\n * // Recreate the timer, note we don't need any options\n * t = factory();\n * ```\n *\n * @param source Kind of timer to make\n * @param duration Duration depends on the timer used. Will be milliseconds, hertz or bpm.\n * @param options Options to pass to timer.\n * @returns\n */\nexport const timingSourceFactory = (source, duration, options = {}) => {\n    switch (source) {\n        case `elapsed`:\n            return () => TimeSources.elapsed(duration, options);\n        case `bpm`:\n            return () => TimeSources.bpm(duration, options);\n        case `hertz`:\n            return () => TimeSources.hertz(duration, options);\n        default:\n            throw new Error(`Unknown source '${source}'. Expected: 'elapsed', 'hertz' or 'bpm'`);\n    }\n};\n","import { resultThrow, integerTest } from \"@ixfx/guards\";\nimport * as Sources from './source/index.js';\n/**\n * Returns a function that shapes a 0..1 value as a\n * triangle waveform.\n *\n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period\n * @returns\n */\nexport function triangleShape(period = 1) {\n    period = 1 / period;\n    const halfPeriod = period / 2;\n    return (t) => {\n        const v = Math.abs((t % period) - halfPeriod);\n        //console.log(`t: ${ t.toFixed(2) } v: ${ v.toFixed(2) }`);\n        return v;\n    };\n}\n/**\n * Returns a function that shapes a 0..1 value as a square waveform.\n *\n * `period` sets the number of cycles in the 0..1 range.\n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period\n * @returns\n */\nexport function squareShape(period = 1) {\n    period = 1 / period;\n    const halfPeriod = period / 2;\n    return (t) => {\n        return (t % period) < halfPeriod ? 1 : 0;\n        //console.log(`square: ${ t } v: ${ v }`);\n        //return v;\n    };\n}\n/**\n * Returns a function that shapes a 0..1 value as a sine waveform.\n * An input value of 0 will be the very beginning of the wave cycle, input of 1 will be the end,\n * 0.5 will be them middle and so on.\n * ```js\n * const s = sineShape();\n * // Calculate value of sine wave at 50%\n * // By default there is one oscillation, thus\n * // it will be the middle of the cycle.\n * s(0.5);\n * ```\n *\n * The `period` determines number of cycles for\n * an input value of 1.\n * ```js\n * // Oscillate twice in 0..1 range\n * const s = sineShape(2);\n * ```\n *\n * No bounds checks are performed on input value.\n * Ensure it is 0..1 (inclusive).\n * @param period\n * @returns\n */\nexport function sineShape(period = 1) {\n    period = period * (Math.PI * 2);\n    return (t) => {\n        const v = (Math.sin(t * period) + 1) / 2;\n        //console.log(`t: ${ t.toFixed(2) } v: ${ v.toFixed(2) }`);\n        return v;\n    };\n}\n/**\n * A series of arcs, sort of like a bouncing ball.\n * @param period\n * @returns\n */\nexport function arcShape(period = 1) {\n    period = period * (Math.PI * 2);\n    return (t) => Math.abs(Math.sin(t * period));\n}\nexport function sineBipolarShape(period = 1) {\n    period = period * (Math.PI * 2);\n    return (t) => Math.sin(t * period);\n}\n/**\n * Creates a wave modulator by name.\n *\n * Defaults to 5-second sine wave.\n * ```js\n * import { wave } from '@ixfx/modulation.js';\n * // Triangle wave that has a single cycle over two seconds\n * const m = wave({ secs: 2, shape: `triangle`});\n *\n * // Call m() to get current value of wave, eg in\n * // an animation loop\n * const v = m();\n * ```\n *\n * @example\n * ```js\n * import { wave } from '@ixfx/modulation.js';\n * import { resolveFields } from '@ixfx/data.js';\n *\n * const state = {\n *  intensity: wave({secs: 2, shape: `sine` }),\n *  someOtherState: 10\n * }\n *\n * const use = async () {\n *  const { intensity } = await resolveFields(state);\n *  // Do something with intensity value...\n * }\n * ```\n * @param options\n * @returns\n */\nexport function wave(options) {\n    const shape = options.shape ?? `sine`;\n    const invert = options.invert ?? false;\n    const period = options.period ?? 1;\n    let sourceFunction;\n    resultThrow(integerTest(period, `aboveZero`, `period`));\n    const sourceOptions = {\n        ...options\n    };\n    if (options.ticks) {\n        sourceFunction = Sources.ticks(options.ticks, sourceOptions);\n    }\n    else if (options.hertz) {\n        sourceFunction = Sources.hertz(options.hertz, sourceOptions);\n    }\n    else if (options.millis) {\n        sourceFunction = Sources.elapsed(options.millis, sourceOptions);\n    }\n    else if (options.source) {\n        sourceFunction = options.source;\n    }\n    else {\n        const secs = options.secs ?? 5;\n        sourceFunction = Sources.elapsed(secs * 1000, sourceOptions);\n    }\n    let shaperFunction;\n    switch (shape) {\n        case `saw`:\n            shaperFunction = (v) => v;\n            break;\n        case `sine`:\n            shaperFunction = sineShape(period);\n            break;\n        case `sine-bipolar`:\n            shaperFunction = sineBipolarShape(period);\n            break;\n        case `square`:\n            shaperFunction = squareShape(period);\n            break;\n        case `triangle`:\n            shaperFunction = triangleShape(period);\n            break;\n        case `arc`:\n            shaperFunction = arcShape(period);\n            break;\n        default:\n            throw new Error(`Unknown wave shape '${shape}'. Expected: sine, sine-bipolar, saw, triangle, arc or square`);\n    }\n    return waveFromSource(sourceFunction, shaperFunction, invert);\n}\n/**\n * Returns a wave-shaping modulator with a source and shaper as input.\n * ```js\n * // 1Hz sine wave source,\n * const wm = waveFromSource(Sources.hertz(1), sineShape(period));\n * ```\n * @param sourceFunction Signal source\n * @param shaperFunction Modulator\n * @returns\n */\nexport function waveFromSource(sourceFunction, shaperFunction, invert = false) {\n    return (feedback) => {\n        let v = sourceFunction(feedback?.clock);\n        if (feedback?.override)\n            v = feedback.override;\n        v = shaperFunction(v);\n        if (invert)\n            v = 1 - v;\n        return v;\n    };\n}\n","/**\n * Weighted average\n *\n * @param currentValue\n * @param targetValue\n * @param slowDownFactor\n * @returns\n */\nexport const weightedAverage = (currentValue, targetValue, slowDownFactor) => {\n    return ((currentValue * (slowDownFactor - 1)) + targetValue) / slowDownFactor;\n};\n","import { get } from \"./easing/index.js\";\n/***\n * Returns a random number, 0..1, weighted by a given easing function.\n * Default easing is `quadIn`, which skews towards zero.\n *\n * Use {@link weightedSource} to return a function instead.\n *\n * ```js\n * Random.weighted();          // quadIn easing by default, which skews toward low values\n * Random.weighted(`quadOut`); // quadOut favours high values\n * ```\n * @param easingNameOrOptions Options. Uses 'quadIn' by default.\n * @see {@link weightedSource} Returns a function rather than value\n * @returns Random number (0-1)\n */\nexport const weighted = (easingNameOrOptions = `quadIn`) => weightedSource(easingNameOrOptions)();\n/***\n * Returns a random number, 0..1, weighted by a given easing function.\n * Default easing is `quadIn`, which skews towards zero.\n * Use {@link weighted} to get a value directly.\n *\n * ```js\n * const r1 = Random.weightedSource();          // quadIn easing by default, which skews toward low values\n * r1(); // Produce a value\n *\n * const r2 = Random.weightedSource(`quadOut`); // quadOut favours high values\n * r2(); // Produce a value\n * ```\n * @param easingNameOrOptions Easing name or options `quadIn` by default.\n * @see {@link weighted} Returns value instead of function\n * @returns Function which returns a weighted random value\n */\nexport const weightedSource = (easingNameOrOptions = `quadIn`) => {\n    const options = typeof easingNameOrOptions === `string`\n        ? { easing: easingNameOrOptions }\n        : easingNameOrOptions;\n    const source = options.source ?? Math.random;\n    const easingName = options.easing ?? `quadIn`;\n    const easingFunction = get(easingName);\n    if (typeof easingFunction === `undefined`) {\n        throw new Error(`Easing function '${easingName}' not found.`);\n    }\n    const compute = () => {\n        const r = source();\n        return easingFunction(r);\n    };\n    return compute;\n};\n","export * as Sources from './source/index.js';\nexport * as Oscillators from './oscillator.js';\nexport * as Easings from './easing/index.js';\nexport * as Envelopes from './envelope/index.js';\nexport * as Forces from './forces.js';\nexport * from './cubic-bezier.js';\nexport * from './drift.js';\nexport * from './gaussian.js';\nexport * from './interpolate.js';\nexport * from './jitter.js';\nexport * from './mix.js';\nexport * from './modulator-timed.js';\nexport * from './no-op.js';\nexport * from './ping-pong.js';\nexport * from './spring.js';\nexport * from './timing-source-factory.js';\nexport * from './waveforms.js';\nexport * from './weighted-average.js';\nexport * from './weighted-random.js';\nexport { interpolate } from '@ixfx/numbers';\n","export class CancelError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = `CancelError`;\n    }\n}\n","import { CancelError } from \"./cancel-error.js\";\n/**\n * Creates a flow of data processors (up to 5 are supported).\n * The flow is encapsulated in a function that accepts an input value an returns an output.\n *\n * ```js\n * const p = flow(\n *  (value:string) => value.toUpperCase(), // Convert to uppercase\n *  (value:string) => value.at(0) === 'A') // If first letter is an A, return true\n * );\n * p('apple'); // True\n * ```\n *\n * Each processing function is expected to take in one input value and return one value.\n * @param processors\n * @returns\n */\nexport function flow(...processors) {\n    return (value) => {\n        let v = value;\n        for (const p of processors) {\n            try {\n                // @ts-expect-error\n                v = p(v);\n            }\n            catch (err) {\n                if (err instanceof CancelError) {\n                    break;\n                }\n                else {\n                    throw err;\n                }\n            }\n        }\n        return v;\n    };\n}\n","import { CancelError } from \"./cancel-error.js\";\n/**\n * Calls a function if the input value is not undefined.\n * Return value from function is passed to next function in flow.\n *\n * ```js\n * const flow = Process.flow(\n *  Process.max(),\n *  Process.seenLastToUndefined(),\n *  Process.ifNotUndefined(v => {\n *    console.log(`v:`, v);\n *  })\n * );\n * flow(100); // Prints 'v:100'\n * flow(90);  // Nothing happens max value has not changed\n * flow(110); // Prints 'v:110'\n * ```\n * @param fn\n * @returns\n */\nexport function ifNotUndefined(fn) {\n    return (value) => {\n        if (value === undefined)\n            return value;\n        const v = fn(value);\n        return v;\n    };\n}\n/**\n * Cancels the remaining flow operations if _undefined_ is an input.\n * See also {@link ifUndefined} or {@link ifNotUndefined}.\n *\n * ```js\n * const c3 = Process.flow(\n *  Basic.max(),\n *  Process.seenLastToUndefined(),\n *  Process.cancelIfUndefined(),\n *  (v => {\n *   console.log(v);\n *  })\n * );\n * c3(100); // Prints '100'\n * c3(90);  // Doesn't print anything since max does not change\n * c3(110); // Prints '110'\n * ```\n * @returns\n */\nexport function cancelIfUndefined() {\n    return (value) => {\n        if (value === undefined)\n            throw new CancelError(`cancel`);\n        return value;\n    };\n}\n/**\n * Returns the output of `fn` if the input value is _undefined_.\n * See also: {@link ifNotUndefined} and {@link cancelIfUndefined}.\n * @param fn\n * @returns\n */\nexport function ifUndefined(fn) {\n    return (value) => {\n        if (value === undefined)\n            return fn();\n        else\n            return value;\n    };\n}\n","/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = (a, b) => a === b;\n/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = (itemToMakeStringFor) => typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);\n","import { isEqualDefault, toStringDefault } from \"./util.js\";\n/**\n * If a value is same as the previous value, _undefined_ is emitted instead.\n *\n * @param eq Equality function. If not specified, === semantics are used.\n * @returns\n */\nexport function seenLastToUndefined(eq) {\n    if (typeof eq === `undefined`)\n        eq = isEqualDefault;\n    let lastValue;\n    return (value) => {\n        if (value !== lastValue) {\n            lastValue = value;\n            return value;\n        }\n        return undefined;\n    };\n}\n/**\n * If a value is same as any previously-seen value, _undefined_ is emitted instead.\n *\n * It stores all previous values and compares against them for each new value.\n * This would likely be not very efficient compared to {@link seenToUndefinedByKey} which uses a one-time computed\n * key and efficient storage of only the keys (using a Set).\n *\n * @param eq Equality function. If not specified, === semantics are used.\n * @returns\n */\nexport function seenToUndefined(eq) {\n    const seen = [];\n    if (typeof eq === `undefined`)\n        eq = isEqualDefault;\n    return (value) => {\n        if (value === undefined)\n            return;\n        for (const s of seen) {\n            if (eq(s, value))\n                return;\n        }\n        seen.push(value);\n        return value;\n    };\n}\n/**\n * If a value is the same as any previously-seen value, _undefined_ is emitted instead.\n *\n * This version uses a function to create a string key of the object, by default JSON.stringify.\n * Thus we don't need to store all previously seen objects, just their keys.\n *\n * Alternatively, if a key function doesn't make sense for the value, use\n * {@link seenToUndefined}, which stores the values (less efficient).\n *\n * @param toString\n * @returns\n */\nexport function seenToUndefinedByKey(toString) {\n    const seen = new Set();\n    if (typeof toString === `undefined`)\n        toString = toStringDefault;\n    return (value) => {\n        if (value === undefined)\n            return;\n        const key = toString(value);\n        if (seen.has(key))\n            return;\n        seen.add(key);\n        return value;\n    };\n}\n","export * from './basic.js';\nexport * from './cancel-error.js';\nexport * from './flow.js';\nexport * from './if-undefined.js';\nexport * from './seen.js';\n"],"mappings":"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"}