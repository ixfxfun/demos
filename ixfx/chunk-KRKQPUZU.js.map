{"version":3,"sources":["../src/text/Segments.ts"],"sourcesContent":["import { afterMatch, beforeAfterMatch, beforeMatch } from './Text.js';\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * Whittles down from whole string to last token.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsWholeToEnd(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `b.c.d`\n * // `c.d`\n * // `d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsWholeToEnd(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n    const trimmed = afterMatch(source, delimiter);\n    if (trimmed === source) {\n      // Delimiter not found\n      break;\n    }\n    source = trimmed;\n  }\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * Starts with last token, builds to whole.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ````js\n * stringSegmentsLastToWhole(`a.b.c.d`);\n * // Yields:\n * // `d`\n * // `c.d`\n * // `b.c.d`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsLastToWhole(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { fromEnd: true, ifNoMatch: `original` });\n    if (ba[ 0 ] === ba[ 1 ] && ba[ 1 ] === source) {\n      // Delimiter not found\n      break;\n    }\n    const v = ba[ 1 ] + accumulator;\n    yield v;\n    accumulator = delimiter + v;\n    source = ba[ 0 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * We start with the first token and build up until end.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsFirstToWhole(`a.b.c.d`);\n * // Yields:\n * // `a`\n * // `a.b`\n * // `a.b.c`\n * // `a.b.c.d`\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsFirstToWhole(source: string, delimiter = `.`) {\n  let accumulator = ``;\n  const orig = source;\n  while (source.length > 0) {\n    const ba = beforeAfterMatch(source, delimiter, { ifNoMatch: `original` });\n    if (ba[ 0 ] === source && ba[ 1 ] === source) break;\n    accumulator += ba[ 0 ];\n    yield accumulator;\n    accumulator += delimiter;\n    source = ba[ 1 ];\n  }\n  yield orig;\n}\n\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n * \n * We start with whole string and whittle down to starting token.\n * \n * If `delimiter` is not found, no results are yielded.\n * \n * ```js\n * stringSegmentsWholeToFirst(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `a.b.c`,\n * // `a.b`,\n * // `a`,\n * ```\n * @param source \n * @param delimiter \n */\nexport function* stringSegmentsWholeToFirst(source: string, delimiter = `.`) {\n  while (source.length > 0) {\n    yield source;\n\n    const b = beforeMatch(source, delimiter, { ifNoMatch: `original`, fromEnd: true });\n    if (b === source) break;\n    source = b;\n  }\n}\n\n\n"],"mappings":";;;;;;;AAmBO,UAAU,yBAAyB,QAAgB,YAAY,KAAK;AACzE,SAAO,OAAO,SAAS,GAAG;AACxB,UAAM;AACN,UAAM,UAAU,WAAW,QAAQ,SAAS;AAC5C,QAAI,YAAY,QAAQ;AAEtB;AAAA,IACF;AACA,aAAS;AAAA,EACX;AACF;AAoBO,UAAU,0BAA0B,QAAgB,YAAY,KAAK;AAC1E,MAAI,cAAc;AAClB,QAAM,OAAO;AACb,SAAO,OAAO,SAAS,GAAG;AACxB,UAAM,KAAK,iBAAiB,QAAQ,WAAW,EAAE,SAAS,MAAM,WAAW,WAAW,CAAC;AACvF,QAAI,GAAI,CAAE,MAAM,GAAI,CAAE,KAAK,GAAI,CAAE,MAAM,QAAQ;AAE7C;AAAA,IACF;AACA,UAAM,IAAI,GAAI,CAAE,IAAI;AACpB,UAAM;AACN,kBAAc,YAAY;AAC1B,aAAS,GAAI,CAAE;AAAA,EACjB;AACA,QAAM;AACR;AAoBO,UAAU,2BAA2B,QAAgB,YAAY,KAAK;AAC3E,MAAI,cAAc;AAClB,QAAM,OAAO;AACb,SAAO,OAAO,SAAS,GAAG;AACxB,UAAM,KAAK,iBAAiB,QAAQ,WAAW,EAAE,WAAW,WAAW,CAAC;AACxE,QAAI,GAAI,CAAE,MAAM,UAAU,GAAI,CAAE,MAAM,OAAQ;AAC9C,mBAAe,GAAI,CAAE;AACrB,UAAM;AACN,mBAAe;AACf,aAAS,GAAI,CAAE;AAAA,EACjB;AACA,QAAM;AACR;AAoBO,UAAU,2BAA2B,QAAgB,YAAY,KAAK;AAC3E,SAAO,OAAO,SAAS,GAAG;AACxB,UAAM;AAEN,UAAM,IAAI,YAAY,QAAQ,WAAW,EAAE,WAAW,YAAY,SAAS,KAAK,CAAC;AACjF,QAAI,MAAM,OAAQ;AAClB,aAAS;AAAA,EACX;AACF;","names":[]}