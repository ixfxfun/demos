{"version":3,"file":"maps-CyRBIIF3.js","names":["chunks","slice","reduce","uniqueByValue","asCallback","last","chunks","concat","dropWhile","until","equals","every","fill","forEach","filter","find","flatten","map","max","min","some","repeat","unique","zip","fromIterable","toArray","fromArray","#store","#disposed","#listeners","fromArray","fromIterable","chunks","concat","dropWhile","until","equals","every","fill","filter","find","flatten","forEach","last","map","max","min","reduce","asCallback","slice","some","toArray","unique","uniqueByValue","zip","min","max","some","toArray","map"],"sources":["../packages/core/dist/src/text.js","../packages/iterables/dist/src/guard.js","../packages/iterables/dist/src/sync/slice.js","../packages/iterables/dist/src/sync/reduce.js","../packages/iterables/dist/src/sync.js","../packages/events/dist/src/map-of.js","../packages/events/dist/src/simple-event-emitter.js","../packages/events/dist/src/index.js","../packages/iterables/dist/src/async.js","../packages/iterables/dist/src/compare-values.js","../packages/iterables/dist/src/from-event.js","../packages/iterables/dist/src/numbers-compute.js","../packages/iterables/dist/src/index.js","../packages/core/dist/src/to-string.js","../packages/core/dist/src/comparers.js","../packages/core/dist/src/maps.js"],"sourcesContent":["import { integerTest, resultThrow } from '@ixfx/guards';\n//export { string as random } from './random/String.js';\n//import { afterMatch, beforeAfterMatch, beforeMatch } from '../Text.js';\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * Whittles down from whole string to last token.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsWholeToEnd(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `b.c.d`\n * // `c.d`\n * // `d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsWholeToEnd(source, delimiter = `.`) {\n    while (source.length > 0) {\n        yield source;\n        const trimmed = afterMatch(source, delimiter);\n        if (trimmed === source) {\n            // Delimiter not found\n            break;\n        }\n        source = trimmed;\n    }\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * Starts with last token, builds to whole.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ````js\n * stringSegmentsLastToWhole(`a.b.c.d`);\n * // Yields:\n * // `d`\n * // `c.d`\n * // `b.c.d`\n * // `a.b.c.d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsLastToWhole(source, delimiter = `.`) {\n    let accumulator = ``;\n    const orig = source;\n    while (source.length > 0) {\n        const ba = beforeAfterMatch(source, delimiter, { fromEnd: true, ifNoMatch: `original` });\n        if (ba[0] === ba[1] && ba[1] === source) {\n            // Delimiter not found\n            break;\n        }\n        const v = ba[1] + accumulator;\n        yield v;\n        accumulator = delimiter + v;\n        source = ba[0];\n    }\n    yield orig;\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * We start with the first token and build up until end.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsFirstToWhole(`a.b.c.d`);\n * // Yields:\n * // `a`\n * // `a.b`\n * // `a.b.c`\n * // `a.b.c.d`\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsFirstToWhole(source, delimiter = `.`) {\n    let accumulator = ``;\n    const orig = source;\n    while (source.length > 0) {\n        const ba = beforeAfterMatch(source, delimiter, { ifNoMatch: `original` });\n        if (ba[0] === source && ba[1] === source)\n            break;\n        accumulator += ba[0];\n        yield accumulator;\n        accumulator += delimiter;\n        source = ba[1];\n    }\n    yield orig;\n}\n/**\n * Returns chunks of `source`, broken up by `delimiter` (default '.').\n *\n * We start with whole string and whittle down to starting token.\n *\n * If `delimiter` is not found, no results are yielded.\n *\n * ```js\n * stringSegmentsWholeToFirst(`a.b.c.d`);\n * // Yields:\n * // `a.b.c.d`\n * // `a.b.c`,\n * // `a.b`,\n * // `a`,\n * ```\n * @param source\n * @param delimiter\n */\nexport function* stringSegmentsWholeToFirst(source, delimiter = `.`) {\n    while (source.length > 0) {\n        yield source;\n        const b = beforeMatch(source, delimiter, { ifNoMatch: `original`, fromEnd: true });\n        if (b === source)\n            break;\n        source = b;\n    }\n}\n/**\n * Given a long string, abbreviates it with ...\n * ```js\n * abbreviate(`This is something`, 7); // `This is...`\n * ```\n *\n * If `source` is under `maxLength` the original is returned.\n * @param source\n * @param maxLength Maximum length. Defaults to 20\n * @returns\n */\nexport const abbreviate = (source, maxLength = 15) => {\n    resultThrow(integerTest(maxLength, `aboveZero`, `maxLength`));\n    if (typeof source !== `string`)\n        throw new Error(`Parameter 'source' is not a string`);\n    if (source.length > maxLength && source.length > 3) {\n        if (maxLength > 15) {\n            const chunk = Math.round((maxLength - 2) / 2);\n            return source.slice(0, chunk) + `...` + source.slice(-chunk);\n        }\n        return source.slice(0, maxLength) + `...`;\n    }\n    return source;\n};\n/**\n * Uses JSON.toString() on `source`, but abbreviates result.\n * @param source Object to stringify\n * @param maxLength Default 20\n * @returns\n */\nexport const toStringAbbreviate = (source, maxLength = 20) => {\n    if (source === undefined)\n        return `(undefined)`;\n    if (source === null)\n        return `(null)`;\n    return abbreviate(JSON.stringify(source), maxLength);\n};\n/**\n * Returns source text that is between `start` and `end` match strings. Returns _undefined_ if start/end is not found.\n *\n * ```js\n * // Yields ` orange `;\n * between(`apple orange melon`, `apple`, `melon`);\n * ```\n * @param source Source text\n * @param start Start match\n * @param end If undefined, the `start` string will be looked for\n * @param lastEndMatch If true, looks for the last match of `end` (default). If false, looks for the first match.\n * @returns\n */\nexport const between = (source, start, end, lastEndMatch = true) => {\n    // ✔ Unit tested\n    const startPos = source.indexOf(start);\n    if (startPos < 0)\n        return;\n    if (typeof end === `undefined`)\n        end = start;\n    const endPos = lastEndMatch\n        ? source.lastIndexOf(end)\n        : source.indexOf(end, startPos + 1);\n    if (endPos < 0)\n        return;\n    return source.slice(startPos + 1, endPos);\n};\n/**\n * Like {@link between}, but also returns the source string without the start/end match and what's between.\n * ```js\n * const [src,between] = betweenChomp('hello [there] friend', '[', ']');\n * // src: 'hello  friend'\n * // between: 'there'\n * ```\n * @param source\n * @param start\n * @param end\n * @param lastEndMatch\n * @returns\n */\nexport const betweenChomp = (source, start, end, lastEndMatch = true) => {\n    // ✔ Unit tested\n    if (typeof source !== `string`)\n        throw new Error(`Parameter 'source' is not a string`);\n    if (typeof start !== `string`)\n        throw new Error(`Parameter 'start' is not a string`);\n    if (end !== undefined && typeof end !== `string`)\n        throw new Error(`Parameter 'end' is not a string`);\n    const startPos = source.indexOf(start);\n    if (startPos < 0)\n        return [source, undefined];\n    if (typeof end === `undefined`)\n        end = start;\n    const endPos = lastEndMatch\n        ? source.lastIndexOf(end)\n        : source.indexOf(end, startPos + 1);\n    if (endPos < 0)\n        return [source, undefined];\n    const between = source.slice(startPos + 1, endPos);\n    const sourceResult = source.slice(0, startPos) + source.slice(endPos + 1);\n    return [sourceResult, between];\n};\n/**\n * Returns first position of the given character code, or -1 if not found.\n * @param source Source string\n * @param code Code to seek\n * @param start Start index, 0 by default\n * @param end End index (inclusive), source.length-1 by default\n * @returns Found position, or -1 if not found\n */\nexport const indexOfCharCode = (source, code, start = 0, end = source.length - 1) => {\n    for (let index = start; index <= end; index++) {\n        if (source.codePointAt(index) === code)\n            return index;\n    }\n    return -1;\n};\n/**\n * Returns `source` with a given number of characters removed from start position.\n *\n * ```js\n * // Remove three characters starting at position 1\n * omitChars(`hello there`, 1, 3); // ie. removes 'ell'\n * // Yields: `ho there`\n * ```\n * @param source\n * @param removeStart Start point to remove\n * @param removeLength Number of characters to remove\n * @returns\n */\nexport const omitChars = (source, removeStart, removeLength) => source.slice(0, removeStart) +\n    source.slice(removeStart + removeLength);\n/**\n * Splits a string into `length`-size chunks.\n *\n * If `length` is greater than the length of `source`, a single element array is returned with source.\n * The final array element may be smaller if we ran out of characters.\n *\n * ```js\n * splitByLength(`hello there`, 2);\n * // Yields:\n * // [`he`, `ll`, `o `, `th`, `er`, `e`]\n * ```\n * @param source Source string\n * @param length Length of each chunk\n * @returns\n */\nexport const splitByLength = (source, length) => {\n    resultThrow(integerTest(length, `aboveZero`, `length`));\n    if (source === null)\n        throw new Error(`source parameter null`);\n    if (typeof source !== `string`) {\n        throw new TypeError(`source parameter not a string`);\n    }\n    // ✔ Unit tested\n    const chunks = Math.ceil(source.length / length);\n    const returnValue = [];\n    let start = 0;\n    for (let c = 0; c < chunks; c++) {\n        returnValue.push(source.slice(start, start + length));\n        start += length;\n    }\n    return returnValue;\n};\n// export const afterMatch = (\n//   source: string,\n//   match: string,\n//   options: MatchOptions = {}\n// ): string => {\n//   if (source === undefined) throw new Error(`Param 'source' is undefined`);\n//   //  ✔️ Unit tested\n//   const startPos = options.startPos ?? undefined;\n//   const fromEnd = options.fromEnd ?? false;\n//   const m = fromEnd\n//     ? source.lastIndexOf(match, startPos)\n//     : source.indexOf(match, startPos);\n//   if (m < 0) return source;\n//   return source.slice(Math.max(0, m + match.length));\n// };\n/**\n * Returns all the text in `source` that precedes (and does not include) `match`. If not found, `source` is returned.\n *\n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n *\n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n *\n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const beforeMatch = (source, match, options = {}) => {\n    const ba = beforeAfterMatch(source, match, options);\n    return ba[0];\n};\n/**\n * Returns all the text in `source` that follows `match`. If not found, `source` is returned.\n *\n * See also: {@link beforeMatch}, {@link beforeAfterMatch}.\n *\n * ```js\n * afterMatch(`Hello. There`, `.`); // ' There'\n * afterMatch(`Hello, there', `,`); // 'Hello, there'\n * ```\n *\n * If `source` is _undefined_, an error is thrown.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const afterMatch = (source, match, options = {}) => {\n    const ba = beforeAfterMatch(source, match, options);\n    return ba[1];\n};\n/**\n * Returns the text that is before and after `match`.\n *\n * See also: {@link beforeMatch}, {@link afterMatch}.\n *\n * If `match` is at the end of start of `source`, after or before might be an empty string.\n * @param source\n * @param match\n * @param options\n * @returns\n */\nexport const beforeAfterMatch = (source, match, options = {}) => {\n    if (source === undefined)\n        throw new Error(`Param 'source' is undefined`);\n    let fallback = options.fallback;\n    const ifNoMatch = options.ifNoMatch ?? (fallback ? `fallback` : `original`);\n    if (ifNoMatch === `original`)\n        fallback = source;\n    if (ifNoMatch === `fallback` && fallback === undefined)\n        throw new Error(`Fallback must be provided`);\n    const startPos = options.startPos ?? undefined;\n    const fromEnd = options.fromEnd ?? false;\n    const m = fromEnd\n        ? source.lastIndexOf(match, startPos)\n        : source.indexOf(match, startPos);\n    if (m < 0 && ifNoMatch === `throw`)\n        throw new Error(`Match '${match}' not found in source.`);\n    if (m < 0 && ifNoMatch === `original`)\n        return [source, source];\n    if (m < 0 && ifNoMatch === `fallback`) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return [fallback, fallback];\n    }\n    return [\n        source.slice(0, m),\n        source.slice(Math.max(0, m + match.length))\n    ];\n};\n/**\n * 'Unwraps' a string, removing one or more 'wrapper' strings that it starts and ends with.\n * Only removes when a matching end is found.\n * ```js\n * unwrap(\"'hello'\", \"'\");        // hello\n * // No mataching end 'a', so nothing happens\n * unwrap(\"apple\", \"a\");          // apple\n * unwrap(\"wow\", \"w\");            // o\n * unwrap(`\"'blah'\"`, '\"', \"'\");  // blah\n * ```\n * @param source\n * @param wrappers\n * @returns\n */\nexport const unwrap = (source, ...wrappers) => {\n    let matched = false;\n    do {\n        matched = false;\n        for (const w of wrappers) {\n            if (source.startsWith(w) && source.endsWith(w)) {\n                source = source.slice(w.length, source.length - w.length * 2 + 1);\n                matched = true;\n            }\n        }\n    } while (matched);\n    return source;\n};\n/**\n * Calculates the span, defined in {@link Range} indexes, that includes `start` through to `end` character positions.\n *\n * After using {@link splitRanges} to split text, `lineSpan` is used to associate some text coordinates with ranges.\n *\n * @param ranges Ranges\n * @param start Start character position, in source text reference\n * @param end End character position, in source text reference\n * @returns Span\n */\nexport const lineSpan = (ranges, start, end) => {\n    let s = -1;\n    let endPos = -1;\n    for (const [index, r] of ranges.entries()) {\n        s = index;\n        if (r.text.length === 0)\n            continue;\n        if (start < r.end) {\n            break;\n        }\n    }\n    for (let index = s; index < ranges.length; index++) {\n        const r = ranges[index];\n        endPos = index;\n        if (end === r.end) {\n            endPos = index + 1;\n            break;\n        }\n        if (end < r.end) {\n            break;\n        }\n    }\n    return { length: endPos - s, start: s, end: endPos };\n};\n/**\n * Splits a source string into ranges:\n * ```js\n * const ranges = splitRanges(\"hello;there;fella\", \";\");\n * ```\n *\n * Each range consists of:\n * ```js\n * {\n *  text: string  - the text of range\n *  start: number - start pos of range, wrt to source\n *  end: number   - end pos of range, wrt to source\n *  index: number - index of range (starting at 0)\n * }\n * ```\n * @param source\n * @param split\n * @returns\n */\nexport const splitRanges = (source, split) => {\n    let start = 0;\n    let text = ``;\n    const ranges = [];\n    let index = 0;\n    for (let index_ = 0; index_ < source.length; index_++) {\n        if (source.indexOf(split, index_) === index_) {\n            const end = index_;\n            ranges.push({\n                text,\n                start,\n                end,\n                index,\n            });\n            start = end + 1;\n            text = ``;\n            index++;\n        }\n        else {\n            text += source.charAt(index_);\n        }\n    }\n    if (start < source.length) {\n        ranges.push({ text, start, index, end: source.length });\n    }\n    return ranges;\n};\n/**\n * Counts the number of times one of `chars` appears at the front of\n * a string, contiguously.\n *\n * ```js\n * countCharsFromStart(`  hi`, ` `); // 2\n * countCharsFromStart(`hi  `, ` `); // 0\n * countCharsFromStart(`  hi  `, ` `); // 2\n * ```\n * @param source\n * @param chars\n * @returns\n */\nexport const countCharsFromStart = (source, ...chars) => {\n    let counted = 0;\n    for (let index = 0; index < source.length; index++) {\n        if (chars.includes(source.charAt(index))) {\n            counted++;\n        }\n        else {\n            break;\n        }\n    }\n    return counted;\n};\n/**\n * Returns _true_ if `source` starts and ends with `start` and `end`. Case-sensitive.\n * If _end_ is omitted, the the `start` value will be used.\n *\n * ```js\n * startsEnds(`This is a string`, `This`, `string`); // True\n * startsEnds(`This is a string`, `is`, `a`); // False\n * starsEnds(`test`, `t`); // True, starts and ends with 't'\n * ```\n * @param source String to search within\n * @param start Start\n * @param end End (if omitted, start will be looked for at end as well)\n * @returns True if source starts and ends with provided values.\n */\nexport const startsEnds = (source, start, end = start) => source.startsWith(start) && source.endsWith(end);\nexport const htmlEntities = (source) => source.replaceAll(/[&<>\\u00A0-\\u9999]/g, (index) => `&#${index.codePointAt(0)};`);\n/**\n * Simple wilcard matching. Use '*' in `pattern` to denote any number of characters.\n * ```js\n * // Must start with 'cat'\n * wildcard(`cat*`,`caterpillar`); // true\n * // Must end with 'cat'\n * wildcat(`*cat`, `bobcat`);  // true\n * // 'cat' anywhere in string\n * wildcard(`*cat*`, `see cat run`); // true\n * ```\n * @param pattern\n * @returns\n */\nexport const wildcard = (pattern) => {\n    // Based on source: https://stackoverflow.com/questions/26246601/wildcard-string-comparison-in-javascript\n    // for this solution to work on any string, no matter what characters it has\n    const escapeRegex = (value) => value.replaceAll(/([!$()*+./:=?[\\\\\\]^{|}])/g, `\\\\$1`);\n    // \".\"  => Find a single character, except newline or line terminator\n    // \".*\" => Matches any string that contains zero or more characters\n    pattern = pattern.split(`*`).map(m => escapeRegex(m)).join(`.*`);\n    // \"^\"  => Matches any string with the following at the beginning of it\n    // \"$\"  => Matches any string with that in front at the end of it\n    pattern = `^` + pattern + `$`;\n    // Create a regular expression object for matching string\n    const regex = new RegExp(pattern);\n    return (value) => {\n        // Returns true if it finds a match, otherwse it returns false\n        return regex.test(value);\n    };\n};\n","export const isAsyncIterable = (v) => {\n    if (typeof v !== `object`)\n        return false;\n    if (v === null)\n        return false;\n    return Symbol.asyncIterator in v;\n};\nexport const isIterable = (v) => {\n    if (typeof v !== `object`)\n        return false;\n    if (v === null)\n        return false;\n    return Symbol.iterator in v;\n};\n","export function* slice(it, start = 0, end = Number.POSITIVE_INFINITY) {\n    if (end < start)\n        throw new Error(`Param 'end' should be more than 'start'`);\n    if (start < 0)\n        throw new Error(`Param 'start' should be at least 0`);\n    let index = 0;\n    for (const v of it) {\n        if (index < start) {\n            index++;\n            continue;\n        }\n        if (index > end) {\n            break;\n        }\n        yield v;\n        index++;\n    }\n}\n","export function reduce(it, f, start) {\n    // https://surma.github.io/underdash/\n    for (const v of it)\n        start = f(start, v);\n    return start;\n}\n","import { toStringDefault } from '@ixfx/core';\nimport { intervalToMs } from '@ixfx/core';\nimport { isIterable } from './guard.js';\nexport { slice } from './sync/slice.js';\nexport { reduce } from './sync/reduce.js';\nexport function* uniqueByValue(input, toString = toStringDefault, seen = new Set()) {\n    for (const v of input) {\n        const key = toString(v);\n        if (seen.has(key))\n            continue;\n        seen.add(key);\n        yield v;\n    }\n}\n/**\n * Calls `callback` whenever the generator produces a value.\n *\n * When using `asCallback`, call it with `await` to let generator\n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n *\n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input\n * @param callback\n */\nexport function asCallback(input, callback, onDone) {\n    for (const value of input) {\n        callback(value);\n    }\n    if (onDone)\n        onDone();\n}\n/**\n * Returns a function that yields a value from a generator.\n * ```js\n * const spring = yieldNumber(Oscillators.spring());\n *\n * spring(); // latest value\n * ```\n *\n * Instead of:\n * ```js\n * const spring = Oscillators.spring();\n *\n * spring.next().value\n * ```\n *\n * A `defaultValue` can be provided if the source generator returns undefined:\n * ```js\n * const spring = yieldNumber(Oscillators.spring(), 0);\n * spring(); // Returns 0 if the generator returns undefined\n * ```\n * @param generator\n * @param defaultValue\n * @returns\n */\nexport function yieldNumber(generator, defaultValue) {\n    return () => {\n        const v = generator.next().value;\n        if (v === undefined)\n            return defaultValue;\n        return v;\n    };\n}\n/**\n * Return first value from an iterable, or _undefined_ if\n * no values are generated\n * @param it\n * @returns\n */\nexport function first(it) {\n    for (const value of it) {\n        return value;\n    }\n}\n/**\n * Returns last value from an iterable, or _undefined_\n * if no values are generated\n * @param it\n */\nexport function last(it) {\n    let returnValue;\n    for (const value of it) {\n        returnValue = value;\n    }\n    return returnValue;\n}\n/**\n * Yields chunks of the iterable `it` such that the end of a chunk is the\n * start of the next chunk.\n *\n * Eg, with the input [1,2,3,4,5] and a size of 2, we would get back\n * [1,2], [2,3], [3,4], [4,5].\n *\n *\n * @param it\n * @param size\n * @returns\n */\nexport function* chunksOverlapping(it, size) {\n    if (size <= 1)\n        throw new Error(`Size should be at least 2`);\n    //eslint-disable-next-line functional/no-let\n    let buffer = [];\n    for (const v of it) {\n        //eslint-disable-next-line functional/immutable-data\n        buffer.push(v);\n        if (buffer.length === size) {\n            yield buffer;\n            //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            buffer = [buffer.at(-1)];\n        }\n    }\n    if (buffer.length <= 1)\n        return;\n    if (buffer.length > 0)\n        yield buffer;\n}\nexport function* chunks(it, size) {\n    //eslint-disable-next-line functional/no-let\n    let buffer = [];\n    for (const v of it) {\n        //eslint-disable-next-line functional/immutable-data\n        buffer.push(v);\n        if (buffer.length === size) {\n            yield buffer;\n            buffer = [];\n        }\n    }\n    if (buffer.length > 0)\n        yield buffer;\n}\nexport function* concat(...its) {\n    for (const it of its)\n        yield* it;\n}\nexport function* dropWhile(it, f) {\n    for (const v of it) {\n        if (!f(v)) {\n            yield v;\n        }\n    }\n}\n/**\n* Loops over a generator until it finishes, calling `callback`.\n* Useful if you don't care about the value generator produces, just the number of loops.\n*\n* ```js\n* until(count(5), () => {\n* // do something 5 times\n* });\n* ```\n*\n* If you want the value from the generator, use a `for of` loop as usual.\n* If `callback` explicitly returns _false_, the generator is aborted.\n* @param it Generator to run\n* @param callback Code to call for each iteration\n*/\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = (it, callback) => {\n    for (const _ of it) {\n        const value = callback();\n        if (typeof value === `boolean` && !value)\n            break;\n    }\n};\nexport const next = (it) => {\n    return () => {\n        const r = it.next();\n        if (r.done)\n            return;\n        return r.value;\n    };\n};\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport function equals(it1, it2, equality) {\n    //it1 = it1[Symbol.iterator]();\n    //it2 = it2[Symbol.iterator]();\n    while (true) {\n        const index1 = it1.next(), index2 = it2.next();\n        if (equality !== undefined) {\n            if (!equality(index1.value, index2.value))\n                return false;\n        }\n        else if (index1.value !== index2.value)\n            return false;\n        if (index1.done ?? index2.done)\n            return index1.done && index2.done;\n    }\n}\nexport function every(it, f) {\n    for (const v of it) {\n        const result = f(v);\n        if (!result)\n            return false;\n    }\n    return true;\n}\nexport function* fill(it, v) {\n    // https://surma.github.io/underdash/\n    for (const _ of it)\n        yield v;\n}\n/**\n * Iterates over `iterator` (iterable/array), calling `fn` for each value.\n * If `fn` returns _false_, iterator cancels.\n *\n * Over the default JS `forEach` function, this one allows you to exit the\n * iteration early.\n *\n * @example\n * ```js\n * import { Sync } from \"https://unpkg.com/ixfx/dist/iterables.js\"\n * Sync.forEach(count(5), () => console.log(`Hi`));  // Prints `Hi` 5x\n * Sync.forEach(count(5), i => console.log(i));      // Prints 0 1 2 3 4\n * Sync.forEach([0,1,2,3,4], i => console.log(i));   // Prints 0 1 2 3 4\n * ```\n *\n * Use {@link forEach} if you want to use an async `iterator` and async `fn`.\n *\n * Alternatives:\n * * {@link @ixfx/flow.repeat}/{@link @ixfx/flow.repeatSync}: if you want to call something a given number of times and get the result\n * @param iterator Iterable or array\n * @typeParam T Type of iterable's values\n * @param fn Function to call for each item. If function returns _false_, iteration cancels\n */\nexport function forEach(iterator, fn) {\n    for (const v of iterator) {\n        const result = fn(v);\n        if (typeof result === `boolean` && !result)\n            break;\n    }\n}\n/**\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport function* filter(it, f) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        if (!f(v))\n            continue;\n        yield v;\n    }\n}\nexport function find(it, f) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        if (f(v))\n            return v;\n    }\n}\nexport function* flatten(it) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        if (typeof v === `object`) {\n            if (Array.isArray(v)) {\n                for (const vv of v)\n                    yield vv;\n            }\n            else if (isIterable(v)) {\n                for (const vv of v) {\n                    yield vv;\n                }\n            }\n        }\n        else {\n            yield v;\n        }\n    }\n}\n/**\n * Maps an iterable of type `V` to type `X`.\n * ```js\n * map([1, 2, 3], e => e*e)\n * returns [1, 4, 9]\n * ```\n * @param it\n * @param f\n */\nexport function* map(it, f) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        yield f(v);\n    }\n}\nexport function* max(it, gt = (a, b) => a > b) {\n    let max;\n    for (const v of it) {\n        if (max === undefined) {\n            max = v;\n            yield max;\n            continue;\n        }\n        if (gt(v, max)) {\n            max = v;\n            yield max;\n        }\n    }\n    return max;\n}\nexport function* min(it, gt = (a, b) => a > b) {\n    let min;\n    for (const v of it) {\n        if (min === undefined) {\n            min = v;\n            yield min;\n        }\n        if (gt(min, v)) {\n            min = v;\n            yield min;\n        }\n    }\n}\nexport function some(it, f) {\n    // https://surma.github.io/underdash/\n    for (const v of it) {\n        if (f(v))\n            return true;\n    }\n    return false;\n}\n// export function* takeWhile<V>(it: Iterable<V>, f: (v: V) => boolean) {\n//   // https://surma.github.io/underdash/\n//   for (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\nexport function* repeat(genCreator, repeatsOrSignal) {\n    const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n    const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n    let count = repeats;\n    while (true) {\n        for (const v of genCreator()) {\n            yield v;\n            if (signal?.aborted)\n                break;\n        }\n        if (Number.isFinite(repeats)) {\n            count--;\n            if (count === 0)\n                break;\n        }\n        if (signal?.aborted)\n            break;\n    }\n}\nexport function* unique(iterable) {\n    // Adapted from https://surma.github.io/underdash/\n    const buffer = [];\n    let itera = [];\n    itera = Array.isArray(iterable) ? iterable : [iterable];\n    for (const it of itera) {\n        for (const v of it) {\n            if (buffer.includes(v))\n                continue;\n            buffer.push(v);\n            yield v;\n        }\n    }\n}\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport function* zip(...its) {\n    // https://surma.github.io/underdash/\n    const iits = its.map((it) => it[Symbol.iterator]());\n    while (true) {\n        const vs = iits.map((it) => it.next());\n        if (vs.some((v) => v.done))\n            return;\n        yield vs.map((v) => v.value);\n    }\n}\nexport function* fromIterable(iterable) {\n    for (const v of iterable) {\n        yield v;\n    }\n}\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a limit via the options or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param options Options when converting to array.\n * @returns\n */\nexport function toArray(it, options = {}) {\n    const result = [];\n    const started = Date.now();\n    const whileFunction = options.while;\n    const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n    const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n    for (const v of it) {\n        if (whileFunction) {\n            if (!whileFunction(result.length))\n                break;\n        }\n        if (result.length >= maxItems)\n            break;\n        if (Date.now() - started > maxElapsed)\n            break;\n        result.push(v);\n    }\n    return result;\n}\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param array Array of values\n */\nexport function* fromArray(array) {\n    for (const v of array) {\n        yield v;\n    }\n}\n","export class MapOfSimple {\n    #store = new Map();\n    /**\n     * Gets a copy of the underlying array storing values at `key`, or an empty array if\n     * key does not exist\n     * @param key\n     * @returns\n     */\n    get(key) {\n        const arr = this.#store.get(key);\n        if (!arr)\n            return [];\n        return [...arr];\n    }\n    /**\n     * Returns the number of values stored under `key`\n     * @param key\n     * @returns\n     */\n    size(key) {\n        const arr = this.#store.get(key);\n        if (!arr)\n            return 0;\n        return arr.length;\n    }\n    /**\n     * Iterate over all values contained under `key`\n     * @param key\n     * @returns\n     */\n    *iterateKey(key) {\n        const arr = this.#store.get(key);\n        if (!arr)\n            return;\n        yield* arr.values();\n    }\n    /**\n     * Iterate all values, regardless of key\n     */\n    *iterateValues() {\n        for (const key of this.#store.keys()) {\n            yield* this.iterateKey(key);\n        }\n    }\n    /**\n     * Iterate all keys\n     */\n    *iterateKeys() {\n        yield* this.#store.keys();\n    }\n    addKeyedValues(key, ...values) {\n        let arr = this.#store.get(key);\n        if (!arr) {\n            arr = [];\n            this.#store.set(key, arr);\n        }\n        arr.push(...values);\n    }\n    deleteKeyValue(key, value) {\n        const arr = this.#store.get(key);\n        if (!arr)\n            return false;\n        const arrCopy = arr.filter(v => v !== value);\n        if (arrCopy.length === arr.length)\n            return false;\n        this.#store.set(key, arrCopy);\n        return true;\n    }\n    clear() {\n        this.#store.clear();\n    }\n}\n","import { MapOfSimple } from \"./map-of.js\";\nexport class SimpleEventEmitter {\n    #listeners = new MapOfSimple();\n    #disposed = false;\n    dispose() {\n        if (this.#disposed)\n            return;\n        this.clearEventListeners();\n    }\n    get isDisposed() {\n        return this.#disposed;\n    }\n    /**\n     * Fire event\n     * @param type Type of event\n     * @param args Arguments for event\n     * @returns\n     */\n    fireEvent(type, args) {\n        if (this.#disposed)\n            throw new Error(`Disposed`);\n        //console.log(`Firing ${ type as string }. Listeners: ${ this.#listeners.size(type as string) }`);\n        for (const l of this.#listeners.iterateKey(type)) {\n            l(args, this);\n        }\n    }\n    /**\n     * Adds event listener.\n     *\n     * @throws Error if emitter is disposed\n     * @typeParam K - Events\n     * @param name Event name\n     * @param listener Event handler\n     */\n    addEventListener(name, listener) {\n        if (this.#disposed)\n            throw new Error(`Disposed`);\n        this.#listeners.addKeyedValues(name, listener);\n    }\n    /**\n     * Remove event listener\n     *\n     * @param listener\n     */\n    removeEventListener(type, listener) {\n        if (this.#disposed)\n            return;\n        // listener: Listener<Events>): void {\n        this.#listeners.deleteKeyValue(type, listener);\n    }\n    /**\n     * Clear all event listeners\n     * @private\n     */\n    clearEventListeners() {\n        if (this.#disposed)\n            return;\n        this.#listeners.clear();\n    }\n}\n","export { SimpleEventEmitter } from './simple-event-emitter.js';\nexport * from './types.js';\n","import { intervalToMs, toStringDefault } from '@ixfx/core';\nimport { sleep } from '@ixfx/core';\nimport { isAsyncIterable, isIterable } from './guard.js';\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n *\n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport async function* fromArray(array, interval = 1) {\n    for (const v of array) {\n        yield v;\n        await sleep(interval);\n    }\n}\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport async function* fromIterable(iterable, interval = 1) {\n    for await (const v of iterable) {\n        yield v;\n        await sleep(interval);\n    }\n}\nexport async function* chunks(it, size) {\n    // Source: https://surma.github.io/underdash/\n    let buffer = [];\n    for await (const v of it) {\n        buffer.push(v);\n        if (buffer.length === size) {\n            yield buffer;\n            buffer = [];\n        }\n    }\n    if (buffer.length > 0)\n        yield buffer;\n}\nexport async function* concat(...its) {\n    // Source: https://surma.github.io/underdash/\n    for await (const it of its)\n        yield* it;\n}\nexport async function* dropWhile(it, f) {\n    for await (const v of it) {\n        if (!f(v)) {\n            yield v;\n        }\n    }\n}\n/**\n * Loops over a generator until it finishes, calling `callback`.\n * Useful if you don't care about the value generator produces, just the number of loops.\n *\n * In this version, we do a `for await of` over `gen`, and also `await callback()`.\n\n * ```js\n * await until(count(5), () => {\n * // do something 5 times\n * });\n * ```\n *\n * If you want the value from the generator, use a `for of` loop as usual.\n *\n * If `callback` explicitly returns _false_, the generator is aborted.\n * @param it Generator to run\n * @param callback Code to call for each iteration\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = async (it, callback) => {\n    for await (const _ of it) {\n        const value = await callback();\n        if (typeof value === `boolean` && !value)\n            break;\n    }\n};\n/**\n * This generator will repeat another generator up until some condition. This is the version\n * that can handle async generators.\n *\n * For example, {@link @ixfx/numbers.count} will count from 0..number and then finish:\n * ```js\n * import { count } from '@ixfx/numbers'\n * for (const v of count(5)) {\n *  // v: 0, 1, 2, 3, 4\n * }\n * ```\n *\n * But what if we want to repeat the count? We have to provide a function to create the generator,\n * rather than using the generator directly, since it's \"one time use\"\n * ```js\n * for await (const v of repeat(() => count(5))) {\n *  // v: 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, ...\n *  // warning: never ends\n * }\n * ```\n *\n * Limiting the number of repeats can be done by passing in extra parameters\n * ```js\n * repeat(generator, { count: 5} ); // Iterate over `generator` five times\n * ```\n *\n * ```js\n * const ac = new AbortController();\n * repeat(generator, { signal: ac.signal }); // Pass in signal\n * ...\n * ac.abort(); // Trigger signal at some point\n * ```\n * @param genCreator\n * @param repeatsOrSignal\n */\nexport const repeat = async function* (genCreator, repeatsOrSignal) {\n    const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n    const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n    let count = repeats;\n    while (true) {\n        for await (const v of genCreator()) {\n            yield v;\n            if (signal?.aborted)\n                break;\n        }\n        if (Number.isFinite(repeats)) {\n            count--;\n            if (count === 0)\n                break;\n        }\n        if (signal?.aborted)\n            break;\n    }\n};\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport async function equals(it1, it2, equality) {\n    // https://surma.github.io/underdash/\n    const iit1 = it1[Symbol.asyncIterator](); // it1[ Symbol.iterator ]();\n    const iit2 = it2[Symbol.asyncIterator]();\n    while (true) {\n        const index1 = await iit1.next();\n        const index2 = await iit2.next();\n        if (equality !== undefined) {\n            if (!equality(index1.value, index2.value))\n                return false;\n        }\n        else if (index1.value !== index2.value)\n            return false;\n        if (index1.done ?? index2.done)\n            return index1.done && index2.done;\n    }\n}\nexport async function every(it, f) {\n    for await (const v of it) {\n        const result = await f(v);\n        if (!result)\n            return false;\n    }\n    return true;\n}\nexport async function* fill(it, v) {\n    // https://surma.github.io/underdash/\n    for await (const _ of it)\n        yield v;\n}\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport async function* filter(it, f) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        if (!await f(v))\n            continue;\n        yield v;\n    }\n}\nexport async function find(it, f) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        if (await f(v))\n            return v;\n    }\n}\nexport async function* flatten(it) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        if (typeof v === `object`) {\n            if (Array.isArray(v)) {\n                for (const vv of v)\n                    yield vv;\n            }\n            else if (isAsyncIterable(v)) {\n                for await (const vv of v) {\n                    yield vv;\n                }\n            }\n            else if (isIterable(v)) {\n                for (const vv of v) {\n                    yield vv;\n                }\n            }\n        }\n        else {\n            yield v;\n        }\n    }\n}\n/**\n * Iterates over an async iterable or array, calling `fn` for each value, with optional\n * interval between each loop. If the async `fn` returns _false_, iterator cancels.\n *\n * ```\n * import { forEach } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * // Prints items from array every second\n * await forEach([0,1,2,3], i => console.log(i), 1000);\n * ```\n *\n * ```\n * // Retry up to five times, with 5 seconds between each attempt\n * await forEach(count(5), i=> {\n *  try {\n *    await doSomething();\n *    return false; // Succeeded, exit early\n *  } catch (ex) {\n *    console.log(ex);\n *    return true; // Keep trying\n *  }\n * }, 5000);\n * ```\n * @param iterator Iterable thing to loop over\n * @param fn Function to invoke on each item. If it returns _false_ loop ends.\n * @param options Options\n * @typeParam V Type of iterable\n */\nexport const forEach = async function (iterator, fn, options = {}) {\n    const interval = options.interval;\n    if (Array.isArray(iterator)) {\n        // Handle array\n        for (const x of iterator) {\n            const r = await fn(x);\n            if (typeof r === `boolean` && !r)\n                break;\n            if (interval)\n                await sleep(interval);\n        }\n    }\n    else {\n        // Handle an async iterator\n        for await (const x of iterator) {\n            const r = await fn(x);\n            if (typeof r === `boolean` && !r)\n                break;\n            if (interval)\n                await sleep(interval);\n        }\n    }\n};\n// export async function forEach<V>(it: AsyncIterable<V>, f: (v: V) => void | boolean | Promise<boolean | void>) {\n//   // https://surma.github.io/underdash/\n//   for await (const v of it) {\n//     const result = await f(v);\n//     if (typeof result === `boolean` && !result) break;\n//   }\n// }\n/**\n * Returns last value from an iterable, or _undefined_\n * if no values are generated\n * @param it\n */\nexport async function last(it, opts = {}) {\n    const abort = opts.abort;\n    let returnValue;\n    for await (const value of it) {\n        if (abort?.aborted)\n            return undefined;\n        returnValue = value;\n    }\n    return returnValue;\n}\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n *\n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\nexport async function* map(it, f) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        yield f(v);\n    }\n}\nexport async function* max(it, gt = ((a, b) => a > b)) {\n    let max;\n    for await (const v of it) {\n        if (max === undefined) {\n            max = v;\n            yield (max);\n            continue;\n        }\n        // If V is bigger than max, we have a new max\n        if (gt(v, max)) {\n            max = v;\n            yield v;\n        }\n    }\n}\n/**\n * Returns the minimum seen of an iterable as it changes.\n * Streaming result: works with endless iterables.\n *\n * Note that `gt` function returns true if A is _greater_ than B, even\n * though we're looking for the minimum.\n *\n * ```js\n * // Rank objects based on 'v' value\n * const rank = (a,b) => a.v > b.v;\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns\n */\nexport async function* min(it, gt = (a, b) => a > b) {\n    let min;\n    for await (const v of it) {\n        if (min === undefined) {\n            min = v;\n            yield min;\n            continue;\n        }\n        // If min is bigger than V, V is the new min\n        if (gt(min, v)) {\n            min = v;\n            yield v;\n        }\n    }\n    return min;\n}\nexport async function reduce(it, f, start) {\n    // https://surma.github.io/underdash/\n    for await (const v of it)\n        start = f(start, v);\n    return start;\n}\n/**\n * Calls `callback` whenever the async generator produces a value.\n *\n * When using `asCallback`, call it with `await` to let generator\n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n *\n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input\n * @param callback\n */\nexport async function asCallback(input, callback, onDone) {\n    for await (const value of input) {\n        callback(value);\n    }\n    if (onDone)\n        onDone();\n}\nexport async function* slice(it, start = 0, end = Number.POSITIVE_INFINITY) {\n    console.log(`Async slice start: ${start}`);\n    // https://surma.github.io/underdash/\n    const iit = it[Symbol.asyncIterator]();\n    if (end < start)\n        throw new Error(`Param 'end' should be more than 'start'`);\n    for (; start > 0; start--, end--)\n        await iit.next();\n    for await (const v of it) {\n        if (end-- > 0) {\n            yield v;\n        }\n        else {\n            break;\n        }\n    }\n}\n/**\n * Enumerates over an input iterable, with a delay between items.\n * @param it\n * @param delay\n */\nexport async function* withDelay(it, delay) {\n    for (const v of it) {\n        await sleep(delay);\n        yield v;\n    }\n}\n/***\n * Returns the next IteratorResult,\n * throwing an error if it does not happen\n * within `interval` (default: 1s)\n */\nexport async function nextWithTimeout(it, options) {\n    const ms = intervalToMs(options, 1000);\n    const value = await Promise.race([\n        (async () => {\n            await sleep({ millis: ms, signal: options.signal });\n            return undefined;\n        })(),\n        (async () => {\n            return await it.next();\n        })()\n    ]);\n    if (value === undefined)\n        throw new Error(`Timeout`);\n    return value;\n}\nexport async function some(it, f) {\n    // https://surma.github.io/underdash/\n    for await (const v of it) {\n        if (await f(v))\n            return true;\n    }\n    return false;\n}\n// export async function* takeWhile<V>(\n//   it: AsyncIterable<V>,\n//   f: (v: V) => boolean\n// ) {\n//   // https://surma.github.io/underdash/\n//   for await (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide limits via the options.\n * ```js\n * // Return maximum five items\n * const data = await toArray(iterable, { limit: 5 });\n * // Return results for a maximum of 5 seconds\n * const data = await toArray(iterable, { elapsed: 5000 });\n * ```\n * Note that limits are ORed, `toArray` will finish if either of them is true.\n *\n * @param it Asynchronous iterable\n * @param options Options when converting to array\n * @returns\n */\nexport async function toArray(it, options = {}) {\n    // https://2ality.com/2016/10/asynchronous-iteration.html\n    const result = [];\n    const iterator = it[Symbol.asyncIterator]();\n    const started = Date.now();\n    const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n    const whileFunction = options.while;\n    const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n    while (result.length < maxItems && (Date.now() - started < maxElapsed)) {\n        if (whileFunction) {\n            if (!whileFunction(result.length))\n                break;\n        }\n        const r = await iterator.next();\n        if (r.done)\n            break;\n        //eslint-disable-next-line functional/immutable-data\n        result.push(r.value);\n    }\n    return result;\n}\nexport async function* unique(iterable) {\n    const buffer = [];\n    const itera = Array.isArray(iterable) ? iterable : [iterable];\n    for await (const it of itera) {\n        for await (const v of it) {\n            if (buffer.includes(v))\n                continue;\n            buffer.push(v);\n            yield v;\n        }\n    }\n}\nexport async function* uniqueByValue(input, toString = toStringDefault, seen = new Set()) {\n    for await (const v of input) {\n        const key = toString(v);\n        if (seen.has(key))\n            continue;\n        seen.add(key);\n        yield v;\n    }\n}\n/**\n * Returns unique items from iterables, given a particular key function\n * ```js\n * unique([{i:0,v:2},{i:1,v:3},{i:2,v:2}], e => e.v);\n * Yields:  [{i:0,v:2},{i:1,v:3}]\n * @param it\n * @param f\n */\n// export async function* unique<V>(\n//   it: AsyncIterable<V>,\n//   f: (id: V) => V = (id) => id\n// ) {\n//   // https://surma.github.io/underdash/\n//   const buffer: Array<V> = [];\n//   for await (const v of it) {\n//     const fv = f(v);\n//     if (buffer.includes(fv)) continue;\n//     buffer.push(fv);\n//     yield v;\n//   }\n// }\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport async function* zip(...its) {\n    // https://surma.github.io/underdash/\n    const iits = its.map((it) => it[Symbol.asyncIterator]());\n    while (true) {\n        const vs = await Promise.all(iits.map((it) => it.next()));\n        if (vs.some((v) => v.done))\n            return;\n        yield vs.map((v) => v.value);\n    }\n}\n","import { compareIterableValuesShallow, isEqualDefault } from \"@ixfx/core\";\n/**\n * Returns the 'max' of some iterable using the provided scoring function.\n * It only yields a value when iterator finishes.\n * @param iterable\n * @param scorer\n * @returns\n */\nexport const maxScore = (iterable, scorer) => {\n    let highestValue;\n    let highestScore = Number.MIN_SAFE_INTEGER;\n    for (const value of iterable) {\n        const score = scorer(value);\n        if (score >= highestScore) {\n            highestScore = score;\n            highestValue = value;\n        }\n    }\n    return highestValue;\n};\n/**\n * Returns the 'min' of some iterable using the provided scoring function.\n * It only yields a value when iterator finishes.\n * @param iterable\n * @param scorer\n * @returns\n */\nexport const minScore = (iterable, scorer) => {\n    let lowestValue;\n    let lowestScore = Number.MAX_SAFE_INTEGER;\n    for (const value of iterable) {\n        const score = scorer(value);\n        if (score <= lowestScore) {\n            lowestScore = score;\n            lowestValue = value;\n        }\n    }\n    return lowestValue;\n};\n/**\n * Returns _true_ if all values in iterables are equal, regardless\n * of their position. Uses === equality semantics by default.\n *\n * Is NOT recursive.\n *\n * @example Default equality checking\n * ```js\n * const a = ['apples','oranges','pears'];\n * const b = ['pears','oranges','apples'];\n * hasEqualValuesShallow(a, b); // True\n * ```\n *\n * @example Custom equality checking\n * ```js\n * const a = [ { name: 'John' }];\n * const b = [ { name: 'John' }];\n * // False, since object identies are different\n * hasEqualValuesShallow(a, b);\n * // True, since now we're comparing by value\n * hasEqualValuesShallow(a, b, (aa,bb) => aa.name === bb.name);\n * ```\n * @param iterableA First iterable to check\n * @param iterableB Iterable to compare against\n * @param eq Equality function, uses === by default\n */\nexport const hasEqualValuesShallow = (iterableA, iterableB, eq) => {\n    const returnValue = compareIterableValuesShallow(iterableA, iterableB, eq);\n    return returnValue.a.length === 0 && returnValue.b.length === 0;\n};\n","export const fromEvent = (eventSource, eventType) => {\n    const pullQueue = [];\n    const pushQueue = [];\n    let done = false;\n    const pushValue = (args) => {\n        if (pullQueue.length > 0) {\n            //eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const resolver = pullQueue.shift();\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            resolver(...args);\n        }\n        else {\n            pushQueue.push(args);\n        }\n    };\n    const pullValue = () => new Promise((resolve) => {\n        if (pushQueue.length > 0) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment\n            const arguments_ = pushQueue.shift();\n            // @ts-expect-error\n            resolve(...arguments_);\n        }\n        else {\n            pullQueue.push(resolve);\n        }\n    });\n    const handler = (...arguments_) => {\n        pushValue(arguments_);\n    };\n    eventSource.addEventListener(eventType, handler);\n    const r = {\n        next: async () => {\n            if (done)\n                return { done: true, value: undefined };\n            return {\n                done: false,\n                value: await pullValue(),\n            };\n        },\n        //eslint-disable-next-line @typescript-eslint/require-await\n        return: async () => {\n            done = true;\n            eventSource.removeEventListener(eventType, handler);\n            return { done: true, value: undefined };\n        },\n        //eslint-disable-next-line @typescript-eslint/require-await\n        throw: async (error) => {\n            done = true;\n            return {\n                done: true,\n                value: Promise.reject(new Error(error)),\n            };\n        },\n    };\n    return r;\n};\n","import { numberArrayCompute } from \"@ixfx/numbers\";\nimport { isIterable } from \"./guard.js\";\n/**\n * Returns the min, max, avg and total of the array or iterable.\n * Any values that are invalid are silently skipped over.\n *\n * ```js\n * const v = [ 10, 2, 4.2, 99 ];\n * const mma = numbersCompute(v);\n * // Yields: { min: 2, max: 99, total: 115.2, avg: 28.8 }\n * ```\n *\n * Use {@link @ixfx/numbers.average}, {@link @ixfx/numbers.max}, {@link @ixfx/numbers.min} or {@link @ixfx/numers.total} if you only need one of these.\n *\n * A start and end range can be provided if the calculation should be restricted to a part\n * of the input array. By default the whole array is used.\n *\n * It's also possible to use an iterable as input.\n * ```js\n * import { count } from '@ixfx/numbers';\n * numbersCompute(count(5,1)); // Averages 1,2,3,4,5\n * ```\n *\n * Returns `NaN` if the input data is empty.\n * @param data\n * @param options Allows restriction of range that is examined\n * @returns `{min, max, avg, total}`\n */\nexport const numbersCompute = (data, options = {}) => {\n    if (typeof data === `undefined`)\n        throw new Error(`Param 'data' is undefined`);\n    if (Array.isArray(data)) {\n        return numberArrayCompute(data, options);\n    }\n    if (isIterable(data)) {\n        return numbersComputeIterable(data, options);\n    }\n    throw new Error(`Param 'data' is neither an array nor iterable`);\n};\nfunction numbersComputeIterable(data, options = {}) {\n    // if (typeof options.startIndex !== `undefined` || typeof options.endIndex !== `undefined`) {\n    //   data = slice(data, options.startIndex, options.endIndex);\n    // }\n    let total = 0;\n    const nonNumbers = options.nonNumbers ?? `ignore`;\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = Number.MIN_SAFE_INTEGER;\n    let count = 0;\n    for (let v of data) {\n        if (typeof v !== `number` || Number.isNaN(v)) {\n            if (nonNumbers === `throw`)\n                throw new TypeError(`Data contains something not a number. Got type '${typeof v}'`);\n            if (nonNumbers === `nan`)\n                v = Number.NaN;\n            if (nonNumbers === `ignore`)\n                continue;\n        }\n        total += v;\n        count++;\n        min = Math.min(min, v);\n        max = Math.max(max, v);\n    }\n    return {\n        avg: total / count,\n        total, max, min, count\n    };\n}\nexport function computeAverage(data, options = {}) {\n    let count = 0;\n    let total = 0;\n    const nonNumbers = options.nonNumbers ?? `ignore`;\n    for (let d of data) {\n        if (typeof d !== `number` || Number.isNaN(d)) {\n            if (nonNumbers === `throw`)\n                throw new TypeError(`Data contains something not a number. Got type '${typeof d}'`);\n            if (nonNumbers === `nan`)\n                d = Number.NaN;\n            if (nonNumbers === `ignore`)\n                continue;\n        }\n        total += d;\n        count++;\n    }\n    return total / count;\n}\n","import * as Async from './async.js';\nimport * as Sync from './sync.js';\nexport * as Async from './async.js';\nexport * as Sync from './sync.js';\nexport * from './compare-values.js';\nexport * from './from-event.js';\nexport * from './guard.js';\nexport * from './types.js';\nimport { isAsyncIterable } from './guard.js';\n//import * as Chains from './chain/index.js';\n// import type { Interval } from '../flow/IntervalType.js';\nimport { toStringDefault } from '@ixfx/core';\nexport * from './numbers-compute.js';\n/**\n * Returns a stream of minimum values.\n *\n * Streaming result: works with endless iterables.\n *\n * ```js\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], (a, b) => a.v > b.v);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns Yields minimum values\n */\nexport function min(it, gt = (a, b) => a > b) {\n    return isAsyncIterable(it) ? Async.min(it, gt) : Sync.min(it, gt);\n}\n/**\n * Returns the maximum value of an iterable as it changes.\n * Streaming result: works with endless iterables.\n *\n * ```js\n * // Rank values by their 'v' field\n * const rank = (a,b) => a.v > b.v;\n *\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:0,v:1}, {i:1,v:9}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns Iterable of maximum values\n */\nexport function max(it, gt = (a, b) => a > b) {\n    return isAsyncIterable(it) ? Async.max(it, gt) : Sync.max(it, gt);\n}\n/**\n * Drops elements that do not meet the predicate `f`.\n * Streaming result: works with endless iterables.\n *\n * ```js\n * dropWhile([1, 2, 3, 4], e => e < 3);\n * returns [3, 4]\n * ```\n * @param it\n * @param f\n */\nexport function dropWhile(it, f) {\n    return isAsyncIterable(it) ? Async.dropWhile(it, f) : Sync.dropWhile(it, f);\n}\n/**\n* Loops over a generator until it finishes, calling `callback`.\n* Useful if you don't care about the value generator produces, just the number of loops.\n*\n* ```js\n* until(count(5), () => {\n* // do something 5 times\n* });\n* ```\n*\n* If you want the value from the generator, use a `for of` loop as usual.\n* If `callback` explicitly returns _false_, the generator is aborted.\n*\n* This does not work for infinite generators, `callback` will never be called.\n* @param it Generator to run\n* @param callback Code to call for each iteration\n*/\nexport function until(it, callback) {\n    if (isAsyncIterable(it)) {\n        return Async.until(it, callback);\n    }\n    else {\n        // @ts-expect-error\n        Sync.until(it, callback);\n    }\n}\n/**\n * Breaks an iterable into array chunks\n *\n * Streaming: works with infinite iterables.\n *\n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param it\n * @param size\n */\nexport function chunks(it, size) {\n    return isAsyncIterable(it) ? Async.chunks(it, size) : Sync.chunks(it, size);\n}\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n *\n * When using async iterables, `f` can be async as well.\n * @param it\n * @param f\n */\nexport function filter(it, f) {\n    return isAsyncIterable(it) ? Async.filter(it, f) : Sync.filter(it, f);\n}\n/**\n * Yields `v` for each item within `it`.\n *\n * ```js\n * fill([1, 2, 3], 0);\n * // Yields: [0, 0, 0]\n * ```\n *\n * This is like a `map` where we return a fixed value, ignoring the input.\n * @param it\n * @param v\n */\nexport function fill(it, v) {\n    return isAsyncIterable(it) ? Async.fill(it, v) : Sync.fill(it, v);\n}\n/**\n * Return concatenation of iterators.\n *\n * Non-streaming: If one of the input iterables is endless, the other ones won't\n * be processed.\n * @param its\n */\nexport function concat(...its) {\n    return isAsyncIterable(its[0]) ? Async.concat(...its) : Sync.concat(...its);\n}\n/**\n * Returns first item from iterable `it` that matches predicate `f`\n * ```js\n * find([1, 2, 3, 4], e => e > 2);\n * // Yields: 3\n * ```\n *\n * When using async iterables, `f` can be async as well.\n * @param it\n * @param f\n * @returns\n */\nexport function find(it, f) {\n    return isAsyncIterable(it) ? Async.find(it, f) : Sync.find(it, f);\n}\n/**\n * Execute function `f` for each item in iterable.\n * If `f` returns _false_, iteration stops.\n * ```js\n * forEach(iterable, v => {\n *  // do something with value\n * });\n * ```\n *\n * When using an async iterable, `fn` can also be async.\n * @param it Iterable or array\n * @param fn Function to execute\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport function forEach(it, fn, options = {}) {\n    if (isAsyncIterable(it)) {\n        return Async.forEach(it, fn, options);\n    }\n    else {\n        Sync.forEach(it, fn);\n    }\n}\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n *\n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\nexport function map(it, f) {\n    return isAsyncIterable(it) ? Async.map(it, f) : Sync.map(it, f);\n}\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n *\n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport function fromArray(array, interval) {\n    return interval === undefined ? Sync.fromArray(array) : Async.fromArray(array, interval);\n}\n/**\n * Returns a 'flattened' copy of array, un-nesting arrays one level.\n * Streaming: works with unlimited iterables.\n * ```js\n * flatten([1, [2, 3], [[4]]]);\n * // Yields: [1, 2, 3, [4]];\n * ```\n * @param it\n */\nexport function flatten(it) {\n    return isAsyncIterable(it) ? Async.flatten(it) : Sync.flatten(it);\n}\n/**\n * Returns true the first time `f` returns true. Useful for spotting any occurrence of\n * data, and exiting quickly\n * ```js\n * some([1, 2, 3, 4], e => e % 3 === 0);\n * // Yields: true\n * ```\n * @param it Iterable\n * @param f Filter function\n * @returns\n */\nexport function some(it, f) {\n    return isAsyncIterable(it) ? Async.some(it, f) : Sync.some(it, f);\n}\n/**\n * Returns the last item of an iterable, or _undefined_ if it yields no results.\n * @param it\n * @returns\n */\nexport function last(it) {\n    return isAsyncIterable(it) ? Async.last(it) : Sync.last(it);\n}\n/**\n * Reduce for iterables\n * ```js\n * reduce([1, 2, 3], (acc, cur) => acc + cur, 0);\n * // Yields: 6\n * ```\n * @param it Iterable\n * @param f Function\n * @param start Start value\n * @returns\n */\nexport function reduce(it, f, start) {\n    return isAsyncIterable(it) ? Async.reduce(it, f, start) : Sync.reduce(it, f, start);\n}\n/**\n * Returns a section from an iterable.\n *\n * 'end' is the end index, not the number of items.\n *\n * ```js\n * // Return five items from step 10\n * slice(it, 10, 15);\n * ```\n * @param it Iterable\n * @param start Start step\n * @param end Exclusive end step (or until completion)\n */\nexport function slice(it, start = 0, end = Number.POSITIVE_INFINITY) {\n    return isAsyncIterable(it) ? Async.slice(it, start, end) : Sync.slice(it, start, end);\n}\n/**\n * Returns unique items from an iterable or\n * array of iterables.\n *\n * ```js\n * const data = [ 'apples', 'oranges' ]\n * const data2 = [ 'oranges', 'pears' ]\n * const unique = [...unique([data,data2]];\n * // Yields: [ 'apples', 'oranges', 'pears' ]\n * ```\n *\n * Uses object reference to compare values.\n * Use {@link uniqueByValue} if this doesn't suffice.\n * @param iterable Iterable, or array of iterables\n */\nexport function unique(iterable) {\n    if (Array.isArray(iterable)) {\n        if (iterable.length === 0)\n            return Sync.fromArray([]);\n        return isAsyncIterable(iterable[0]) ? Async.unique(iterable) : Sync.unique(iterable);\n    }\n    else if (isAsyncIterable(iterable)) {\n        return Async.unique(iterable);\n    }\n    else {\n        return Sync.unique(iterable);\n    }\n}\n/**\n * Filters the `input` iterable, only yielding unique values. Use {@link unique} to compare\n * by object reference instead.\n *\n * Streaming: Works with unbounded iterables.\n *\n * ```js\n * const d = ['a', 'b', 'c', 'b', 'd' ];\n * for (const v of uniqueByValue(d)) {\n *  // Yields: 'a', 'b', 'c', 'd'\n * // (extra 'b' is skipped)\n * }\n * ```\n *\n * By default, JSON.stringify is used to create a string representing value. These are added\n * to a Set of strings, which is how we keep track of uniqueness. If the value is already a string it is used as-is.\n *\n * This allows you to have custom logic for what determines uniqueness. Eg, using a single field\n * of an object as an identifier:\n *\n * ```js\n * const people = [\n *  { name: `Mary`, size: 20 }, { name: `Abdul`, size: 19 }, { name: `Mary`, size: 5 }\n * ]\n * for (const v of uniqueByValue(d, v=>v.name)) {\n *  // Yields: { name: `Mary`, size: 20 }, { name: `Abdul`, size: 19 }\n *  // Second 'Mary' is skipped because name is the same, even though size field is different.\n * }\n * ```\n *\n * If you want to keep track of the set of keys, or prime it with some existing data, provide a Set instance:\n * ```js\n * const unique = new Set();\n * unique.add(`b`);\n * const d = [`a`, `b`, `c`];\n * for (const v of uniqueByValue(d, toStringDefault, unique)) {\n *  // Yields: `a`, `c`\n *  // `b` is skipped because it was already in set\n * }\n * // After completion, `unique` contains `a`, `b` and `c`.\n * ```\n *\n * Creating your own Set is useful for tracking unique values across several calls to `uniqueByValue`.\n * @param input\n * @param seen\n * @param toString\n */\nexport function* uniqueByValue(input, toString = toStringDefault, seen = new Set()) {\n    return isAsyncIterable(input) ? Async.uniqueByValue(input, toString, seen) : Sync.uniqueByValue(input, toString, seen);\n}\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a `count` or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param count Number of items to return, by default all.\n * @returns\n */\nexport function toArray(it, options = {}) {\n    return isAsyncIterable(it) ? Async.toArray(it, options) : Sync.toArray(it, options);\n}\n/**\n * Returns _true_ if `f` returns _true_ for\n * every item in iterable.\n *\n * Streaming: If an infinite iterable is used, function will never return value.\n * @param it\n * @param f\n * @returns\n */\nexport function every(it, f) {\n    return isAsyncIterable(it) ? Async.every(it, f) : Sync.every(it, f);\n}\n/**\n * Returns _true_ if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport function equals(it1, it2, equality) {\n    const as = isAsyncIterable(it1) && isAsyncIterable(it2);\n    return as ? Async.equals(it1, it2, equality) : Sync.equals(it1, it2, equality);\n}\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport function zip(...its) {\n    if (its.length === 0)\n        return Sync.fromArray([]);\n    return isAsyncIterable(its[0]) ? Async.zip(...its) : Sync.zip(...its);\n}\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport function fromIterable(iterable, interval) {\n    if (isAsyncIterable(iterable) || interval !== undefined)\n        return Async.fromIterable(iterable, interval);\n    return Sync.fromIterable(iterable);\n}\n/**\n * Access `callback` as an iterable:\n * ```js\n * const fn = () => Math.random();\n * for (const v of fromFunction(fn)) {\n *  // Generate infinite random numbers\n * }\n * ```\n *\n * Use {@link fromFunctionAwaited} to await `callback`.\n * @param callback Function that generates a value\n */\nexport function* fromFunction(callback) {\n    while (true) {\n        const v = callback();\n        yield v;\n    }\n}\n/**\n * Access awaited `callback` as an iterable:\n * ```js\n * const fn = () => Math.random();\n * for await (const v of fromFunctionAwaited(fn)) {\n *  // Generate infinite random numbers\n * }\n * ```\n *\n * `callback` can be async, result is awaited.\n * This requires the use of `for await`.\n * Use {@link fromFunction} otherwise;\n * @param callback\n */\nexport async function* fromFunctionAwaited(callback) {\n    while (true) {\n        const v = await callback();\n        yield v;\n    }\n}\n/**\n * Calls `callback` whenever the generator produces a value.\n *\n * When using `asCallback`, call it with `await` to let generator\n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n *\n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input\n * @param callback\n */\nexport function asCallback(input, callback, onDone) {\n    if (isAsyncIterable(input)) {\n        return Async.asCallback(input, callback);\n    }\n    else {\n        Sync.asCallback(input, callback);\n        return;\n    }\n}\n","// Via Vuejs\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\n/**\n * Returns _true_ if `value` is a Map type\n * @param value\n * @returns\n */\nexport const isMap = (value) => toTypeString(value) === `[object Map]`;\n/**\n * Returns _true_ if `value` is a Set type\n * @param value\n * @returns\n */\nexport const isSet = (value) => toTypeString(value) === `[object Set]`;\n/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = (itemToMakeStringFor) => typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);\n/**\n * Converts a value to string form.\n * For simple objects, .toString() is used, other JSON.stringify is used.\n * It is meant for creating debugging output or 'hash' versions of objects, and does\n * not necessarily maintain full fidelity of the input\n * @param value\n * @returns\n */\nexport const defaultToString = (value) => {\n    //ECMA specification: http://www.ecma-international.org/ecma-262/6.0/#sec-tostring\n    if (value === null)\n        return `null`;\n    if (typeof value === `boolean` || typeof value === `number`) {\n        return value.toString();\n    }\n    if (typeof value === `string`)\n        return value;\n    if (typeof value === `symbol`)\n        throw new TypeError(`Symbol cannot be converted to string`);\n    return JSON.stringify(value);\n};\n","import { defaultToString } from \"./to-string.js\";\n/**\n * Sort numbers in ascending order.\n *\n * ```js\n * [10, 4, 5, 0].sort(numericComparer);\n * // Yields: [0, 4, 5, 10]\n * [10, 4, 5, 0].sort(comparerInverse(numericComparer));\n * // Yields: [ 10, 5, 4, 0]\n * ```\n * @param x\n * @param y\n * @returns\n */\nexport const numericComparer = (x, y) => {\n    // ✔️ Unit tested\n    if (x === y)\n        return 0;\n    if (x > y)\n        return 1;\n    return -1;\n};\n/**\n * Default sort comparer, following same sematics as Array.sort.\n * Consider using {@link defaultComparer} to get more logical sorting of numbers.\n *\n * Note: numbers are sorted in alphabetical order, eg:\n * ```js\n * [ 10, 20, 5, 100 ].sort(jsComparer); // same as .sort()\n * // Yields: [10, 100, 20, 5]\n * ```\n *\n * Returns -1 if x is less than y\n * Returns 1 if x is greater than y\n * Returns 0 if x is the same as y\n * @param x\n * @param y\n * @returns\n */\nexport const jsComparer = (x, y) => {\n    // ✔️ Unit tested\n    // Via https://stackoverflow.com/questions/47334234/how-to-implement-array-prototype-sort-default-compare-function\n    if (x === undefined && y === undefined)\n        return 0;\n    if (x === undefined)\n        return 1;\n    if (y === undefined)\n        return -1;\n    const xString = defaultToString(x);\n    const yString = defaultToString(y);\n    if (xString < yString)\n        return -1;\n    if (xString > yString)\n        return 1;\n    return 0;\n};\n/**\n * Inverts the source comparer.\n * @param comparer\n * @returns\n */\nexport const comparerInverse = (comparer) => {\n    return (x, y) => {\n        const v = comparer(x, y);\n        return v * -1;\n    };\n};\n/**\n * Compares numbers by numeric value, otherwise uses the default\n * logic of string comparison.\n *\n * Is an ascending sort:\n * * b, a, c -> a, b, c\n * * 10, 5, 100 -> 5, 10, 100\n *\n * Returns -1 if x is less than y\n * Returns 1 if x is greater than y\n * Returns 0 if x is the same as y\n * @param x\n * @param y\n * @see {@link comparerInverse} Inverted order\n * @returns\n */\nexport const defaultComparer = (x, y) => {\n    if (typeof x === `number` && typeof y === `number`) {\n        return numericComparer(x, y);\n    }\n    return jsComparer(x, y);\n};\n","import { defaultComparer } from './comparers.js';\nimport { isEqualDefault } from './is-equal.js';\nimport { toStringDefault, } from './to-string.js';\n/**\n * Gets the closest integer key to `target` in `data`.\n * * Requires map to have numbers as keys, not strings\n * * Math.round is used for rounding `target`.\n *\n * Examples:\n * ```js\n * // Assuming numeric keys 1, 2, 3, 4 exist:\n * getClosestIntegerKey(map, 3);    // 3\n * getClosestIntegerKey(map, 3.1);  // 3\n * getClosestIntegerKey(map, 3.5);  // 4\n * getClosestIntegerKey(map, 3.6);  // 4\n * getClosestIntegerKey(map, 100);  // 4\n * getClosestIntegerKey(map, -100); // 1\n * ```\n * @param data Map\n * @param target Target value\n * @returns\n */\nexport const getClosestIntegerKey = (data, target) => {\n    target = Math.round(target);\n    if (data.has(target)) {\n        return target;\n    }\n    else {\n        let offset = 1;\n        while (offset < 1000) {\n            if (data.has(target - offset))\n                return target - offset;\n            else if (data.has(target + offset))\n                return target + offset;\n            offset++;\n        }\n        throw new Error(`Could not find target ${target.toString()}`);\n    }\n};\n/**\n * Returns the first value in `data` that matches a key from `keys`.\n * ```js\n * // Iterate, yielding: `a.b.c.d`, `b.c.d`, `c.d`, `d`\n * const keys = Text.segmentsFromEnd(`a.b.c.d`);\n * // Gets first value that matches a key (starting from most precise)\n * const value = findBySomeKey(data, keys);\n * ```\n * @param data\n * @param keys\n * @returns\n */\nexport const findBySomeKey = (data, keys) => {\n    for (const key of keys) {\n        if (data.has(key))\n            return data.get(key);\n    }\n};\n/**\n * Returns true if map contains `value` under `key`, using `comparer` function. Use {@link hasAnyValue} if you don't care\n * what key value might be under.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n *\n * @example Find key value based on string equality\n * ```js\n * hasKeyValue(map,`hello`, `samantha`, (a, b) => a === b);\n * ```\n * @param map Map to search\n * @param key Key to search\n * @param value Value to search\n * @param comparer Function to determine match. By default uses === comparison.\n * @returns True if key is found\n */\nexport const hasKeyValue = (map, key, value, comparer = isEqualDefault) => {\n    if (!map.has(key))\n        return false;\n    const values = [...map.values()];\n    return values.some((v) => comparer(v, value));\n};\n/**\n * Deletes all key/values from map where value matches `value`,\n * with optional comparer. Mutates map.\n *\n * ```js\n * // Compare fruits based on their colour property\n * const colourComparer = (a, b) => a.colour === b.colour;\n *\n * // Deletes all values where .colour = `red`\n * deleteByValueCompareMutate(map, { colour: `red` }, colourComparer);\n * ```\n * @param map\n * @param value\n * @param comparer Uses === equality by default. Use isEqualValueDefault to compare by value\n */\nexport const deleteByValueCompareMutate = (map, value, comparer = isEqualDefault) => {\n    for (const entry of map.entries()) {\n        if (comparer(entry[1], value)) {\n            map.delete(entry[0]);\n        }\n    }\n};\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = findEntryByPredicate(map, (value, key) => {\n *  return (value === 'b');\n * });\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link findEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport const findEntryByPredicate = (map, predicate) => {\n    for (const entry of map.entries()) {\n        if (predicate(entry[1], entry[0]))\n            return entry;\n    }\n};\n/**\n * Finds first entry by value.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = findEntryByValue(map, 'b');\n * // Entry is: ['there', 'b']\n * ```\n *\n * Uses JS's === comparison by default. Consider using {@link isEqualValueDefault} to match by value.\n * An alternative is {@link findEntryByValue} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport const findEntryByValue = (map, value, isEqual = isEqualDefault) => {\n    for (const entry of map.entries()) {\n        if (isEqual(entry[1], value))\n            return entry;\n    }\n};\n/**\n * Adds items to a map only if their key doesn't already exist\n *\n * Uses provided {@link ToString} function to create keys for items. Item is only added if it doesn't already exist.\n * Thus the older item wins out, versus normal `Map.set` where the newest wins.\n *\n * Returns a copy of the input map.\n * @example\n * ```js\n * const map = new Map();\n * const peopleArray = [ _some people objects..._];\n * addKeepingExisting(map, p => p.name, ...peopleArray);\n * ```\n * @param set\n * @param hasher\n * @param values\n * @returns\n */\n// export const addKeepingExisting = <V>(\n//   set: ReadonlyMap<string, V> | undefined,\n//   hasher: ToString<V>,\n//   ...values: readonly V[]\n// ) => {\n//   const s = set === undefined ? new Map() : new Map(set);\n//   for (const v of values) {\n//     const hashResult = hasher(v);\n//     if (s.has(hashResult)) continue;\n//     s.set(hashResult, v);\n//   }\n//   return s;\n// };\n/**\n * Mutates `map`, adding each value to it using a\n * function to produce a key. Use {@link addValue} for an immutable version.\n * ```\n * const map = new Map();\n * addValueMutate(map, v=>v.name, { name:`Jane`, size:10 }, { name:`Bob`, size: 9 });\n * // Map consists of entries:\n * // [ `Jane`, { name:`Jane`, size:10 } ],\n * // [ `Bob` { name:`Bob`, size: 9 } ]\n * ```\n *\n * Uses {@link addValueMutator} under the hood.\n * @param map Map to modify. If _undefined_, a new map is created\n * @param hasher Function to generate a string key for a given object value\n * @param values Values to add\n * @param collisionPolicy What to do if the key already exists\n * @returns Map instance\n */\nexport const addValueMutate = (map, hasher, collisionPolicy, ...values) => {\n    const m = map ?? new Map();\n    const f = addValueMutator(m, hasher, collisionPolicy);\n    f(...values);\n    return m;\n};\n/**\n * Adds values to a map, returning a new, modified copy and leaving the original\n * intact.\n *\n * Use {@link addValueMutate} for a mutable\n * @param map Map to start with, or _undefined_ to automatically create a map\n * @param hasher Function to create keys for values\n * @param collisionPolicy What to do if a key already exists\n * @param values Values to add\n * @returns A new map containing values\n */\nexport const addValue = (map, hasher, collisionPolicy, ...values) => {\n    const m = map === undefined ? new Map() : new Map(map);\n    for (const v of values) {\n        const hashResult = hasher(v);\n        if (collisionPolicy !== `overwrite`) {\n            if (m.has(hashResult)) {\n                if (collisionPolicy === `throw`)\n                    throw new Error(`Key '${hashResult}' already in map`);\n                if (collisionPolicy === `skip`)\n                    continue;\n            }\n        }\n        m.set(hashResult, v);\n    }\n    return m;\n};\n/**\n * Returns a function that adds values to a map, using a hashing function to produce a key.\n * Use {@link addValueMutate} if you don't need a reusable function.\n *\n * ```js\n * const map = new Map(); // Create map\n * const mutate = addValueMutator(map, v=>v.name); // Create a mutator using default 'overwrite' policy\n * mutate( { name:`Bob`, size:10 }, { name: `Alice`, size: 2 }); // Add values to map\n * mutate( {name: `Bob`, size: 11 }); // Change the value stored under key `Bob`.\n * map.get(`Bob`); // { name: `Bob`, size: 11 }\n * ```\n *\n * The 'collision policy' determines what to do if the key already exists. The default behaviour\n * is to overwrite the key, just as Map.set would.\n * ```js\n * const map = new Map();\n * const mutate = addValueMutator(map, v=>v.name, `skip`);\n * mutate( { name:`Bob`,size:10 }, { name: `Alice`, size: 2 }); // Add values to map\n * mutate( { name:`Bob`, size: 20 }); // This value would be skipped because map already contains 'Bob'\n * map.get(`Bob`); // { name: `Bob`, size: 10 }\n * ```\n *\n * @param map Map to modify\n * @param hasher Hashing function to make a key for a value\n * @param collisionPolicy What to do if a value is already stored under a key\n * @returns Function\n */\nexport const addValueMutator = (map, hasher, collisionPolicy = `overwrite`) => {\n    return (...values) => {\n        for (const v of values) {\n            const hashResult = hasher(v);\n            if (collisionPolicy !== `overwrite`) {\n                if (map.has(hashResult)) {\n                    if (collisionPolicy === `throw`)\n                        throw new Error(`Key '${hashResult}' already in map`);\n                    if (collisionPolicy === `skip`)\n                        continue;\n                }\n            }\n            map.set(hashResult, v);\n        }\n        return map;\n    };\n};\n/**\n * Returns a array of entries from a map, sorted by value.\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n *\n * // Compare by name\n * const comparer = (a, b) => defaultComparer(a.name, b.name);\n *\n * // Get sorted values\n * const sorted = Maps.sortByValue(m, comparer);\n * ```\n *\n * `sortByValue` takes a comparison function that should return -1, 0 or 1 to indicate order of `a` to `b`. If not provided, {@link Util.defaultComparer} is used.\n * @param map\n * @param comparer\n * @returns\n */\nexport const sortByValue = (map, comparer) => {\n    const f = comparer ?? defaultComparer;\n    return [...map.entries()].sort((a, b) => f(a[1], b[1]));\n};\n/**\n * Returns an array of entries from a map, sorted by a property of the value\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n * const sorted = sortByValueProperty(m, `name`);\n * ```\n * @param map Map to sort\n * @param property Property of value\n * @param compareFunction Comparer. If unspecified, uses a default.\n */\nexport const sortByValueProperty = (map, property, compareFunction) => {\n    const cfn = typeof compareFunction === `undefined` ? defaultComparer : compareFunction;\n    return [...map.entries()].sort((aE, bE) => {\n        const a = aE[1];\n        const b = bE[1];\n        return cfn(a[property], b[property]);\n    });\n};\n/**\n * Returns _true_ if any key contains `value`, based on the provided `comparer` function. Use {@link hasKeyValue}\n * if you only want to find a value under a certain key.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n * @example Finds value where name is 'samantha', regardless of other properties\n * ```js\n * hasAnyValue(map, {name:`samantha`}, (a, b) => a.name === b.name);\n * ```\n *\n * Works by comparing `value` against all values contained in `map` for equality using the provided `comparer`.\n *\n * @param map Map to search\n * @param value Value to find\n * @param comparer Function that determines matching. Should return true if `a` and `b` are considered equal.\n * @returns True if value is found\n */\nexport const hasAnyValue = (map, value, comparer) => {\n    const entries = [...map.entries()];\n    return entries.some((kv) => comparer(kv[1], value));\n};\n/**\n * Returns values where `predicate` returns true.\n *\n * If you just want the first match, use `find`\n *\n * @example All people over thirty\n * ```js\n * // for-of loop\n * for (const v of filterValues(people, person => person.age > 30)) {\n *\n * }\n * // If you want an array\n * const overThirty = Array.from(filterValues(people, person => person.age > 30));\n * ```\n * @param map Map\n * @param predicate Filtering predicate\n * @returns Values that match predicate\n */\nexport function* filterValues(map, predicate) {\n    for (const v of map.values()) {\n        if (predicate(v))\n            yield v;\n    }\n}\n//export const filter = <V>(map:ReadonlyMap<string, V>, predicate:(v:V) => boolean):ReadonlyArray<V> => Array.from(map.values()).filter(predicate);\n/**\n * Copies data to an array\n * @param map\n * @returns\n */\nexport const toArray = (map) => [...map.values()];\n/**\n * Returns a Map from an iterable. By default throws an exception\n * if iterable contains duplicate values.\n *\n * ```js\n * const data = [\n *  { fruit: `granny-smith`, family: `apple`, colour: `green` },\n *  { fruit: `mango`, family: `stone-fruit`, colour: `orange` }\n * ];\n * const map = fromIterable(data, v => v.fruit);\n * map.get(`granny-smith`); // { fruit: `granny-smith`, family: `apple`, colour: `green` }\n * ```\n * @param data Input data\n * @param keyFunction Function which returns a string id. By default uses the JSON value of the object.\n * @param collisionPolicy By default, values with same key overwrite previous (`overwrite`)\n * @returns\n */\nexport const fromIterable = (data, keyFunction = (toStringDefault), collisionPolicy = `overwrite`) => {\n    const m = new Map();\n    for (const d of data) {\n        const key = keyFunction(d);\n        if (m.has(key)) {\n            if (collisionPolicy === `throw`)\n                throw new Error(`Key '${key}' is already used and new data will overwrite it. `);\n            if (collisionPolicy === `skip`)\n                continue;\n        }\n        m.set(key, d);\n    }\n    return m;\n};\n/**\n * Returns a Map from an object, or array of objects.\n * Assumes the top-level properties of the object is the key.\n *\n * ```js\n * const data = {\n *  Sally: { name: `Sally`, colour: `red` },\n *  Bob: { name: `Bob`, colour: `pink` }\n * };\n * const map = fromObject(data);\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To add an object to an existing map, use {@link addObjectEntriesMutate}.\n * @param data\n * @returns\n */\nexport const fromObject = (data) => {\n    const map = new Map();\n    if (Array.isArray(data)) {\n        for (const d of data)\n            addObjectEntriesMutate(map, d);\n    }\n    else {\n        addObjectEntriesMutate(map, data);\n    }\n    return map;\n};\n/**\n * Adds an object to an existing map, mutating it.\n * It assumes a structure where each top-level property is a key:\n *\n * ```js\n * const data = {\n *  Sally: { colour: `red` },\n *  Bob:   { colour: `pink` }\n * };\n * const map = new Map();\n * addObjectEntriesMutate(map, data);\n *\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To create a new map from an object, use {@link fromObject} instead.\n * @param map\n * @param data\n */\nexport const addObjectEntriesMutate = (map, data) => {\n    const entries = Object.entries(data);\n    for (const [key, value] of entries) {\n        map.set(key, value);\n    }\n};\n/**\n * Returns the first found value that matches `predicate` or _undefined_.\n * To get an entry see {@link findEntryByPredicate}\n *\n * Use {@link some} if you don't care about the value, just whether it appears.\n * Use {@link filter} to get all value(s) that match `predicate`.\n *\n * @example First person over thirty\n * ```js\n * const overThirty = findValue(people, person => person.age > 30);\n * ```\n * @param map Map to search\n * @param predicate Function that returns true for a matching value\n * @returns Found value or _undefined_\n */\nexport const findValue = (map, predicate) => [...map.values()].find(v => predicate(v));\n/**\n * Returns _true_ if `predicate` yields _true_ for any value in `map`.\n * Use {@link find} if you want the matched value.\n * ```js\n * const map = new Map();\n * map.set(`fruit`, `apple`);\n * map.set(`colour`, `red`);\n * Maps.some(map, v => v === `red`);    // true\n * Maps.some(map, v => v === `orange`); // false\n * ```\n * @param map\n * @param predicate\n * @returns\n */\nexport const some = (map, predicate) => [...map.values()].some(v => predicate(v));\n/**\n * Converts a map to a simple object, transforming from type `T` to `K` as it does so. If no transforms are needed, use {@link toObject}.\n *\n * ```js\n * const map = new Map();\n * map.set(`name`, `Alice`);\n * map.set(`pet`, `dog`);\n *\n * const o = mapToObjectTransform(map, v => {\n *  ...v,\n *  registered: true\n * });\n *\n * // Yields: { name: `Alice`, pet: `dog`, registered: true }\n * ```\n *\n * If the goal is to create a new map with transformed values, use {@link transformMap}.\n * @param m\n * @param valueTransform\n * @typeParam T Value type of input map\n * @typeParam K Value type of destination map\n * @returns\n */\nexport const mapToObjectTransform = (m, valueTransform) => [...m].reduce((object, [key, value]) => {\n    const t = valueTransform(value);\n    object[key] = t;\n    return object;\n}, {});\n/**\n * Zips together an array of keys and values into an object. Requires that\n * `keys` and `values` are the same length.\n *\n * @example\n * ```js\n * const o = zipKeyValue([`a`, `b`, `c`], [0, 1, 2])\n * Yields: { a: 0, b: 1, c: 2}\n *```\n * @param keys String keys\n * @param values Values\n * @typeParam V Type of values\n * @return Object with keys and values\n */\nexport const zipKeyValue = (keys, values) => {\n    if (keys.length !== values.length) {\n        throw new Error(`Keys and values arrays should be same length`);\n    }\n    return Object.fromEntries(keys.map((k, index) => [k, values[index]]));\n};\n//#region Functions by Kees C. Bakker\n// Functions by Kees C. Bakker\n// https://keestalkstech.com/2021/10/having-fun-grouping-arrays-into-maps-with-typescript/\n/**\n * Like `Array.map`, but for a Map. Transforms from Map<K,V> to Map<K,R>, returning as a new Map.\n *\n * @example\n * ```js\n * const mapOfStrings = new Map();\n * mapOfStrings.set(`a`, `10`);\n * mapOfStrings.get(`a`); // Yields `10` (a string)\n *\n * // Convert a map of string->string to string->number\n * const mapOfInts = transformMap(mapOfStrings, (value, key) => parseInt(value));\n *\n * mapOfInts.get(`a`); // Yields 10 (a proper number)\n * ```\n *\n * If you want to combine values into a single object, consider instead  {@link mapToObjectTransform}.\n * @param source\n * @param transformer\n * @typeParam K Type of keys (generally a string)\n * @typeParam V Type of input map values\n * @typeParam R Type of output map values\n * @returns\n */\nexport const transformMap = (source, transformer) => new Map(Array.from(source, (v) => [v[0], transformer(v[1], v[0])]));\n/**\n * Converts a `Map` to a plain object, useful for serializing to JSON.\n * To convert back to a map use {@link fromObject}.\n *\n * @example\n * ```js\n * const map = new Map();\n * map.set(`Sally`, { name: `Sally`, colour: `red` });\n * map.set(`Bob`, { name: `Bob`, colour: `pink });\n *\n * const objects = Maps.toObject(map);\n * // Yields: {\n * //  Sally: { name: `Sally`, colour: `red` },\n * //  Bob: { name: `Bob`, colour: `pink` }\n * // }\n * ```\n * @param m\n * @returns\n */\nexport const toObject = (m) => [...m].reduce((object, [key, value]) => {\n    object[key] = value;\n    return object;\n}, {});\n/**\n * Converts Map to Array with a provided `transformer` function. Useful for plucking out certain properties\n * from contained values and for creating a new map based on transformed values from an input map.\n *\n * @example Get an array of ages from a map of Person objects\n * ```js\n * const person = { age: 29, name: `John`};\n * map.set(person.name, person);\n *\n * const ages = mapToArray(map, (key, person) => person.age);\n * // [29, ...]\n * ```\n *\n * In the above example, the `transformer` function returns a number, but it could\n * just as well return a transformed version of the input:\n *\n * ```js\n * // Return with random heights and uppercased name\n * mapToArray(map, (key, person) => ({\n *  ...person,\n *  height: Math.random(),\n *  name: person.name.toUpperCase();\n * }))\n * // Yields:\n * // [{height: 0.12, age: 29, name: \"JOHN\"}, ...]\n * ```\n * @param m\n * @param transformer A function that takes a key and item, returning a new item.\n * @returns\n */\nexport const mapToArray = (m, transformer) => [...m.entries()].map((x) => transformer(x[0], x[1]));\n/**\n * Merges maps left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also {@link Data.Arrays.mergeByKey Arrays.mergeByKey} if you don't already have a map.\n *\n * For example, if we have the map A:\n * 1 => `A-1`, 2 => `A-2`, 3 => `A-3`\n *\n * And map B:\n * 1 => `B-1`, 2 => `B-2`, 4 => `B-4`\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(reconcile, mapA, mapB);\n * ```\n *\n * The final result will be:\n *\n * 1 => `B!1`, 2 => `B!2`, 3 => `A-3`, 4 => `B-4`\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param reconcile\n * @param maps\n */\nexport const mergeByKey = (reconcile, ...maps) => {\n    const result = new Map();\n    for (const m of maps) {\n        for (const [mk, mv] of m) {\n            let v = result.get(mk);\n            v = v ? reconcile(v, mv) : mv;\n            result.set(mk, v);\n        }\n    }\n    return result;\n};\n/**\n * @inheritDoc getOrGenerate\n * @param map\n * @param fn\n * @returns\n */\nexport const getOrGenerateSync = (map, fn) => (key, args) => {\n    let value = map.get(key);\n    if (value !== undefined)\n        return value;\n    value = fn(key, args);\n    map.set(key, value);\n    return value;\n};\n/**\n * Returns a function that fetches a value from a map, or generates and sets it if not present.\n * Undefined is never returned, because if `fn` yields that, an error is thrown.\n *\n * See {@link getOrGenerateSync} for a synchronous version.\n *\n * ```\n * const m = getOrGenerate(new Map(), (key) => {\n *  return key.toUppercase();\n * });\n *\n * // Not contained in map, so it will run the uppercase function,\n * // setting the value to the key 'hello'.\n * const v = await m(`hello`);  // Yields 'HELLO'\n * const v1 = await m(`hello`); // Value exists, so it is returned ('HELLO')\n * ```\n *\n */\nexport const getOrGenerate = (map, fn) => async (key, args) => {\n    let value = map.get(key);\n    if (value !== undefined)\n        return value; //Promise.resolve(value);\n    value = await fn(key, args);\n    if (value === undefined)\n        throw new Error(`fn returned undefined`);\n    map.set(key, value);\n    return value;\n};\n"],"mappings":"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"}