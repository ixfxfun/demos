{"version":3,"file":"index-DSWMSAve.d.ts","names":["Point","Point3d","Placeholder","Readonly","Placeholder3d","Point","Point3d","abs","Point","angleRadian","angleRadianCircle","Point","Point3d","PointApplyFn","Point3dApplyFn","apply","Point","PointAverager","PointAverageKinds","averager","Partial","Point","Point3d","RectArray","RectPositionedArray","Rect","Rect3d","RectPositioned","Rect3dPositioned","Rect3dPositioned","RectPositioned","Point","Point3d","bbox","ReadonlyArray","bbox3d","Point","centroid","ReadonlyArray","Point","Point3d","clamp","Point","Point3d","compare","compareByX","compareByY","compareByZ","Point","convexHull","ReadonlyArray","Point","distance","Point","Circle","CircleToSvg","CirclePositioned","CircleRandomPointOpts","Point","Line","PolyLine","ReadonlyArray","CirclePositioned","Line","PolyLine","Point","Point3d","RectPositioned","ShapePositioned","ContainsResult","Sphere","PointCalculableShape","Point","ArrowOpts","arrow","ReadonlyArray","Point","Triangle","BarycentricCoord","RandomSource","ShapePositioned","Point","Rect","Triangle","Circle","ShapeRandomPointOpts","randomPoint","Partial","center","Point","ShapePositioned","isIntersecting","Point","starburst","Point","PointCalculableShape","distanceToCenter","Point","PointCalculableShape","distanceToExterior","Point","Point3d","divide","divider","Point","dotProduct","Empty","Unit","Empty3d","Unit3d","Point","Point3d","findMinimum","ReadonlyArray","Point","Point3d","from","fromString","fromNumbers","Point","Point3d","getTwoPointParameters","getPointParameter","Array","ReadonlyArray","Point","Point3d","Result","isNull","isNaN","test","guard","guardNonZeroPoint","isPoint","isPoint3d","isEmpty","isPlaceholder","Point","interpolate","Point","Point3d","invert","Point","isEqual","ReadonlyArray","Point","clampMagnitude","Point","leftmost","ReadonlyArray","rightmost","Point","Point3d","multiply","multiplyScalar","Point","normalise","Rect","Point","normaliseByRect","Point","pipelineApply","pipeline","Point","PointRelation","PointRelationResult","Point","PolarToCartesian","Coord","PolarRay","Readonly","PolarRayWithOrigin","Coord","rotate","invert","isOpposite","isParallel","isAntiParallel","rotateDegrees","Point","Coord","PolarToCartesian","toLine","toCartesian","fromCartesian","toString","toPoint","Coord","isPolarCoord","guard","Coord","normalise","clampMagnitude","dotProduct","multiply","divide","Line","Point","PolarRay","toCartesian","toString","fromLine","Coord","spiral","IterableIterator","spiralRaw","Ray","TrackedValueMap","TrackedValueOpts","TrackOpts","TimestampedObject","ObjectTracker","Coord","PolarCoord","Line","PolyLine","Point","Point3d","PointRelation","TrimReason","PointRelationResult","PointTrack","PointTrackerResults","Readonly","PointTracker","PointerEvent","MouseEvent","PointsTracker","Promise","Point3d","Point","progressBetween","Point","project","Point","Point3d","quantiseEvery","RandomSource","Point","Point3d","random","random3d","Point","reduce","ReadonlyArray","PointRelation","Point","relation","Point","rotate","rotatePointArray","ReadonlyArray","Array","Point","round","Point","Point3d","subtract","Point","Point3d","sum","Point","Point3d","toIntegerValues","to2d","to3d","toString","Point","toArray","ReadonlyArray","Point","withinRange","Point","wrap","Point","Point3d","Rect","area","RectPositioned","Rect","ApplyMergeOp","ApplyFieldOp","applyFields","applyMerge","applyScalar","applyDim","ISetMutable","GridVisual","Grid","GridCell","GridNeighbours","GridCardinalDirection","GridCardinalDirectionOptional","GridArray1d","T","GridReadable","GridWritable","GridBoundsLogic","GridNeighbourSelectionLogic","GridIdentifyNeighbours","GridNeighbourSelector","GridVisitorOpts","Readonly","GridCreateVisitor","Partial","Generator","GridCellAndValue","GridNeighbourMaybe","GridNeighbour","GridCellAccessor","TValue","GridCellSetter","GridBoundsLogic","GridCell","Grid","applyBounds","GridCellAccessor","GridCell","GridBoundsLogic","Grid","GridCellSetter","GridArray1d","access","V","setMutate","set","wrapMutable","T","wrap","createArray","createMutable","GridBoundsLogic","GridCell","GridCellAccessor","GridCellSetter","Grid","GridReadable","GridWritable","ArrayGrid","T","create","ReadonlyArray","Array","setMutate","V","access","wrapMutable","set","wrap","GridCell","Grid","rows","Generator","columns","GridBoundsLogic","GridCardinalDirection","GridCardinalDirectionOptional","GridCell","Grid","GridNeighbours","allDirections","crossDirections","offsetCardinals","getVectorFromCardinal","Grid","GridCell","GridCellAndValue","GridReadable","cells","Generator","cellValues","T","cellsAndValues","GridCell","getLine","ReadonlyArray","simpleLine","GridCell","Grid","isCell","guardCell","guardGrid","Grid","GridCell","GridBoundsLogic","indexFromCell","cellFromIndex","Grid","GridCell","inside","GridCell","Grid","GridVisual","isEqual","cellEquals","GridBoundsLogic","GridCardinalDirection","GridCell","Grid","GridNeighbour","GridNeighbours","randomNeighbour","neighbourList","neighbours","Grid","GridCell","GridBoundsLogic","offset","Grid","toArray2d","V","GridCell","cellKeyString","RectPositioned","GridCell","GridVisual","Point","asRectangles","IterableIterator","cellAtPoint","rectangleForCell","cellMiddle","GridReadable","GridCell","values","T","Iterable","Generator","GridNeighbourSelectionLogic","breadthLogic","GridNeighbourSelectionLogic","neighboursLogic","GridNeighbourSelectionLogic","GridVisitorOpts","columnLogic","Partial","GridNeighbourSelectionLogic","depthLogic","Grid","GridCell","GridCreateVisitor","stepper","GridNeighbourSelectionLogic","randomLogic","GridNeighbourSelectionLogic","randomContiguousLogic","GridNeighbourSelectionLogic","GridVisitorOpts","rowLogic","Partial","GridNeighbourSelectionLogic","Grid","GridCell","GridVisitorOpts","visitByNeighbours","Partial","Generator","GridCell","Grid","GridNeighbourSelectionLogic","GridVisitorOpts","VisitorTypes","create","Partial","Generator","withLogic","Array1d","Array2d","As","By","Visit","RectPositioned","GridCardinalDirection","Point","cardinal","Point","RectPositioned","centerOrigin","Point","Rect","RectPositioned","center","Point","Rect","RectPositioned","corners","RectPositioned","Point","distanceFromExterior","distanceFromCenter","RectPositioned","Rect","divide","divideScalar","divideDim","Rect","RectPositioned","Point","Line","edges","getEdgeX","getEdgeY","Empty","Readonly","EmptyPositioned","Point","RectPositioned","encompass","RectPositioned","Point","fromCenter","Rect","fromElement","HTMLElement","RectPositioned","Rect","fromNumbers","Point","RectPositioned","fromTopLeft","Point","Rect","RectPositioned","getRectPositionedParameter","RectPositioned","Rect","Point","guardDim","guard","getRectPositioned","guardPositioned","isEmpty","isPlaceholder","isPositioned","isRect","isRectPositioned","Rect","RectPositioned","Point","CirclePositioned","intersectsPoint","isIntersecting","Rect","RectPositioned","isEqualSize","isEqual","RectPositioned","lengths","Point","RectPositioned","maxFromCorners","RectPositioned","Rect","multiply","multiplyScalar","multiplyDim","Point","RectPositioned","nearestInternal","Placeholder","Readonly","PlaceholderPositioned","Rect","perimeter","Point","Rect","dividerByLargestDimension","Readonly","RandomSource","Point","Rect","RectPositioned","random","RectRandomPointOpts","randomPoint","Rect","RectPositioned","subtract","subtractSize","subtractOffset","Rect","RectPositioned","sum","sumOffset","Rect","RectArray","RectPositioned","RectPositionedArray","toArray","Point","RectPositioned","Path","ReadonlyArray","WithBeziers","CompoundPath","Dimensions","Point","Arc","ArcPositioned","ArcInterpolate","ArcToSvg","ArcSvgOpts","Point","Line","Path","Rect","RectPositioned","Arc","ArcInterpolate","ArcPositioned","ArcToSvg","CirclePositioned","isArc","isPositioned","fromDegrees","toLine","getStartEnd","point","guard","interpolate","angularSize","toPath","fromCircle","fromCircleAmount","length","bbox","toSvg","distanceCenter","isEqual","Path","Point","QuadraticBezier","QuadraticBezierPath","CubicBezier","CubicBezierPath","Path","QuadraticBezier","CubicBezier","isQuadraticBezier","isCubicBezier","Point","CubicBezier","CubicBezierPath","QuadraticBezier","QuadraticBezierPath","quadraticSimple","interpolator","quadraticToSvgString","ReadonlyArray","toPath","cubic","quadratic","Circle","area","CirclePositioned","Circle","RectPositioned","bbox","CirclePositioned","Circle","center","Readonly","Point","CompoundPath","Dimensions","Path","RectPositioned","setSegment","interpolate","distanceToPoint","relativePosition","computeDimensions","bbox","toString","guardContinuous","toSvgString","fromPaths","Point","Path","getStart","getEnd","Path","Circle","CircularPath","CirclePositioned","Point","distanceCenter","CirclePositioned","Point","distanceFromExterior","Point","CirclePositioned","exteriorIntegerPoints","IterableIterator","Point","Circle","CirclePositioned","guard","guardPositioned","isNaN","isPositioned","isCircle","isCirclePositioned","CirclePositioned","Point","interiorIntegerPoints","IterableIterator","Point","CirclePositioned","interpolate","CirclePositioned","Point","RectPositioned","isIntersecting","Point","CirclePositioned","Line","intersectionLine","intersections","CirclePositioned","Point","isContainedBy","Circle","CirclePositioned","isEqual","CirclePositioned","Circle","multiplyScalar","Point","Circle","CirclePositioned","nearest","pointOnPerimeter","circumference","length","Point","Circle","CirclePositioned","CircleRandomPointOpts","randomPoint","Partial","CircleToSvg","toSvg","CirclePositioned","CircularPath","toPath","Circle","CirclePositioned","Point","toPositioned","Line","parallel","perpendicularPoint","RectPositioned","Line","bbox","Point","Line","distanceSingleLine","Point","Line","divide","Line","fromFlatArray","Line","fromNumbers","Point","Line","fromPoints","Point","fromPivot","Readonly","Path","Point","Line","LinePath","ReadonlyArray","Point","LinePath","fromPointsToPath","Point","Line","getPointParameter","Line","PolyLine","isLine","isPolyLine","guard","Point","Line","interpolate","pointAtDistance","Line","isEqual","Point","PolyLine","joinPointsToLines","Point","Line","PolyLine","length","Point","Line","midpoint","Line","Point","multiply","Point","Line","nearest","Point","Line","relativePosition","Line","reverse","Point","Line","rotate","Point","Line","subtract","Point","Line","sum","LinePath","Line","toPath","Point","Line","toString","Point","Line","Empty","Readonly","Placeholder","isEmpty","isPlaceholder","apply","angleRadian","normaliseByRect","withinRange","slope","scaleFromMidpoint","pointAtX","extendFromA","pointsOf","Generator","distance","toFlatArray","asPoints","Iterable","toSvgString","CirclePositioned","Path","Point","Waypoint","WaypointOpts","fromPoints","Partial","Waypoints","WaypointResult","init","RandomSource","ShapePositioned","Circle","CirclePositioned","RandomOpts","random","CirclePacking","Point","Path","Ellipse","EllipsePositioned","fromDegrees","EllipticalPath","Point","degreeToRadian","radianInvert","degreeToGradian","gradianToDegree","radianToGradian","gradianToRadian","radianToDegree","radiansFromAxisX","radiansSum","degreesSum","radianArc","degreeArc","Angle","angleParse","angleConvert","turnToDegree","turnToRadian","degreeToTurn","radianToTurn","Point","rdpShortestDistance","Array","rdpPerpendicularDistance","TraversableTree","Point","ShapePositioned","RectPositioned","QuadTreeOpts","Direction","QuadTreeItem","quadTree","Partial","QuadTreeNode","IterableIterator","Point","Rect","Scaler","ScalerCombined","ScaleBy","scaler","Line","Point","Polar","Vector","Coord","fromRadians","Readonly","toRadians","fromPointPolar","fromLineCartesian","fromLinePolar","normalise","quadrantOffsetAngle","toPolar","toCartesian","toString","dotProduct","clampMagnitude","sum","subtract","multiply","divide","Point","Point3d","Circle","CirclePositioned","Sphere","VogelSpiralOpts","circleVogelSpiral","IterableIterator","CircleRingsOpts","circleRings","sphereFibonacci","Triangle","angles","ReadonlyArray","anglesDegrees","Triangle","area","Point","BarycentricCoord","Triangle","barycentricCoord","barycentricToCartestian","RectPositioned","Triangle","bbox","Point","Triangle","centroid","Point","Triangle","corners","ReadonlyArray","Point","Triangle","Empty","Readonly","Placeholder","equilateralFromVertex","Triangle","PolyLine","edges","Triangle","Point","fromRadius","fromFlatArray","fromPoints","CirclePositioned","Triangle","innerCircle","Point","Triangle","intersectsPoint","Triangle","isEquilateral","isIsosceles","isRightAngle","isOblique","isAcute","isObtuse","Triangle","lengths","ReadonlyArray","Point","Triangle","apply","Readonly","Triangle","CirclePositioned","outerCircle","Triangle","perimeter","Point","Triangle","rotate","rotateByVertex","Triangle","toFlatArray","Triangle","guard","isTriangle","isEmpty","isPlaceholder","isEqual","Circle","Point","Triangle","TriangleEquilateral","fromCenter","centerFromA","centerFromB","centerFromC","height","perimeter","area","circumcircle","incircle","Circle","Point","Triangle","Right","DefinedRight","fromA","fromB","fromC","resolveLengths","height","hypotenuseSegments","perimeter","area","angleAtPointA","angleAtPointB","medians","circumcircle","incircle","oppositeFromAdjacent","oppositeFromHypotenuse","adjacentFromHypotenuse","adjacentFromOpposite","hypotenuseFromOpposite","hypotenuseFromAdjacent","Circle","Point","Triangle","Isosceles","baseAngle","apexAngle","height","legHeights","perimeter","area","circumcircle","incircle","medians","fromCenter","fromA","fromB","fromC","Equilateral","Right","Isosceles","Arcs","Beziers","Circles","Grids","Lines","Paths","Points","Polar","Rects","Shapes","Waypoints","Layouts","Compound","Ellipses","CurveSimplification","QuadTree","Vectors","SurfacePoints","Triangles"],"sources":["../../geometry/dist/src/point/point-type.d.ts","../../geometry/dist/src/point/abs.d.ts","../../geometry/dist/src/point/angle.d.ts","../../geometry/dist/src/point/apply.d.ts","../../geometry/dist/src/point/averager.d.ts","../../geometry/dist/src/rect/rect-types.d.ts","../../geometry/dist/src/point/bbox.d.ts","../../geometry/dist/src/point/centroid.d.ts","../../geometry/dist/src/point/clamp.d.ts","../../geometry/dist/src/point/compare.d.ts","../../geometry/dist/src/point/convex-hull.d.ts","../../geometry/dist/src/point/distance.d.ts","../../geometry/dist/src/circle/circle-type.d.ts","../../geometry/dist/src/line/line-type.d.ts","../../geometry/dist/src/shape/shape-type.d.ts","../../geometry/dist/src/shape/arrow.d.ts","../../geometry/dist/src/triangle/triangle-type.d.ts","../../geometry/dist/src/shape/etc.d.ts","../../geometry/dist/src/shape/is-intersecting.d.ts","../../geometry/dist/src/shape/starburst.d.ts","../../geometry/dist/src/shape/index.d.ts","../../geometry/dist/src/point/distance-to-center.d.ts","../../geometry/dist/src/point/distance-to-exterior.d.ts","../../geometry/dist/src/point/divider.d.ts","../../geometry/dist/src/point/dot-product.d.ts","../../geometry/dist/src/point/empty.d.ts","../../geometry/dist/src/point/find-minimum.d.ts","../../geometry/dist/src/point/from.d.ts","../../geometry/dist/src/point/get-point-parameter.d.ts","../../geometry/dist/src/point/guard.d.ts","../../geometry/dist/src/point/interpolate.d.ts","../../geometry/dist/src/point/invert.d.ts","../../geometry/dist/src/point/is-equal.d.ts","../../geometry/dist/src/point/magnitude.d.ts","../../geometry/dist/src/point/most.d.ts","../../geometry/dist/src/point/multiply.d.ts","../../geometry/dist/src/point/normalise.d.ts","../../geometry/dist/src/point/normalise-by-rect.d.ts","../../geometry/dist/src/point/pipeline.d.ts","../../geometry/dist/src/point/point-relation-types.d.ts","../../geometry/dist/src/polar/types.d.ts","../../geometry/dist/src/polar/angles.d.ts","../../geometry/dist/src/polar/conversions.d.ts","../../geometry/dist/src/polar/guard.d.ts","../../geometry/dist/src/polar/math.d.ts","../../geometry/dist/src/polar/ray.d.ts","../../geometry/dist/src/polar/spiral.d.ts","../../geometry/dist/src/polar/index.d.ts","../../geometry/dist/src/point/point-tracker.d.ts","../../geometry/dist/src/point/progress-between.d.ts","../../geometry/dist/src/point/project.d.ts","../../geometry/dist/src/point/quantise.d.ts","../../geometry/dist/src/point/random.d.ts","../../geometry/dist/src/point/reduce.d.ts","../../geometry/dist/src/point/relation.d.ts","../../geometry/dist/src/point/rotate.d.ts","../../geometry/dist/src/point/rotate-point-array.d.ts","../../geometry/dist/src/point/round.d.ts","../../geometry/dist/src/point/subtract.d.ts","../../geometry/dist/src/point/sum.d.ts","../../geometry/dist/src/point/To.d.ts","../../geometry/dist/src/point/to-array.d.ts","../../geometry/dist/src/point/within-range.d.ts","../../geometry/dist/src/point/wrap.d.ts","../../geometry/dist/src/point/index.d.ts","../../geometry/dist/src/rect/area.d.ts","../../geometry/dist/src/rect/apply.d.ts","../../geometry/dist/src/grid/types.d.ts","../../geometry/dist/src/grid/apply-bounds.d.ts","../../geometry/dist/src/grid/array-1d.d.ts","../../geometry/dist/src/grid/array-2d.d.ts","../../geometry/dist/src/grid/as.d.ts","../../geometry/dist/src/grid/directions.d.ts","../../geometry/dist/src/grid/enumerators/cells.d.ts","../../geometry/dist/src/grid/enumerators/index.d.ts","../../geometry/dist/src/grid/geometry.d.ts","../../geometry/dist/src/grid/guards.d.ts","../../geometry/dist/src/grid/indexing.d.ts","../../geometry/dist/src/grid/inside.d.ts","../../geometry/dist/src/grid/is-equal.d.ts","../../geometry/dist/src/grid/neighbour.d.ts","../../geometry/dist/src/grid/offset.d.ts","../../geometry/dist/src/grid/to-array.d.ts","../../geometry/dist/src/grid/to-string.d.ts","../../geometry/dist/src/grid/visual.d.ts","../../geometry/dist/src/grid/values.d.ts","../../geometry/dist/src/grid/visitors/breadth.d.ts","../../geometry/dist/src/grid/visitors/cell-neighbours.d.ts","../../geometry/dist/src/grid/visitors/columns.d.ts","../../geometry/dist/src/grid/visitors/depth.d.ts","../../geometry/dist/src/grid/visitors/step.d.ts","../../geometry/dist/src/grid/visitors/random.d.ts","../../geometry/dist/src/grid/visitors/random-contiguous.d.ts","../../geometry/dist/src/grid/visitors/rows.d.ts","../../geometry/dist/src/grid/visitors/visitor.d.ts","../../geometry/dist/src/grid/visitors/index.d.ts","../../geometry/dist/src/grid/index.d.ts","../../geometry/dist/src/rect/cardinal.d.ts","../../geometry/dist/src/rect/center-origin.d.ts","../../geometry/dist/src/rect/center.d.ts","../../geometry/dist/src/rect/corners.d.ts","../../geometry/dist/src/rect/distance.d.ts","../../geometry/dist/src/rect/divide.d.ts","../../geometry/dist/src/rect/edges.d.ts","../../geometry/dist/src/rect/empty.d.ts","../../geometry/dist/src/rect/encompass.d.ts","../../geometry/dist/src/rect/from-center.d.ts","../../geometry/dist/src/rect/from-element.d.ts","../../geometry/dist/src/rect/from-numbers.d.ts","../../geometry/dist/src/rect/from-top-left.d.ts","../../geometry/dist/src/rect/get-rect-positionedparameter.d.ts","../../geometry/dist/src/rect/guard.d.ts","../../geometry/dist/src/rect/Intersects.d.ts","../../geometry/dist/src/rect/is-equal.d.ts","../../geometry/dist/src/rect/lengths.d.ts","../../geometry/dist/src/rect/max.d.ts","../../geometry/dist/src/rect/multiply.d.ts","../../geometry/dist/src/rect/nearest.d.ts","../../geometry/dist/src/rect/placeholder.d.ts","../../geometry/dist/src/rect/perimeter.d.ts","../../geometry/dist/src/rect/normalise-by-rect.d.ts","../../geometry/dist/src/rect/random.d.ts","../../geometry/dist/src/rect/subtract.d.ts","../../geometry/dist/src/rect/sum.d.ts","../../geometry/dist/src/rect/to-array.d.ts","../../geometry/dist/src/rect/index.d.ts","../../geometry/dist/src/path/path-type.d.ts","../../geometry/dist/src/arc/arc-type.d.ts","../../geometry/dist/src/arc/index.d.ts","../../geometry/dist/src/bezier/bezier-type.d.ts","../../geometry/dist/src/bezier/guard.d.ts","../../geometry/dist/src/bezier/index.d.ts","../../geometry/dist/src/circle/area.d.ts","../../geometry/dist/src/circle/bbox.d.ts","../../geometry/dist/src/circle/center.d.ts","../../geometry/dist/src/path/compound-path.d.ts","../../geometry/dist/src/path/start-end.d.ts","../../geometry/dist/src/path/index.d.ts","../../geometry/dist/src/circle/circular-path.d.ts","../../geometry/dist/src/circle/distance-center.d.ts","../../geometry/dist/src/circle/distance-from-exterior.d.ts","../../geometry/dist/src/circle/exterior-points.d.ts","../../geometry/dist/src/circle/guard.d.ts","../../geometry/dist/src/circle/interior-points.d.ts","../../geometry/dist/src/circle/interpolate.d.ts","../../geometry/dist/src/circle/intersecting.d.ts","../../geometry/dist/src/circle/intersections.d.ts","../../geometry/dist/src/circle/is-contained-by.d.ts","../../geometry/dist/src/circle/is-equal.d.ts","../../geometry/dist/src/circle/multiply.d.ts","../../geometry/dist/src/circle/perimeter.d.ts","../../geometry/dist/src/circle/random.d.ts","../../geometry/dist/src/circle/svg.d.ts","../../geometry/dist/src/circle/to-path.d.ts","../../geometry/dist/src/circle/to-positioned.d.ts","../../geometry/dist/src/circle/index.d.ts","../../geometry/dist/src/line/angles.d.ts","../../geometry/dist/src/line/bbox.d.ts","../../geometry/dist/src/line/distance-single-line.d.ts","../../geometry/dist/src/line/divide.d.ts","../../geometry/dist/src/line/from-flat-array.d.ts","../../geometry/dist/src/line/from-numbers.d.ts","../../geometry/dist/src/line/from-points.d.ts","../../geometry/dist/src/line/from-pivot.d.ts","../../geometry/dist/src/line/line-path-type.d.ts","../../geometry/dist/src/line/from-points-to-path.d.ts","../../geometry/dist/src/line/get-points-parameter.d.ts","../../geometry/dist/src/line/guard.d.ts","../../geometry/dist/src/line/interpolate.d.ts","../../geometry/dist/src/line/is-equal.d.ts","../../geometry/dist/src/line/join-points-to-lines.d.ts","../../geometry/dist/src/line/length.d.ts","../../geometry/dist/src/line/midpoint.d.ts","../../geometry/dist/src/line/multiply.d.ts","../../geometry/dist/src/line/nearest.d.ts","../../geometry/dist/src/line/relative-position.d.ts","../../geometry/dist/src/line/reverse.d.ts","../../geometry/dist/src/line/rotate.d.ts","../../geometry/dist/src/line/subtract.d.ts","../../geometry/dist/src/line/sum.d.ts","../../geometry/dist/src/line/to-path.d.ts","../../geometry/dist/src/line/to-string.d.ts","../../geometry/dist/src/line/index.d.ts","../../geometry/dist/src/waypoint.d.ts","../../geometry/dist/src/circle-packing.d.ts","../../geometry/dist/src/layout.d.ts","../../geometry/dist/src/ellipse.d.ts","../../geometry/dist/src/angles.d.ts","../../geometry/dist/src/curve-simplification.d.ts","../../geometry/dist/src/quad-tree.d.ts","../../geometry/dist/src/scaler.d.ts","../../geometry/dist/src/vector.d.ts","../../geometry/dist/src/surface-points.d.ts","../../geometry/dist/src/triangle/angles.d.ts","../../geometry/dist/src/triangle/area.d.ts","../../geometry/dist/src/triangle/barycentric.d.ts","../../geometry/dist/src/triangle/bbox.d.ts","../../geometry/dist/src/triangle/centroid.d.ts","../../geometry/dist/src/triangle/corners.d.ts","../../geometry/dist/src/triangle/create.d.ts","../../geometry/dist/src/triangle/edges.d.ts","../../geometry/dist/src/triangle/from.d.ts","../../geometry/dist/src/triangle/inner-circle.d.ts","../../geometry/dist/src/triangle/intersects.d.ts","../../geometry/dist/src/triangle/kinds.d.ts","../../geometry/dist/src/triangle/lengths.d.ts","../../geometry/dist/src/triangle/math.d.ts","../../geometry/dist/src/triangle/outer-circle.d.ts","../../geometry/dist/src/triangle/perimeter.d.ts","../../geometry/dist/src/triangle/rotate.d.ts","../../geometry/dist/src/triangle/to.d.ts","../../geometry/dist/src/triangle/guard.d.ts","../../geometry/dist/src/triangle/equilateral.d.ts","../../geometry/dist/src/triangle/right.d.ts","../../geometry/dist/src/triangle/isosceles.d.ts","../../geometry/dist/src/triangle/index.d.ts","../../geometry/dist/src/index.d.ts"],"sourcesContent":["/**\n * A point, consisting of x, y and maybe z fields.\n */\nexport type Point = {\n    readonly x: number;\n    readonly y: number;\n    readonly z?: number;\n};\nexport type Point3d = Point & {\n    readonly z: number;\n};\n/**\n * Placeholder point: `{ x: NaN, y: NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder3d` get a point with `z` property.\n */\nexport declare const Placeholder: Readonly<{\n    x: number;\n    y: number;\n}>;\n/**\n * Placeholder point: `{x: NaN, y:NaN, z:NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder` to get a point without `z` property.\n */\nexport declare const Placeholder3d: Readonly<{\n    x: number;\n    y: number;\n    z: number;\n}>;\n//# sourceMappingURL=point-type.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function abs(pt: Point3d): Point3d;\nexport declare function abs(pt: Point): Point;\n//# sourceMappingURL=abs.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns the angle in radians between `a` and `b`.\n *\n * Eg if `a` is the origin, and `b` is another point,\n * in degrees one would get 0 to -180 when `b` was above `a`.\n *  -180 would be `b` in line with `a`.\n * Same for under `a`.\n *\n * Providing a third point `c` gives the interior angle, where `b` is the middle point.\n *\n * See also {@link angleRadianCircle} which returns coordinates on 0..Math.Pi*2\n * range. This avoids negative numbers.\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport declare const angleRadian: (a: Point, b?: Point, c?: Point) => number;\n/**\n * Returns the angle between point(s) using a radian circle system.\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport declare const angleRadianCircle: (a: Point, b?: Point, c?: Point) => number;\n//# sourceMappingURL=angle.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport type PointApplyFn = (v: number, field: `x` | `y`) => number;\nexport type Point3dApplyFn = (v: number, field: `x` | `y` | `z`) => number;\nexport declare function apply(pt: Point3d, fn: Point3dApplyFn): Point3d;\nexport declare function apply(pt: Point, fn: PointApplyFn): Point;\n//# sourceMappingURL=apply.d.ts.map","import type { Point } from \"./point-type.js\";\nexport type PointAverager = (point: Point) => Point;\nexport type PointAverageKinds = `moving-average-light`;\n/**\n * Keeps track of average x, y and z values.\n *\n * When calling, you have to specify the averaging technique. At the moment\n * only 'moving-average-light' is supported. This uses @ixfx/numbers.movingAverageLight\n * under-the-hood.\n *\n * ```js\n * // Create averager\n * const averager = Points.averager(`moving-average-light`);\n *\n * // Call function with a point to add it to average\n * // and return the current average.\n * averager(somePoint); // Yields current average {x,y,z?}\n * ```\n *\n * @param kind Averaging strategy\n * @param opts Scaling parameter. Higher means more smoothing, lower means less (minimum: 1). Default: 3\n * @returns\n */\nexport declare function averager(kind: `moving-average-light`, opts: Partial<{\n    scaling: number;\n}>): PointAverager;\n//# sourceMappingURL=averager.d.ts.map","import type { Point, Point3d } from \"../point/point-type.js\";\n/**\n * Rectangle as array: `[width, height]`\n */\nexport type RectArray = readonly [width: number, height: number];\n/**\n * Positioned rectangle as array: `[x, y, width, height]`\n */\nexport type RectPositionedArray = readonly [\n    x: number,\n    y: number,\n    width: number,\n    height: number\n];\nexport type Rect = {\n    readonly width: number;\n    readonly height: number;\n};\nexport type Rect3d = Rect & {\n    readonly depth: number;\n};\nexport type RectPositioned = Point & Rect;\nexport type Rect3dPositioned = Point3d & Rect3d;\n//# sourceMappingURL=rect-types.d.ts.map","import type { Rect3dPositioned, RectPositioned } from \"../rect/rect-types.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n/**\n * Returns the minimum rectangle that can enclose all provided points\n * @param points\n * @returns\n */\nexport declare const bbox: (...points: ReadonlyArray<Point>) => RectPositioned;\nexport declare const bbox3d: (...points: ReadonlyArray<Point3d>) => Rect3dPositioned;\n//# sourceMappingURL=bbox.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Calculates the [centroid](https://en.wikipedia.org/wiki/Centroid#Of_a_finite_set_of_points) of a set of points\n * Undefined values are skipped over.\n *\n * ```js\n * // Find centroid of a list of points\n * const c1 = centroid(p1, p2, p3, ...);\n *\n * // Find centroid of an array of points\n * const c2 = centroid(...pointsArray);\n * ```\n * @param points\n * @returns A single point\n */\nexport declare const centroid: (...points: ReadonlyArray<Point | undefined>) => Point;\n//# sourceMappingURL=centroid.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function clamp(a: Point, min?: number, max?: number): Point;\nexport declare function clamp(a: Point3d, min?: number, max?: number): Point3d;\n//# sourceMappingURL=clamp.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\n/**\n * Returns -2 if both x & y of a is less than b\n * Returns -1 if either x/y of a is less than b\n *\n * Returns 2 if both x & y of a is greater than b\n * Returns 1 if either x/y of a is greater than b's x/y\n *\n * Returns 0 if x/y of a and b are equal\n * @param a\n * @param b\n * @returns\n */\nexport declare const compare: (a: Point, b: Point) => number;\n/**\n * Compares points based on x value. Y value is ignored.\n *\n * Return values:\n * * 0: If a.x === b.x\n * * 1: a is to the right of b (ie. a.x > b.x)\n * * -1: a is to the left of b (ie. a.x < b.x)\n *\n * @example Sorting by x\n * ```js\n * arrayOfPoints.sort(Points.compareByX);\n * ```\n *\n * @param a\n * @param b\n * @returns\n */\nexport declare const compareByX: (a: Point, b: Point) => number;\n/**\n * Compares points based on Y value. X value is ignored.\n *\n * Return values:\n * * 0: If a.y === b.y\n * * 1: A is below B (ie. a.y > b.y)\n * * -1: A is above B (ie. a.y < b.y)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByY);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const compareByY: (a: Point, b: Point) => number;\n/**\n * Compares points based on Z value. XY values are ignored.\n *\n * Return values:\n * * 0: If a.z === b.z\n * * 1: A is below B (ie. a.z > b.z)\n * * -1: A is above B (ie. a.z < b.z)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByZ);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const compareByZ: (a: Point3d, b: Point3d) => number;\n//# sourceMappingURL=compare.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Simple convex hull impementation. Returns a set of points which\n * enclose `pts`.\n *\n * For more power, see something like [Hull.js](https://github.com/AndriiHeonia/hull)\n * @param pts\n * @returns\n */\nexport declare const convexHull: (...pts: ReadonlyArray<Point>) => ReadonlyArray<Point>;\n//# sourceMappingURL=convex-hull.d.ts.map","import type { Point } from './point-type.js';\nexport declare function distance(a: Point, b?: Point): number;\nexport declare function distance(a: Point, x: number, y: number): number;\n//# sourceMappingURL=distance.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * A circle\n */\nexport type Circle = {\n    readonly radius: number;\n};\nexport type CircleToSvg = {\n    (circleOrRadius: Circle | number, sweep: boolean, origin: Point): readonly string[];\n    (circle: CirclePositioned, sweep: boolean): readonly string[];\n};\n/**\n * A {@link Circle} with position\n */\nexport type CirclePositioned = Point & Circle;\nexport type CircleRandomPointOpts = {\n    /**\n     * Algorithm to calculate random values.\n     * Default: 'uniform'\n     */\n    readonly strategy: `naive` | `uniform`;\n    /**\n     * Random number source.\n     * Default: Math.random\n     */\n    readonly randomSource: () => number;\n    /**\n     * Margin within shape to start generating random points\n     * Default: 0\n     */\n    readonly margin: number;\n};\n//# sourceMappingURL=circle-type.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * A line, which consists of an `a` and `b` {@link Point}.\n */\nexport type Line = {\n    readonly a: Point;\n    readonly b: Point;\n};\n/**\n * A PolyLine, consisting of more than one line.\n */\nexport type PolyLine = ReadonlyArray<Line>;\n//# sourceMappingURL=line-type.d.ts.map","import type { CirclePositioned } from \"../circle/circle-type.js\";\nimport type { Line, PolyLine } from \"../line/line-type.js\";\nimport type { Point, Point3d } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"../rect/rect-types.js\";\nexport type ShapePositioned = CirclePositioned | RectPositioned;\nexport type ContainsResult = `none` | `contained`;\nexport type Sphere = Point3d & {\n    readonly radius: number;\n};\nexport type PointCalculableShape = PolyLine | Line | RectPositioned | Point | CirclePositioned;\n//# sourceMappingURL=shape-type.d.ts.map","import type { Point } from \"../point/point-type.js\";\nexport type ArrowOpts = {\n    readonly arrowSize?: number;\n    readonly tailLength?: number;\n    readonly tailThickness?: number;\n    readonly angleRadian?: number;\n};\n/**\n * Returns the points forming an arrow.\n *\n * @example Create an arrow anchored by its tip at 100,100\n * ```js\n * const opts = {\n *  tailLength: 10,\n *  arrowSize: 20,\n *  tailThickness: 5,\n *  angleRadian: degreeToRadian(45)\n * }\n * const arrow = Shapes.arrow({x:100, y:100}, `tip`, opts); // Yields an array of points\n *\n * // Eg: draw points\n * Drawing.connectedPoints(ctx, arrow, {strokeStyle: `red`, loop: true});\n * ```\n *\n * @param origin Origin of arrow\n * @param from Does origin describe the tip, tail or middle?\n * @param opts Options for arrow\n * @returns\n */\nexport declare const arrow: (origin: Point, from: `tip` | `tail` | `middle`, opts?: ArrowOpts) => ReadonlyArray<Point>;\n//# sourceMappingURL=arrow.d.ts.map","import type { Point } from \"../point/point-type.js\";\nexport type Triangle = {\n    readonly a: Point;\n    readonly b: Point;\n    readonly c: Point;\n};\nexport type BarycentricCoord = {\n    readonly a: number;\n    readonly b: number;\n    readonly c: number;\n};\n//# sourceMappingURL=triangle-type.d.ts.map","import type { RandomSource } from \"@ixfx/random\";\nimport type { ShapePositioned } from \"./shape-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Rect } from \"../rect/rect-types.js\";\nimport type { Triangle } from \"../triangle/triangle-type.js\";\nimport type { Circle } from \"../circle/circle-type.js\";\nexport type ShapeRandomPointOpts = {\n    readonly randomSource: RandomSource;\n};\n/**\n * Returns a random point within a shape.\n * `shape` can be {@link Circles.CirclePositioned} or {@link Rects.RectPositioned}\n * @param shape\n * @param opts\n * @returns\n */\nexport declare const randomPoint: (shape: ShapePositioned, opts?: Partial<ShapeRandomPointOpts>) => Point;\n/**\n * Returns the center of a shape\n * Shape can be: rectangle, triangle, circle\n * @param shape\n * @returns\n */\nexport declare const center: (shape?: Rect | Triangle | Circle) => Point;\n//# sourceMappingURL=etc.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { ShapePositioned } from \"./shape-type.js\";\n/**\n * Returns the intersection result between a and b.\n * `a` can be a {@link Circles.CirclePositioned} or {@link Rects.RectPositioned}\n * `b` can be as above or a {@link Point}.\n * @param a\n * @param b\n */\nexport declare const isIntersecting: (a: ShapePositioned, b: ShapePositioned | Point) => boolean;\n//# sourceMappingURL=is-intersecting.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * Generates a starburst shape, returning an array of points. By default, initial point is top and horizontally-centred.\n *\n * ```\n * // Generate a starburst with four spikes\n * const pts = starburst(4, 100, 200);\n * ```\n *\n * `points` of two produces a lozenge shape.\n * `points` of three produces a triangle shape.\n * `points` of five is the familiar 'star' shape.\n *\n * Note that the path will need to be closed back to the first point to enclose the shape.\n *\n * @example Create starburst and draw it. Note use of 'loop' flag to close the path\n * ```\n * const points = starburst(4, 100, 200);\n * Drawing.connectedPoints(ctx, pts, {loop: true, fillStyle: `orange`, strokeStyle: `red`});\n * ```\n *\n * Options:\n * * initialAngleRadian: angle offset to begin from. This overrides the `-Math.PI/2` default.\n *\n * @param points Number of points in the starburst. Defaults to five, which produces a typical star\n * @param innerRadius Inner radius. A proportionally smaller inner radius makes for sharper spikes. If unspecified, 50% of the outer radius is used.\n * @param outerRadius Outer radius. Maximum radius of a spike to origin\n * @param opts Options\n * @param origin Origin, or `{ x:0, y:0 }` by default.\n */\nexport declare const starburst: (outerRadius: number, points?: number, innerRadius?: number, origin?: Point, opts?: {\n    readonly initialAngleRadian?: number;\n}) => readonly Point[];\n//# sourceMappingURL=starburst.d.ts.map","export type * from './shape-type.js';\nexport * from './arrow.js';\nexport * from './etc.js';\nexport * from './is-intersecting.js';\nexport * from './starburst.js';\n//# sourceMappingURL=index.d.ts.map","import type { Point } from \"./point-type.js\";\nimport type { PointCalculableShape } from \"../shape/index.js\";\n/**\n * Returns the distance from point `a` to the center of `shape`.\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport declare const distanceToCenter: (a: Point, shape: PointCalculableShape) => number;\n//# sourceMappingURL=distance-to-center.d.ts.map","import type { Point } from \"./point-type.js\";\nimport type { PointCalculableShape } from \"../shape/shape-type.js\";\n/**\n * Returns the distance from point `a` to the exterior of `shape`.\n *\n * @example Distance from point to rectangle\n * ```\n * const distance = distanceToExterior(\n *  {x: 50, y: 50},\n *  {x: 100, y: 100, width: 20, height: 20}\n * );\n * ```\n *\n * @example Find closest shape to point\n * ```\n * import {minIndex} from '../data/arrays.js';\n * const shapes = [ some shapes... ]; // Shapes to compare against\n * const pt = { x: 10, y: 10 };       // Comparison point\n * const distances = shapes.map(v => distanceToExterior(pt, v));\n * const closest = shapes[minIndex(...distances)];\n * ```\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport declare const distanceToExterior: (a: Point, shape: PointCalculableShape) => number;\n//# sourceMappingURL=distance-to-exterior.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function divide(a: Point, b: Point): Point;\nexport declare function divide(a: Point3d, b: Point3d): Point3d;\nexport declare function divide(a: Point, x: number, y: number): Point;\nexport declare function divide(a: Point3d, x: number, y: number, z: number): Point3d;\nexport declare function divide(ax: number, ay: number, bx: number, by: number): Point;\nexport declare function divide(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n/**\n * Returns a function that divides a point:\n * ```js\n * const f = divider(100, 200);\n * f(50,100); // Yields: { x: 0.5, y: 0.5 }\n * ```\n *\n * Input values can be Point, separate x,y and optional z values or an array:\n * ```js\n * const f = divider({ x: 100, y: 100 });\n * const f = divider( 100, 100 );\n * const f = divider([ 100, 100 ]);\n * ```\n *\n * Likewise the returned function an take these as inputs:\n * ```js\n * f({ x: 100, y: 100});\n * f( 100, 100 );\n * f([ 100, 100 ]);\n * ```\n *\n * Function throws if divisor has 0 for any coordinate (since we can't divide by 0)\n * @param a Divisor point, array of points or x\n * @param b Divisor y value\n * @param c Divisor z value\n * @returns\n */\nexport declare function divider(a: Point3d | Point | number | number[], b?: number, c?: number): (aa: Point3d | Point | number | number[], bb?: number, cc?: number) => Point;\n//# sourceMappingURL=divider.d.ts.map","import type { Point } from './point-type.js';\nexport declare const dotProduct: (...pts: readonly Point[]) => number;\n//# sourceMappingURL=dot-product.d.ts.map","/**\n * An empty point of `{ x: 0, y: 0 }`.\n *\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty3d` to get an empty point with `z`.\n */\nexport declare const Empty: {\n    readonly x: 0;\n    readonly y: 0;\n};\n/**\n * Returns { x:1, y:1 }\n */\nexport declare const Unit: {\n    readonly x: 1;\n    readonly y: 1;\n};\n/**\n * An empty Point of `{ x: 0, y: 0, z: 0}`\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty` to get an empty point without `z`.\n */\nexport declare const Empty3d: {\n    readonly x: 0;\n    readonly y: 0;\n    readonly z: 0;\n};\n/**\n * Returns { x:1,y:1,z:1 }\n */\nexport declare const Unit3d: {\n    readonly x: 1;\n    readonly y: 1;\n    readonly z: 1;\n};\n//# sourceMappingURL=empty.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function findMinimum(comparer: (a: Point, b: Point) => Point, ...points: ReadonlyArray<Point>): Point;\nexport declare function findMinimum(comparer: (a: Point3d, b: Point3d) => Point3d, ...points: ReadonlyArray<Point3d>): Point3d;\n//# sourceMappingURL=find-minimum.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function from(x: number, y: number, z: number): Point3d;\nexport declare function from(x: number, y: number): Point;\nexport declare function from(array: [x: number, y: number, z: number]): Point3d;\nexport declare function from(array: [x: number, y: number]): Point;\n/**\n * Parses a point as a string, in the form 'x,y' or 'x,y,z'.\n * eg '10,15' will be returned as `{ x: 10, y: 15 }`.\n *\n * Throws an error if `str` is not a string.\n *\n * ```js\n * Points.fromString(`10,15`);  // { x:10, y:15 }\n * Points.fromString(`a,10`);   // { x:NaN, y:10 }\n * ```\n *\n * Use {@link Points.isNaN} to check if returned point has NaN for either coordinate.\n * @param string_\n */\nexport declare const fromString: (string_: string) => Point;\n/**\n * Returns an array of points from an array of numbers.\n *\n * Array can be a continuous series of x, y values:\n * ```\n * [1,2,3,4] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n *\n * Or it can be an array of arrays:\n * ```\n * [[1,2], [3,4]] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n * @param coords\n * @returns\n */\nexport declare const fromNumbers: (...coords: readonly (readonly number[])[] | readonly number[]) => readonly Point[];\n//# sourceMappingURL=from.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function getTwoPointParameters(a: Point, b: Point): [a: Point, b: Point];\nexport declare function getTwoPointParameters(a: Point3d, b: Point3d): [a: Point3d, b: Point3d];\nexport declare function getTwoPointParameters(a: Point, x: number, y: number): [a: Point, b: Point];\nexport declare function getTwoPointParameters(a: Point3d, x: number, y: number, z: number): [a: Point3d, b: Point3d];\nexport declare function getTwoPointParameters(ax: number, ay: number, bx: number, by: number): [a: Point, b: Point];\nexport declare function getTwoPointParameters(ax: number, ay: number, az: number, bx: number, by: number, bz: number): [a: Point3d, b: Point3d];\n/**\n * Returns a Point form of either a point, x,y params or x,y,z params.\n * If parameters are undefined, an empty point is returned (0, 0)\n * @ignore\n * @param a\n * @param b\n * @returns\n */\nexport declare function getPointParameter(a?: Point3d | Point | number | Array<number> | ReadonlyArray<number>, b?: number | boolean, c?: number): Point | Point3d;\n//# sourceMappingURL=get-point-parameter.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nimport { type Result } from '@ixfx/guards';\n/**\n * Returns true if xy (and z, if present) are _null_.\n * @param p\n * @returns\n */\nexport declare const isNull: (p: Point) => boolean;\n/***\n * Returns true if either x, y, z isNaN.\n */\nexport declare const isNaN: (p: Point) => boolean;\nexport declare function test(p: Point, name?: string, extraInfo?: string): Result<Point, string>;\n/**\n * Throws an error if point is invalid\n * @param p\n * @param name\n */\nexport declare function guard(p: Point, name?: string, info?: string): void;\n/**\n * Throws if parameter is not a valid point, or either x or y is 0\n * @param pt\n * @returns\n */\nexport declare const guardNonZeroPoint: (pt: Point | Point3d, name?: string) => boolean;\n/**\n * Returns _true_ if `p` has x & y properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * Use {@link isPoint3d} to check further check for `z`.\n * @param p\n * @returns\n */\nexport declare function isPoint(p: number | unknown): p is Point;\n/**\n * Returns _true_ if `p` has x, y, & z properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * @param p\n * @returns\n */\nexport declare const isPoint3d: (p: Point | unknown) => p is Point3d;\n/**\n * Returns true if both xy (and z, if present) are 0.\n * Use `Points.Empty` to return an empty point.\n * @param p\n * @returns\n */\nexport declare const isEmpty: (p: Point) => boolean;\n/**\n * Returns true if point is a placeholder, where xy (and z, if present)\n * are `NaN`.\n *\n * Use Points.Placeholder to return a placeholder point.\n * @param p\n * @returns\n */\nexport declare const isPlaceholder: (p: Point) => boolean;\n//# sourceMappingURL=guard.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns a relative point between two points.\n *\n * ```js\n * interpolate(0.5, { x:0, y:0 }, { x:10, y:10 }); // Halfway { x, y }\n * ```\n *\n * Alias for Lines.interpolate(amount, a, b);\n *\n * @param amount Relative amount, 0-1\n * @param a\n * @param b\n * @param allowOverflow If true, length of line can be exceeded for `amount` of below 0 and above `1`.\n * @returns {@link Point}\n */\nexport declare const interpolate: (amount: number, a: Point, b: Point, allowOverflow?: boolean) => Point;\n//# sourceMappingURL=interpolate.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\n/**\n * Inverts one or more axis of a point\n * ```js\n * invert({x:10, y:10}); // Yields: {x:-10, y:-10}\n * invert({x:10, y:10}, `x`); // Yields: {x:-10, y:10}\n * ```\n * @param pt Point to invert\n * @param what Which axis. If unspecified, both axies are inverted\n * @returns\n */\nexport declare const invert: (pt: Point | Point3d, what?: `both` | `x` | `y` | `z`) => Point;\n//# sourceMappingURL=invert.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns _true_ if the points have identical values\n *\n * ```js\n * const a = {x: 10, y: 10};\n * const b = {x: 10, y: 10;};\n * a === b        // False, because a and be are different objects\n * isEqual(a, b)   // True, because a and b are same value\n * ```\n * @param p Points\n * @returns _True_ if points are equal\n */\nexport declare const isEqual: (...p: ReadonlyArray<Point>) => boolean;\n//# sourceMappingURL=is-equal.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Clamps the magnitude of a point.\n * This is useful when using a Point as a vector, to limit forces.\n * @param pt\n * @param max Maximum magnitude (1 by default)\n * @param min Minimum magnitude (0 by default)\n * @returns\n */\nexport declare const clampMagnitude: (pt: Point, max?: number, min?: number) => Point;\n//# sourceMappingURL=magnitude.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns the left-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x <= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport declare const leftmost: (...points: ReadonlyArray<Point>) => Point;\n/**\n * Returns the right-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x >= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport declare const rightmost: (...points: ReadonlyArray<Point>) => Point;\n//# sourceMappingURL=most.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function multiply(a: Point, b: Point): Point;\nexport declare function multiply(a: Point3d, b: Point3d): Point3d;\nexport declare function multiply(a: Point, x: number, y: number): Point;\nexport declare function multiply(a: Point3d, x: number, y: number, z: number): Point3d;\nexport declare function multiply(ax: number, ay: number, bx: number, by: number): Point;\nexport declare function multiply(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n/**\n * Multiplies all components by `v`.\n * Existing properties of `pt` are maintained.\n *\n * ```js\n * multiplyScalar({ x:2, y:4 }, 2);\n * // Yields: { x:4, y:8 }\n * ```\n * @param pt Point\n * @param v Value to multiply by\n * @returns\n */\nexport declare const multiplyScalar: (pt: Point | Point3d, v: number) => Point | Point3d;\n//# sourceMappingURL=multiply.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Normalise point as a unit vector.\n *\n * ```js\n * normalise({x:10, y:20});\n * normalise(10, 20);\n * ```\n * @param ptOrX Point, or x value\n * @param y y value if first param is x\n * @returns\n */\nexport declare const normalise: (ptOrX: Point | number, y?: number) => Point;\n//# sourceMappingURL=normalise.d.ts.map","import type { Rect } from \"../rect/rect-types.js\";\nimport type { Point } from \"./point-type.js\";\n/**\n * Normalises a point by a given width and height\n *\n * ```js\n * normaliseByRect({ x: 10, y: 10 }, 20, 40 }); // { x: 0.5, y: 0.2 }\n * ```\n * @param point Point\n * @param width Width\n * @param height Height\n */\nexport declare function normaliseByRect(point: Point, width: number, height: number): Point;\n/**\n * Normalises a point by a given rect's width and height\n *\n * ```js\n * normaliseByRect({ x: 10, y: 10, width: 20, height: 40 }); // { x: 0.5, y: 0.2 }\n * ```\n * @param pt\n * @param rect\n */\nexport declare function normaliseByRect(pt: Point, rect: Rect): Point;\n/**\n * Normalises x,y by width and height so it is on a 0..1 scale\n *\n * ```js\n * normaliseByRect(10, 10, 20, 40); // { x: 0.5, y: 0.2 }\n * ```\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport declare function normaliseByRect(x: number, y: number, width: number, height: number): Point;\n//# sourceMappingURL=normalise-by-rect.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Runs a sequential series of functions on `pt`. The output from one feeding into the next.\n *\n * ```js\n * const p = Points.pipelineApply(somePoint, Points.normalise, Points.invert);\n * ```\n *\n * If you want to make a reusable pipeline of functions, consider {@link pipeline} instead.\n * @param point\n * @param pipelineFns\n * @returns\n */\nexport declare const pipelineApply: (point: Point, ...pipelineFns: readonly ((pt: Point) => Point)[]) => Point;\n/**\n * Returns a pipeline function that takes a point to be transformed through a series of functions\n * ```js\n * // Create pipeline\n * const p = Points.pipeline(Points.normalise, Points.invert);\n *\n * // Now run it on `somePoint`.\n * // First we normalised, and then invert\n * const changedPoint = p(somePoint);\n * ```\n *\n * If you don't want to create a pipeline, use {@link pipelineApply}.\n * @param pipeline Pipeline of functions\n * @returns\n */\nexport declare const pipeline: (...pipeline: readonly ((pt: Point) => Point)[]) => (pt: Point) => Point;\n//# sourceMappingURL=pipeline.d.ts.map","import type { Point } from \"./point-type.js\";\nexport type PointRelation = (a: Point | number, b?: number) => PointRelationResult;\nexport type PointRelationResult = {\n    /**\n     * Angle from start\n     */\n    readonly angle: number;\n    /**\n     * Distance from start\n     */\n    readonly distanceFromStart: number;\n    /**\n     * Distance from last compared point\n     */\n    readonly distanceFromLast: number;\n    /**\n     * Center point from start\n     */\n    readonly centroid: Point;\n    /**\n     * Average of all points seen\n     * This is calculated by summing x,y and dividing by total points\n     */\n    readonly average: Point;\n    /**\n     * Speed. Distance/millisecond from one sample to the next.\n     */\n    readonly speed: number;\n};\n//# sourceMappingURL=point-relation-types.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * Converts to Cartesian coordiantes\n */\nexport type PolarToCartesian = {\n    (point: Coord, origin?: Point): Point;\n    (distance: number, angleRadians: number, origin?: Point): Point;\n};\n/**\n * A polar ray is allows you to express a line in polar coordinates\n *\n * It consists of an angle (in radians) with a given offset and length.\n *\n * * angleRadian: Angle of line\n * * Offset: distance from the polar origin (default: 0)\n * * Length: length of ray\n * * Origin: Start Cartesian coordinate of line\n */\nexport type PolarRay = Readonly<{\n    /**\n     * Angle of ray\n     */\n    angleRadian: number;\n    /**\n     * Starting point of a ray, defined as an\n     * offset from the polar origin.\n     */\n    offset: number;\n    /**\n     * Length of ray\n     */\n    length: number;\n    /**\n     * Optional origin point of ray (ie start)\n     */\n    origin?: Point;\n}>;\nexport type PolarRayWithOrigin = PolarRay & Readonly<{\n    origin: Point;\n}>;\n/**\n * Polar coordinate, made up of a distance and angle in radians.\n * Most computations involving PolarCoord require an `origin` as well.\n */\nexport type Coord = {\n    readonly distance: number;\n    readonly angleRadian: number;\n};\n//# sourceMappingURL=types.d.ts.map","import type { Coord } from \"./types.js\";\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountRadian Amount to rotate, in radians\n * @returns\n */\nexport declare const rotate: (c: Coord, amountRadian: number) => Coord;\n/**\n * Inverts the direction of coordinate. Ie if pointing north, will point south.\n * @param p\n * @returns\n */\nexport declare const invert: (p: Coord) => Coord;\n/**\n * Returns true if PolarCoords have same magnitude but opposite direction\n * @param a\n * @param b\n * @returns\n */\nexport declare const isOpposite: (a: Coord, b: Coord) => boolean;\n/**\n * Returns true if Coords have the same direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport declare const isParallel: (a: Coord, b: Coord) => boolean;\n/**\n * Returns true if coords are opposite direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport declare const isAntiParallel: (a: Coord, b: Coord) => boolean;\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountDeg Amount to rotate, in degrees\n * @returns\n */\nexport declare const rotateDegrees: (c: Coord, amountDeg: number) => Coord;\n//# sourceMappingURL=angles.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Coord, PolarToCartesian } from \"./types.js\";\n/**\n * Converts a polar coordinate to a Line.\n *\n * ```js\n * const line = toLine({ angleRadian: Math.Pi, distance: 0.5 }, { x: 0.2, y: 0.1 });\n * // Yields { a: { x, y}, b: { x, y } }\n * ```\n *\n * The 'start' parameter is taken to be the origin of the Polar coordinate.\n * @param c\n * @param start\n * @returns\n */\nexport declare const toLine: (c: Coord, start: Point) => {\n    a: Point;\n    b: Point;\n};\n/**\n * Converts to Cartesian coordinate from polar.\n *\n * ```js\n *\n * const origin = { x: 50, y: 50}; // Polar origin\n * // Yields: { x, y }\n * const polar = Polar.toCartesian({ distance: 10, angleRadian: 0 }, origin);\n * ```\n *\n * Distance and angle can be provided as numbers intead:\n *\n * ```\n * // Yields: { x, y }\n * const polar = Polar.toCartesian(10, 0, origin);\n * ```\n *\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport declare const toCartesian: PolarToCartesian;\n/**\n * Converts a Cartesian coordinate to polar\n *\n * ```js\n *\n * // Yields: { angleRadian, distance }\n * const polar = Polar.fromCartesian({x: 50, y: 50}, origin);\n * ```\n *\n * Any additional properties of `point` are copied to object.\n * @param point Point\n * @param origin Origin\n * @returns\n */\nexport declare const fromCartesian: (point: Point, origin: Point) => Coord;\n/**\n * Returns a human-friendly string representation `(distance, angleDeg)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport declare const toString: (p: Coord, digits?: number) => string;\nexport declare const toPoint: (v: Coord, origin?: {\n    readonly x: 0;\n    readonly y: 0;\n}) => Point;\n//# sourceMappingURL=conversions.d.ts.map","import type { Coord } from \"./types.js\";\n/**\n * Returns true if `p` seems to be a {@link Polar.Coord} (ie has both distance & angleRadian fields)\n * @param p\n * @returns True if `p` seems to be a PolarCoord\n */\nexport declare const isPolarCoord: (p: unknown) => p is Coord;\n/**\n * Throws an error if Coord is invalid\n * @param p\n * @param name\n */\nexport declare const guard: (p: Coord, name?: string) => void;\n//# sourceMappingURL=guard.d.ts.map","import type { Coord } from \"./types.js\";\nexport declare const normalise: (c: Coord) => Coord;\n/**\n * Clamps the magnitude of a vector\n * @param v\n * @param max\n * @param min\n * @returns\n */\nexport declare const clampMagnitude: (v: Coord, max?: number, min?: number) => Coord;\n/**\n * Calculate dot product of two PolarCoords.\n *\n * Eg, power is the dot product of force and velocity\n *\n * Dot products are also useful for comparing similarity of\n *  angle between two unit PolarCoords.\n * @param a\n * @param b\n * @returns\n */\nexport declare const dotProduct: (a: Coord, b: Coord) => number;\n/**\n * Multiplies the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport declare const multiply: (v: Coord, amt: number) => Coord;\n/**\n * Divides the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport declare const divide: (v: Coord, amt: number) => Coord;\n//# sourceMappingURL=math.d.ts.map","import { type Line } from \"../line/line-type.js\";\nimport { type Point } from '../point/point-type.js';\nimport { type PolarRay } from \"./types.js\";\n/**\n * Converts a ray to a Line in cartesian coordinates.\n *\n * By default, the ray's origin is taken to be 0,0.\n * Passing in an origin will override this default, or whatever\n * the ray's origin property is.\n * @param ray Ray\n * @param origin Override or provide origin point\n * @returns\n */\nexport declare const toCartesian: (ray: PolarRay, origin?: Point) => Line;\n/**\n * Returns a copy of `ray` ensuring it has an origin.\n * If the `origin` parameter is provided, it will override the existing origin.\n * If no origin information is available, 0,0 is used.\n * @param ray\n * @param origin\n * @returns\n */\n/**\n * Returns a string representation of the ray, useful for debugging.\n *\n * ```\n * \"PolarRay(angle: ... offset: ... len: ... origin: ...)\"\n * ```\n * @param ray\n * @returns\n */\nexport declare const toString: (ray: PolarRay) => string;\n/**\n * Returns a PolarRay based on a line and origin.\n *\n * If `origin` is omitted, the origin is taken to be the 'a' point of the line.\n * Otherwise, the origin value is used to determine the 'offset' of the ray.\n * @param line\n * @param origin\n * @returns\n */\nexport declare const fromLine: (line: Line, origin?: Point) => PolarRay;\n//# sourceMappingURL=ray.d.ts.map","/**\n * Produces an Archimedean spiral. It's a generator.\n *\n * ```js\n * const s = spiral(0.1, 1);\n * for (const coord of s) {\n *  // Use Polar coord...\n *  if (coord.step === 1000) break; // Stop after 1000 iterations\n * }\n * ```\n *\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n */\nimport type { Coord } from \"./types.js\";\nexport declare function spiral(smoothness: number, zoom: number): IterableIterator<Coord & {\n    readonly step: number;\n}>;\n/**\n * Produces an Archimedian spiral with manual stepping.\n * @param step Step number. Typically 0, 1, 2 ...\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n * @returns\n */\nexport declare const spiralRaw: (step: number, smoothness: number, zoom: number) => Coord;\n//# sourceMappingURL=spiral.d.ts.map","export type * from './types.js';\nexport * from './angles.js';\nexport * from './conversions.js';\nexport * from './guard.js';\nexport * from './math.js';\nexport * as Ray from './ray.js';\nexport * from './spiral.js';\n//# sourceMappingURL=index.d.ts.map","import { TrackedValueMap, type TrackedValueOpts as TrackOpts, type TimestampedObject } from '@ixfx/trackers';\nimport { ObjectTracker } from '@ixfx/trackers';\nimport type { Coord as PolarCoord } from '../polar/index.js';\nimport type { Line, PolyLine } from '../line/line-type.js';\nimport type { Point, Point3d } from './point-type.js';\nimport type { PointRelation } from './point-relation-types.js';\nimport type { TrimReason } from '@ixfx/trackers';\nimport type { PointRelationResult } from \"./point-relation-types.js\";\n/**\n * Information about seen points\n */\nexport type PointTrack = PointRelationResult & {};\n/**\n * Results of point tracking\n */\nexport type PointTrackerResults = Readonly<{\n    /**\n     * Relation of last point to previous point\n     */\n    fromLast: PointTrack;\n    /**\n     * Relation of last point to 'initial' point.\n     * This will be the oldest point in the buffer of the tracker.\n     */\n    fromInitial: PointTrack;\n    /**\n     * Relation of last point to a 'mark' point,\n     * which is manually set.\n     *\n     * Will give _undefined_ if `.mark()` has not been called on tracker.\n     */\n    fromMark: PointTrack | undefined;\n    values: readonly Point[];\n}>;\n/**\n * A tracked point. Mutable. Useful for monitoring how\n * it changes over time. Eg. when a pointerdown event happens, to record the start position and then\n * track the pointer as it moves until pointerup.\n *\n * See also\n * * [Playground](https://clinth.github.io/ixfx-play/data/point-tracker/index.html)\n * * {@link PointsTracker}: Track several points, useful for multi-touch.\n * * [ixfx Guide to Point Tracker](https://ixfx.fun/geometry/tracking/)\n *\n * ```js\n * // Create a tracker on a pointerdown\n * const t = new PointTracker();\n *\n * // ...and later, tell it when a point is seen (eg. pointermove)\n * const nfo = t.seen({x: evt.x, y:evt.y});\n * // nfo gives us some details on the relation between the seen point, the start, and points inbetween\n * // nfo.angle, nfo.centroid, nfo.speed etc.\n * ```\n *\n * Compute based on last seen point\n * ```js\n * t.angleFromStart();\n * t.distanceFromStart();\n * t.x / t.y\n * t.length; // Total length of accumulated points\n * t.elapsed; // Total duration since start\n * t.lastResult; // The PointSeenInfo for last seen point\n * ```\n *\n * Housekeeping\n * ```js\n * t.reset(); // Reset tracker\n * ```\n *\n * By default, the tracker only keeps track of the initial point and\n * does not store intermediate 'seen' points. To use the tracker as a buffer,\n * set `storeIntermediate` option to _true_.\n *\n * ```js\n * // Keep only the last 10 points\n * const t = new PointTracker({\n *  sampleLimit: 10\n * });\n *\n * // Store all 'seen' points\n * const t = new PointTracker({\n *  storeIntermediate: true\n * });\n *\n * // In this case, the whole tracker is automatically\n * // reset after 10 samples\n * const t = new PointTracker({\n *  resetAfterSamples: 10\n * })\n * ```\n *\n * When using a buffer limited by `sampleLimit`, the 'initial' point will be the oldest in the\n * buffer, not actually the very first point seen.\n */\nexport declare class PointTracker extends ObjectTracker<Point, PointTrackerResults> {\n    initialRelation: PointRelation | undefined;\n    markRelation: PointRelation | undefined;\n    lastResult: PointTrackerResults | undefined;\n    constructor(opts?: TrackOpts);\n    /**\n     * Notification that buffer has been knocked down to `sampleLimit`.\n     *\n     * This will reset the `initialRelation`, which will use the new oldest value.\n     */\n    onTrimmed(_reason: TrimReason): void;\n    /**\n     * @ignore\n     */\n    onReset(): void;\n    /**\n     * Adds a PointerEvent along with its\n     * coalesced events, if available.\n     * @param p\n     * @returns\n     */\n    seenEvent(p: PointerEvent | MouseEvent): PointTrackerResults;\n    /**\n     * Makes a 'mark' in the tracker, allowing you to compare values\n     * to this point.\n     */\n    mark(): void;\n    /**\n     * Tracks a point, returning data on its relation to the\n     * initial point and the last received point.\n     *\n     * Use {@link seenEvent} to track a raw `PointerEvent`.\n     *\n     * @param _p Point\n     */\n    computeResults(_p: TimestampedObject<Point>[]): PointTrackerResults;\n    /**\n     * Returns a polyline representation of stored points.\n     * Returns an empty array if points were not saved, or there's only one.\n     */\n    get line(): PolyLine;\n    /**\n     * Returns a vector of the initial/last points of the tracker.\n     * Returns as a polar coordinate\n     */\n    get vectorPolar(): PolarCoord;\n    /**\n     * Returns a vector of the initial/last points of the tracker.\n     * Returns as a Cartesian coordinate\n     */\n    get vectorCartesian(): Point;\n    /**\n     * Returns a line from initial point to last point.\n     *\n     * If there are less than two points, Lines.Empty is returned\n     */\n    get lineStartEnd(): Line;\n    /**\n     * Returns distance from latest point to initial point.\n     * If there are less than two points, zero is returned.\n     *\n     * This is the direct distance from initial to last,\n     * not the accumulated length.\n     * @returns Distance\n     */\n    distanceFromStart(): number;\n    /**\n     * Difference between last point and the initial point, calculated\n     * as a simple subtraction of x,y & z.\n     *\n     * `Points.Placeholder` is returned if there's only one point so far.\n     */\n    difference(): Point | Point3d;\n    /**\n     * Returns angle (in radians) from latest point to the initial point\n     * If there are less than two points, undefined is return.\n     * @returns Angle in radians\n     */\n    angleFromStart(): number | undefined;\n    /**\n     * Returns the total length of accumulated points.\n     * Returns 0 if points were not saved, or there's only one\n     */\n    get length(): number;\n    /**\n   * Returns the last x coord\n   */\n    get x(): number;\n    /**\n     * Returns the last y coord\n     */\n    get y(): number;\n    /**\n     * Returns the last z coord (or _undefined_ if not available)\n     */\n    get z(): number | undefined;\n}\n/**\n * A {@link TrackedValueMap} for points. Uses {@link PointTracker} to\n * track added values.\n */\nexport declare class PointsTracker extends TrackedValueMap<Point, PointTracker, PointTrackerResults> {\n    constructor(opts?: TrackOpts);\n    /**\n     * Track a PointerEvent\n     * @param event\n     */\n    seenEvent(event: PointerEvent): Promise<PointTrackerResults[]>;\n}\n//# sourceMappingURL=point-tracker.d.ts.map","import type { Point3d, Point } from \"./point-type.js\";\n/**\n * Computes the progress between two waypoints, given `position`.\n *\n * [Source](https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09)\n * @param position Current position\n * @param waypointA Start\n * @param waypointB End\n * @returns\n */\nexport declare const progressBetween: (position: Point | Point3d, waypointA: Point | Point3d, waypointB: Point | Point3d) => number;\n//# sourceMappingURL=progress-between.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Project `origin` by `distance` and `angle` (radians).\n *\n * To figure out rotation, imagine a horizontal line running through `origin`.\n * * Rotation = 0 deg puts the point on the right of origin, on same y-axis\n * * Rotation = 90 deg/3:00 puts the point below origin, on the same x-axis\n * * Rotation = 180 deg/6:00 puts the point on the left of origin on the same y-axis\n * * Rotation = 270 deg/12:00 puts the point above the origin, on the same x-axis\n *\n * ```js\n * // Yields a point 100 units away from 10,20 with 10 degrees rotation (ie slightly down)\n * const a = Points.project({x:10, y:20}, 100, degreeToRadian(10));\n * ```\n * @param origin\n * @param distance\n * @param angle\n * @returns\n */\nexport declare const project: (origin: Point, distance: number, angle: number) => {\n    x: number;\n    y: number;\n};\n//# sourceMappingURL=project.d.ts.map","import type { Point, Point3d } from './point-type.js';\nexport declare function quantiseEvery(pt: Point3d, snap: Point3d, middleRoundsUp?: boolean): Point3d;\nexport declare function quantiseEvery(pt: Point, snap: Point, middleRoundsUp?: boolean): Point;\n//# sourceMappingURL=quantise.d.ts.map","import { type RandomSource } from '@ixfx/random';\nimport type { Point, Point3d } from './point-type.js';\n/**\n * Returns a random 2D point on a 0..1 scale.\n * ```js\n * import { Points } from \"@ixfx/geometry.js\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"@ixfx/geometry.js\";\n * import { weightedSource } from \"@ixfx/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport declare const random: (rando?: RandomSource) => Point;\n/**\n * Returns a random 3D point on a 0..1 scale.\n * ```js\n * import { Points } from \"@ixfx/geometry\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"@ixfx/geometry\";\n * import { weightedSource } from \"@ixfx/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport declare const random3d: (rando?: RandomSource) => Point3d;\n//# sourceMappingURL=random.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Reduces over points, treating _x_ and _y_ separately.\n *\n * ```\n * // Sum x and y values\n * const total = Points.reduce(points, (p, acc) => {\n *  return {x: p.x + acc.x, y: p.y + acc.y}\n * });\n * ```\n * @param pts Points to reduce\n * @param fn Reducer\n * @param initial Initial value, uses `{ x:0, y:0 }` by default\n * @returns\n */\nexport declare const reduce: (pts: ReadonlyArray<Point>, fn: (p: Point, accumulated: Point) => Point, initial?: Point) => Point;\n//# sourceMappingURL=reduce.d.ts.map","import type { PointRelation } from \"./point-relation-types.js\";\nimport type { Point } from \"./point-type.js\";\n/**\n * Tracks the relation between two points.\n *\n * 1. Call `Points.relation` with the initial reference point\n * 2. You get back a function\n * 3. Call the function with a new point to compute relational information.\n *\n * It computes angle, average, centroid, distance and speed.\n *\n * ```js\n * // Reference point: 50,50\n * const t = Points.relation({x:50,y:50}); // t is a function\n *\n * // Invoke the returned function with a point\n * const relation = t({ x:0, y:0 }); // Juicy relational data\n * ```\n *\n * Or with destructuring:\n *\n * ```js\n * const { angle, distanceFromStart, distanceFromLast, average, centroid, speed } = t({ x:0,y:0 });\n * ```\n *\n * x & y coordinates can also be used as parameters:\n * ```js\n * const t = Points.relation(50, 50);\n * const result = t(0, 0);\n * // result.speed, result.angle ...\n * ```\n *\n * Note that intermediate values are not stored. It keeps the initial\n * and most-recent point. If you want to compute something over a set\n * of prior points, you may want to use {@link PointsTracker}\n * @param a Initial point, or x value\n * @param b y value, if first option is a number.\n * @returns\n */\nexport declare const relation: (a: Point | number, b?: number) => PointRelation;\n//# sourceMappingURL=relation.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Rotate a single point by a given amount in radians\n * @param pt\n * @param amountRadian\n * @param origin\n */\nexport declare function rotate(pt: Point, amountRadian: number, origin?: Point): Point;\n/**\n * Rotate several points by a given amount in radians\n * @param pt Points\n * @param amountRadian Amount to rotate in radians. If 0 is given, a copy of the input array is returned\n * @param origin Origin to rotate around. Defaults to 0,0\n */\nexport declare function rotate(pt: readonly Point[], amountRadian: number, origin?: Point): readonly Point[];\n//# sourceMappingURL=rotate.d.ts.map","export declare const rotatePointArray: (v: ReadonlyArray<ReadonlyArray<number>>, amountRadian: number) => Array<Array<number>>;\n//# sourceMappingURL=rotate-point-array.d.ts.map","import type { Point } from './point-type.js';\n/**\n * Round the point's _x_ and _y_ to given number of digits\n * @param ptOrX\n * @param yOrDigits\n * @param digits\n * @returns\n */\nexport declare const round: (ptOrX: Point | number, yOrDigits?: number, digits?: number) => Point;\n//# sourceMappingURL=round.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function subtract(a: Point, b: Point): Point;\nexport declare function subtract(a: Point3d, b: Point3d): Point3d;\nexport declare function subtract(a: Point, x: number, y: number): Point;\nexport declare function subtract(a: Point3d, x: number, y: number, z: number): Point3d;\nexport declare function subtract(ax: number, ay: number, bx: number, by: number): Point;\nexport declare function subtract(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n//# sourceMappingURL=subtract.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function sum(a: Point, b: Point): Point;\nexport declare function sum(a: Point3d, b: Point3d): Point3d;\nexport declare function sum(a: Point, x: number, y: number): Point;\nexport declare function sum(a: Point3d, x: number, y: number, z: number): Point3d;\nexport declare function sum(ax: number, ay: number, bx: number, by: number): Point;\nexport declare function sum(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n//# sourceMappingURL=sum.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\n/**\n * Returns a point with rounded x,y coordinates. By default uses `Math.round` to round.\n * ```js\n * toIntegerValues({x:1.234, y:5.567}); // Yields: {x:1, y:6}\n * ```\n *\n * ```js\n * toIntegerValues(pt, Math.ceil); // Use Math.ceil to round x,y of `pt`.\n * ```\n * @param pt Point to round\n * @param rounder Rounding function, or Math.round by default\n * @returns\n */\nexport declare const toIntegerValues: (pt: Point, rounder?: (x: number) => number) => Point;\n/**\n * Returns a copy of `pt` with `z` field omitted.\n * If it didn't have one to begin within, a copy is still returned.\n * @param pt\n * @returns\n */\nexport declare const to2d: (pt: Point) => Point;\n/**\n * Returns a copy of `pt` with a `z` field set.\n * Defaults to a z value of 0.\n * @param pt Point\n * @param z Z-value, defaults to 0\n * @returns\n */\nexport declare const to3d: (pt: Point, z?: number) => Point3d;\n/**\n * Returns a human-friendly string representation `(x, y)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport declare function toString(p: Point, digits?: number): string;\n//# sourceMappingURL=To.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns point as an array in the form [x,y]. This can be useful for some libraries\n * that expect points in array form.\n *\n * ```\n * const p = {x: 10, y:5};\n * const p2 = toArray(p); // yields [10,5]\n * ```\n * @param p\n * @returns\n */\nexport declare const toArray: (p: Point) => ReadonlyArray<number>;\n//# sourceMappingURL=to-array.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns true if two points are within a specified range on both axes.\n *\n * Provide a point for the range to set different x/y range, or pass a number\n * to use the same range for both axis.\n *\n * Note this simply compares x,y values it does not calcuate distance.\n *\n * @example\n * ```js\n * withinRange({x:100,y:100}, {x:101, y:101}, 1); // True\n * withinRange({x:100,y:100}, {x:105, y:101}, {x:5, y:1}); // True\n * withinRange({x:100,y:100}, {x:105, y:105}, {x:5, y:1}); // False - y axis too far\n * ```\n * @param a\n * @param b\n * @param maxRange\n * @returns\n */\nexport declare const withinRange: (a: Point, b: Point, maxRange: Point | number) => boolean;\n//# sourceMappingURL=within-range.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Wraps a point to be within `ptMin` and `ptMax`.\n * Note that max values are _exclusive_, meaning the return value will always be one less.\n *\n * Eg, if a view port is 100x100 pixels, wrapping the point 150,100 yields 50,99.\n *\n * ```js\n * // Wraps 150,100 to on 0,0 -100,100 range\n * wrap({x:150,y:100}, {x:100,y:100});\n * ```\n *\n * Wrap normalised point:\n * ```js\n * wrap({x:1.2, y:1.5}); // Yields: {x:0.2, y:0.5}\n * ```\n * @param pt Point to wrap\n * @param ptMax Maximum value, or `{ x:1, y:1 }` by default\n * @param ptMin Minimum value, or `{ x:0, y:0 }` by default\n * @returns Wrapped point\n */\nexport declare const wrap: (pt: Point, ptMax?: Point, ptMin?: Point) => Point;\n//# sourceMappingURL=wrap.d.ts.map","export * from './abs.js';\nexport * from './angle.js';\nexport * from './apply.js';\nexport * from './averager.js';\nexport * from './bbox.js';\nexport * from './centroid.js';\nexport * from './clamp.js';\nexport * from './compare.js';\nexport * from './convex-hull.js';\nexport * from './distance.js';\nexport * from './distance-to-center.js';\nexport * from './distance-to-exterior.js';\nexport * from './divider.js';\nexport * from './dot-product.js';\nexport * from './empty.js';\nexport * from './find-minimum.js';\nexport * from './from.js';\nexport * from './get-point-parameter.js';\nexport * from './guard.js';\nexport * from './interpolate.js';\nexport * from './invert.js';\nexport * from './is-equal.js';\nexport * from './magnitude.js';\nexport * from './most.js';\nexport * from './multiply.js';\nexport * from './normalise.js';\nexport * from './normalise-by-rect.js';\nexport * from './pipeline.js';\nexport * from './point-relation-types.js';\nexport * from './point-tracker.js';\nexport * from './point-type.js';\nexport * from './progress-between.js';\nexport * from './project.js';\nexport * from './quantise.js';\nexport * from './random.js';\nexport * from './reduce.js';\nexport * from './relation.js';\nexport * from './rotate.js';\nexport * from './rotate-point-array.js';\nexport * from './round.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './To.js';\nexport * from './to-array.js';\nexport * from './within-range.js';\nexport * from './wrap.js';\nexport type { Point, Point3d } from './point-type.js';\n//# sourceMappingURL=index.d.ts.map","import type { Rect } from \"./rect-types.js\";\n/**\n * Returns the area of `rect`\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.area(rect);\n * ```\n * @param rect\n * @returns\n */\nexport declare const area: (rect: Rect) => number;\n//# sourceMappingURL=area.d.ts.map","import type { RectPositioned, Rect } from \"./rect-types.js\";\n/**\n * An operation between two fields of a rectangle.\n * Used in the context of {@link applyMerge}\n * ```\n * // Multiply fields\n * const op = (a, b) => a*b;\n * ```\n */\nexport type ApplyMergeOp = (a: number, b: number) => number;\nexport type ApplyFieldOp = (fieldValue: number, fieldName?: `x` | `y` | `width` | `height`) => number;\nexport declare function applyFields(op: ApplyFieldOp, rect: RectPositioned): RectPositioned;\nexport declare function applyFields(op: ApplyFieldOp, rect: Rect): Rect;\nexport declare function applyFields(op: ApplyFieldOp, width: number, height: number): Rect;\nexport declare function applyMerge(op: ApplyMergeOp, rect: RectPositioned, width: number, height?: number): RectPositioned;\nexport declare function applyMerge(op: ApplyMergeOp, rect: Rect, width: number, height: number): Rect;\nexport declare function applyMerge(op: ApplyMergeOp, a: RectPositioned, b: Rect): RectPositioned;\nexport declare function applyMerge(op: ApplyMergeOp, a: Rect, b: Rect): Rect;\n/**\n * Uses `op` with `param` to width and height.\n * @param op\n * @param rect\n * @param parameter\n */\nexport declare function applyScalar(op: ApplyMergeOp, rect: Rect, parameter: number): Rect;\n/**\n * Uses `op` to apply with `param` to width, height, x & y.\n * Use `applyDim` to apply just to dimensions.\n * @param op\n * @param rect\n * @param parameter\n */\nexport declare function applyScalar(op: ApplyMergeOp, rect: RectPositioned, parameter: number): RectPositioned;\n/**\n * Applies `op` with `param` to `rect`'s width and height.\n * @param op\n * @param rect\n * @param parameter\n * @returns\n */\nexport declare function applyDim(op: ApplyMergeOp, rect: Rect | RectPositioned, parameter: number): Rect | RectPositioned;\n//# sourceMappingURL=apply.d.ts.map","import type { ISetMutable } from \"@ixfx/collections\";\nexport type GridVisual = Grid & {\n    readonly size: number;\n};\nexport type Grid = {\n    readonly rows: number;\n    readonly cols: number;\n};\nexport type GridCell = {\n    readonly x: number;\n    readonly y: number;\n};\nexport type GridNeighbours = {\n    readonly n: GridCell | undefined;\n    readonly e: GridCell | undefined;\n    readonly s: GridCell | undefined;\n    readonly w: GridCell | undefined;\n    readonly ne: GridCell | undefined;\n    readonly nw: GridCell | undefined;\n    readonly se: GridCell | undefined;\n    readonly sw: GridCell | undefined;\n};\nexport type GridCardinalDirection = `n` | `ne` | `e` | `se` | `s` | `sw` | `w` | `nw`;\nexport type GridCardinalDirectionOptional = GridCardinalDirection | ``;\nexport type GridArray1d<T> = GridReadable<T> & GridWritable<T> & {\n    array: T[];\n};\n/**\n * Bounds logic\n * * Unbounded: attempts to read beyond limits\n * * Undefined: returns _undefined_ when reading beyond limits\n * * Stop: returns cell value at edge of limits\n * * Wrap: Wrap-around cell positions\n *\n */\nexport type GridBoundsLogic = \n/**\n * Unbounded: attempts to read beyond limits\n */\n`unbounded` | \n/**\n * Undefined: returns _undefined_ when reading beyond limits\n */\n`undefined` | \n/**\n * Stop: returns cell value at edge of limits\n */\n`stop` | \n/**\n * Wrap-around cell positions\n */\n`wrap`;\n/**\n * Logic to select the next cell based on a list of neighbours\n */\nexport type GridNeighbourSelectionLogic = {\n    /**\n     * Returns neighbours for a given cell in a grid\n     */\n    readonly getNeighbours?: GridIdentifyNeighbours;\n    /**\n     * Select a neighbour from given list\n     */\n    readonly select: GridNeighbourSelector;\n};\nexport type GridVisitorOpts = Readonly<{\n    start: GridCell;\n    visited: ISetMutable<GridCell>;\n    reversed: boolean;\n    debug: boolean;\n    boundsWrap: GridBoundsLogic;\n}>;\nexport type GridCreateVisitor = (grid: Grid, opts?: Partial<GridVisitorOpts>) => Generator<GridCell>;\nexport type GridCellAndValue<T> = {\n    cell: GridCell;\n    value: T | undefined;\n};\nexport type GridNeighbourMaybe = readonly [keyof GridNeighbours, GridCell | undefined];\nexport type GridNeighbour = readonly [keyof GridNeighbours, GridCell];\n/**\n * A function that returns a value (or _undefined_) based on a _cell_\n *\n * Implementations:\n * * {@link Grids.Array1d.access}: For accessing a single-dimension array as a grid\n * * {@link Grids.Array2d.access}: For accessing a two-dimension array as a grid\n *\n */\nexport type GridCellAccessor<TValue> = (cell: GridCell, wrap?: GridBoundsLogic) => TValue | undefined;\n/**\n * A function that sets the value of a cell.\n */\nexport type GridCellSetter<TValue> = (value: TValue, cell: GridCell, wrap?: GridBoundsLogic) => void;\n/**\n * Shape of a grid and a function to read values from it, based on\n * cell location.\n *\n * These functions create a GridReadable:\n * * {@link Grids.Array1d.wrap}: wrap an array and read as a grid\n * * {@link Grids.Array1d.wrapMutable}: wrap and modify an array as a grid\n * * {@link Grids.Array2d.wrap}: wrap a two-dimensional grid\n * * {@link Grids.Array2d.wrapMutable}\n */\nexport type GridReadable<T> = Grid & {\n    get: GridCellAccessor<T>;\n};\nexport type GridWritable<T> = Grid & {\n    set: GridCellSetter<T>;\n};\n/**\n * Neighbour selector logic. For a given set of `neighbours` pick one to visit next.\n */\nexport type GridNeighbourSelector = (neighbours: readonly GridNeighbour[]) => GridNeighbour | undefined;\n/**\n * Identify neighbours logic. For a given `grid` and `origin`, return a list of neighbours\n */\nexport type GridIdentifyNeighbours = (grid: Grid, origin: GridCell) => readonly GridNeighbour[];\n//# sourceMappingURL=types.d.ts.map","import type { GridBoundsLogic, GridCell, Grid } from \"./types.js\";\n/**\n * Calculates a legal position for a cell based on\n * `grid` size and `bounds` wrapping logic.\n * @param grid\n * @param cell\n * @param wrap\n * @returns\n */\nexport declare const applyBounds: (grid: Grid, cell: GridCell, wrap?: GridBoundsLogic) => GridCell | undefined;\n//# sourceMappingURL=apply-bounds.d.ts.map","import type { GridCellAccessor, GridCell, GridBoundsLogic, Grid, GridCellSetter, GridArray1d } from \"./types.js\";\n/**\n * Returns a {@link GridCellAccessor} to get values from `array`\n * based on cell (`{x,y}`) coordinates.\n *\n * ```js\n * const arr = [\n *  1,2,3,\n *  4,5,6\n * ]\n * const a = access(arr, 3);\n * a({x:0,y:0});  // 1\n * a({x:2, y:2}); // 6\n * ```\n * @param array\n * @param cols\n * @returns\n */\nexport declare const access: <V>(array: readonly V[], cols: number) => GridCellAccessor<V>;\n/**\n * Returns a {@link GridCellSetter} that can mutate\n * array values based on cell {x,y} positions.\n * ```js\n * const arr = [\n *  1,2,3,\n *  4,5,6\n * ]\n * const a = setMutate(arr, 3);\n * a(10, {x:0,y:0});\n * a(20, {x:2, y:2});\n *\n * // Arr is now:\n * // [\n * //  10, 2, 3,\n * //  4, 5, 20\n * // ]\n * ```\n * @param array\n * @param cols\n * @returns\n */\nexport declare const setMutate: <V>(array: V[], cols: number) => GridCellSetter<V>;\nexport declare const set: <V>(array: readonly V[], cols: number) => (value: V, cell: GridCell, wrap: GridBoundsLogic) => V[];\n/**\n * Wraps `array` for grid access.\n * Mutable, meaning that `array` gets modified if `set` function is used.\n *\n * ```js\n * const g = wrapMutable(myArray, 5); // 5 columns wide\n * g.get({x:1,y:2});     // Get value at cell position\n * g.set(10, {x:1,y:2}); // Set value at cell position\n * g.array;              // Get reference to original passed-in array\n * ```\n *\n * Use {@link wrap} for an immutable version.\n *\n * @param array Array to wrap\n * @param cols Width of grid\n * @returns\n */\nexport declare const wrapMutable: <T>(array: T[], cols: number) => GridArray1d<T>;\n/**\n * Wraps `array` for grid access.\n * Immutable, such that underlying array is not modified and a\n * call to `set` returns a new `GridArray1d`.\n *\n * ```js\n * const myArray = [\n *    `a`, `b`, `c`,\n *    `d`, `e`, `f`\n * ];\n * let g = wrap(myArray, 3);  // 3 columns wide\n * g.get({ x:1, y:2 });          // Get value at cell position\n *\n * // Note that `set` returns a new instance\n * g = g.set(10, { x:1, y:2 });  // Set value at cell position\n * g.array;                      // Get reference to current array\n * ```\n *\n * Use {@link wrapMutable} to modify an array in-place\n * @param array Array to wrap\n * @param cols Width of grid\n * @returns\n */\nexport declare const wrap: <T>(array: T[], cols: number) => GridArray1d<T>;\n/**\n * Creates a 1-dimensional array to fit a grid of rows x cols.\n * Use {@link createArray} if you want to create this array and wrap it for grid access.\n *\n * ```js\n * // Creates an array filled with 0, sized for a grid 10 rows by 20 columns\n * const arr = createArray(0, 10, 20);\n *\n * // Alternatively, pass in a grid\n * const arr = createArray(0, { rows: 10, cols: 20 });\n * ```\n * @param rowsOrGrid Number of rows, or a grid to use the settings of\n * @param columns Columns\n */\nexport declare const createArray: <T>(initialValue: T, rowsOrGrid: number | Grid, columns?: number) => T[];\n/**\n * Creates a {@link GridArray1d} instance given the dimensions of the grid.\n * Use {@link createArray} if you just want to create an array sized for a grid.\n *\n * Behind the scenes, it runs:\n * ```js\n * const arr = createArray(initialValue, rows, cols);\n * return wrapMutable(arr, cols);\n * ```\n * @param initialValue\n * @param rowsOrGrid\n * @param columns\n * @returns\n */\nexport declare const createMutable: <T>(initialValue: T, rowsOrGrid: number | Grid, columns?: number) => GridArray1d<T>;\n//# sourceMappingURL=array-1d.d.ts.map","import type { GridBoundsLogic, GridCell, GridCellAccessor, GridCellSetter, Grid, GridReadable, GridWritable } from \"./types.js\";\nexport type ArrayGrid<T> = GridReadable<T> & GridWritable<T> & {\n    array: T[][];\n};\n/**\n * Create a grid from a 2-dimensional array.\n * ```js\n * const data = [\n *  [1,2,3],\n *  [4,5,6]\n * ]\n * const g = create(data);\n * // { rows: 2, cols: 3 }\n * ```\n * @param array\n * @returns\n */\nexport declare const create: <T>(array: ReadonlyArray<T[]> | Array<T[]>) => Grid;\nexport declare const setMutate: <V>(array: V[][]) => GridCellSetter<V>;\nexport declare const access: <T>(array: ReadonlyArray<T[]>) => GridCellAccessor<T>;\nexport declare const wrapMutable: <T>(array: T[][]) => ArrayGrid<T>;\nexport declare const set: <V>(array: readonly V[][]) => (value: V, cell: GridCell, wrap: GridBoundsLogic) => V[][];\n/**\n * Wraps `array` with two dimensions for grid access.\n * Immutable, such that underlying array is not modified and a\n * call to `set` returns a new `GridArray1d`.\n *\n * ```js\n * // Grid of rows: 2, cols: 3\n * const myArray = [\n *  [ `a`, `b`, `c` ],\n *  [ `d`, `e`, `f` ]\n * ]\n * let g = wrap(myArray);\n * g.get({x:1,y:2});          // Get value at cell position\n * g = g.set(10, {x:1,y:2}); // Set value at cell position\n * g.array;                  // Get reference to current array\n * ```\n *\n * Use {@link wrapMutable} to modify an array in-place\n * @param array Array to wrap\n * @returns\n */\nexport declare const wrap: <T>(array: T[][]) => ArrayGrid<T>;\n//# sourceMappingURL=array-2d.d.ts.map","import type { GridCell, Grid } from \"./types.js\";\n/**\n * Enumerate rows of grid, returning all the cells in the row\n * as an array\n *\n * ```js\n * for (const row of Grid.As.rows(shape)) {\n *  // row is an array of Cells.\n *  // [ {x:0, y:0}, {x:1, y:0} ... ]\n * }\n * ```\n *\n * Use `Grid.values` to convert the returned iterator into values:\n * ```js\n * for (const v of Grid.values(Grid.rows(shape))) {\n * }\n * ```\n * @param grid\n * @param start\n */\nexport declare const rows: (grid: Grid, start?: GridCell) => Generator<GridCell[], void, unknown>;\n/**\n * Enumerate columns of grid, returning all the cells in the\n * same column as an array.\n *\n * ```js\n * for (const col of Grid.As.columns(grid)) {\n * }\n * ```\n *\n * Use `Grid.values` to convert into values\n * ```js\n * for (const value of Grid.values(Grid.As.columns(grid))) {\n * }\n * ```\n * @param grid\n * @param start\n */\nexport declare function columns(grid: Grid, start?: GridCell): Generator<GridCell[], void, unknown>;\n//# sourceMappingURL=as.d.ts.map","import type { GridBoundsLogic, GridCardinalDirection, GridCardinalDirectionOptional, GridCell, Grid, GridNeighbours } from \"./types.js\";\n/**\n * Returns a list of all cardinal directions: n, ne, nw, e, s, se, sw, w\n */\nexport declare const allDirections: readonly GridCardinalDirection[];\n/**\n * Returns a list of + shaped directions: n, e, s, w\n */\nexport declare const crossDirections: readonly GridCardinalDirection[];\n/**\n * Returns cells that correspond to the cardinal directions at a specified distance\n * i.e. it projects a line from `start` cell in all cardinal directions and returns the cells at `steps` distance.\n * @param grid Grid\n * @param steps Distance\n * @param start Start poiint\n * @param bounds Logic for if bounds of grid are exceeded\n * @returns Cells corresponding to cardinals\n */\nexport declare const offsetCardinals: (grid: Grid, start: GridCell, steps: number, bounds?: GridBoundsLogic) => GridNeighbours;\n/**\n * Returns an `{ x, y }` signed vector corresponding to the provided cardinal direction.\n * ```js\n * const n = getVectorFromCardinal(`n`); // {x: 0, y: -1}\n * ```\n *\n * Optional `multiplier` can be applied to vector\n * ```js\n * const n = getVectorFromCardinal(`n`, 10); // {x: 0, y: -10}\n * ```\n *\n * Blank direction returns `{ x: 0, y: 0 }`\n * @param cardinal Direction\n * @param multiplier Multipler\n * @returns Signed vector in the form of `{ x, y }`\n */\nexport declare const getVectorFromCardinal: (cardinal: GridCardinalDirectionOptional, multiplier?: number) => GridCell;\n//# sourceMappingURL=directions.d.ts.map","import type { Grid, GridCell, GridCellAndValue, GridReadable } from \"../types.js\";\n/**\n * Enumerate all cell coordinates in an efficient manner.\n * Runs left-to-right, top-to-bottom.\n *\n * If end of grid is reached, behaviour depends on `wrap`:\n * * _true_ (default): iterator will wrap to ensure all are visited.\n * * _false_: iterator stops at end of grid\n *\n * ```js\n * import { Grids } from 'ixfx/geometry.js';\n *\n * // Enumerate each cell position, left-to-right, top-to-bottom\n * for (const cell of Grids.By.cells(grid)) {\n *  // cell will be { x, y }\n * }\n * ```\n *\n * See also:\n * * {@link cellValues}: Iterate over cell values\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid Grid to iterate over\n * @param start Starting cell position (default: {x:0,y:0})\n * @param wrap If true (default), iteration will wrap around through (0,0) when end of grid is reached.\n */\nexport declare function cells(grid: Grid, start?: GridCell, wrap?: boolean): Generator<{\n    x: number;\n    y: number;\n}, void, unknown>;\n/**\n * Yield all the values of a grid, left-to-right, top-to-bottom.\n *\n * This is just a wrapper around Grids.values:\n * ```js\n * yield* values(grid, cells(grid, start, wrap));\n * ```\n *\n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid\n * @param start\n * @param wrap\n */\nexport declare function cellValues<T>(grid: GridReadable<T>, start?: GridCell, wrap?: boolean): Generator<T, void, any>;\n/**\n * Yield all cell coordinates and values of a grid, left-to-right, top-to-bottom\n *\n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellValues}: Iterate over cell values\n * @param grid\n * @param start\n * @param wrap\n */\nexport declare function cellsAndValues<T>(grid: GridReadable<T>, start?: GridCell, wrap?: boolean): Generator<GridCellAndValue<T>>;\n//# sourceMappingURL=cells.d.ts.map","export * from './cells.js';\n//# sourceMappingURL=index.d.ts.map","import type { GridCell } from \"./types.js\";\n/**\n * Returns the cells on the line of `start` and `end`, inclusive\n *\n * ```js\n * // Get cells that connect 0,0 and 10,10\n * const cells = Grids.getLine({x:0,y:0}, {x:10,y:10});\n * ```\n *\n * This function does not handle wrapped coordinates.\n * @param start Starting cell\n * @param end End cell\n * @returns\n */\nexport declare const getLine: (start: GridCell, end: GridCell) => ReadonlyArray<GridCell>;\n/**\n * Returns a list of cells from `start` to `end`.\n *\n * Throws an error if start and end are not on same row or column.\n *\n * @param start Start cell\n * @param end end clel\n * @param endInclusive\n * @return Array of cells\n */\nexport declare const simpleLine: (start: GridCell, end: GridCell, endInclusive?: boolean) => ReadonlyArray<GridCell>;\n//# sourceMappingURL=geometry.d.ts.map","import type { GridCell, Grid } from \"./types.js\";\n/**\n * Returns true if `cell` parameter is a cell with x,y fields.\n * Does not check validity of fields.\n *\n * @param cell\n * @return True if parameter is a cell\n */\nexport declare const isCell: (cell: GridCell | undefined) => cell is GridCell;\n/**\n * Throws an exception if any of the cell's parameters are invalid\n * @private\n * @param cell\n * @param parameterName\n * @param grid\n */\nexport declare const guardCell: (cell: GridCell, parameterName?: string, grid?: Grid) => void;\n/**\n * Throws an exception if any of the grid's parameters are invalid\n * @param grid\n * @param parameterName\n */\nexport declare const guardGrid: (grid: Grid, parameterName?: string) => void;\n//# sourceMappingURL=guards.d.ts.map","import type { Grid, GridCell, GridBoundsLogic } from \"./types.js\";\n/**\n * Returns the index for a given cell.\n * This is useful if a grid is stored in an array.\n *\n * ```js\n * const data = [\n *  1, 2,\n *  3, 4,\n *  5, 6 ];\n * const cols = 2; // Grid of 2 columns wide\n * const index = indexFromCell(cols, {x: 1, y: 1});\n * // Yields an index of 3\n * console.log(data[index]); // Yields 4\n * ```\n *\n * Bounds logic is applied to cell.x/y separately. Wrapping\n * only ever happens in same col/row.\n * @see cellFromIndex\n * @param grid Grid\n * @param cell Cell to get index for\n * @param wrap Logic for if we hit bounds of grid\n * @returns\n */\nexport declare const indexFromCell: (grid: Grid, cell: GridCell, wrap: GridBoundsLogic) => number | undefined;\n/**\n * Returns x,y from an array index.\n *\n * ```js\n *  const data = [\n *   1, 2,\n *   3, 4,\n *   5, 6 ];\n *\n * // Cols of 2, index 2 (ie. data[2] == 3)\n * const cell = cellFromIndex(2, 2);\n * // Yields: {x: 0, y: 1}\n * ```\n * @see indexFromCell\n * @param colsOrGrid\n * @param index\n * @returns\n */\nexport declare const cellFromIndex: (colsOrGrid: number | Grid, index: number) => GridCell;\n//# sourceMappingURL=indexing.d.ts.map","import type { Grid, GridCell } from \"./types.js\";\n/**\n * Returns _true_ if cell coordinates are above zero and within bounds of grid\n *\n * @param grid\n * @param cell\n * @return\n */\nexport declare const inside: (grid: Grid, cell: GridCell) => boolean;\n//# sourceMappingURL=inside.d.ts.map","import type { GridCell, Grid, GridVisual } from \"./types.js\";\n/**\n * Returns _true_ if grids `a` and `b` are equal in value.\n * Returns _false_ if either parameter is undefined.\n *\n * @param a\n * @param b\n * @return\n */\nexport declare const isEqual: (a: Grid | GridVisual, b: Grid | GridVisual) => boolean;\n/**\n * Returns _true_ if two cells equal.\n * Returns _false_ if either cell are undefined\n *\n * @param a\n * @param b\n * @returns\n */\nexport declare const cellEquals: (a: GridCell | undefined, b: GridCell | undefined) => boolean;\n//# sourceMappingURL=is-equal.d.ts.map","import type { GridBoundsLogic, GridCardinalDirection, GridCell, Grid, GridNeighbour, GridNeighbours } from \"./types.js\";\nexport declare const randomNeighbour: (nbos: readonly GridNeighbour[]) => GridNeighbour;\n/**\n * Gets a list of neighbours for `cell` (using {@link neighbours}), filtering\n * results to only those that are valid neighbours (using {@link isNeighbour})\n *\n * ```js\n * // Get all eight surrounding cells\n * const n = Grids.neighbourList(grid, cell, Grids.allDirections);\n *\n * // Get north, east, south, west cells\n * const n = Grids.neighbourList(grid, cell, Grids.crossDirections);\n * ```\n * @param grid Grid\n * @param cell Cell\n * @param directions Directions\n * @param bounds Bounds\n * @returns\n */\nexport declare const neighbourList: (grid: Grid, cell: GridCell, directions: readonly GridCardinalDirection[], bounds: GridBoundsLogic) => readonly GridNeighbour[];\n/**\n * Returns neighbours for a cell. If no `directions` are provided, it defaults to {@link allDirections}.\n *\n * ```js\n * const grid = { rows: 5, cols: 5 };\n * const cell = { x:2, y:2 };\n *\n * // Get n,ne,nw,e,s,se,sw and w neighbours\n * const n = Grids.neighbours(grid, cell, `wrap`);\n *\n * Yields:\n * {\n *  n: {x: 2, y: 1}\n *  s: {x: 2, y: 3}\n *  ....\n * }\n * ```\n *\n * Returns neighbours without diagonals (ie: n, e, s, w):\n * ```js\n * const n = Grids.neighbours(grid, cell, `stop`, Grids.crossDirections);\n * ```\n * @returns Returns a map of cells, keyed by cardinal direction\n * @param grid Grid\n * @param cell Cell\n * @param bounds How to handle edges of grid\n * @param directions Directions to return\n */\nexport declare const neighbours: (grid: Grid, cell: GridCell, bounds?: GridBoundsLogic, directions?: readonly GridCardinalDirection[]) => GridNeighbours;\n//# sourceMappingURL=neighbour.d.ts.map","import type { Grid, GridCell, GridBoundsLogic } from './types.js';\n/**\n * Returns a coordinate offset from `start` by `vector` amount.\n *\n * Different behaviour can be specified for how to handle when coordinates exceed the bounds of the grid\n *\n * Note: x and y wrapping are calculated independently. A large wrapping of x, for example won't shift up/down a line.\n *\n * Use {@link Grids.applyBounds} if you need to calculate a wrapped coordinate without adding two together.\n * @param grid Grid to traverse\n * @param vector Offset in x/y\n * @param start Start point\n * @param bounds\n * @returns Cell\n */\nexport declare const offset: (grid: Grid, start: GridCell, vector: GridCell, bounds?: GridBoundsLogic) => GridCell | undefined;\n//# sourceMappingURL=offset.d.ts.map","/**\n * Returns a two-dimensional array according to `grid`\n * size.\n *\n * ```js\n * const a = Grids.toArray({ rows: 3, cols: 2 });\n * Yields:\n * [ [_,_] ]\n * [ [_,_] ]\n * [ [_,_] ]\n * ```\n *\n * `initialValue` can be provided to set the value\n * for all cells.\n * @param grid Grid\n * @param initialValue Initial value\n * @returns\n */\nimport type { Grid } from \"./types.js\";\nexport declare const toArray2d: <V>(grid: Grid, initialValue?: V) => V[][];\n//# sourceMappingURL=to-array.d.ts.map","import type { GridCell } from \"./types.js\";\n/**\n * Returns a key string for a cell instance\n * A key string allows comparison of instances by value rather than reference\n *\n * ```js\n * cellKeyString({x:10,y:20});\n * // Yields: \"Cell{10,20}\";\n * ```\n * @param v\n * @returns\n */\nexport declare const cellKeyString: (v: GridCell) => string;\n//# sourceMappingURL=to-string.d.ts.map","import type { RectPositioned } from \"../rect/rect-types.js\";\nimport type { GridCell, GridVisual } from \"./types.js\";\nimport type { Point } from \"../point/point-type.js\";\n/**\n * Generator that returns rectangles for each cell in a grid\n *\n * @example Draw rectangles\n * ```js\n * import { Drawing } from 'visuals.js'\n * const rects = [...Grids.asRectangles(grid)];\n * Drawing.rect(ctx, rects, { strokeStyle: `silver`});\n * ```\n * @param grid\n */\nexport declare function asRectangles(grid: GridVisual): IterableIterator<RectPositioned>;\n/**\n * Returns the cell at a specified visual coordinate\n * or _undefined_ if the position is outside of the grid.\n *\n * `position` must be in same coordinate/scale as the grid.\n *\n * @param position Position, eg in pixels\n * @param grid Grid\n * @return Cell at position or undefined if outside of the grid\n */\nexport declare const cellAtPoint: (grid: GridVisual, position: Point) => GridCell | undefined;\n/**\n * Returns a visual rectangle of the cell, positioned from the top-left corner\n *\n * ```js\n * const cell = { x: 1, y: 0 };\n *\n * // 5x5 grid, each cell 5px in size\n * const grid = { rows: 5, cols: 5, size: 5 }\n *\n * const r = rectangleForCell(grid, cell,);\n *\n * // Yields: { x: 5, y: 0, width: 5, height: 5 }\n * ```\n * @param cell\n * @param grid\n * @return\n */\nexport declare const rectangleForCell: (grid: GridVisual, cell: GridCell) => RectPositioned;\n/**\n * Returns the visual midpoint of a cell (eg. pixel coordinate)\n *\n * @param cell\n * @param grid\n * @return\n */\nexport declare const cellMiddle: (grid: GridVisual, cell: GridCell) => Point;\n//# sourceMappingURL=visual.d.ts.map","import type { GridReadable, GridCell } from \"./types.js\";\nexport declare function values<T>(grid: GridReadable<T>, iter: Iterable<GridCell>): Generator<T>;\nexport declare function values<T>(grid: GridReadable<T>, iter: Iterable<GridCell[]>): Generator<T[]>;\n//# sourceMappingURL=values.d.ts.map","import type { GridNeighbourSelectionLogic } from \"../types.js\";\nexport declare const breadthLogic: () => GridNeighbourSelectionLogic;\n//# sourceMappingURL=breadth.d.ts.map","import type { GridNeighbourSelectionLogic } from \"../types.js\";\nexport declare const neighboursLogic: () => GridNeighbourSelectionLogic;\n//# sourceMappingURL=cell-neighbours.d.ts.map","import type { GridNeighbourSelectionLogic, GridVisitorOpts } from \"../types.js\";\n/**\n * Visits cells running down columns, left-to-right.\n * @param opts Options\n * @returns Visitor generator\n */\nexport declare const columnLogic: (opts?: Partial<GridVisitorOpts>) => GridNeighbourSelectionLogic;\n//# sourceMappingURL=columns.d.ts.map","import type { GridNeighbourSelectionLogic } from \"../types.js\";\nexport declare const depthLogic: () => GridNeighbourSelectionLogic;\n//# sourceMappingURL=depth.d.ts.map","import type { Grid, GridCell, GridCreateVisitor } from \"../types.js\";\n/**\n * Runs the provided `visitor` for `steps`, returning the cell we end at\n * ```js\n * // Create visitor & stepper\n * const visitor = Grids.Visit.create(`row`);\n * const stepper = Grids.Visit.stepper(grid, visitor);\n *\n * // Step by 10\n * stepper(10); // GridCell {x,y}\n *\n * // Step by another 2\n * stepper(2);\n * ```\n * @param grid Grid to traverse\n * @param start Start point\n * @param createVisitor Visitor function\n * @returns\n */\nexport declare const stepper: (grid: Grid, createVisitor: GridCreateVisitor, start?: GridCell, resolution?: number) => (step: number, fromStart?: boolean) => GridCell | undefined;\n//# sourceMappingURL=step.d.ts.map","import type { GridNeighbourSelectionLogic } from \"../types.js\";\nexport declare const randomLogic: () => GridNeighbourSelectionLogic;\n//# sourceMappingURL=random.d.ts.map","import type { GridNeighbourSelectionLogic } from \"../types.js\";\nexport declare const randomContiguousLogic: () => GridNeighbourSelectionLogic;\n//# sourceMappingURL=random-contiguous.d.ts.map","import type { GridNeighbourSelectionLogic, GridVisitorOpts } from \"../types.js\";\n/**\n* Visit by following rows. Normal order is left-to-right, top-to-bottom.\n* @param opts Options\n* @returns\n*/\nexport declare const rowLogic: (opts?: Partial<GridVisitorOpts>) => GridNeighbourSelectionLogic;\n//# sourceMappingURL=rows.d.ts.map","import type { GridNeighbourSelectionLogic, Grid, GridCell, GridVisitorOpts } from \"../types.js\";\n/**\n * Visits every cell in grid using supplied selection function\n * In-built functions to use: visitorDepth, visitorBreadth, visitorRandom,\n * visitorColumn, visitorRow.\n *\n * Usage example:\n * ```js\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell);\n *  for (let cell of visitor) {\n *   // do something with cell\n *  }\n * ```\n *\n * If you want to keep tabs on the visitor, pass in a @ixfx/collections.Sets.ISetMutable instance. This gets\n * updated as cells are visited to make sure we don't visit the same one twice. If a set is not passed\n * in, one will be created internally.\n * ```js\n * let visited = new SetStringMutable<Grids.Cell>(c => Grids.cellKeyString(c));\n * let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell, visited);\n * ```\n *\n * To visit with some delay, try this pattern\n * ```js\n *  const delayMs = 100;\n *  const run = () => {\n *   let cell = visitor.next().value;\n *   if (cell === undefined) return;\n *   // Do something with cell\n *   setTimeout(run, delayMs);\n *  }\n *  setTimeout(run, delayMs);\n * ```\n * @param logic Logic for selecting next cell\n * @param grid Grid to visitl\n * @param opts Options\n * @returns Cells\n */\nexport declare function visitByNeighbours(logic: GridNeighbourSelectionLogic, grid: Grid, opts?: Partial<GridVisitorOpts>): Generator<GridCell>;\n//# sourceMappingURL=visitor.d.ts.map","import type { GridCell, Grid, GridNeighbourSelectionLogic, GridVisitorOpts } from '../types.js';\nexport * from './breadth.js';\nexport * from './cell-neighbours.js';\nexport * from './columns.js';\nexport * from './depth.js';\nexport * from './step.js';\nexport * from './random.js';\nexport * from './random-contiguous.js';\nexport * from './rows.js';\nexport * from './visitor.js';\nexport type VisitorTypes = `row` | `column` | `neighbours` | `breadth` | `depth` | `random` | `random-contiguous`;\n/**\n * Logic types:\n * * 'row': left-to-right, top-to-bottom\n * * 'column': top-to-bottom, left-to-right\n * * 'neighbours': neighbours surrounding cell (eight)\n * * 'breadth`: breadth-first\n * * 'depth': depth-first\n * * 'random': any random cell in grid\n * * 'random-contiguous': any random cell neighbouring an already visited cell\n * @param type\n * @param opts\n * @returns\n */\nexport declare const create: (type: VisitorTypes, opts?: Partial<GridVisitorOpts>) => (grid: Grid, optionsOverride?: Partial<GridVisitorOpts>) => Generator<GridCell, any, any>;\nexport declare const withLogic: (logic: GridNeighbourSelectionLogic, options?: Partial<GridVisitorOpts>) => (grid: Grid, optionsOverride?: Partial<GridVisitorOpts>) => Generator<GridCell, any, any>;\n//# sourceMappingURL=index.d.ts.map","export * from './apply-bounds.js';\nexport * as Array1d from './array-1d.js';\nexport * as Array2d from './array-2d.js';\n/**\n * Iterates over slices of the grid (eg a whole row, a whole column)\n */\nexport * as As from './as.js';\nexport * from './directions.js';\nexport * as By from './enumerators/index.js';\nexport * from './geometry.js';\nexport * from './guards.js';\nexport * from './indexing.js';\nexport * from './inside.js';\nexport * from './is-equal.js';\nexport * from './neighbour.js';\nexport * from './offset.js';\nexport * from './to-array.js';\nexport * from './to-string.js';\nexport type * from './types.js';\nexport * from './visual.js';\nexport * from './values.js';\nexport * as Visit from './visitors/index.js';\n//# sourceMappingURL=index.d.ts.map","import type { RectPositioned } from \"./rect-types.js\";\nimport type { GridCardinalDirection } from '../grid/index.js';\nimport type { Point } from \"../point/point-type.js\";\n/**\n * Returns a point on cardinal direction, or 'center' for the middle.\n *\n * ```js\n * cardinal({x: 10, y:10, width:100, height: 20}, 'center');\n * ```\n * @param rect Rectangle\n * @param card Cardinal direction or 'center'\n * @returns Point\n */\nexport declare const cardinal: (rect: RectPositioned, card: GridCardinalDirection | `center`) => Point;\n//# sourceMappingURL=cardinal.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n/**\n * Perform basic point translation using a rectangle where its center is the origin.\n *\n * Thus the relative coordinate { x: 0, y: 0} corresponds to the absolute middle of the\n * rectangle.\n *\n * The relative coordinate { x: -1, y: -1 } corresponds to the rectangle's {x,y} properties, and so on.\n * @param rectAbsolute\n * @returns\n */\nexport declare const centerOrigin: (rectAbsolute: RectPositioned) => {\n    relativeToAbsolute: (point: Point) => {\n        x: number;\n        y: number;\n        z?: number;\n    };\n    absoluteToRelative: (point: Point) => {\n        x: number;\n        y: number;\n        z?: number;\n    };\n};\n//# sourceMappingURL=center-origin.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Returns the center of a rectangle as a {@link Point}.\n *  If the rectangle lacks a position and `origin` parameter is not provided, 0,0 is used instead.\n *\n * ```js\n * const p = Rects.center({x:10, y:20, width:100, height:50});\n * const p2 = Rects.center({width: 100, height: 50}); // Assumes 0,0 for rect x,y\n * ```\n * @param rect Rectangle\n * @param origin Optional origin. Overrides `rect` position if available. If no position is available 0,0 is used by default.\n * @returns\n */\nexport declare const center: (rect: RectPositioned | Rect, origin?: Point) => Point;\n//# sourceMappingURL=center.d.ts.map","import { type Point } from \"../point/point-type.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Returns the four corners of a rectangle as an array of Points.\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 0, y: 0};\n * const pts = Rects.corners(rect);\n * ```\n *\n * If the rectangle is not positioned, is origin can be provided.\n * Order of corners: ne, nw, sw, se\n * @param rect\n * @param origin\n * @returns\n */\nexport declare const corners: (rect: RectPositioned | Rect, origin?: Point) => readonly Point[];\n//# sourceMappingURL=corners.d.ts.map","import type { RectPositioned } from \"./rect-types.js\";\nimport { type Point } from '../point/point-type.js';\n/**\n * Returns the distance from the perimeter of `rect` to `pt`.\n * If the point is within the rectangle, 0 is returned.\n *\n * If `rect` does not have an x,y it's assumed to be 0,0\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromExterior(rect, { x: 20, y: 20 });\n * ```\n * @param rect Rectangle\n * @param pt Point\n * @returns Distance\n */\nexport declare const distanceFromExterior: (rect: RectPositioned, pt: Point) => number;\n/**\n * Return the distance of `pt` to the center of `rect`.\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromCenter(rect, { x: 20, y: 20 });\n * ```\n * @param rect\n * @param pt\n * @returns\n */\nexport declare const distanceFromCenter: (rect: RectPositioned, pt: Point) => number;\n//# sourceMappingURL=distance.d.ts.map","import type { RectPositioned, Rect } from \"./rect-types.js\";\n/**\n * Divides positioned `rect` by width/height. Useful for normalising a value.\n * x & y value of second parameter are ignored\n * ```js\n * // Normalise based on window size\n * const r = { x: 10, y: 200, width: 100, height: 30 };\n * const rr = Rects.divide(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Division applies to the first parameter's x/y fields. X is affected by `width`, Y is affected by `height`.\n */\nexport declare function divide(rect: RectPositioned, width: number, height?: number): RectPositioned;\n/**\n * Divides `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * // Normalise based on window size\n * const r = { width: 100, height: 30 };\n * const rr = Rects.divide(r, window.innerWidth, window.innerHeight);\n * ```\n *\n */\nexport declare function divide(rect: Rect, width: number, height: number): Rect;\n/**\n * Divides positioned rect `a` by width and height of rect `b`.\n * ```js\n * // Returns { ...a, width: a.width / b.width, height: a.height/b.height, x: a.x / b.width, y: a.y / b.height }\n * Rects.divide(a, b);\n * ```\n *\n * @param a\n * @param b\n */\nexport declare function divide(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n/**\n * Divides rect `a` by width and height of rect `b`.\n *\n * ```js\n * // Returns {...a, width: a.width / b.width, height: a.height/b.height }\n * Rects.divide(a, b);\n * ```\n *\n * @param a\n * @param b\n */\nexport declare function divide(a: Rect, b: Rect): Rect;\n/**\n * Divides all components of `rect` by `amount`.\n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport declare function divideScalar(rect: Rect, amount: number): Rect;\n/**\n * Divides all components of `rect` by `amount`.\n * This includes x,y if present.\n *\n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * divideScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 0.5, y: 1, width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport declare function divideScalar(rect: RectPositioned, amount: number): RectPositioned;\nexport declare function divideDim(rect: Rect | RectPositioned, amount: number): Rect | RectPositioned;\n//# sourceMappingURL=divide.d.ts.map","import type { Rect, RectPositioned } from \"./rect-types.js\";\nimport type { Point } from '../point/point-type.js';\nimport type { Line } from \"../line/line-type.js\";\n/**\n * Returns four lines based on each corner.\n * Lines are given in order: top, right, bottom, left\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lines = Rects.lines(rect);\n * ```\n *\n * @param {(RectPositioned|Rect)} rect\n * @param {Points.Point} [origin]\n * @returns {Lines.Line[]}\n */\nexport declare const edges: (rect: RectPositioned | Rect, origin?: Point) => readonly Line[];\n/**\n * Returns a point on the edge of rectangle\n * ```js\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeX(r1, `right`);  // Yields: 110\n * Rects.getEdgeX(r1, `bottom`); // Yields: 10\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeX(r2, `right`);  // Yields: 100\n * Rects.getEdgeX(r2, `bottom`); // Yields: 0\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport declare const getEdgeX: (rect: RectPositioned | Rect, edge: `right` | `bottom` | `left` | `top`) => number;\n/**\n * Returns a point on the edge of rectangle\n *\n * ```js\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeY(r1, `right`);  // Yields: 10\n * Rects.getEdgeY(r1, `bottom`); // Yields: 60\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeY(r2, `right`);  // Yields: 0\n * Rects.getEdgeY(r2, `bottom`); // Yields: 50\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport declare const getEdgeY: (rect: RectPositioned | Rect, edge: `right` | `bottom` | `left` | `top`) => number;\n//# sourceMappingURL=edges.d.ts.map","export declare const Empty: Readonly<{\n    width: 0;\n    height: 0;\n}>;\nexport declare const EmptyPositioned: Readonly<{\n    x: 0;\n    y: 0;\n    width: 0;\n    height: 0;\n}>;\n//# sourceMappingURL=empty.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n/**\n * Returns a copy of `rect` with `rect` resized so it also encompasses `points`.\n * If provided point(s) are within bounds of `rect`, a copy of `rect` is returned.\n * @param rect\n * @param points\n * @returns\n */\nexport declare const encompass: (rect: RectPositioned, ...points: Point[]) => RectPositioned;\n//# sourceMappingURL=encompass.d.ts.map","import { type RectPositioned } from \"./rect-types.js\";\nimport type { Point } from \"../point/point-type.js\";\n/**\n * Initialises a rectangle based on its center, a width and height\n *\n * ```js\n * // Rectangle with center at 50,50, width 100 height 200\n * Rects.fromCenter({x: 50, y:50}, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport declare const fromCenter: (origin: Point, width: number, height: number) => RectPositioned;\n//# sourceMappingURL=from-center.d.ts.map","import type { Rect } from \"./rect-types.js\";\n/**\n * Initialise a rectangle based on the width and height of a HTML element.\n *\n * ```js\n * Rects.fromElement(document.querySelector(`body`));\n * ```\n * @param el\n * @returns\n */\nexport declare const fromElement: (el: HTMLElement) => Rect;\n//# sourceMappingURL=from-element.d.ts.map","import type { RectPositioned, Rect } from \"./rect-types.js\";\n/**\n * Returns a rectangle from width, height\n * ```js\n * const r = Rects.fromNumbers(100, 200);\n * // {width: 100, height: 200}\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @param width\n * @param height\n */\nexport declare function fromNumbers(width: number, height: number): Rect;\n/**\n * Returns a rectangle from x,y,width,height\n *\n * ```js\n * const r = Rects.fromNumbers(10, 20, 100, 200);\n * // {x: 10, y: 20, width: 100, height: 200}\n * ```\n *\n * Use the spread operator (...) if the source is an array:\n * ```js\n * const r3 = Rects.fromNumbers(...[10, 20, 100, 200]);\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport declare function fromNumbers(x: number, y: number, width: number, height: number): RectPositioned;\n//# sourceMappingURL=from-numbers.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n/**\n * Creates a rectangle from its top-left coordinate, a width and height.\n *\n * ```js\n * // Rectangle at 50,50 with width of 100, height of 200.\n * const rect = Rects.fromTopLeft({ x: 50, y:50 }, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport declare const fromTopLeft: (origin: Point, width: number, height: number) => RectPositioned;\n//# sourceMappingURL=from-top-left.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Accepts:\n * * x,y,w,h\n * * x,y,rect\n * * point,rect\n * * RectPositioned\n * * Rect, x,y\n * * Rect, Point\n * @param a\n * @param b\n * @param c\n * @param d\n * @returns\n */\nexport declare function getRectPositionedParameter(a: number | Point | Rect | RectPositioned, b?: Rect | number | Point, c?: number | Rect, d?: number): RectPositioned;\n//# sourceMappingURL=get-rect-positionedparameter.d.ts.map","import type { RectPositioned, Rect } from \"./rect-types.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Throws an error if the dimensions of the rectangle are undefined, NaN or negative.\n * @param d\n * @param name\n */\nexport declare const guardDim: (d: number, name?: string) => void;\n/**\n * Throws an error if rectangle is missing fields or they\n * are not valid.\n *\n * Checks:\n * * `width` and `height` must be defined on `rect`\n * * dimensions (w & h) must not be NaN\n * * dimensions (w & h) must not be negative\n *\n * If `rect` has x,y, this value is checked as well.\n * @param rect\n * @param name\n */\nexport declare const guard: (rect: Rect, name?: string) => void;\n/**\n * Returns a positioned rect or if it's not possible, throws an error.\n *\n * If `rect` does not have a position, `origin` is used.\n * If `rect` is positioned and `origin` is provided, returned result uses `origin` as x,y instead.\n * ```js\n * // Returns input because it's positioned\n * getRectPositioned({ x:1, y:2, width:10, height:20 });\n *\n * // Returns { x:1, y:2, width:10, height:20 }\n * getRectPositioned({ width:10, height:20 }, { x:1, y:2 });\n *\n * // Throws, because we have no point\n * getRectPositioned({width:10,height:20})\n * ```\n * @param rect\n * @param origin\n * @returns\n */\nexport declare const getRectPositioned: (rect: Rect | RectPositioned, origin?: Point) => RectPositioned;\n/**\n * Throws an error if `rect` is does not have a position, or\n * is an invalid rectangle\n * @param rect\n * @param name\n */\nexport declare const guardPositioned: (rect: RectPositioned, name?: string) => void;\n/**\n * Returns _true_ if `rect` has width and height values of 0.\n * Use Rects.Empty or Rects.EmptyPositioned to generate an empty rectangle.\n * @param rect\n * @returns\n */\nexport declare const isEmpty: (rect: Rect) => boolean;\n/**\n * Returns _true_ if `rect` is a placeholder, with both width and height values of NaN.\n * Use Rects.Placeholder or Rects.PlaceholderPositioned to generate a placeholder.\n * @param rect\n * @returns\n */\nexport declare const isPlaceholder: (rect: Rect) => boolean;\n/**\n * Returns _true_ if `rect` has position (x,y) fields.\n * @param rect Point, Rect or RectPositiond\n * @returns\n */\nexport declare const isPositioned: (rect: Point | Rect | RectPositioned) => rect is Point;\n/**\n * Returns _true_ if `rect` has width and height fields.\n * @param rect\n * @returns\n */\nexport declare const isRect: (rect: unknown) => rect is Rect;\n/**\n * Returns _true_ if `rect` is a positioned rectangle\n * Having width, height, x and y properties.\n * @param rect\n * @returns\n */\nexport declare const isRectPositioned: (rect: any) => rect is RectPositioned;\n//# sourceMappingURL=guard.d.ts.map","import type { Rect, RectPositioned } from \"./rect-types.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { CirclePositioned } from \"../circle/circle-type.js\";\n/**\n * Returns _true_ if `point` is within, or on boundary of `rect`.\n *\n * ```js\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * ```\n * @param rect\n * @param point\n */\nexport declare function intersectsPoint(rect: Rect | RectPositioned, point: Point): boolean;\n/**\n * Returns true if x,y coordinate is within, or on boundary of `rect`.\n * ```js\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param x\n * @param y\n */\nexport declare function intersectsPoint(rect: Rect | RectPositioned, x: number, y: number): boolean;\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A rectangle can be checked for intersections with another RectPositioned, CirclePositioned or Point.\n *\n */\nexport declare const isIntersecting: (a: RectPositioned, b: CirclePositioned | Point) => boolean;\n//# sourceMappingURL=Intersects.d.ts.map","import type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Returns _true_ if the width & height of the two rectangles is the same.\n *\n * ```js\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const isEqualSize: (a: Rect, b: Rect) => boolean;\n/**\n * Returns _true_ if two rectangles have identical values.\n * Both rectangles must be positioned or not.\n *\n * ```js\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const isEqual: (a: Rect | RectPositioned, b: Rect | RectPositioned) => boolean;\n//# sourceMappingURL=is-equal.d.ts.map","import type { RectPositioned } from './rect-types.js';\n/**\n * Returns the length of each side of the rectangle (top, right, bottom, left)\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lengths = Rects.lengths(rect);\n * ```\n * @param rect\n * @returns\n */\nexport declare const lengths: (rect: RectPositioned) => readonly number[];\n//# sourceMappingURL=lengths.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n/**\n * Returns a rectangle based on provided four corners.\n *\n * To create a rectangle that contains an arbitary set of points, use {@link Points.bbox}.\n *\n * Does some sanity checking such as:\n *  - x will be smallest of topLeft/bottomLeft\n *  - y will be smallest of topRight/topLeft\n *  - width will be largest between top/bottom left and right\n *  - height will be largest between left and right top/bottom\n *\n */\nexport declare const maxFromCorners: (topLeft: Point, topRight: Point, bottomRight: Point, bottomLeft: Point) => RectPositioned;\n//# sourceMappingURL=max.d.ts.map","import type { RectPositioned, Rect } from \"./rect-types.js\";\n/**\n * Multiplies positioned `rect` by width/height. Useful for denormalising a value.\n * x/y value of second parameter are ignored.\n * ```js\n * // Normalised rectangle\n * const r = { x:0.5, y:0.5, width: 0.5, height: 0.5};\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields.\n */\nexport declare function multiply(rect: RectPositioned, width: number, height?: number): RectPositioned;\n/**\n * Multiplies `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * // Normalised rectangle of width 50%, height 50%\n * const r = { width: 0.5, height: 0.5 };\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields, if present.\n */\nexport declare function multiply(rect: Rect, width: number, height: number): Rect;\n/**\n * Multiplies positioned rect `a` by width and height of rect `b`.\n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n * ```\n *\n * @param a\n * @param b\n */\nexport declare function multiply(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n/**\n * Multiplies rect `a` by width and height of rect `b`.\n *\n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n * ```\n *\n * @param a\n * @param b\n */\nexport declare function multiply(a: Rect, b: Rect): Rect;\n/**\n * Multiplies all components of `rect` by `amount`.\n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * ```\n * @param rect\n * @param amount\n */\nexport declare function multiplyScalar(rect: Rect, amount: number): Rect;\n/**\n * Multiplies all components of `rect` by `amount`.\n * This includes x,y if present.\n *\n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * multiplyScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 2, y: 4, width:20, height: 40 }\n * ```\n * @param rect\n * @param amount\n */\nexport declare function multiplyScalar(rect: RectPositioned, amount: number): RectPositioned;\n/**\n * Multiplies only the width/height of `rect`, leaving `x` and `y` as they are.\n * ```js\n * multiplyDim({ x:1,y:2,width:3,height:4 }, 2);\n * // Yields: { x:1, y:2, width:6, height: 8 }\n * ```\n *\n * In comparison, {@link multiply} will also include x & y.\n * @param rect Rectangle\n * @param amount Amount to multiply by\n * @returns\n */\nexport declare function multiplyDim(rect: Rect | RectPositioned, amount: number): Rect | RectPositioned;\n//# sourceMappingURL=multiply.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n/**\n * If `p` is inside of `rect`, a copy of `p` is returned.\n * If `p` is outside of `rect`, a point is returned closest to `p` on the edge\n * of the rectangle.\n * @param rect\n * @param p\n * @returns\n */\nexport declare const nearestInternal: (rect: RectPositioned, p: Point) => Point;\n//# sourceMappingURL=nearest.d.ts.map","export declare const Placeholder: Readonly<{\n    width: number;\n    height: number;\n}>;\nexport declare const PlaceholderPositioned: Readonly<{\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}>;\n//# sourceMappingURL=placeholder.d.ts.map","import type { Rect } from \"./rect-types.js\";\n/**\n * Returns the perimeter of `rect` (ie. sum of all edges)\n *  * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.perimeter(rect);\n * ```\n * @param rect\n * @returns\n */\nexport declare const perimeter: (rect: Rect) => number;\n//# sourceMappingURL=perimeter.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Rect } from \"./rect-types.js\";\n/**\n * Returns a function that divides numbers or points by the largest dimension of `rect`.\n *\n * ```js\n * const d = dividerByLargestDimension({width:100,height:50});\n * d(50);                // 0.5 (50/100)\n * d({ x: 10, y: 20 }); // { x: 0.1, y: 0.2 }\n * ```\n * @param rect\n * @returns\n */\nexport declare const dividerByLargestDimension: (rect: Rect) => (value: number | Point) => number | Readonly<{\n    x: number;\n    y: number;\n    z?: number;\n}>;\n//# sourceMappingURL=normalise-by-rect.d.ts.map","import { type RandomSource } from '@ixfx/random';\nimport type { Point } from '../point/point-type.js';\nimport type { Rect, RectPositioned } from './rect-types.js';\n/**\n * Returns a random positioned Rect on a 0..1 scale.\n * ```js\n * const r = Rects.random(); // eg {x: 0.2549012, y:0.859301, width: 0.5212, height: 0.1423 }\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Rects } from \"@ixfx/geometry.js\";\n * import { weightedSource } from \"@ixfx/random.js\"\n * const r = Rects.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport declare const random: (rando?: RandomSource) => RectPositioned;\nexport type RectRandomPointOpts = {\n    readonly strategy?: `naive`;\n    readonly randomSource?: RandomSource;\n    readonly margin?: {\n        readonly x: number;\n        readonly y: number;\n    };\n};\n/**\n * Returns a random point within a rectangle.\n *\n * By default creates a uniform distribution.\n *\n * ```js\n * const pt = randomPoint({width: 5, height: 10});\n * ```'\n * @param within Rectangle to generate a point within\n * @param options Options\n * @returns\n */\nexport declare const randomPoint: (within: Rect | RectPositioned, options?: RectRandomPointOpts) => Point;\n//# sourceMappingURL=random.d.ts.map","import type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Subtracts width/height of `b` from `a` (ie: a - b), returning result.\n * x,y of second parameter is ignored.\n * ```js\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rectA, rectB);\n * ```\n * @param a\n * @param b\n */\nexport declare function subtract(a: Rect, b: Rect | RectPositioned): Rect;\nexport declare function subtract(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n/**\n * Subtracts a width/height from `a`, returning result.\n * ```js\n * const rect = { width: 100, height: 100 };\n * Rects.subtract(rect, 200, 200);\n * // Yields: { width: -100, height: -100 }\n * ```\n * @param a\n * @param width\n * @param height\n */\nexport declare function subtract(a: Rect, width: number, height: number): Rect;\nexport declare function subtract(a: RectPositioned, width: number, height: number): RectPositioned;\n/**\n * Subtracts a width & height from `a`. Leaves x & y as-is.\n * ```js\n * const rect = { x: 10, y: 20, width: 100, height: 200 };\n * subtractSize(rect, { width: 50, height: 100 });\n * subtractSize(rec, 50, 100);\n * // Both yields: { x:10, y: 20, width: 50, height: 100 }\n * ```\n * @param a Rectangle\n * @param b Rectangle to subtract by, or width\n * @param c Height, if second parameter is width\n */\nexport declare function subtractSize(a: RectPositioned, b: Rect | number, c?: number): RectPositioned;\n/**\n * Subtracts a width & height from `a`.\n * ```js\n * const rect = { width: 100, height: 200 };\n * subtractSize(rect, { width: 50, height: 100 });\n * subtractSize(rec, 50, 100);\n * // Both yields: { width: 50, height: 100 }\n * ```\n * @param a Rectangle\n * @param b Rectangle to subtract by, or width\n * @param c Height, if second parameter is width\n */\nexport declare function subtractSize(a: Rect, b: Rect | number, c?: number): Rect;\n/**\n * Subtracts A-B. Applies to x, y, width & height\n * ```js\n * subtractOffset(\n *  { x:100, y:100, width:100, height:100 },\n *  { x:10, y:20,   width: 30, height: 40 }\n * );\n * // Yields: {x: 90, y: 80, width: 70, height: 60 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used.\n * @param a\n * @param b\n * @returns\n */\nexport declare function subtractOffset(a: RectPositioned | Rect, b: RectPositioned | Rect): RectPositioned;\n//# sourceMappingURL=subtract.d.ts.map","import type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Sums width/height of `b` with `a` (ie: a + b), returning result.\n * x/y of second parameter are ignored\n * ```js\n * import { Rects } from \"@ixfx/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.sum(rectA, rectB);\n * ```\n * @param a\n * @param b\n */\nexport declare function sum(a: Rect, b: Rect | RectPositioned): Rect;\n/**\n * Sums width/height of `b` with `a`, returning result.\n *\n * Note that width/height of `b` is also added to `a`'s x & y properties\n * ```js\n * // Yields: { x:101, y:202, width: 110, height: 220 }\n * sum({x:1, y:2, width:10, height:20}, {width:100, height: 200});\n * ```\n *\n * x & y values of `b` are ignored. If you want to sum with those, use `sumOffset`\n * @param a\n * @param b\n */\nexport declare function sum(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n/**\n * Sums width/height of `rect` with given `width` and `height`\n * ```js\n * import { Rects } from \"@ixfx/geometry.js\";\n * const rect = { width: 100, height: 100 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.subtract(rect, 200, 200);\n * ```\n * @param rect\n * @param width\n * @param height\n */\nexport declare function sum(rect: Rect, width: number, height: number): Rect;\n/**\n * Sums width/height of `rect` with `width` and `height`\n *\n * `width` and `height` is added to `rect`'s `x` and `y` values.\n * ```js\n * // Yields: { x:101, y:202, width: 110, height: 220 }\n * sum({x:1, y:2, width:10, height:20}, 100, 200);\n * ```\n * @param rect\n * @param width\n * @param height\n */\nexport declare function sum(rect: RectPositioned, width: number, height: number): RectPositioned;\n/**\n * Sums x,y,width,height of a+b.\n * ```js\n * sumOffset({x:100,y:100,width:100,height:100}, {x:10, y:20, width: 30, height: 40});\n * // Yields: {x: 110, y: 120, width: 130, height: 140 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used\n * @param a\n * @param b\n * @returns\n */\nexport declare function sumOffset(a: RectPositioned | Rect, b: RectPositioned | Rect): RectPositioned;\n//# sourceMappingURL=sum.d.ts.map","import type { Rect, RectArray, RectPositioned, RectPositionedArray } from \"./rect-types.js\";\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n *\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\nexport declare function toArray(rect: Rect): RectArray;\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n *\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\nexport declare function toArray(rect: RectPositioned): RectPositionedArray;\n//# sourceMappingURL=to-array.d.ts.map","export * from './area.js';\nexport * from './apply.js';\nexport * from './cardinal.js';\nexport * from './center-origin.js';\nexport * from './center.js';\nexport * from './corners.js';\nexport * from './distance.js';\nexport * from './divide.js';\nexport * from './edges.js';\nexport * from './empty.js';\nexport * from './encompass.js';\nexport * from './from-center.js';\nexport * from './from-element.js';\nexport * from './from-numbers.js';\nexport * from './from-top-left.js';\nexport * from './get-rect-positionedparameter.js';\nexport * from './guard.js';\nexport * from './Intersects.js';\nexport * from './is-equal.js';\nexport * from './lengths.js';\nexport * from './max.js';\nexport * from './multiply.js';\nexport * from './nearest.js';\nexport * from './placeholder.js';\nexport * from './perimeter.js';\nexport * from './normalise-by-rect.js';\nexport * from './random.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './to-array.js';\nexport type * from './rect-types.js';\n//# sourceMappingURL=index.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"../rect/rect-types.js\";\nexport type Path = {\n    /**\n     * Length of path\n     */\n    length(): number;\n    /**\n     * Returns a point at a relative (0.0-1.0) position along the path\n     *\n     * Inverse of {@link relativePosition}.\n     * @param {number} t Relative position (0.0-1.0)\n     * @returns {Point} Point\n     */\n    interpolate(t: number): Point;\n    /**\n     * Returns relative position of `point` along path.\n     * If `pt` is same as start, result will be 0, if it's the same as end, it will be 1.\n     *\n     * Inverse of {@link interpolate}.\n     * @param point\n     * @param intersectionThreshold\n     */\n    relativePosition(point: Point, intersectionThreshold: number): number;\n    /**\n     * Gets smallest box that encloses path\n     */\n    bbox(): RectPositioned;\n    /**\n     * Returns the nearest point on path to `point`\n     * @param point\n     */\n    nearest(point: Point): Point;\n    /**\n     * Distance from start of path to this point.\n     * If path is closed (eg. a circle) it may have some arbitary 'start' point\n     * @param point\n     */\n    distanceToPoint(point: Point): number;\n    /**\n     * Returns a string representation of pth values\n     */\n    toString(): string;\n    /**\n     * Returns an array of SVG segments that can render path\n     */\n    toSvgString(): ReadonlyArray<string>;\n    /**\n     * Well-known path kind\n     */\n    readonly kind: `compound` | `elliptical` | `circular` | `arc` | `bezier/cubic` | `bezier/quadratic` | `line`;\n};\nexport type WithBeziers = {\n    getBeziers(): ReadonlyArray<Path>;\n};\nexport type CompoundPath = Path & {\n    readonly segments: ReadonlyArray<Path>;\n    readonly kind: `compound`;\n};\nexport type Dimensions = {\n    /**\n     * Width of each path (based on bounding box)\n     */\n    readonly widths: ReadonlyArray<number>;\n    /**\n     * Length of each path\n     */\n    readonly lengths: ReadonlyArray<number>;\n    /**\n     * Total length of all paths\n     */\n    readonly totalLength: number;\n    /**\n     * Total width of all paths\n     */\n    readonly totalWidth: number;\n};\n//# sourceMappingURL=path-type.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * Arc, defined by radius, start and end point in radians and direction\n */\nexport type Arc = {\n    /**\n     * Radius of arc\n     */\n    readonly radius: number;\n    /**\n     * Start radian\n     */\n    readonly startRadian: number;\n    /**\n     * End radian\n     */\n    readonly endRadian: number;\n    /**\n     * If true, arc runs in clockwise direction\n     */\n    readonly clockwise: boolean;\n};\n/**\n * An {@link Arc} that also has a center position, given in x, y\n */\nexport type ArcPositioned = Point & Arc;\n/**\n * Function which can interpolate along an {@link Arc} or {@link ArcPositioned}.\n */\nexport type ArcInterpolate = {\n    (amount: number, arc: Arc, allowOverflow: boolean, origin: Point): Point;\n    (amount: number, arc: ArcPositioned, allowOverflow?: boolean): Point;\n};\n/**\n * Function to convert an arc to SVG segments\n */\nexport type ArcToSvg = {\n    /**\n     * SVG path for arc description\n     * @param origin Origin of arc\n     * @param radius Radius\n     * @param startRadian Start\n     * @param endRadian End\n     */\n    (origin: Point, radius: number, startRadian: number, endRadian: number, opts?: ArcSvgOpts): readonly string[];\n    /**\n     * SVG path for non-positioned arc.\n     * If `arc` does have a position, `origin` will override it.\n     */\n    (arc: Arc, origin: Point, opts?: ArcSvgOpts): readonly string[];\n    /**\n     * SVG path for positioned arc\n     */\n    (arc: ArcPositioned, opts?: ArcSvgOpts): readonly string[];\n};\nexport type ArcSvgOpts = {\n    /**\n     * \"If the arc should be greater or less than 180 degrees\"\n     * ie. tries to maximise arc length\n     */\n    readonly largeArc?: boolean;\n    /**\n     * \"If the arc should begin moving at positive angles\"\n     * ie. the kind of bend it makes to reach end point\n     */\n    readonly sweep?: boolean;\n};\n//# sourceMappingURL=arc-type.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { Line } from '../line/line-type.js';\nimport type { Path } from '../path/path-type.js';\nimport type { Rect, RectPositioned } from '../rect/rect-types.js';\nimport type { Arc, ArcInterpolate, ArcPositioned, ArcToSvg } from './arc-type.js';\nimport type { CirclePositioned } from '../circle/circle-type.js';\nexport type * from './arc-type.js';\n/**\n * Returns true if parameter is an arc\n * @param p Arc or number\n * @returns\n */\nexport declare const isArc: (p: unknown) => p is Arc;\n/**\n * Returns true if parameter has a positioned (x,y)\n * @param p Point, Arc or ArcPositiond\n * @returns\n */\nexport declare const isPositioned: (p: Point | Arc | ArcPositioned) => p is Point;\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @returns Arc\n */\nexport declare function fromDegrees(radius: number, startDegrees: number, endDegrees: number, clockwise: boolean): Arc;\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @param origin Optional center of arc\n * @param clockwise Whether arc moves in clockwise direction\n * @returns Arc\n */ export declare function fromDegrees(radius: number, startDegrees: number, endDegrees: number, clockwise: boolean, origin: Point): ArcPositioned;\n/**\n * Returns a {@link Line} linking the start and end points of an {@link ArcPositioned}.\n *\n * @param arc\n * @returns Line from start to end of arc\n */\nexport declare const toLine: (arc: ArcPositioned) => Line;\n/**\n * Return start and end points of `arc`.\n * `origin` will override arc's origin, if defined.\n *\n * See also:\n * * {@link point} - get point on arc by angle\n * * {@link interpolate} - get point on arc by interpolation percentage\n * @param arc\n * @param origin\n * @returns\n */\nexport declare const getStartEnd: (arc: ArcPositioned | Arc, origin?: Point) => [start: Point, end: Point];\n/**\n * Calculates a coordinate on an arc, based on an angle.\n * `origin` will override arc's origin, if defined.\n *\n * See also:\n * * {@link getStartEnd} - get start and end of arc\n * * {@link interpolate} - get point on arc by interpolation percentage\n * @param arc Arc\n * @param angleRadian Angle of desired coordinate\n * @param origin Origin of arc (0,0 used by default)\n * @returns Coordinate\n */\nexport declare const point: (arc: Arc | ArcPositioned, angleRadian: number, origin?: Point) => Point;\n/**\n * Throws an error if arc instance is invalid\n * @param arc\n */\nexport declare const guard: (arc: Arc | ArcPositioned) => void;\n/**\n * Compute relative position on arc.\n *\n * See also:\n * * {@link getStartEnd} - get start and end of arc\n * * {@link point} - get point on arc by angle\n * @param arc Arc\n * @param amount Relative position 0-1\n * @param origin If arc is not positioned, pass in an origin\n * @param allowOverflow If _true_ allows point to overflow arc dimensions (default: _false_)\n * @returns\n */\nexport declare const interpolate: ArcInterpolate;\n/**\n * Returns the angular size of arc.\n * Eg if arc runs from 45-315deg in clockwise direction, size will be 90deg.\n * @param arc\n */\nexport declare const angularSize: (arc: Arc) => number;\n/**\n * Creates a {@link Path} instance from the arc. This wraps up some functions for convienence.\n * @param arc\n * @returns Path\n */\nexport declare const toPath: (arc: ArcPositioned) => Path;\n/**\n * Returns an arc based on a circle using start and end angles.\n * If you don't have the end angle, but rather the size of the arc, use {@link fromCircleAmount}\n * @param circle Circle\n * @param startRadian Start radian\n * @param endRadian End radian\n * @param clockwise Whether arc goes in a clockwise direction (default: true)\n * @returns\n */\nexport declare const fromCircle: (circle: CirclePositioned, startRadian: number, endRadian: number, clockwise?: boolean) => ArcPositioned;\n/**\n * Returns an arc based on a circle, a start angle, and the size of the arc.\n * See {@link fromCircle} if you already have start and end angles.\n * @param circle Circle to base off\n * @param startRadian Starting angle\n * @param sizeRadian Size of arc\n * @param clockwise Whether arc moves in clockwise direction (default: true)\n * @returns\n */\nexport declare const fromCircleAmount: (circle: CirclePositioned, startRadian: number, sizeRadian: number, clockwise?: boolean) => ArcPositioned;\n/**\n * Calculates the length of the arc\n * @param arc\n * @returns Length\n */\nexport declare const length: (arc: Arc) => number;\n/**\n * Calculates a {@link Rect} bounding box for arc.\n * @param arc\n * @returns Rectangle encompassing arc.\n */\nexport declare const bbox: (arc: ArcPositioned | Arc) => RectPositioned | Rect;\n/**\n * Creates an SV path snippet for arc\n * @returns\n */\nexport declare const toSvg: ArcToSvg;\n/**\n * Calculates the distance between the centers of two arcs\n * @param a\n * @param b\n * @returns Distance\n */\nexport declare const distanceCenter: (a: ArcPositioned, b: ArcPositioned) => number;\n/**\n * Returns true if the two arcs have the same values\n *\n * ```js\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * arcA === arcB; // false, because object identities are different\n * Arcs.isEqual(arcA, arcB); // true, because values are identical\n * ```\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport declare const isEqual: (a: Arc | ArcPositioned, b: Arc | ArcPositioned) => boolean;\n//# sourceMappingURL=index.d.ts.map","import type { Path } from \"../path/path-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nexport type QuadraticBezier = {\n    readonly a: Point;\n    readonly b: Point;\n    readonly quadratic: Point;\n};\nexport type QuadraticBezierPath = Path & QuadraticBezier;\nexport type CubicBezier = {\n    readonly a: Point;\n    readonly b: Point;\n    readonly cubic1: Point;\n    readonly cubic2: Point;\n};\nexport type CubicBezierPath = Path & CubicBezier;\n//# sourceMappingURL=bezier-type.d.ts.map","import type { Path } from \"../path/path-type.js\";\nimport type { QuadraticBezier, CubicBezier } from \"./bezier-type.js\";\nexport declare const isQuadraticBezier: (path: Path | QuadraticBezier | CubicBezier) => path is QuadraticBezier;\nexport declare const isCubicBezier: (path: Path | CubicBezier | QuadraticBezier) => path is CubicBezier;\n//# sourceMappingURL=guard.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { CubicBezier, CubicBezierPath, QuadraticBezier, QuadraticBezierPath } from './bezier-type.js';\nexport * from './bezier-type.js';\nexport * from './guard.js';\n/**\n * Returns a new quadratic bezier with specified bend amount\n *\n * @param {QuadraticBezier} b Curve\n * @param {number} [bend=0] Bend amount, from -1 to 1\n * @returns {QuadraticBezier}\n */\n/**\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve.\n *\n * Use {@link interpolator} to calculate a point along the curve.\n * @param {Point} start Start of curve\n * @param {Point} end End of curve\n * @param {number} [bend=0] Bend amount, -1 to 1\n * @returns {QuadraticBezier}\n */\nexport declare const quadraticSimple: (start: Point, end: Point, bend?: number) => QuadraticBezier;\n/**\n * Returns a relative point on a simple quadratic\n * @param start Start\n * @param end  End\n * @param bend Bend (-1 to 1)\n * @param amt Amount\n * @returns Point\n */\n/**\n * Interpolate cubic or quadratic bezier\n * ```js\n * const i = interpolator(myBezier);\n *\n * // Get point at 50%\n * i(0.5); // { x, y }\n * ```\n * @param q\n * @returns\n */\nexport declare const interpolator: (q: QuadraticBezier | CubicBezier) => (amount: number) => Point;\nexport declare const quadraticToSvgString: (start: Point, end: Point, handle: Point) => ReadonlyArray<string>;\nexport declare const toPath: (cubicOrQuadratic: CubicBezier | QuadraticBezier) => CubicBezierPath | QuadraticBezierPath;\nexport declare const cubic: (start: Point, end: Point, cubic1: Point, cubic2: Point) => CubicBezier;\nexport declare const quadratic: (start: Point, end: Point, handle: Point) => QuadraticBezier;\n//# sourceMappingURL=index.d.ts.map","import type { Circle } from \"./circle-type.js\";\n/**\n * Returns the area of `circle`.\n * @param circle\n * @returns\n */\nexport declare const area: (circle: Circle) => number;\n//# sourceMappingURL=area.d.ts.map","import type { CirclePositioned, Circle } from \"./circle-type.js\";\nimport type { RectPositioned } from \"../rect/rect-types.js\";\n/**\n * Computes a bounding box that encloses circle\n * @param circle\n * @returns\n */\nexport declare const bbox: (circle: CirclePositioned | Circle) => RectPositioned;\n//# sourceMappingURL=bbox.d.ts.map","import type { CirclePositioned, Circle } from \"./circle-type.js\";\n/**\n * Returns the center of a circle\n *\n * If the circle has an x,y, that is the center.\n * If not, `radius` is used as the x and y.\n *\n * ```js\n * const circle = { radius: 5, x: 10, y: 10};\n *\n * // Yields: { x: 5, y: 10 }\n * Circles.center(circle);\n * ```\n *\n * It's a trivial function, but can make for more understandable code\n * @param circle\n * @returns Center of circle\n */\nexport declare const center: (circle: CirclePositioned | Circle) => Readonly<{\n    x: number;\n    y: number;\n}>;\n//# sourceMappingURL=center.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { CompoundPath, Dimensions, Path } from './path-type.js';\nimport type { RectPositioned } from '../rect/rect-types.js';\n/**\n * Returns a new compoundpath, replacing a path at a given index\n *\n * @param compoundPath Existing compoundpath\n * @param index Index to replace at\n * @param path Path to substitute in\n * @returns New compoundpath\n */\nexport declare const setSegment: (compoundPath: CompoundPath, index: number, path: Path) => CompoundPath;\n/**\n * Computes x,y point at a relative position along compoundpath\n *\n * @param paths Combined paths (assumes contiguous)\n * @param t Position (given as a percentage from 0 to 1)\n * @param useWidth If true, widths are used for calulcating. If false, lengths are used\n * @param dimensions Precalculated dimensions of paths, will be computed if omitted\n * @returns\n */\nexport declare const interpolate: (paths: readonly Path[], t: number, useWidth?: boolean, dimensions?: Dimensions) => Point;\n/**\n * Returns the shortest distance of `point` to any point on `paths`.\n * @param paths\n * @param point\n * @returns\n */\nexport declare const distanceToPoint: (paths: readonly Path[], point: Point) => number;\n/**\n * Relative position\n * @param paths Paths\n * @param point Point\n * @param intersectionThreshold Threshold\n * @param dimensions Pre-computed dimensions\n * @returns\n */\nexport declare const relativePosition: (paths: readonly Path[], point: Point, intersectionThreshold: number, dimensions?: Dimensions) => number;\n/**\n * Computes the widths and lengths of all paths, adding them up as well\n *\n * @param paths\n * @returns\n */\nexport declare const computeDimensions: (paths: readonly Path[]) => Dimensions;\n/**\n * Computes the bounding box that encloses entire compoundpath\n *\n * @param paths\n * @returns\n */\nexport declare const bbox: (paths: readonly Path[]) => RectPositioned;\n/**\n * Produce a human-friendly representation of paths\n *\n * @param paths\n * @returns\n */\nexport declare const toString: (paths: readonly Path[]) => string;\n/**\n * Throws an error if paths are not connected together, in order\n *\n * @param paths\n */\nexport declare const guardContinuous: (paths: readonly Path[]) => void;\nexport declare const toSvgString: (paths: readonly Path[]) => readonly string[];\n/**\n * Create a compoundpath from an array of paths.\n * All this does is verify they are connected, and precomputes dimensions\n *\n * @param paths\n * @returns\n */\nexport declare const fromPaths: (...paths: readonly Path[]) => CompoundPath;\n//# sourceMappingURL=compound-path.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Path } from \"./path-type.js\";\n/**\n * Return the start point of a path\n *\n * @param path\n * @return Point\n */\nexport declare const getStart: (path: Path) => Point;\n/**\n * Return the end point of a path\n *\n * @param path\n * @return Point\n */\nexport declare const getEnd: (path: Path) => Point;\n//# sourceMappingURL=start-end.d.ts.map","export * from './compound-path.js';\nexport type * from './path-type.js';\nexport * from './start-end.js';\n//# sourceMappingURL=index.d.ts.map","import type { Path } from \"../path/index.js\";\nimport type { Circle } from \"./circle-type.js\";\nexport type CircularPath = Circle & Path & {\n    readonly kind: `circular`;\n};\n//# sourceMappingURL=circular-path.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Returns the distance between two circle centers.\n *\n * ```js\n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * Throws an error if either is lacking position.\n * @param a\n * @param b\n * @returns Distance\n */\nexport declare const distanceCenter: (a: CirclePositioned, b: CirclePositioned | Point) => number;\n//# sourceMappingURL=distance-center.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Returns the distance between the exterior of two circles, or between the exterior of a circle and point.\n * If `b` overlaps or is enclosed by `a`, distance is 0.\n *\n * ```js\n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * @param a\n * @param b\n */\nexport declare const distanceFromExterior: (a: CirclePositioned, b: CirclePositioned | Point) => number;\n//# sourceMappingURL=distance-from-exterior.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { CirclePositioned } from \"./circle-type.js\";\n/**\n * Yields the points making up the exterior (ie. circumference) of the circle.\n * Uses [Midpoint Circle Algorithm](http://en.wikipedia.org/wiki/Midpoint_circle_algorithm)\n *\n * @example Draw outline of circle\n * ```js\n * const circle = { x: 100, y: 100, radius: 50 }\n * for (const pt of Circles.exteriorIntegerPoints(circle)) {\n *  // Fill 1x1 pixel\n *  ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle\n */\nexport declare function exteriorIntegerPoints(circle: CirclePositioned): IterableIterator<Point>;\n//# sourceMappingURL=exterior-points.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { Circle, CirclePositioned } from './circle-type.js';\n/**\n * Throws if radius is out of range. If x,y is present, these will be validated too.\n * @param circle\n * @param parameterName\n */\nexport declare const guard: (circle: CirclePositioned | Circle, parameterName?: string) => void;\n/**\n * Throws if `circle` is not positioned or has dodgy fields\n * @param circle\n * @param parameterName\n * @returns\n */\nexport declare const guardPositioned: (circle: CirclePositioned, parameterName?: string) => void;\n/***\n * Returns true if radius, x or y are NaN\n */\nexport declare const isNaN: (a: Circle | CirclePositioned) => boolean;\n/**\n * Returns true if parameter has x,y. Does not verify if parameter is a circle or not\n *\n * ```js\n * const circleA = { radius: 5 };\n * Circles.isPositioned(circle); // false\n *\n * const circleB = { radius: 5, x: 10, y: 10 }\n * Circles.isPositioned(circle); // true\n * ```\n * @param p Circle\n * @returns\n */\nexport declare const isPositioned: (p: Circle | Point) => p is Point;\nexport declare const isCircle: (p: any) => p is Circle;\nexport declare const isCirclePositioned: (p: any) => p is CirclePositioned;\n//# sourceMappingURL=guard.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Returns all integer points contained within `circle`.\n *\n * ```js\n * const c = { x:100, y:100, radius:100 };\n * for (const pt of Circles.interiorIntegerPoints(c)) {\n *   ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle\n */\nexport declare function interiorIntegerPoints(circle: CirclePositioned): IterableIterator<Point>;\n//# sourceMappingURL=interior-points.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { CirclePositioned } from \"./circle-type.js\";\n/**\n * Computes relative position along circle perimeter\n *\n * ```js\n * const circle = { radius: 100, x: 100, y: 100 };\n *\n * // Get a point halfway around circle\n * // Yields { x, y }\n * const pt = Circles.interpolate(circle, 0.5);\n * ```\n * @param circle\n * @param t Position, 0-1\n * @returns\n */\nexport declare const interpolate: (circle: CirclePositioned, t: number) => Point;\n//# sourceMappingURL=interpolate.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\nimport type { RectPositioned } from \"../rect/index.js\";\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A circle can be checked for intersections with another CirclePositioned, Point or RectPositioned.\n *\n * Use `intersections` to find the points of intersection.\n *\n * @param a Circle\n * @param b Circle or point to test\n * @returns True if circle overlap\n */\nexport declare const isIntersecting: (a: CirclePositioned, b: CirclePositioned | Point | RectPositioned, c?: number) => boolean;\n//# sourceMappingURL=intersecting.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { CirclePositioned } from \"./circle-type.js\";\nimport type { Line } from \"../line/line-type.js\";\n/**\n * Returns the point(s) of intersection between a circle and line.\n *\n * ```js\n * const circle = { radius: 5, x: 5, y: 5 };\n * const line = { a: { x: 0, y: 0 }, b: { x: 10, y: 10 } };\n * const pts = Circles.intersectionLine(circle, line);\n * ```\n * @param circle\n * @param line\n * @returns Point(s) of intersection, or empty array\n */\nexport declare const intersectionLine: (circle: CirclePositioned, line: Line) => readonly Point[];\n/**\n *\n * Returns the points of intersection betweeen `a` and `b`.\n *\n * Returns an empty array if circles are equal, one contains the other or if they don't touch at all.\n *\n * @param a Circle\n * @param b Circle\n * @returns Points of intersection, or an empty list if there are none\n */\nexport declare const intersections: (a: CirclePositioned, b: CirclePositioned) => readonly Point[];\n//# sourceMappingURL=intersections.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Returns true if `b` is completely contained by `a`\n *\n * ```js\n * // Compare two points\n * isContainedBy(circleA, circleB);\n *\n * // Compare a circle with a point\n * isContainedBy(circleA, {x: 10, y: 20});\n *\n * // Define radius as third parameter\n * isContainedBy(circleA, {x: 10, y: 20}, 20);\n * ```\n * @param a Circle\n * @param b Circle or point to compare to\n * @param c Radius to accompany parameter b if it's a point\n * @returns\n */\nexport declare const isContainedBy: (a: CirclePositioned, b: CirclePositioned | Point, c?: number) => boolean;\n//# sourceMappingURL=is-contained-by.d.ts.map","import type { Circle, CirclePositioned } from \"./circle-type.js\";\n/**\n * Returns true if the two objects have the same values\n *\n * ```js\n * const circleA = { radius: 10, x: 5, y: 5 };\n * const circleB = { radius: 10, x: 5, y: 5 };\n *\n * circleA === circleB; // false, because identity of objects is different\n * Circles.isEqual(circleA, circleB); // true, because values are the same\n * ```\n *\n * Circles must both be positioned or not.\n * @param a\n * @param b\n * @returns\n */\nexport declare const isEqual: (a: CirclePositioned | Circle, b: CirclePositioned | Circle) => boolean;\n//# sourceMappingURL=is-equal.d.ts.map","import type { CirclePositioned, Circle } from \"./circle-type.js\";\nexport declare function multiplyScalar(a: CirclePositioned, value: number): CirclePositioned;\nexport declare function multiplyScalar(a: Circle, value: number): Circle;\n//# sourceMappingURL=multiply.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Circle, CirclePositioned } from \"./circle-type.js\";\n/**\n * Returns the nearest point on `circle`'s perimeter closest to `point`.\n *\n * ```js\n * const pt = Circles.nearest(circle, {x:10,y:10});\n * ```\n *\n * If an array of circles is provided, it will be the closest point amongst all the circles\n * @param circle Circle or array of circles\n * @param point\n * @returns Point `{ x, y }`\n */\nexport declare const nearest: (circle: CirclePositioned | readonly CirclePositioned[], point: Point) => Point;\n/**\n * Returns a point on a circle's perimeter at a specified angle in radians\n *\n * ```js\n * // Circle without position\n * const circleA = { radius: 5 };\n *\n * // Get point at angle Math.PI, passing in a origin coordinate\n * const ptA = Circles.pointOnPerimeter(circleA, Math.PI, {x: 10, y: 10 });\n *\n * // Point on circle with position\n * const circleB = { radius: 5, x: 10, y: 10};\n * const ptB = Circles.pointOnPerimeter(circleB, Math.PI);\n * ```\n * @param circle\n * @param angleRadian Angle in radians\n * @param origin or offset of calculated point. By default uses center of circle or 0,0 if undefined\n * @returns Point oo circle\n */\nexport declare const pointOnPerimeter: (circle: Circle | CirclePositioned, angleRadian: number, origin?: Point) => Point;\n/**\n * Returns circumference of `circle` (alias of {@link length})\n * @param circle\n * @returns\n */\nexport declare const circumference: (circle: Circle) => number;\n/**\n * Returns circumference of `circle` (alias of {@link circumference})\n * @param circle\n * @returns\n */\nexport declare const length: (circle: Circle) => number;\n//# sourceMappingURL=perimeter.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Circle, CirclePositioned, CircleRandomPointOpts } from \"./circle-type.js\";\n/**\n * Returns a random point within a circle.\n *\n * By default creates a uniform distribution.\n *\n * ```js\n * const pt = randomPoint({radius: 5});\n * const pt = randomPoint({radius: 5, x: 10, y: 20});\n * ```'\n *\n * Generate points with a gaussian distribution\n * ```js\n * const pt = randomPoint(circle, {\n *  randomSource: Random.gaussian\n * })\n * ```\n * @param within Circle to generate a point within\n * @param opts Options\n * @returns\n */\nexport declare const randomPoint: (within: Circle | CirclePositioned, opts?: Partial<CircleRandomPointOpts>) => Point;\n//# sourceMappingURL=random.d.ts.map","import type { CircleToSvg } from \"./circle-type.js\";\n/**\n * Creates a SVG path segment.\n * @param a Circle or radius\n * @param sweep If true, path is 'outward'\n * @param origin Origin of path. Required if first parameter is just a radius or circle is non-positioned\n * @returns\n */\nexport declare const toSvg: CircleToSvg;\n//# sourceMappingURL=svg.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { CircularPath } from \"./circular-path.js\";\n/**\n * Returns a `CircularPath` representation of a circle\n *\n * @param {CirclePositioned} circle\n * @returns {CircularPath}\n */\nexport declare const toPath: (circle: CirclePositioned) => CircularPath;\n//# sourceMappingURL=to-path.d.ts.map","import type { Circle, CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Returns a positioned version of a circle.\n * If circle is already positioned, it is returned.\n * If no default position is supplied, 0,0 is used.\n * @param circle\n * @param defaultPositionOrX\n * @param y\n * @returns\n */\nexport declare const toPositioned: (circle: Circle | CirclePositioned, defaultPositionOrX?: Point | number, y?: number) => CirclePositioned;\n//# sourceMappingURL=to-positioned.d.ts.map","export * from './area.js';\nexport * from './bbox.js';\nexport * from './center.js';\nexport type * from './circle-type.js';\nexport * from './circular-path.js';\nexport * from './distance-center.js';\nexport * from './distance-from-exterior.js';\nexport * from './exterior-points.js';\nexport * from './guard.js';\nexport * from './interior-points.js';\nexport * from './interpolate.js';\nexport * from './intersecting.js';\nexport * from './intersections.js';\nexport * from './is-contained-by.js';\nexport * from './is-equal.js';\nexport * from './multiply.js';\nexport * from './perimeter.js';\nexport * from './random.js';\nexport * from './svg.js';\nexport * from './to-path.js';\nexport * from './to-positioned.js';\n//# sourceMappingURL=index.d.ts.map","import type { Line } from \"./line-type.js\";\n/**\n * Returns a parallel line to `line` at `distance`.\n *\n * ```js\n * const l = Lines.parallel(line, 10);\n * ```\n * @param line\n * @param distance\n */\nexport declare const parallel: (line: Line, distance: number) => Line;\n/**\n * Returns a point perpendicular to `line` at a specified `distance`. Use negative\n * distances for the other side of line.\n * ```\n * // Project a point 100 units away from line, at its midpoint.\n * const pt = Lines.perpendicularPoint(line, 100, 0.5);\n * ```\n * @param line Line\n * @param distance Distance from line. Use negatives to flip side\n * @param amount Relative place on line to project point from. 0 projects from A, 0.5 from the middle, 1 from B.\n */\nexport declare const perpendicularPoint: (line: Line, distance: number, amount?: number) => {\n    x: number;\n    y: number;\n};\n//# sourceMappingURL=angles.d.ts.map","import type { RectPositioned } from \"../rect/rect-types.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns a rectangle that encompasses dimension of line\n *\n * ```js\n * const rect = Lines.bbox(line);\n * ```\n */\nexport declare const bbox: (line: Line) => RectPositioned;\n//# sourceMappingURL=bbox.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns the distance of `point` to the nearest point on `line`\n *\n * ```js\n * const distance = Lines.distanceSingleLine(line, pt);\n * ```\n * @param line Line\n * @param point Target point\n * @returns\n */\nexport declare const distanceSingleLine: (line: Line, point: Point) => number;\n//# sourceMappingURL=distance-single-line.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Divides both start and end points by given x,y\n * ```js\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.divide(l, {x:2, y:4});\n * // Yields: 0.5,0.25 -> 5,2.5\n * ```\n *\n * Dividing by zero will give Infinity for that dimension.\n * @param line\n * @param point\n * @returns\n */\nexport declare const divide: (line: Line, point: Point) => Line;\n//# sourceMappingURL=divide.d.ts.map","import type { Line } from \"./line-type.js\";\n/**\n * Returns a line from four numbers [x1,y1,x2,y2].\n *\n * See {@link toFlatArray} to create an array from a line.\n *\n * ```js\n * const line = Lines.fromFlatArray(...[0, 0, 100, 100]);\n * // line is {a: { x:0, y:0 }, b: { x: 100, y: 100 } }\n * ```\n * @param array Array in the form [x1,y1,x2,y2]\n * @returns Line\n */\nexport declare const fromFlatArray: (array: readonly number[]) => Line;\n//# sourceMappingURL=from-flat-array.d.ts.map","import type { Line } from \"./line-type.js\";\n/**\n * Returns a line from a basis of coordinates (x1, y1, x2, y2)\n *\n * ```js\n * // Line from 0,1 -> 10,15\n * Lines.fromNumbers(0, 1, 10, 15);\n * ```\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @returns\n */\nexport declare const fromNumbers: (x1: number, y1: number, x2: number, y2: number) => Line;\n//# sourceMappingURL=from-numbers.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns a line from two points\n *\n * ```js\n * // Line from 0,1 to 10,15\n * const line = Lines.fromPoints( { x:0, y:1 }, { x:10, y:15 });\n * // line is: { a: { x: 0, y: 1}, b: { x: 10, y: 15 } };\n * ```\n * @param a Start point\n * @param b End point\n * @returns\n */\nexport declare const fromPoints: (a: Point, b: Point) => Line;\n//# sourceMappingURL=from-points.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * Creates a line from an origin point.\n * ```js\n * // Line of length 0.2 with middle at 0.5,0.5\n * fromPivot({ x:0.5, y:0.5 }, 0.2);\n * // Same line, but on an angle\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45));\n *\n * // ...now with pivot point at 20%, rather than center\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45), 0.2);\n * ```\n *\n * Examples:\n * * Angle of 0 (deg/rad) results in a horizontal line,\n * * Angle of 90deg in a vertical line.\n * * Angle of 45deg will be angled downwards.\n *\n * @param origin Origin to pivot around\n * @param length Total length of line\n * @param angleRadian Angle of line, in radians\n * @param balance Percentage of where origin ought to be on line. Default: 0.5, meaning the middle of line\n */\nexport declare const fromPivot: (origin?: Point, length?: number, angleRadian?: number, balance?: number) => Readonly<{\n    a: Point;\n    b: Point;\n}>;\n//# sourceMappingURL=from-pivot.d.ts.map","import type { Path } from \"../path/path-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nexport type LinePath = Line & Path & {\n    toFlatArray(): ReadonlyArray<number>;\n    toPoints(): ReadonlyArray<Point>;\n    rotate(amountRadian: number, origin: Point): LinePath;\n    sum(point: Point): LinePath;\n    divide(point: Point): LinePath;\n    multiply(point: Point): LinePath;\n    subtract(point: Point): LinePath;\n    apply(fn: (point: Point) => Point): LinePath;\n    midpoint(): Point;\n    parallel(distance: number): Line;\n    perpendicularPoint(distance: number, amount?: number): Point;\n    slope(): number;\n    withinRange(point: Point, maxRange: number): boolean;\n    isEqual(otherLine: Line): boolean;\n};\n//# sourceMappingURL=line-path-type.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { LinePath } from \"./line-path-type.js\";\n/**\n * Returns a {@link LinePath} from two points\n *\n * ```js\n * const path = Lines.fromPointsToPath(ptA, ptB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const fromPointsToPath: (a: Point, b: Point) => LinePath;\n//# sourceMappingURL=from-points-to-path.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns [a,b] points from either a line parameter, or two points.\n * It additionally applies the guardPoint function to ensure validity.\n * This supports function overloading.\n * @ignore\n * @param aOrLine\n * @param b\n * @returns\n */\nexport declare const getPointParameter: (aOrLine: Point | Line, b?: Point) => readonly [Point, Point];\n//# sourceMappingURL=get-points-parameter.d.ts.map","import type { Line, PolyLine } from \"./line-type.js\";\n/**\n * Returns true if `p` is a valid line, containing `a` and `b` Points.\n * ```js\n * Lines.isLine(l);\n * ```\n * @param p Value to check\n * @returns True if a valid line.\n */\nexport declare const isLine: (p: any) => p is Line;\n/**\n * Returns true if `p` is a {@link PolyLine}, ie. an array of {@link Line}s.\n * Validates all items in array.\n * @param p\n * @returns\n */\nexport declare const isPolyLine: (p: any) => p is PolyLine;\n/**\n * Throws an exception if:\n * * line is undefined\n * * a or b parameters are missing\n *\n * Does not validate points\n * @param line\n * @param name\n */\nexport declare const guard: (line: Line, name?: string) => void;\n//# sourceMappingURL=guard.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Calculates a point in-between `a` and `b`.\n *\n * If an interpolation amount below 0 or above 1 is given, _and_\n * `allowOverflow_ is true, a point will be returned that is extended\n * past `line`. This is useful for easing functions which might\n * briefly go past the limits.\n *\n * ```js\n * // Get {x,y} at 50% along line\n * Lines.interpolate(0.5, line);\n *\n * // Get {x,y} at 80% between point A and B\n * Lines.interpolate(0.8, ptA, ptB);\n * ```\n * @param amount Relative position, 0 being at a, 0.5 being halfway, 1 being at b\n * @param a Start\n * @param pointB End\n * @returns Point between a and b\n */\nexport declare function interpolate(amount: number, a: Point, pointB: Point, allowOverflow?: boolean): Point;\n/**\n * Calculates a point in-between `line`'s start and end points.\n *\n * ```js\n * // Get {x, y } at 50% along line\n * Lines.interpolate(0.5, line);\n * ```\n *\n * Any additional properties from `b`  are returned on the result as well.\n * @param amount 0..1\n * @param line Line\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line\n */\nexport declare function interpolate(amount: number, line: Line, allowOverflow?: boolean): Point;\n/**\n * Returns the point along a line from its start (A)\n * @param line Line\n * @param distance Distance\n * @param fromA If _true_ (default) returns from A. Use _false_ to calculate from end\n * @returns\n */\nexport declare function pointAtDistance(line: Line, distance: number, fromA?: boolean): Point;\n//# sourceMappingURL=interpolate.d.ts.map","import type { Line } from \"./line-type.js\";\n/**\n * Returns true if the lines have the same value. Note that only\n * the line start and end points are compared. So the lines might\n * be different in other properties, and `isEqual` will still return\n * true.\n *\n * ```js\n * const a = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * const b = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * a === b; // false, because they are different objects\n * Lines.isEqual(a, b); // true, because they have the same value\n * ```\n * @param {Line} a\n * @param {Line} b\n * @returns {boolean}\n */\nexport declare const isEqual: (a: Line, b: Line) => boolean;\n//# sourceMappingURL=is-equal.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { PolyLine } from \"./line-type.js\";\n/**\n * Returns an array of lines that connects provided points. Note that line is not closed.\n *\n * Eg, if points a,b,c are provided, two lines are provided: a->b and b->c.\n *\n * ```js\n * const lines = Lines.joinPointsToLines(ptA, ptB, ptC);\n * // lines is an array of, well, lines\n * ```\n * @param points\n * @returns\n */\nexport declare const joinPointsToLines: (...points: readonly Point[]) => PolyLine;\n//# sourceMappingURL=join-points-to-lines.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n/**\n * Returns the length between two points\n * ```js\n * Lines.length(ptA, ptB);\n * ```\n * @param a First point\n * @param b Second point\n * @returns\n */\nexport declare function length(a: Point, b: Point): number;\n/**\n * Returns length of line. If a polyline (array of lines) is provided,\n * it is the sum total that is returned.\n *\n * ```js\n * Lines.length(a: {x:0, y:0}, b: {x: 100, y:100});\n * Lines.length(lines);\n * ```\n * @param line Line\n */\nexport declare function length(line: Line | PolyLine): number;\n//# sourceMappingURL=length.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns the mid-point of a line (same as `interpolate` with an amount of 0.5)\n *\n * ```js\n * Lines.midpoint(line); // Returns {x, y}\n * ```\n * @param aOrLine\n * @param pointB\n * @returns\n */\nexport declare const midpoint: (aOrLine: Point | Line, pointB?: Point) => Point;\n//# sourceMappingURL=midpoint.d.ts.map","import type { Line } from \"./line-type.js\";\nimport { type Point } from \"../point/index.js\";\n/**\n * Multiplies start and end of line by point.x, point.y.\n *\n * ```js\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1, 1, 10, 10);\n * const ll = Lines.multiply(l, {x:2, y:3});\n * // Yields: 2,20 -> 3,30\n * ```\n * @param line\n * @param point\n * @returns\n */\nexport declare const multiply: (line: Line, point: Point) => Line;\n//# sourceMappingURL=multiply.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns the nearest point on `line` closest to `point`.\n *\n * ```js\n * const pt = Lines.nearest(line, {x:10,y:10});\n * ```\n *\n * If an array of lines is provided, it will be the closest point amongst all the lines\n * @param line Line or array of lines\n * @param point\n * @returns Point `{ x, y }`\n */\nexport declare const nearest: (line: Line | readonly Line[], point: Point) => Point;\n//# sourceMappingURL=nearest.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns the relative position of `pt` along `line`.\n * Warning: assumes `pt` is actually on `line`. Results may be bogus if not.\n * @param line\n * @param pt\n */\nexport declare const relativePosition: (line: Line, pt: Point) => number;\n//# sourceMappingURL=relative-position.d.ts.map","import type { Line } from \"./line-type.js\";\n/**\n * Reverses a line.\n * ````js\n * const a = { x: 10, y: 20 };\n * const b = { x: 100, y: 200 };\n * const line = reverse({ a, b });\n * // { a: { x: 100, y: 200 }, b: { x: 10, y: 20 } }\n * ```\n * @param line\n * @returns\n */\nexport declare function reverse(line: Line): Line;\n//# sourceMappingURL=reverse.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns a line that is rotated by `angleRad`. By default it rotates\n * around its center, but an arbitrary `origin` point can be provided.\n * If `origin` is a number, it's presumed to be a 0..1 percentage of the line.\n *\n * ```js\n * // Rotates line by 0.1 radians around point 10,10\n * const r = Lines.rotate(line, 0.1, {x:10,y:10});\n *\n * // Rotate line by 5 degrees around its center\n * const r = Lines.rotate(line, degreeToRadian(5));\n *\n * // Rotate line by 5 degres around its end point\n * const r = Lines.rotate(line, degreeToRadian(5), line.b);\n *\n * // Rotate by 90 degrees at the 80% position\n * const r = Lines.rotated = rotate(line, Math.PI / 2, 0.8);\n * ```\n * @param line Line to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of line will be used\n * @returns\n */\nexport declare const rotate: (line: Line, amountRadian?: number, origin?: Point | number) => Line;\n//# sourceMappingURL=rotate.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Subtracts both start and end points by given x,y\n * ```js\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.subtract(l, {x:2, y:4});\n * // Yields: -1,-3 -> 8,6\n * ```\n * @param line\n * @param point\n * @returns\n */\nexport declare const subtract: (line: Line, point: Point) => Line;\n//# sourceMappingURL=subtract.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Adds both start and end points by given x,y\n * ```js\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.sum(l, {x:2, y:4});\n * // Yields: 3,5 -> 12,14\n * ```\n * @param line\n * @param point\n * @returns\n */\nexport declare const sum: (line: Line, point: Point) => Line;\n//# sourceMappingURL=sum.d.ts.map","import type { LinePath } from \"./line-path-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns a path wrapper around a line instance. This is useful if there are a series\n * of operations you want to do with the same line because you don't have to pass it\n * in as an argument to each function.\n *\n * Note that the line is immutable, so a function like `sum` returns a new LinePath,\n * wrapping the result of `sum`.\n *\n * ```js\n * // Create a path\n * const l = Lines.toPath(fromNumbers(0,0,10,10));\n *\n * // Now we can use it...\n * l.length();\n *\n * // Mutate functions return a new path\n * const ll = l.sum({x:10,y:10});\n * ll.length();\n * ```\n * @param line\n * @returns\n */\nexport declare const toPath: (line: Line) => LinePath;\n//# sourceMappingURL=to-path.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns a string representation of two points\n * ```js\n * console.log(Lines.toString(a, b)));\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare function toString(a: Point, b: Point): string;\n/**\n * Returns a string representation of a line\n * ```js\n * Lines.toString(line);\n * ```\n * @param line\n */\nexport declare function toString(line: Line): string;\n//# sourceMappingURL=to-string.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { Line } from './line-type.js';\nexport * from './angles.js';\nexport * from './bbox.js';\nexport * from './distance-single-line.js';\nexport * from './divide.js';\nexport * from './from-flat-array.js';\nexport * from './from-numbers.js';\nexport * from './from-points.js';\nexport * from './from-pivot.js';\nexport * from './from-points-to-path.js';\nexport * from './get-points-parameter.js';\nexport * from './guard.js';\nexport * from './interpolate.js';\nexport * from './is-equal.js';\nexport * from './join-points-to-lines.js';\nexport * from './length.js';\nexport type * from './line-path-type.js';\nexport type * from './line-type.js';\nexport * from './midpoint.js';\nexport * from './multiply.js';\nexport * from './nearest.js';\nexport * from './relative-position.js';\nexport * from './reverse.js';\nexport * from './rotate.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './to-path.js';\nexport * from './to-string.js';\nexport declare const Empty: Readonly<{\n    a: Readonly<{\n        x: 0;\n        y: 0;\n    }>;\n    b: Readonly<{\n        x: 0;\n        y: 0;\n    }>;\n}>;\nexport declare const Placeholder: Readonly<{\n    a: Readonly<{\n        x: number;\n        y: number;\n    }>;\n    b: Readonly<{\n        x: number;\n        y: number;\n    }>;\n}>;\n/**\n * Returns true if `l` is the same as Line.Empty, that is\n * the `a` and `b` points are Points.Empty.\n * @param l\n * @returns\n */\nexport declare const isEmpty: (l: Line) => boolean;\nexport declare const isPlaceholder: (l: Line) => boolean;\n/**\n * Applies `fn` to both start and end points.\n *\n * ```js\n * // Line 10,10 -> 20,20\n * const line = Lines.fromNumbers(10,10, 20,20);\n *\n * // Applies randomisation to both x and y.\n * const rand = (p) => ({\n *  x: p.x * Math.random(),\n *  y: p.y * Math.random()\n * });\n *\n * // Applies our randomisation function\n * const line2 = apply(line, rand);\n * ```\n * @param line Line\n * @param fn Function that takes a point and returns a point\n * @returns\n */\nexport declare const apply: (line: Line, fn: (p: Point) => Point) => Readonly<Line>;\n/**\n * Returns the angle in radians of a line, or two points\n * ```js\n * Lines.angleRadian(line);\n * Lines.angleRadian(ptA, ptB);\n * ```\n * @param lineOrPoint\n * @param b\n * @returns\n */\nexport declare const angleRadian: (lineOrPoint: Line | Point, b?: Point) => number;\n/**\n * Normalises start and end points by given width and height. Useful\n * for converting an absolutely-defined line to a relative one.\n *\n * ```js\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.normaliseByRect(l, 10, 10);\n * // Yields: 0.1,0.1 -> 1,1\n * ```\n * @param line\n * @param width\n * @param height\n * @returns\n */\nexport declare const normaliseByRect: (line: Line, width: number, height: number) => Line;\n/**\n * Returns true if `point` is within `maxRange` of `line`.\n *\n * ```js\n * const line = Lines.fromNumbers(0,20,20,20);\n * Lines.withinRange(line, {x:0,y:21}, 1); // True\n * ```\n * @param line\n * @param point\n * @param maxRange\n * @returns True if point is within range\n */\nexport declare const withinRange: (line: Line, point: Point, maxRange: number) => boolean;\n/**\n * Calculates [slope](https://en.wikipedia.org/wiki/Slope) of line.\n *\n * @example\n * ```js\n * Lines.slope(line);\n * Lines.slope(ptA, ptB)\n * ```\n * @param lineOrPoint Line or point. If point is provided, second point must be given too\n * @param b Second point if needed\n * @returns\n */\nexport declare const slope: (lineOrPoint: Line | Point, b?: Point) => number;\n/**\n * Scales a line from its midpoint\n *\n * @example Shorten by 50%, anchored at the midpoint\n * ```js\n * const l = {\n *  a: {x:50, y:50}, b: {x: 100, y: 90}\n * }\n * const l2 = Lines.scaleFromMidpoint(l, 0.5);\n * ```\n * @param line\n * @param factor\n */\nexport declare const scaleFromMidpoint: (line: Line, factor: number) => Line;\n/**\n * Calculates `y` where `line` intersects `x`.\n * @param line Line to extend\n * @param x Intersection of x-axis.\n */\nexport declare const pointAtX: (line: Line, x: number) => Point;\n/**\n * Returns a line extended from its `a` point by a specified distance\n *\n * ```js\n * const line = {a: {x: 0, y:0}, b: {x:10, y:10} }\n * const extended = Lines.extendFromA(line, 2);\n * ```\n * @param line\n * @param distance\n * @return Newly extended line\n */\nexport declare const extendFromA: (line: Line, distance: number) => Line;\n/**\n * Yields every integer point along `line`.\n *\n * @example Basic usage\n * ```js\n * const l = { a: {x: 0, y: 0}, b: {x: 100, y: 100} };\n * for (const p of Lines.pointsOf(l)) {\n *  // Do something with point `p`...\n * }\n * ```\n *\n * Some precision is lost as start and end\n * point is also returned as an integer.\n *\n * Uses [Bresenham's line algorithm](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)\n * @param line Line\n */\nexport declare function pointsOf(line: Line): Generator<Point>;\n/**\n * Returns the distance of `point` to the\n * nearest point on `line`.\n *\n * ```js\n * const d = Lines.distance(line, {x:10,y:10});\n * ```\n *\n * If an array of lines is provided, the shortest distance is returned.\n * @param line Line (or array of lines)\n * @param point Point to check against\n * @returns Distance\n */\nexport declare const distance: (line: Line | readonly Line[], point: Point) => number;\n/**\n * Returns an array representation of line: [a.x, a.y, b.x, b.y]\n *\n * See {@link fromFlatArray} to create a line _from_ this representation.\n *\n * ```js\n * Lines.toFlatArray(line);\n * Lines.toFlatArray(pointA, pointB);\n * ```\n * @param {Point} a\n * @param {Point} b\n * @returns {number[]}\n */\nexport declare const toFlatArray: (a: Point | Line, b: Point) => readonly number[];\n/**\n * Yields all the points of all the lines.\n *\n * ```js\n * const lines = [ ..some array of lines.. ];\n * for (const pt of Lines.asPoints(lines)) {\n *  // Yields a and then b of each point sequentially\n * }\n * ```\n * @param lines\n */\nexport declare function asPoints(lines: Iterable<Line>): Generator<Point, void, unknown>;\n/**\n * Returns an SVG description of line\n * ```\n * Lines.toSvgString(ptA, ptB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const toSvgString: (a: Point, b: Point) => readonly string[];\n//# sourceMappingURL=index.d.ts.map","import type { CirclePositioned } from \"./circle/circle-type.js\";\nimport type { Path } from \"./path/path-type.js\";\nimport type { Point } from \"./point/point-type.js\";\nexport type Waypoint = CirclePositioned;\nexport type WaypointOpts = {\n    readonly maxDistanceFromLine: number;\n    readonly enforceOrder: boolean;\n};\n/**\n * Create from set of points, connected in order starting at array position 0.\n * @param waypoints\n * @param opts\n * @returns\n */\nexport declare const fromPoints: (waypoints: readonly Point[], opts?: Partial<WaypointOpts>) => Waypoints;\n/**\n * Result\n */\nexport type WaypointResult = {\n    /**\n     * Path being compared against\n     */\n    path: Path;\n    /**\n     * Index of this path in original `paths` array\n     */\n    index: number;\n    /**\n     * Nearest point on path. See also {@link distance}\n     */\n    nearest: Point;\n    /**\n     * Closest distance to path. See also {@link nearest}\n     */\n    distance: number;\n    /**\n     * Rank of this result, 0 being highest.\n     */\n    rank: number;\n    /**\n     * Relative position on this path segment\n     * 0 being start, 0.5 middle and so on.\n     */\n    positionRelative: number;\n};\n/**\n * Given point `pt`, returns a list of {@link WaypointResult}, comparing\n * this point to a set of paths.\n * ```js\n * // Init once with a set of paths\n * const w = init(paths);\n * // Now call with a point to get results\n * const results = w({ x: 10, y: 20 });\n * ```\n */\nexport type Waypoints = (pt: Point) => WaypointResult[];\n/**\n * Initialise\n *\n * Options:\n * * maxDistanceFromLine: Distances greater than this are not matched. Default 0.1\n * @param paths\n * @param opts\n * @returns\n */\nexport declare const init: (paths: readonly Path[], opts?: Partial<WaypointOpts>) => Waypoints;\n//# sourceMappingURL=waypoint.d.ts.map","import type { RandomSource } from \"@ixfx/random\";\nimport { type ShapePositioned } from \"./shape/index.js\";\nimport type { Circle, CirclePositioned } from \"./circle/circle-type.js\";\nexport type RandomOpts = {\n    readonly attempts?: number;\n    readonly randomSource?: RandomSource;\n};\n/**\n * Naive randomised circle packing.\n * [Algorithm by Taylor Hobbs](https://tylerxhobbs.com/essays/2016/a-randomized-approach-to-cicle-packing)\n */\nexport declare const random: (circles: readonly Circle[], container: ShapePositioned, opts?: RandomOpts) => CirclePositioned[];\n//# sourceMappingURL=circle-packing.d.ts.map","export * as CirclePacking from './circle-packing.js';\n//# sourceMappingURL=layout.d.ts.map","import type { Point } from './point/point-type.js';\nimport type { Path } from './path/index.js';\n/**\n * An ellipse\n */\nexport type Ellipse = {\n    readonly radiusX: number;\n    readonly radiusY: number;\n    /**\n     * Rotation, in radians\n     */\n    readonly rotation?: number;\n    readonly startAngle?: number;\n    readonly endAngle?: number;\n};\n/**\n * A {@link Ellipse} with position\n */\nexport type EllipsePositioned = Point & Ellipse;\nexport declare const fromDegrees: (radiusX: number, radiusY: number, rotationDeg?: number, startAngleDeg?: number, endAngleDeg?: number) => Ellipse;\nexport type EllipticalPath = Ellipse & Path & {\n    readonly kind: `elliptical`;\n};\n//# sourceMappingURL=ellipse.d.ts.map","import type { Point } from './point/point-type.js';\n/**\n * Convert angle in degrees to angle in radians.\n * @param angleInDegrees\n * @returns\n */\nexport declare function degreeToRadian(angleInDegrees: number): number;\n/**\n * Convert angles in degrees to angles in radians\n * @param angleInDegrees\n */\nexport declare function degreeToRadian(angleInDegrees: readonly number[]): readonly number[];\n/**\n * Inverts the angle so it points in the opposite direction of a unit circle\n * @param angleInRadians\n * @returns\n */\nexport declare function radianInvert(angleInRadians: number): number;\nexport declare function degreeToGradian(angleInDegrees: number): number;\n/**\n * Returns the gradian value converted to degrees.\n * By default it wraps, so any value 360 or greater wraps around.\n * @param angleInGradians\n * @param wrap\n * @returns\n */\nexport declare function gradianToDegree(angleInGradians: number, wrap?: boolean): number;\nexport declare function radianToGradian(angleInRadians: number): number;\nexport declare function gradianToRadian(angleInGradian: number): number;\n/**\n * Convert angle in radians to angle in degrees\n * @param angleInRadians\n * @returns\n */\nexport declare function radianToDegree(angleInRadians: number): number;\n/**\n * Convert angles in radians to angles in degrees\n * @param angleInRadians\n */\nexport declare function radianToDegree(angleInRadians: readonly number[]): readonly number[];\n/**\n * Angle from x-axis to point (ie. `Math.atan2`)\n * @param point\n * @returns\n */\nexport declare const radiansFromAxisX: (point: Point) => number;\n/**\n * Sum angles together, accounting for the 'wrap around'.\n *\n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n *\n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(Math.PI, Math.PI/2, true);\n * ```\n *\n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * {@link degreesSum} is the same, but uses degrees (0..360)\n * @param start Starting angle, in radian\n * @param amount Angle to add, in radian\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in radians\n */\nexport declare const radiansSum: (start: number, amount: number, clockwise?: boolean) => number;\n/**\n * Sum angles together, accounting for the 'wrap around'.\n *\n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n *\n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(180, 90, true);\n * ```\n *\n * {@link radiansSum} is the same, but uses radians (0..2 Pi)\n *\n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Starting angle, in degrees\n * @param amount Angle to add, in degrees\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in degrees\n */\nexport declare const degreesSum: (start: number, amount: number, clockwise?: boolean) => number;\n/**\n * Computes the angle arc between a start and end angle,\n * given in radians. It properly accounts for the wrap-around\n * values.\n *\n * ```js\n * // Between 0-90deg in clockwise direction\n * radianArc(0, Math.PI/2, true); // Yields: 3Pi/2 (270 deg)\n *\n * // In counter-clockwise direction\n * radianArc(0, Math.PI/2, false); // Yields: Math.PI/2 (90deg)\n * ```\n *\n * See {@link degreeArc} to operate in degrees.\n *\n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param start Start angle, in radians\n * @param end End angle, in radians\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in radians.\n */\nexport declare const radianArc: (start: number, end: number, clockwise?: boolean) => number;\n/**\n * Computes the angle arc between a start and end angle,\n * given in degrees. It properly accounts for the wrap-around\n * values.\n *\n * ```js\n * // Between 0-90 in clockwise direction\n * degreeArc(0, 90, true); // Yields: 270\n *\n * // In counter-clockwise direction\n * degreeArc(0, 90, false); // Yields: 90\n * ```\n *\n * See {@link radianArc} to operate in radians.\n *\n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Start angle, in degrees\n * @param end End angle, in degrees\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in degrees.\n */\nexport declare const degreeArc: (start: number, end: number, clockwise?: boolean) => number;\nexport type Angle = {\n    value: number;\n    unit: `deg` | `rad` | `turn` | `grad`;\n};\n/**\n * Parses CSS-style angle strings. By default assumes degrees.\n *\n * ```js\n * angleParse(`100`);     // { value: 100, unit: `deg` }\n * angleParse(100);       // { value: 100, unit: `deg` }\n * angleParse(`100deg`);   // { value: 100, unit: `deg` }\n *\n * // More exotic units:\n * angleParse(`100rad`);  // { value: 100, unit: `rad` }\n * angleParse(`100turn`); // { value: 100, unit: `turn` }\n * angleParse(`100grad`); // { value: 100, unit: `grad` }\n * ```\n *\n * Once parsed in this format, use {@link angleConvert} to convert to\n * a different unit.\n * @param value\n * @returns\n */\nexport declare const angleParse: (value: string | number | Angle) => Angle;\n/**\n * Converts an angle to another representation.\n * Input value is assumed degrees unless it's an {@link Angle} type of has the unit.\n *\n * These are all identical inputs: 100, `100`, `100deg`\n * ```js\n * angleConvert(100, `rad`); // Converts 100deg to radians\n * ```\n *\n * Other units can be used for string input: `2turn`, `1grad`, `2rad`.\n * ```js\n * angleConvert(`2rad`, `deg`); // Converts 2radians to degrees\n * ```\n *\n * Can also use an object input:\n * ```js\n * angleConvert({ value: 10, unit: `deg`}, `rad`);\n * ```\n * @param angleOrDegrees\n * @param destination\n * @returns\n */\nexport declare const angleConvert: (angleOrDegrees: Angle | number | string, destination: Angle[`unit`]) => Angle;\n/**\n * Converts 'turns' to degrees. By defaults wraps the value, so\n * turn value of 1 or 2 equal 0deg instead of 360 or 720deg.\n * @param turns\n * @param wrap\n * @returns\n */\nexport declare const turnToDegree: (turns: number, wrap?: boolean) => number;\nexport declare const turnToRadian: (turns: number) => number;\nexport declare const degreeToTurn: (degrees: number) => number;\nexport declare const radianToTurn: (radians: number) => number;\n//# sourceMappingURL=angles.d.ts.map","import type { Point } from \"./point/point-type.js\";\n/**\n * Simplifies a curve by dropping points based on shortest distance.\n *\n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n *\n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n *\n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n *\n * @param points\n * @param epsilon\n * @returns\n */\nexport declare const rdpShortestDistance: (points: Array<Point>, epsilon?: number) => Array<Point>;\n/**\n * Simplifies a curve by dropping points based on perpendicular distance\n *\n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n *\n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n *\n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n *\n * @param points\n * @param epsilon\n * @returns\n */\nexport declare const rdpPerpendicularDistance: (points: Array<Point>, epsilon?: number) => Array<Point>;\n//# sourceMappingURL=curve-simplification.d.ts.map","import { type TraversableTree } from '@ixfx/collections';\nimport type { Point } from './point/point-type.js';\nimport type { ShapePositioned } from './shape/index.js';\nimport type { RectPositioned } from './rect/rect-types.js';\n/**\n * Options for quad tree\n */\nexport type QuadTreeOpts = {\n    /**\n     * Maximum items per node\n     */\n    readonly maxItems: number;\n    /**\n     * Maximum level of sub-division\n     */\n    readonly maxLevels: number;\n};\n/**\n * Direction\n */\nexport declare enum Direction {\n    Nw = 0,\n    Ne = 1,\n    Sw = 2,\n    Se = 3\n}\n/**\n * A Point or ShapePositioned\n */\nexport type QuadTreeItem = Point | ShapePositioned;\n/**\n * Creates a QuadTreeNode\n * @param bounds Bounds of region\n * @param initialData Initial items to place in quad tree\n * @param opts Options\n * @returns New quad tree\n */\nexport declare const quadTree: (bounds: RectPositioned, initialData?: readonly QuadTreeItem[], opts?: Partial<QuadTreeOpts>) => QuadTreeNode;\n/**\n * QuadTreeNode. The values of the node is an array of {@link QuadTreeItem}.\n *\n * To create, you probably want the {@link quadTree} function.\n *\n */\nexport declare class QuadTreeNode implements TraversableTree<QuadTreeItem[]> {\n    #private;\n    readonly boundary: RectPositioned;\n    readonly level: number;\n    readonly opts: QuadTreeOpts;\n    /**\n     * Constructor\n     * @param boundary\n     * @param level\n     * @param opts\n     */\n    constructor(parent: QuadTreeNode | undefined, boundary: RectPositioned, level: number, opts: QuadTreeOpts);\n    getLengthChildren(): number;\n    parents(): IterableIterator<QuadTreeNode>;\n    getParent(): QuadTreeNode | undefined;\n    /**\n     * Iterates over immediate children\n     */\n    children(): IterableIterator<QuadTreeNode>;\n    /**\n     * Array of QuadTreeItem\n     * @returns\n     */\n    getValue(): QuadTreeItem[];\n    getIdentity(): this;\n    /**\n     * Get a descendant node in a given direction\n     * @param d\n     * @returns\n     */\n    direction(d: Direction): QuadTreeNode | undefined;\n    /**\n     * Add an item to the quadtree\n     * @param p\n     * @returns False if item is outside of boundary, True if item was added\n     */\n    add(p: QuadTreeItem): boolean;\n    /**\n     * Returns true if point is inside node's boundary\n     * @param p\n     * @returns\n     */\n    couldHold(p: Point): boolean;\n}\n//# sourceMappingURL=quad-tree.d.ts.map","import type { Point } from './point/point-type.js';\nimport type { Rect } from './rect/index.js';\n/**\n * A scale function that takes an input value to scale.\n * Input can be in the form of `{ x, y }` or two number parameters.\n *\n * ```js\n * scale(10, 20);\n * scale({ x:10, y:20 });\n * ```\n *\n * Output range can be specified as a `{ width, height }` or two number parameters.\n * If omitted, the default range\n * is used.\n *\n * ```js\n * // Scale 10,20 with range w:800 h:600\n * scale(10, 20, 800, 600);\n * scale({x:10, y:20}, 800, 600);\n * scale({x:10, y:20}, {width: 800, height: 600});\n * ```\n */\nexport type Scaler = (a: number | Point, b?: number | Rect, c?: number | Rect, d?: number) => Point;\n/**\n * A scaler than can convert to a from an output range\n */\nexport type ScalerCombined = {\n    /**\n     * Relative to absolute coordinates\n     */\n    readonly abs: Scaler;\n    /**\n     * Absolute to relative coordintes\n     */\n    readonly rel: Scaler;\n    readonly width: number;\n    readonly height: number;\n    computeScale(): Point;\n};\nexport type ScaleBy = `both` | `min` | `max` | `width` | `height`;\n/**\n * Returns a set of scaler functions, to convert to and from ranges.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`, {width:window.innerWidth, height:window.innerHeight});\n * // Assuming screen of 800x400...\n * scaler.abs(400,200);          // Yields { x:0.5, y:0.5 }\n * scaler.abs({ x:400, y:200 }); // Yields { x:0.5, y:0.5 }\n *\n * scaler.rel(0.5, 0.5);         // Yields: { x:400, y:200 }\n * scaler.rel({ x:0.5, y:0.5 }); // Yields: { x:400, y:200 }\n * ```\n *\n * If no default range is provided, it must be given each time the scale function is used.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`);\n *\n * scaler.abs(400, 200, 800, 400);\n * scaler.abs(400, 200, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, 800, 400);\n * // All are the same, yielding { x:0.5, y:0.5 }\n *\n * scaler.abs(400, 200); // Throws an exception because there is no scale\n * ```\n * @param scaleBy Dimension to scale by\n * @param defaultRect Default range\n * @returns\n */\nexport declare const scaler: (scaleBy?: ScaleBy, defaultRect?: Rect) => ScalerCombined;\n//# sourceMappingURL=scaler.d.ts.map","import type { Line } from './line/line-type.js';\nimport type { Point } from './point/point-type.js';\nimport * as Polar from './polar/index.js';\nexport type Vector = Point | Polar.Coord;\nexport declare const fromRadians: (radians: number) => Readonly<{\n    x: number;\n    y: number;\n}>;\nexport declare const toRadians: (point: Point) => number;\n/**\n * Create a vector from a point\n *\n * If `unipolar` normalisation is used, direction will be fixed to 0..2\n * if `bipolar` normalisation is used, direction will be fixed to -...\n * @param pt Point\n * @param angleNormalisation Technique to normalise angle\n * @param origin Origin to calculate vector from or 0,0 if left empty\n * @returns\n */\nexport declare const fromPointPolar: (pt: Point, angleNormalisation?: `` | `unipolar` | `bipolar`, origin?: Point) => Polar.Coord;\n/**\n * Returns a Cartesian-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport declare const fromLineCartesian: (line: Line) => Point;\n/**\n * Returns a polar-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport declare const fromLinePolar: (line: Line) => Polar.Coord;\n/**\n * Returns the normalised vector (aka unit vector). This is where\n * direction is kept, but magnitude set to 1. This then just\n * suggests direction.\n * @param v\n * @returns\n */\nexport declare const normalise: (v: Vector) => Vector;\nexport declare const quadrantOffsetAngle: (p: Point) => number;\n/**\n * Converts a vector to a polar coordinate. If the provided\n * value is already Polar, it is returned.\n * @param v\n * @param origin\n * @returns Polar vector\n */\nexport declare const toPolar: (v: Vector, origin?: {\n    readonly x: 0;\n    readonly y: 0;\n}) => Polar.Coord;\n/**\n * Converts a Vector to a Cartesian coordinate. If the provided\n * value is already Cartesian, it is returned.\n * @param v\n * @returns Cartestian vector\n */\nexport declare const toCartesian: (v: Vector) => Point;\n/**\n * Return a human-friendly representation of vector\n * @param v\n * @param digits\n * @returns\n */\nexport declare const toString: (v: Vector, digits?: number) => string;\n/**\n * Calculate dot product of a vector\n * @param a\n * @param b\n * @returns\n */\nexport declare const dotProduct: (a: Vector, b: Vector) => number;\n/**\n * Clamps the magnitude of a vector\n * @param v Vector to clamp\n * @param max Maximum magnitude\n * @param min Minium magnitude\n * @returns\n */\nexport declare const clampMagnitude: (v: Vector, max?: number, min?: number) => Point | Polar.Coord;\n/**\n * Returns `a + b`.\n *\n * Vector is returned in the same type as `a`.\n * @param a\n * @param b\n * @returns\n */\nexport declare const sum: (a: Vector, b: Vector) => Point | Polar.Coord;\n/**\n * Returns `a - b`.\n *\n * Vector is returned in the same type as `a`\n * @param a\n * @param b\n */\nexport declare const subtract: (a: Vector, b: Vector) => Point | Polar.Coord;\n/**\n * Returns `a * b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport declare const multiply: (a: Vector, b: Vector) => Point | Polar.Coord;\n/**\n * Returns `a / b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport declare const divide: (a: Vector, b: Vector) => Point | Polar.Coord;\n//# sourceMappingURL=vector.d.ts.map","import type { Point, Point3d } from './point/point-type.js';\nimport type { Circle, CirclePositioned } from './circle/circle-type.js';\nimport type { Sphere } from './shape/index.js';\n/**\n * Options for a Vogel spiral\n */\nexport type VogelSpiralOpts = {\n    /**\n     * Upper limit of points to produce.\n     * By default, 5000.\n     */\n    readonly maxPoints?: number;\n    /**\n     * Density value (0..1) which determines spacing of points.\n     * This is useful because it scales with whatever circle radius is given\n     * Use this parameter OR the `spacing` parameter.\n     */\n    readonly density?: number;\n    /**\n     * Spacing between points.\n     * Use this option OR the density value.\n     */\n    readonly spacing?: number;\n    /**\n     * Rotation offset to apply, in radians. 0 by default\n     */\n    readonly rotation?: number;\n};\n/**\n * Generates points on a Vogel spiral - a sunflower-like arrangement of points.\n *\n * @example With no arguments, assumes a unit circle\n * ```js\n * for (const pt of circleVogelSpiral()) {\n *  // Generate points on a unit circle, with 95% density\n * }\n * ```\n *\n *\n * @example Specifying a circle and options\n * ```js\n * const circle = { radius: 100, x: 100, y: 100 };\n * const opts = {\n *  maxPoints: 50,\n *  density: 0.99\n * };\n * for (const pt of circleVogelSpiral(circle, opts)) {\n *  // Do something with point...\n * }\n * ```\n *\n * @example Array format\n * ```js\n * const ptsArray = [...circleVogelSpiral(circle, opts)];\n * ```\n * @param circle\n * @param opts\n */\nexport declare function circleVogelSpiral(circle?: Circle, opts?: VogelSpiralOpts): IterableIterator<Point>;\nexport type CircleRingsOpts = {\n    readonly rings?: number;\n    /**\n     * Rotation offset, in radians\n     */\n    readonly rotation?: number;\n};\n/**\n * Generates points spaced out on the given number of rings.\n *\n * Get points as array\n * ```js\n * const circle = { radius: 5, x: 100, y: 100 };\n * const opts = { rings: 5 };\n * const points = [...circleRings(circle, rings)];\n * ```\n *\n * Or iterate over them\n * ```js\n * for (const point of circleRings(circle, opts)) {\n * }\n * ```\n * Source: http://www.holoborodko.com/pavel/2015/07/23/generating-equidistant-points-on-unit-disk/#more-3453\n * @param circle\n */\nexport declare function circleRings(circle?: Circle | CirclePositioned, opts?: CircleRingsOpts): IterableIterator<Point>;\n/**\n * Fibonacci sphere algorithm. Generates points\n * distributed on a sphere.\n *\n * @example Generate points of a unit sphere\n * ```js\n * for (const pt of sphereFibonacci(100)) {\n *  // pt.x, pt.y, pt.z\n * }\n * ```\n *\n * @example Generate points into an array\n * ```js\n * const sphere = { radius: 10, x: 10, y: 200 }\n * const pts = [...sphereFibonacci(100, 0, sphere)];\n * ```\n *\n * Source: https://codepen.io/elchininet/pen/vXeRyL\n *\n * @param samples\n * @returns\n */\nexport declare function sphereFibonacci(samples?: number, rotationRadians?: number, sphere?: Sphere): IterableIterator<Point3d>;\n//# sourceMappingURL=surface-points.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Return the three interior angles of the triangle, in radians.\n * @param t\n * @returns\n */\nexport declare const angles: (t: Triangle) => ReadonlyArray<number>;\n/**\n * Returns the three interior angles of the triangle, in degrees\n * @param t\n * @returns\n */\nexport declare const anglesDegrees: (t: Triangle) => ReadonlyArray<number>;\n//# sourceMappingURL=angles.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Calculates the area of a triangle\n * @param t\n * @returns\n */\nexport declare const area: (t: Triangle) => number;\n//# sourceMappingURL=area.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { BarycentricCoord, Triangle } from \"./triangle-type.js\";\n/**\n * Returns the [Barycentric coordinate](https://en.wikipedia.org/wiki/Barycentric_coordinate_system) of a point within a triangle\n *\n * @param t\n * @param a\n * @param b\n * @returns\n */\nexport declare const barycentricCoord: (t: Triangle, a: Point | number, b?: number) => BarycentricCoord;\n/**\n * Convert Barycentric coordinate to Cartesian\n * @param t\n * @param bc\n * @returns\n */\nexport declare const barycentricToCartestian: (t: Triangle, bc: BarycentricCoord) => Point;\n//# sourceMappingURL=barycentric.d.ts.map","import type { RectPositioned } from \"../rect/rect-types.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns the bounding box that encloses the triangle.\n * @param t\n * @param inflation If specified, box will be inflated by this much. Default: 0.\n * @returns\n */\nexport declare const bbox: (t: Triangle, inflation?: number) => RectPositioned;\n//# sourceMappingURL=bbox.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns simple centroid of triangle\n * @param t\n * @returns\n */\nexport declare const centroid: (t: Triangle) => Point;\n//# sourceMappingURL=centroid.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns the corners (vertices) of the triangle as an array of points\n * @param t\n * @returns Array of length three\n */\nexport declare const corners: (t: Triangle) => ReadonlyArray<Point>;\n//# sourceMappingURL=corners.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * A triangle consisting of three empty points (Points.Empty)\n */\nexport declare const Empty: Readonly<{\n    a: {\n        x: number;\n        y: number;\n    };\n    b: {\n        x: number;\n        y: number;\n    };\n    c: {\n        x: number;\n        y: number;\n    };\n}>;\n/**\n * A triangle consisting of three placeholder points (Points.Placeholder)\n */\nexport declare const Placeholder: Readonly<{\n    a: {\n        x: number;\n        y: number;\n    };\n    b: {\n        x: number;\n        y: number;\n    };\n    c: {\n        x: number;\n        y: number;\n    };\n}>;\n/**\n * Returns a triangle anchored at `origin` with a given `length` and `angleRadian`.\n * The origin will be point `b` of the triangle, and the angle will be the angle for b.\n * @param origin Origin\n * @param length Length\n * @param angleRadian Angle\n * @returns\n */\nexport declare const equilateralFromVertex: (origin?: Point, length?: number, angleRadian?: number) => Triangle;\n//# sourceMappingURL=create.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\nimport type { PolyLine } from \"../line/line-type.js\";\n/**\n * Returns the edges (ie sides) of the triangle as an array of lines\n * @param t\n * @returns Array of length three\n */\nexport declare const edges: (t: Triangle) => PolyLine;\n//# sourceMappingURL=edges.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\n/**\n * Returns an equilateral triangle centered at the origin.\n *\n * ```js\n * // Create a triangle at 100,100 with radius of 60\n * const tri = fromRadius({x:100,y:100}, 60);\n *\n * // Triangle with point A upwards, B to the right, C to the left\n * constr tri2 = fromRadius({x:100,y:100}, 60, {initialAngleRadian: -Math.PI / 2});\n * ```\n *\n *\n * @param origin Origin\n * @param radius Radius of triangle\n * @param opts Options\n */\nexport declare const fromRadius: (origin: Point, radius: number, opts?: {\n    readonly initialAngleRadian?: number;\n}) => Triangle;\n/**\n * Returns a triangle from a set of coordinates in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param coords\n * @returns\n */\nexport declare const fromFlatArray: (coords: readonly number[]) => Triangle;\n/**\n * Returns a triangle from an array of three points\n * @param points\n * @returns\n */\nexport declare const fromPoints: (points: readonly Point[]) => Triangle;\n//# sourceMappingURL=from.d.ts.map","import type { CirclePositioned } from \"../circle/circle-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns the largest circle enclosed by triangle `t`.\n * @param t\n */\nexport declare const innerCircle: (t: Triangle) => CirclePositioned;\n//# sourceMappingURL=inner-circle.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns true if point is within or on the boundary of triangle\n * @param t\n * @param a\n * @param b\n */\nexport declare const intersectsPoint: (t: Triangle, a: Point | number, b?: number) => boolean;\n//# sourceMappingURL=intersects.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns true if it is an equilateral triangle\n * @param t\n * @returns\n */\nexport declare const isEquilateral: (t: Triangle) => boolean;\n/**\n * Returns true if it is an isosceles triangle\n * @param t\n * @returns\n */\nexport declare const isIsosceles: (t: Triangle) => boolean;\n/**\n * Returns true if at least one interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport declare const isRightAngle: (t: Triangle) => boolean;\n/**\n * Returns true if triangle is oblique: No interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport declare const isOblique: (t: Triangle) => boolean;\n/**\n * Returns true if triangle is actue: all interior angles less than 90 degrees\n * @param t\n * @returns\n */\nexport declare const isAcute: (t: Triangle) => boolean;\n/**\n * Returns true if triangle is obtuse: at least one interior angle is greater than 90 degrees\n * @param t\n * @returns\n */\nexport declare const isObtuse: (t: Triangle) => boolean;\n//# sourceMappingURL=kinds.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns the lengths of the triangle sides\n * @param t\n * @returns Array of length three\n */\nexport declare const lengths: (t: Triangle) => ReadonlyArray<number>;\n//# sourceMappingURL=lengths.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Applies `fn` to each of a triangle's corner points, returning the result.\n *\n * @example Add some random to the x of each corner\n * ```\n * const t = apply(tri, p => {\n *  const r = 10;\n *  return {\n *    x: p.x + (Math.random()*r*2) - r,\n *    y: p.y\n *  }\n * });\n * ```\n * @param t\n * @param fn\n * @returns\n */\nexport declare const apply: (t: Triangle, fn: (p: Point, label?: string) => Point) => Readonly<Triangle>;\n//# sourceMappingURL=math.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\nimport type { CirclePositioned } from '../circle/circle-type.js';\n/**\n * Returns the largest circle touching the corners of triangle `t`.\n * @param t\n * @returns\n */\nexport declare const outerCircle: (t: Triangle) => CirclePositioned;\n//# sourceMappingURL=outer-circle.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Calculates perimeter of a triangle\n * @param t\n * @returns\n */\nexport declare const perimeter: (t: Triangle) => number;\n//# sourceMappingURL=perimeter.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns a triangle that is rotated by `angleRad`. By default it rotates\n * around its center but an arbitrary `origin` point can be provided.\n *\n * ```js\n * let triangle = Triangles.fromPoints([a, b, c]);\n *\n * // Rotate triangle by 5 degrees\n * triangle = Triangles.rotate(triangle, degreeToRadian(5));\n *\n * // Rotate by 90 degrees\n * triangle = Triangles.rotate(triangle, Math.PI / 2);\n * ```\n * @param triangle Triangle to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of triangle will be used\n * @returns A new triangle\n */\nexport declare const rotate: (triangle: Triangle, amountRadian?: number, origin?: Point) => Triangle;\n/**\n * Rotates the vertices of the triangle around one point (by default, `b`), returning\n * as a new object.\n *\n * ```js\n * let triangle = Triangles.fromPoints([a, b, c]);\n * triangle = Triangles.rotateByVertex(triangle, Math.Pi, `a`);\n * ```\n * @param triangle Triangle\n * @param amountRadian Angle to rotate by\n * @param vertex Name of vertex: a, b or c.\n * @returns A new triangle\n */\nexport declare const rotateByVertex: (triangle: Triangle, amountRadian: number, vertex?: `a` | `b` | `c`) => Triangle;\n//# sourceMappingURL=rotate.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns the coordinates of triangle in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param t\n * @returns\n */\nexport declare const toFlatArray: (t: Triangle) => readonly number[];\n//# sourceMappingURL=to.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Throws an exception if the triangle is invalid\n * @param t\n * @param name\n */\nexport declare const guard: (t: Triangle, name?: string) => void;\n/**\n * Returns true if the parameter appears to be a valid triangle\n * @param p\n * @returns\n */\nexport declare const isTriangle: (p: unknown) => p is Triangle;\n/**\n * Returns true if triangle is empty\n * @param t\n * @returns\n */\nexport declare const isEmpty: (t: Triangle) => boolean;\n/**\n * Returns true if triangle is a placeholder\n * @param t\n * @returns\n */\nexport declare const isPlaceholder: (t: Triangle) => boolean;\n/**\n * Returns true if the two parameters have equal values\n * @param a\n * @param b\n * @returns\n */\nexport declare const isEqual: (a: Triangle, b: Triangle) => boolean;\n//# sourceMappingURL=guard.d.ts.map","import type { Circle } from \"../circle/circle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nexport type TriangleEquilateral = {\n    readonly length: number;\n} | number;\n/**\n * Returns a positioned `Triangle` from an equilateral triangle definition.\n * By default the rotation is such that point `a` and `c` are lying on the horizontal,\n * and `b` is the upward-facing tip.\n *\n * Default is a triangle pointing upwards with b at the top, c to the left and b to right on the baseline.\n *\n * Example rotation values in radians:\n * *  0: a and c on vertical, b at the tip\n * *  Math.PI: `c`and `a` are on vertical, with `b` at the tip.\n * *  Math.PI/2: `c` and `a` are on horizontal, `c` to the left. `b` at the bottom.\n * *  Math.PI*1.5: `c` and `a` are on horizontal, `c` to the right. `b` at the top. (default)\n * @param t\n * @param origin\n * @param rotationRad\n * @returns\n */\nexport declare const fromCenter: (t: TriangleEquilateral, origin?: Point, rotationRad?: number) => Triangle;\n/**\n * Calculate center from the given point A\n * @param t\n * @param ptA\n * @returns\n */\nexport declare const centerFromA: (t: TriangleEquilateral, ptA?: Point) => Point;\n/**\n * Calculate center from the given point B\n * @param t\n * @param ptB\n * @returns\n */\nexport declare const centerFromB: (t: TriangleEquilateral, ptB?: Point) => Point;\n/**\n * Calculate center from the given point C\n * @param t\n * @param ptC\n * @returns\n */\nexport declare const centerFromC: (t: TriangleEquilateral, ptC?: Point) => Point;\n/**\n * Returns the height (or rise) of an equilateral triangle.\n * Ie. from one vertex to the perpendicular edge.\n * (line marked x in the diagram below)\n *\n * ```\n *      .\n *     .x .\n *    . x  .\n *   .  x   .\n *  ..........\n * ```\n * @param t\n */\nexport declare const height: (t: TriangleEquilateral) => number;\nexport declare const perimeter: (t: TriangleEquilateral) => number;\nexport declare const area: (t: TriangleEquilateral) => number;\n/**\n * Circle that encompasses all points of triangle\n * @param t\n */\nexport declare const circumcircle: (t: TriangleEquilateral) => Circle;\n/**\n * Circle that is inside the edges of the triangle\n * @param t\n * @returns\n */\nexport declare const incircle: (t: TriangleEquilateral) => Circle;\n//# sourceMappingURL=equilateral.d.ts.map","import type { Circle } from \"../circle/circle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nexport type Right = {\n    readonly adjacent?: number;\n    readonly hypotenuse?: number;\n    readonly opposite?: number;\n};\nexport type DefinedRight = {\n    readonly adjacent: number;\n    readonly hypotenuse: number;\n    readonly opposite: number;\n};\n/**\n * Returns a positioned triangle from a point for A.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport declare const fromA: (t: Right, origin?: Point) => Triangle;\n/**\n * Returns a positioned triangle from a point for B.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport declare const fromB: (t: Right, origin?: Point) => Triangle;\n/**\n * Returns a positioned triangle from a point for C.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n *\n *\n * ```js\n * // Triangle pointing up to 0,0 with sides of 15\n * Triangles.Right.fromC({ adjacent: 15, opposite:15 }, { x: 0, y: 0 });\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport declare const fromC: (t: Right, origin?: Point) => Triangle;\n/**\n * Returns a right triangle with all lengths defined.\n * At least two lengths must already exist\n * @param t\n * @returns\n */\nexport declare const resolveLengths: (t: Right) => DefinedRight;\n/**\n * Height of right-triangle\n * @param t\n * @returns\n */\nexport declare const height: (t: Right) => number;\n/**\n * Returns the lengths of the hypotenuse split into p and q segments.\n * In other words, if one makes a line from the right-angle vertex down to hypotenuse.\n *\n * [See here](https://rechneronline.de/pi/right-triangle.php)\n * @param t\n * @returns\n */\nexport declare const hypotenuseSegments: (t: Right) => readonly [p: number, q: number];\nexport declare const perimeter: (t: Right) => number;\nexport declare const area: (t: Right) => number;\n/**\n * Angle (in radians) between hypotenuse and adjacent edge\n * @param t\n * @returns\n */\nexport declare const angleAtPointA: (t: Right) => number;\n/**\n * Angle (in radians) between opposite edge and hypotenuse\n * @param t\n * @returns\n */\nexport declare const angleAtPointB: (t: Right) => number;\n/**\n * Returns the median line lengths a, b and c in an array.\n *\n * The median lines are the lines from each vertex to the center.\n *\n * @param t\n * @returns\n */\nexport declare const medians: (t: Right) => readonly [a: number, b: number, c: number];\n/**\n * The circle which passes through the points of the triangle\n * @param t\n * @returns\n */\nexport declare const circumcircle: (t: Right) => Circle;\n/**\n * Circle enclosed by triangle\n * @param t\n * @returns\n */\nexport declare const incircle: (t: Right) => Circle;\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param adjacent\n * @returns\n */\nexport declare const oppositeFromAdjacent: (angleRad: number, adjacent: number) => number;\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param hypotenuse\n * @returns\n */\nexport declare const oppositeFromHypotenuse: (angleRad: number, hypotenuse: number) => number;\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param hypotenuse\n * @returns\n */\nexport declare const adjacentFromHypotenuse: (angleRadian: number, hypotenuse: number) => number;\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport declare const adjacentFromOpposite: (angleRadian: number, opposite: number) => number;\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport declare const hypotenuseFromOpposite: (angleRadian: number, opposite: number) => number;\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param adjacent\n * @returns\n */\nexport declare const hypotenuseFromAdjacent: (angleRadian: number, adjacent: number) => number;\n//# sourceMappingURL=right.d.ts.map","import type { Circle } from \"../circle/circle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nexport type Isosceles = {\n    readonly legs: number;\n    readonly base: number;\n};\nexport declare const baseAngle: (t: Isosceles) => number;\nexport declare const apexAngle: (t: Isosceles) => number;\nexport declare const height: (t: Isosceles) => number;\nexport declare const legHeights: (t: Isosceles) => number;\nexport declare const perimeter: (t: Isosceles) => number;\nexport declare const area: (t: Isosceles) => number;\nexport declare const circumcircle: (t: Isosceles) => Circle;\nexport declare const incircle: (t: Isosceles) => Circle;\nexport declare const medians: (t: Isosceles) => readonly [a: number, b: number, c: number];\n/**\n * Returns a positioned `Triangle` based on a center origin.\n * Center is determined by the intesecting of the medians.\n *\n * See: https://rechneronline.de/pi/isosceles-triangle.php\n * @param t\n * @param origin\n * @returns\n */\nexport declare const fromCenter: (t: Isosceles, origin?: Point) => Triangle;\nexport declare const fromA: (t: Isosceles, origin?: Point) => Triangle;\nexport declare const fromB: (t: Isosceles, origin?: Point) => Triangle;\nexport declare const fromC: (t: Isosceles, origin?: Point) => Triangle;\n//# sourceMappingURL=isosceles.d.ts.map","export type * from './triangle-type.js';\nexport * from './angles.js';\nexport * from './area.js';\nexport * from './barycentric.js';\nexport * from './bbox.js';\nexport * from './centroid.js';\nexport * from './corners.js';\nexport * from './create.js';\nexport * from './edges.js';\nexport * from './from.js';\nexport * from './inner-circle.js';\nexport * from './intersects.js';\nexport * from './kinds.js';\nexport * from './lengths.js';\nexport * from './math.js';\nexport * from './outer-circle.js';\nexport * from './perimeter.js';\nexport * from './rotate.js';\nexport * from './to.js';\nexport * from './guard.js';\n/**\n * Functions for working with equilateral triangles, defined by length\n */\nexport * as Equilateral from './equilateral.js';\n/**\n * Functions for working with right-angled triangles, defined by two of three edges\n */\nexport * as Right from './right.js';\nexport * as Isosceles from './isosceles.js';\n/**\n* Triangle.\n*\n* Helpers for creating:\n*  - {@link Triangles.fromFlatArray}: Create from [x1, y1, x2, y2, x3, y3]\n*  - {@link Triangles.fromPoints}: Create from three `{x,y}` sets\n*  - {@link Triangles.fromRadius}: Equilateral triangle of a given radius and center\n*/\n//# sourceMappingURL=index.d.ts.map","/**\n * Arcs are a angle-limited circle. Essentially describing a wedge.\n */\nexport * as Arcs from './arc/index.js';\nexport type * from './arc/arc-type.js';\nexport * as Beziers from './bezier/index.js';\nexport type * from './bezier/bezier-type.js';\n/**\n * A circle is defined as having a radius\n */\nexport * as Circles from './circle/index.js';\nexport type * from './circle/circle-type.js';\nexport * as Grids from './grid/index.js';\nexport type * from './grid/types.js';\nexport * as Lines from './line/index.js';\nexport type * from './line/line-path-type.js';\nexport type * from './line/line-type.js';\nexport * as Paths from './path/index.js';\nexport type * from './path/path-type.js';\nexport * as Points from './point/index.js';\nexport type * from './point/point-type.js';\nexport type * from './point/point-relation-types.js';\n/**\n * Work with Polar coordinates.\n * A {@link Polar.Coord} is just `{ angleRadians:number, distance: number }`.\n *\n * Conversion: {@link toCartesian}, {@link fromCartesian}, {@link toString}\n *\n * Math: {@link divide}, {@link invert}, {@link multiply}, {@link dotProduct}\n *\n * Geometric manipulations: {@link rotate}, {@link rotateDegrees}\n *\n * Cleaning: {@link clampMagnitude}, {@link normalise}\n *\n * Debugging: {@link toString}\n *\n * Comparisons: {@link isAntiParallel}, {@link isOpposite}, {@link isParallel}, {@link isPolarCoord}\n */\nexport * as Polar from './polar/index.js';\nexport type * from './polar/types.js';\nexport * as Rects from './rect/index.js';\nexport type * from './rect/rect-types.js';\n/**\n * Generate a few basic geometric shapes\n * Overview:\n * * {@link arrow}\n * * {@link starburst}\n */\nexport * as Shapes from './shape/index.js';\nexport type * from './shape/shape-type.js';\nexport * as Waypoints from './waypoint.js';\nexport * as Layouts from './layout.js';\nexport * from './point/point-tracker.js';\nexport * as Compound from './path/compound-path.js';\nexport * as Ellipses from './ellipse.js';\nexport * from './angles.js';\nexport * as CurveSimplification from './curve-simplification.js';\n/**\n * Quad tree is a datastructure for efficiently determining whether\n * a point/shape is at a location\n * - {@link quadTree}: Create a quad tree\n */\nexport * as QuadTree from './quad-tree.js';\nexport * from './scaler.js';\n/**\n * Helper functions for working with vectors, which can either be a {@link Points.Point} or Polar {@link Polar.Coord}.\n * While most of the functionality is provided in either of those modules, the Vector module lets you cleanly\n * interoperate between these two coordinates.\n */\nexport * as Vectors from './vector.js';\n/**\n * Functions for producing points within a shape.\n * Useful for creating patterns.\n *\n * Overview:\n * * {@link sphereFibonacci}: Generate points on a sphere\n * * {@link circleVogelSpiral}: Generate a sunflower-esque pattern of points in a circle\n */\nexport * as SurfacePoints from './surface-points.js';\n/**\n * Triangle processing.\n *\n * Helpers for creating:\n * - {@link Triangles.fromFlatArray}: Create from `[ aX, aY, bX, bY, cX, cY ]`\n * - {@link Triangles.fromPoints}: Create from an array of three Points.\n * - {@link Triangles.fromRadius}: Equilateral triangle of a given radius and center\n *\n * There are sub-modules for dealing with particular triangles:\n * - {@link Triangles.Equilateral}: Equilateral triangls\n * - {@link Triangles.Right}: Right-angled triangles\n * - {@link Triangles.Isosceles}: Iscosceles triangles\n *\n * Calculations\n * - {@link angles}: Internal angles in radians. {@link anglesDegrees} for degrees.\n * - {@link area}: Area of triangle\n * - {@link bbox}: Bounding box\n * - {@link centroid}: Centroid of triangle\n * - {@link perimeter}: Calculate perimeter\n * - {@link lengths}: Return array lengths of triangle's edges\n * - {@link rotate}, {@link rotateByVertex}\n *\n * Conversions\n * - {@link edges}: Edges of triangle as {@link Lines.Line}\n * - {@link corners}: Corner positions\n * - {@link innerCircle}: Largest circle to fit within triangle\n * - {@link outerCircle}: Largest circle to enclose triangle\n * - {@link toFlatArray}: Returns an array of coordinates: `[aX, aY, bX, bY, cX, cY]`\n *\n * Comparisons\n * - {@link intersectsPoint}: Whether a point intersects triangle\n * - {@link isEqual}: Check whether two triangles have equal values\n * - {@link isAcute}, {@link isEquilateral}, {@link isIsosceles}, {@link isRightAngle}\n * - {@link isTriangle}: Returns true if object has expected properties of a triangle\n */\nexport * as Triangles from './triangle/index.js';\nexport type * from './triangle/triangle-type.js';\n//# sourceMappingURL=index.d.ts.map"],"mappings":"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"}