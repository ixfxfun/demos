{"version":3,"file":"trackers.js","names":["#store","#keyString","keyString?: ToString<V>","value: V | string","freq: number | undefined","sortStyle: KeyValueSortSyles","opts: TrackedValueOpts","opts?: TrackedValueOpts","limit: number","reason: TrimReason","rawValues: V[]","last: TimestampedPrimitive<V>","values: TimestampedPrimitive<V>[]","reason: TrimReason","values: TimestampedPrimitive<number>[]","r: NumberTrackerResults","opts: TrackedValueOpts","options?: TrackedValueOpts","opts: Partial<RateTrackerOpts>","#resetAfterSamples","#sampleLimit","#resetTimer","#fromTime","#events","intervals: number[]","opts: TrackedValueOpts","reason: TrimReason","limit: number","p: V[] | TimestampedObject<V>[]","creator: (key: string, start: V | undefined) => T","id: string"],"sources":["../packages/trackers/src/frequency-mutable.ts","../packages/trackers/src/tracker-base.ts","../packages/trackers/src/primitive-tracker.ts","../packages/trackers/src/number-tracker.ts","../packages/trackers/src/interval-tracker.ts","../packages/trackers/src/rate-tracker.ts","../packages/trackers/src/object-tracker.ts","../packages/trackers/src/tracked-value.ts"],"sourcesContent":["import { keyValueSorter, type KeyValue, type KeyValueSortSyles, type ToString } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events';\nimport { numberArrayCompute } from '@ixfx/numbers';\n\nexport type FrequencyEventMap = {\n  readonly change: { context: unknown };\n};\n\n/**\n * Frequency keeps track of how many times a particular value is seen, but\n * unlike a Map it does not store the data. By default compares\n * items by value (via JSON.stringify).\n *\n * Fires `change` event when items are added or it is cleared.\n *\n * Overview\n * ```\n * const fh = new FrequencyTracker();\n * fh.add(value); // adds a value\n * fh.clear();    // clears all data\n * fh.keys() / .values() // returns an iterator for keys and values\n * fh.toArray();  //  returns an array of data in the shape [[key,freq],[key,freq]...]\n * ```\n *\n * Usage\n * ```\n * const fh = new FrequencyTracker();\n * fh.add(`apples`); // Count an occurence of `apples`\n * fh.add(`oranges)`;\n * fh.add(`apples`);\n *\n * const fhData = fh.toArray(); // Expect result [[`apples`, 2], [`oranges`, 1]]\n * fhData.forEach((d) => {\n *  const [key,freq] = d;\n *  console.log(`Key '${key}' occurred ${freq} time(s).`);\n * })\n * ```\n *\n * Custom key string\n * ```\n * const fh = frequency( person => person.name);\n * // All people with name `Samantha` will be counted in same group\n * fh.add({name:`Samantha`, city:`Brisbane`});\n * ```\n * @typeParam V - Type of items\n */\nexport class FrequencyTracker<V> extends SimpleEventEmitter<FrequencyEventMap> {\n  readonly #store: Map<string, number>;\n  readonly #keyString: ToString<V>;\n\n  /**\n   * Constructor\n   * @param keyString Function to key items. Uses JSON.stringify by default\n   */\n  constructor(keyString?: ToString<V>) {\n    super();\n    this.#store = new Map();\n\n    if (typeof keyString === `undefined`) {\n      keyString = (a) => {\n        if (a === undefined) throw new Error(`Cannot create key for undefined`);\n        return typeof a === `string` ? a : JSON.stringify(a);\n      };\n    }\n    this.#keyString = keyString;\n  }\n\n  /**\n   * Clear data. Fires `change` event\n   */\n  clear() {\n    this.#store.clear();\n    this.fireEvent(`change`, { context: this });\n  }\n\n  /**\n   * @returns Iterator over keys (ie. groups)\n   */\n  keys(): IterableIterator<string> {\n    return this.#store.keys();\n  }\n\n  /**\n   * @returns Iterator over frequency counts\n   */\n  values(): IterableIterator<number> {\n    return this.#store.values();\n  }\n\n  /**\n   * @returns Copy of entries as an array of `[key, count]`\n   */\n  toArray(): [ key: string, count: number ][] {\n    return [ ...this.#store.entries() ];\n  }\n\n  /**\n   * Returns a string with keys and counts, useful for debugging.\n   * @returns\n   */\n  debugString(): string {\n    let t = ``;\n    for (const [ key, count ] of this.#store.entries()) {\n      t += `${ key }: ${ count.toString() }, `;\n    }\n    if (t.endsWith(`, `)) return t.slice(0, Math.max(0, t.length - 2));\n    return t;\n  }\n\n  /**\n   *\n   * @param value Value to count\n   * @returns Frequency of value, or _undefined_ if it does not exist\n   */\n  frequencyOf(value: V | string): number | undefined {\n    if (typeof value === `string`) return this.#store.get(value);\n\n    const key = this.#keyString(value);\n    return this.#store.get(key);\n  }\n\n  /**\n   *\n   * @param value Value to count\n   * @returns Relative frequency of `value`, or _undefined_ if it does not exist\n   */\n  relativeFrequencyOf(value: V | string): number | undefined {\n    let freq: number | undefined;\n    if (typeof value === `string`) freq = this.#store.get(value);\n    else {\n      const key = this.#keyString(value);\n      freq = this.#store.get(key);\n    }\n    if (freq === undefined) return;\n\n    const mma = this.computeValues();\n    return freq / mma.total;\n  }\n\n  /**\n   * Returns copy of entries as an array\n   * @returns Copy of entries as an array\n   */\n  entries(): KeyValue[] {\n    return [ ...this.#store.entries() ];\n  }\n\n  /**\n   * Calculate min,max,avg,total & count from values\n   * @returns Returns `{min,max,avg,total}`\n   */\n  computeValues() {\n    const valuesAsNumbers = [ ...this.values() ];\n    return numberArrayCompute(valuesAsNumbers);\n  }\n\n  /**\n   * Return entries sorted\n   * @param sortStyle Sorting style (default: _value_, ie. count)\n   * @returns Sorted array of [key,frequency]\n   */\n  entriesSorted(\n    sortStyle: KeyValueSortSyles = `value`\n  ): readonly KeyValue[] {\n    const s = keyValueSorter(sortStyle);\n    return s(this.entries());\n  }\n\n  /**\n   * Add one or more values, firing _change_ event.\n   * @param values Values to add. Fires _change_ event after adding item(s)\n   */\n  add(...values: V[]) {\n    if (typeof values === `undefined`) throw new Error(`Param 'values' undefined`);\n\n    const keys = values.map(v => this.#keyString(v));\n\n    //const key = this.#keyString(value);\n    for (const key of keys) {\n      const score = this.#store.get(key) ?? 0;\n      this.#store.set(key, score + 1);\n    }\n    this.fireEvent(`change`, { context: this });\n  }\n}\n\n\nexport const frequency = <V>(keyString?: ToString<V>) =>\n  new FrequencyTracker<V>(keyString);\n","import type { Timestamped, TrackedValueOpts, TrimReason } from './types.js';\n\n/**\n * Base tracker class\n */\nexport abstract class TrackerBase<V, SeenResultType> {\n  /**\n   * @ignore\n   */\n  seenCount: number;\n\n  /**\n   * @ignore\n   */\n  protected storeIntermediate: boolean;\n\n  /**\n   * @ignore\n   */\n  protected resetAfterSamples: number;\n\n  /**\n   * @ignore\n   */\n  protected sampleLimit: number;\n\n  public readonly id: string;\n\n  protected debug: boolean;\n\n  constructor(opts: TrackedValueOpts = {}) {\n    this.id = opts.id ?? `tracker`;\n    this.debug = opts.debug ?? false;\n    this.sampleLimit = opts.sampleLimit ?? -1;\n    this.resetAfterSamples = opts.resetAfterSamples ?? -1;\n\n    this.storeIntermediate =\n      opts.storeIntermediate ??\n      (this.sampleLimit > -1 || this.resetAfterSamples > -1);\n    this.seenCount = 0;\n\n    if (this.debug) {\n      console.log(`TrackerBase: sampleLimit: ${ this.sampleLimit } resetAfter: ${ this.resetAfterSamples } store: ${ this.storeIntermediate }`);\n    }\n  }\n\n  /**\n   * Reset tracker\n   */\n  reset() {\n    this.seenCount = 0;\n    this.onReset();\n  }\n\n  /**\n   * Adds a value, returning computed result.\n   *  \n   * At this point, we check if the buffer is larger than `resetAfterSamples`. If so, `reset()` is called.\n   * If not, we check `sampleLimit`. If the buffer is twice as large as sample limit, `trimStore()` is\n   * called to take it down to sample limit, and `onTrimmed()` is called.\n   * @param p \n   * @returns \n   */\n  seen(...p: V[]): SeenResultType {\n    if (this.resetAfterSamples > 0 && this.seenCount > this.resetAfterSamples) {\n      this.reset();\n    } else if (this.sampleLimit > 0 && this.seenCount > this.sampleLimit * 2) {\n      this.seenCount = this.trimStore(this.sampleLimit);\n      this.onTrimmed(`resize`);\n    }\n\n    this.seenCount += p.length;\n    const t = this.filterData(p);\n    return this.computeResults(t);\n  }\n\n  /**\n   * @ignore\n   * @param p\n   */\n  abstract filterData(p: V[]): Timestamped[];\n\n  abstract get last(): V | undefined;\n\n  /**\n   * Returns the initial value, or undefined\n   */\n  abstract get initial(): V | undefined;\n\n  /**\n   * Returns the elapsed milliseconds since the initial value\n   */\n  abstract get elapsed(): number;\n\n  /**\n   * @ignore\n   */\n\n  abstract computeResults(_p: Timestamped[]): SeenResultType;\n\n  /**\n   * @ignore\n   */\n  abstract onReset(): void;\n\n\n  /**\n   * Notification that buffer has been trimmed\n   */\n  abstract onTrimmed(reason: TrimReason): void;\n  abstract trimStore(limit: number): number;\n}\n\n\n","import type { TrackedValueOpts, TrimReason, TimestampedPrimitive } from \"./types.js\";\nimport { TrackerBase } from \"./tracker-base.js\";\n\n\nexport abstract class PrimitiveTracker<\n  V extends number | string,\n  TResult\n> extends TrackerBase<V, TResult> {\n  values: V[];\n  timestamps: number[];\n\n  constructor(opts?: TrackedValueOpts) {\n    super(opts);\n    this.values = [];\n    this.timestamps = [];\n  }\n\n  /**\n   * Reduces size of value store to `limit`. Returns\n   * number of remaining items\n   * @param limit\n   */\n  trimStore(limit: number): number {\n    if (limit >= this.values.length) return this.values.length;\n    this.values = this.values.slice(-limit);\n    this.timestamps = this.timestamps.slice(-limit);\n    return this.values.length;\n  }\n\n  onTrimmed(reason: TrimReason) {\n    // no-op\n  }\n\n  get last(): V | undefined {\n    return this.values.at(-1);\n  }\n\n  get initial(): V | undefined {\n    return this.values.at(0);\n  }\n\n  /**\n   * Returns number of recorded values (this can include the initial value)\n   */\n  get size() {\n    return this.values.length;\n  }\n\n  /**\n   * Returns the elapsed time, in milliseconds since the instance was created\n   */\n  get elapsed(): number {\n    if (this.values.length < 0) throw new Error(`No values seen yet`);\n    return Date.now() - this.timestamps[ 0 ];\n  }\n\n  onReset() {\n    this.values = [];\n    this.timestamps = [];\n  }\n\n  /**\n   * Tracks a value\n   */\n  filterData(rawValues: V[]): TimestampedPrimitive<V>[] {\n    const lastValue = rawValues.at(-1);\n    const last: TimestampedPrimitive<V> = { value: lastValue as unknown as V, at: performance.now() };\n\n    const values: TimestampedPrimitive<V>[] = rawValues.map(value => ({\n      at: performance.now(),\n      value: value\n    }));\n\n    //const now = Date.now();\n    if (this.storeIntermediate) {\n      this.values.push(...rawValues);\n      this.timestamps.push(...values.map(v => v.at));\n    } else switch (this.values.length) {\n      case 0: {\n        // Add as initial value\n        this.values.push(last.value);\n        this.timestamps.push(last.at);\n        break;\n      }\n      case 2: {\n        // Replace last value\n        this.values[ 1 ] = last.value;\n        this.timestamps[ 1 ] = last.at;\n        break;\n      }\n      case 1: {\n        // Add last value\n        this.values.push(last.value);\n        this.timestamps.push(last.at);\n        break;\n      }\n      // No default\n    }\n\n    return values;\n  }\n}\n","import { PrimitiveTracker } from \"./primitive-tracker.js\";\nimport type { TimestampedPrimitive, TrackedValueOpts, TrimReason } from './types.js';\nimport { minFast, maxFast, totalFast } from \"@ixfx/numbers\";\n\nexport type NumberTrackerResults = {\n  readonly total: number\n  readonly min: number\n  readonly max: number\n  readonly avg: number\n};\n\nexport class NumberTracker extends PrimitiveTracker<number, NumberTrackerResults> {\n  total = 0;\n  min = Number.MAX_SAFE_INTEGER;\n  max = Number.MIN_SAFE_INTEGER;\n\n\n  get avg() {\n    return this.total / this.seenCount;\n  }\n\n  /**\n   * Difference between last value and initial.\n   * Eg. if last value was 10 and initial value was 5, 5 is returned (10 - 5)\n   * If either of those is missing, undefined is returned\n   */\n  difference(): number | undefined {\n    if (this.last === undefined) return;\n    if (this.initial === undefined) return;\n    return this.last - this.initial;\n  }\n\n  /**\n   * Relative difference between last value and initial.\n   * Eg if last value was 10 and initial value was 5, 2 is returned (200%)\n   */\n  relativeDifference(): number | undefined {\n    if (this.last === undefined) return;\n    if (this.initial === undefined) return;\n    return this.last / this.initial;\n  }\n\n  onReset() {\n    this.min = Number.MAX_SAFE_INTEGER;\n    this.max = Number.MIN_SAFE_INTEGER;\n    this.total = 0;\n    super.onReset();\n  }\n\n  /**\n   * When trimmed, recomputes to set total/min/max to be based on\n   * current values.\n   * @param reason \n   */\n  onTrimmed(reason: TrimReason) {\n    this.min = minFast(this.values);\n    this.max = maxFast(this.values);\n    this.total = totalFast(this.values);\n  }\n\n  computeResults(values: TimestampedPrimitive<number>[]): NumberTrackerResults {\n    if (values.some((v) => Number.isNaN(v))) throw new Error(`Cannot add NaN`);\n    const numbers = values.map(value => value.value);\n\n    this.total = numbers.reduce((accumulator, v) => accumulator + v, this.total);\n    this.min = Math.min(...numbers, this.min);\n    this.max = Math.max(...numbers, this.max);\n    const r: NumberTrackerResults = {\n      max: this.max,\n      min: this.min,\n      total: this.total,\n      avg: this.avg\n    }\n    return r;\n  }\n\n  getMinMaxAvg() {\n    return {\n      min: this.min,\n      max: this.max,\n      avg: this.avg,\n    };\n  }\n}\n\n/**\n * Keeps track of the total, min, max and avg in a stream of values. By default values\n * are not stored.\n *\n * Usage:\n *\n * ```js\n * import { number } from 'https://unpkg.com/ixfx/dist/trackers.js';\n *\n * const t = number();\n * t.seen(10);\n *\n * t.avg / t.min/ t.max\n * t.initial; // initial value\n * t.size;    // number of seen values\n * t.elapsed; // milliseconds since intialisation\n * t.last;    // last value\n * ```\n *\n * To get `{ avg, min, max, total }`\n * ```\n * t.getMinMax()\n * ```\n *\n * Use `t.reset()` to clear everything.\n *\n * Trackers can automatically reset after a given number of samples\n * ```\n * // reset after 100 samples\n * const t = number({ resetAfterSamples: 100 });\n * ```\n *\n * To store values, use the `storeIntermediate` option:\n *\n * ```js\n * const t = number({ storeIntermediate: true });\n * ```\n *\n * Difference between last value and initial value:\n * ```js\n * t.relativeDifference();\n * ```\n *\n * Get raw data (if it is being stored):\n * ```js\n * t.values; // array of numbers\n * t.timestampes; // array of millisecond times, indexes correspond to t.values\n * ```\n */\nexport const number = (opts: TrackedValueOpts = {}) => new NumberTracker(opts);\n","import type { TrackedValueOpts } from './types.js';\nimport { NumberTracker } from './number-tracker.js';\n\n/**\n * A `Tracker` that tracks interval between calls to `mark()`\n */\nexport class IntervalTracker extends NumberTracker {\n  lastMark = 0;\n\n  mark() {\n    if (this.lastMark > 0) {\n      this.seen(performance.now() - this.lastMark);\n    }\n    this.lastMark = performance.now();\n  }\n}\n\n/**\n * Returns a new {@link IntervalTracker} instance. IntervalTracker\n * records the interval between each call to `mark`.\n *\n * ```js\n * import { interval } from 'https://unpkg.com/ixfx/dist/trackers.js';\n *\n * const t = interval();\n *\n * // Call `mark` to record an interval\n * t.mark();\n * ...\n * t.mark();\n *\n * // Get average time in milliseconds between calls to `mark`\n * t.avg;\n *\n * // Longest and shortest times are available too...\n * t.min / t.max\n * ```\n *\n * Interval tracker can automatically reset after a given number of samples:\n *\n * ```\n * // Reset after 100 samples\n * const t = interval({ resetAfterSamples: 100} );\n * ```\n * @param options Options for tracker\n * @returns New interval tracker\n */\nexport const interval = (options?: TrackedValueOpts) => new IntervalTracker(options);\n","import type { Interval } from \"@ixfx/core\";\nimport { type Timeout, timeout } from \"@ixfx/flow\";\n\nexport type RateTrackerOpts = Readonly<{\n  /**\n * If above zero, tracker will reset after this many samples\n */\n  resetAfterSamples?: number;\n\n  /**\n   * If set, tracker will reset after this much time\n   * since last `mark()` call.\n   */\n  timeoutInterval?: Interval\n  /**\n   * If above zero, there will be a limit to intermediate values kept.\n   *\n   * When the seen values is twice `sampleLimit`, the stored values will be trimmed down\n   * to `sampleLimit`. We only do this when the values are double the size so that\n   * the collections do not need to be trimmed repeatedly whilst we are at the limit.\n   *\n   * Automatically implies storeIntermediate\n   */\n  sampleLimit?: number;\n}>\n\n/**\n * Tracks the rate of events.\n * It's also able to compute the min,max and average interval between events.\n * \n * @example\n * ```js\n * const clicks = Trackers.rate();\n * \n * // Mark when a click happens\n * document.addEventListener(`click`, () => clicks.mark());\n * \n * // Get details\n * clicks.perSecond; // How many clicks per second\n * clicks.perMinute; // How many clicks per minute\n * ```\n * \n * `timeoutInterval` is a useful option to make the tracker reset\n * after some period without `mark()` being called.\n * \n * Another useful option is `sampleLimit`, which sets an upper bound\n * for how many events to track. A smaller value means the results\n * will more accurately track, but it might be less smooth.\n * \n * ```js\n * // Eg reset tracker after 5 seconds of inactivity\n * const clicks = Trackers.rate({ \n *  sampleLimit: 10,\n *  timeoutInterval: { secs: 5 }\n * });\n * ```\n */\nexport class RateTracker {\n  #events: number[] = []\n  #fromTime;\n  #resetAfterSamples;\n  #sampleLimit;\n  #resetTimer: Timeout | undefined;\n\n  constructor(opts: Partial<RateTrackerOpts> = {}) {\n    this.#resetAfterSamples = opts.resetAfterSamples ?? Number.MAX_SAFE_INTEGER;\n    this.#sampleLimit = opts.sampleLimit ?? Number.MAX_SAFE_INTEGER;\n    if (opts.timeoutInterval) {\n      this.#resetTimer = timeout(() => {\n        this.reset();\n      }, opts.timeoutInterval);\n    }\n    this.#fromTime = performance.now();\n  }\n\n  /**\n   * Mark that an event has happened\n   */\n  mark() {\n    if (this.#events.length >= this.#resetAfterSamples) {\n      this.reset();\n    } else if (this.#events.length >= this.#sampleLimit) {\n      this.#events = this.#events.slice(1);\n      this.#fromTime = this.#events[ 0 ];\n    }\n    this.#events.push(performance.now());\n    if (this.#resetTimer) {\n      this.#resetTimer.start();\n    }\n  }\n\n  /**\n   * Compute {min,max,avg} for the interval _between_ events.\n   * @returns \n   */\n  computeIntervals() {\n    const intervals: number[] = [];\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = Number.MIN_SAFE_INTEGER;\n    let total = 0;\n    let count = 0;\n    let start = 0;\n    for (const event of this.#events) {\n      if (count > 0) {\n        const index = event - start;\n        min = Math.min(index, min);\n        max = Math.max(index, max);\n        total += index;\n        intervals.push(index);\n      }\n      start = event;\n      count++;\n    }\n    const avg = total / count;\n    return {\n      min, max, avg\n    }\n  }\n\n  /**\n   * Returns the time period (in milliseconds) that encompasses\n   * the data set. Eg, a result of 1000 means there's data that\n   * covers a one second period.\n   */\n  get elapsed() {\n    return performance.now() - this.#fromTime;\n  }\n\n  /**\n   * Resets the tracker.\n   */\n  reset() {\n    this.#events = [];\n    this.#fromTime = performance.now();\n  }\n\n  /**\n   * Get the number of events per second\n   */\n  get perSecond() {\n    return this.#events.length / (this.elapsed / 1000)\n  }\n\n  /**\n   * Get the number of events per minute\n   */\n  get perMinute() {\n    return this.#events.length / (this.elapsed / 1000 / 60)\n  }\n}\n\n/**\n * @inheritdoc RateTracker\n * @param opts \n * @returns \n */\nexport const rate = (opts: Partial<RateTrackerOpts> = {}) => new RateTracker(opts);\n","import type { TimestampedObject, TrackedValueOpts, TrimReason } from './types.js';\nimport { TrackerBase } from './tracker-base.js';\n\n/**\n * A tracked value of type `V`.\n */\nexport abstract class ObjectTracker<V extends object, SeenResultType> extends TrackerBase<V, SeenResultType> {\n  values: TimestampedObject<V>[];\n\n  constructor(opts: TrackedValueOpts = {}) {\n    super(opts);\n    this.values = [];\n  }\n\n  onTrimmed(reason: TrimReason) {\n    // no-op\n  }\n\n  /**\n   * Reduces size of value store to `limit`. \n   * Returns number of remaining items\n   * @param limit\n   */\n  trimStore(limit: number): number {\n    if (limit >= this.values.length) return this.values.length;\n    // Index 0 will be the oldest\n    this.values = this.values.slice(-limit);\n    return this.values.length;\n  }\n\n  /**\n   * Allows sub-classes to be notified when a reset happens\n   * @ignore\n   */\n  onReset() {\n    this.values = [];\n  }\n\n  /**\n   * Tracks a value\n   * @ignore\n   */\n  filterData(p: V[] | TimestampedObject<V>[]): TimestampedObject<V>[] {\n    // Make sure values have a timestamp\n    const ts = p.map((v) =>\n      `at` in v\n        ? v\n        : {\n          ...v,\n          at: Date.now(),\n        }\n    );\n\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const last = ts.at(-1)!;\n\n    if (this.storeIntermediate) this.values.push(...ts);\n    else switch (this.values.length) {\n      case 0: {\n        // Add as initial value\n        this.values.push(last);\n        break;\n      }\n      case 1: {\n        // Add last value\n        this.values.push(last);\n        break;\n      }\n      case 2: {\n        // Replace last value\n        this.values[ 1 ] = last;\n        break;\n      }\n    }\n    return ts;\n  }\n\n  /**\n   * Last seen value. If no values have been added, it will return the initial value\n   */\n  get last() {\n    if (this.values.length === 1) return this.values[ 0 ];\n    //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return this.values.at(-1)!;\n  }\n\n  /**\n   * Returns the oldest value in the buffer\n   */\n  get initial() {\n    return this.values.at(0);\n  }\n\n  /**\n   * Returns number of recorded values (includes the initial value in the count)\n   */\n  get size() {\n    return this.values.length;\n  }\n\n  /**\n   * Returns the elapsed time, in milliseconds since the initial value\n   */\n  get elapsed(): number {\n    return Date.now() - this.values[ 0 ].at;\n  }\n\n}\n","import { type GetOrGenerate, getOrGenerate } from '@ixfx/core/maps';\nimport { TrackerBase } from './tracker-base.js';\n\n\n/**\n * Keeps track of keyed values of type `V` (eg Point). It stores occurences in type `T`, which\n * must extend from `TrackerBase<V>`, eg `PointTracker`.\n *\n * The `creator` function passed in to the constructor is responsible for instantiating\n * the appropriate `TrackerBase` sub-class.\n *\n * @example Sub-class\n * ```js\n * export class PointsTracker extends TrackedValueMap<Points.Point> {\n *  constructor(opts:TrackOpts = {}) {\n *   super((key, start) => {\n *    if (start === undefined) throw new Error(`Requires start point`);\n *    const p = new PointTracker(key, opts);\n *    p.seen(start);\n *    return p;\n *   });\n *  }\n * }\n * ```\n *\n */\nexport class TrackedValueMap<V, T extends TrackerBase<V, TResult>, TResult> {\n  store: Map<string, T>;\n  gog: GetOrGenerate<string, T, V>;\n\n  constructor(creator: (key: string, start: V | undefined) => T) {\n    this.store = new Map();\n    this.gog = getOrGenerate<string, T, V>(this.store, creator);\n  }\n\n  /**\n   * Number of named values being tracked\n   */\n  get size() {\n    return this.store.size;\n  }\n\n  /**\n   * Returns _true_ if `id` is stored\n   * @param id\n   * @returns\n   */\n  has(id: string) {\n    return this.store.has(id);\n  }\n\n  /**\n   * For a given id, note that we have seen one or more values.\n   * @param id Id\n   * @param values Values(s)\n   * @returns Information about start to last value\n   */\n\n  public async seen(id: string, ...values: V[]): Promise<TResult> {\n    const trackedValue = await this.getTrackedValue(id, ...values);\n\n    // Pass it over to the TrackedValue\n    const result = trackedValue.seen(...values);\n\n    return result;\n  }\n\n  /**\n   * Creates or returns a TrackedValue instance for `id`.\n   * @param id\n   * @param values\n   * @returns\n   */\n  protected async getTrackedValue(id: string, ...values: V[]) {\n    if (id === null) throw new Error(`id parameter cannot be null`);\n    if (id === undefined) throw new Error(`id parameter cannot be undefined`);\n\n    // Create or recall TrackedValue by id\n    const trackedValue = await this.gog(id, values[ 0 ]);\n    return trackedValue;\n  }\n\n  /**\n   * Remove a tracked value by id.\n   * Use {@link reset} to clear them all.\n   * @param id\n   */\n  delete(id: string) {\n    this.store.delete(id);\n  }\n\n  /**\n   * Remove all tracked values.\n   * Use {@link delete} to remove a single value by id.\n   */\n  reset() {\n    this.store = new Map();\n  }\n\n  /**\n   * Enumerate ids\n   */\n  *ids() {\n    yield* this.store.keys();\n  }\n\n  /**\n   * Enumerate tracked values\n   */\n  *tracked() {\n    yield* this.store.values();\n  }\n\n  /**\n   * Iterates TrackedValues ordered with oldest first\n   * @returns\n   */\n  *trackedByAge() {\n    const tp = [ ...this.store.values() ];\n    tp.sort((a, b) => {\n      const aa = a.elapsed;\n      const bb = b.elapsed;\n      if (aa === bb) return 0;\n      if (aa > bb) return -1;\n      return 1;\n    });\n\n    for (const t of tp) {\n      yield t;\n    }\n  }\n\n  /**\n   * Iterates underlying values, ordered by age (oldest first)\n   * First the named values are sorted by their `elapsed` value, and then\n   * we return the last value for that group.\n   */\n  *valuesByAge() {\n    for (const tb of this.trackedByAge()) {\n      yield tb.last;\n    }\n  }\n\n  /**\n   * Enumerate last received values\n   *\n   * @example Calculate centroid of latest-received values\n   * ```js\n   * const pointers = pointTracker();\n   * const c = Points.centroid(...Array.from(pointers.lastPoints()));\n   * ```\n   */\n  *last() {\n    for (const p of this.store.values()) {\n      yield p.last;\n    }\n  }\n\n  /**\n   * Enumerate starting values\n   */\n  *initialValues() {\n    for (const p of this.store.values()) {\n      yield p.initial;\n    }\n  }\n\n  /**\n   * Returns a tracked value by id, or undefined if not found\n   * @param id\n   * @returns\n   */\n  get(id: string): TrackerBase<V, TResult> | undefined {\n    return this.store.get(id);\n  }\n}\n"],"mappings":"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"}