{"version":3,"sources":["../src/rx/index.ts","../src/rx/sources/Function.ts","../src/iterables/IterableAsync.ts","../src/rx/sources/Iterator.ts","../src/rx/ResolveSource.ts","../src/rx/Cache.ts","../src/rx/InitStream.ts","../src/dom/SetProperty.ts","../src/rx/sinks/Dom.ts","../src/rx/ToReadable.ts","../src/rx/ops/Annotate.ts","../src/rx/ops/Chunk.ts","../src/rx/ops/Transform.ts","../src/rx/ops/CloneFromFields.ts","../src/rx/ops/CombineLatestToArray.ts","../src/data/Pathed.ts","../src/data/Util.ts","../src/rx/sources/Object.ts","../src/rx/ops/CombineLatestToObject.ts","../src/rx/ops/ComputeWithPrevious.ts","../src/rx/ops/Debounce.ts","../src/rx/ops/Elapsed.ts","../src/rx/ops/Field.ts","../src/rx/ops/Filter.ts","../src/numbers/Wrap.ts","../src/modulation/easing/index.ts","../src/modulation/easing/EasingsNamed.ts","../src/modulation/Gaussian.ts","../src/geometry/point/index.ts","../src/geometry/point/Guard.ts","../src/geometry/point/Abs.ts","../src/geometry/point/Angle.ts","../src/geometry/point/Apply.ts","../src/numbers/AverageWeighted.ts","../src/numbers/MovingAverage.ts","../src/geometry/point/Averager.ts","../src/geometry/point/FindMinimum.ts","../src/geometry/rect/Max.ts","../src/geometry/point/Bbox.ts","../src/geometry/point/Centroid.ts","../src/geometry/point/Clamp.ts","../src/geometry/point/Compare.ts","../src/geometry/point/IsEqual.ts","../src/geometry/point/ConvexHull.ts","../src/geometry/point/GetPointParameter.ts","../src/geometry/point/Distance.ts","../src/geometry/circle/Guard.ts","../src/geometry/circle/DistanceCenter.ts","../src/geometry/circle/DistanceFromExterior.ts","../src/geometry/rect/Guard.ts","../src/geometry/circle/IsEqual.ts","../src/geometry/point/Sum.ts","../src/geometry/point/Subtract.ts","../src/geometry/circle/Intersections.ts","../src/geometry/Intersects.ts","../src/geometry/rect/Intersects.ts","../src/geometry/rect/Center.ts","../src/geometry/point/PointType.ts","../src/geometry/rect/Distance.ts","../src/geometry/point/DistanceToCenter.ts","../src/geometry/point/DistanceToExterior.ts","../src/geometry/point/Divider.ts","../src/geometry/point/ToArray.ts","../src/geometry/point/DotProduct.ts","../src/geometry/point/Empty.ts","../src/geometry/point/From.ts","../src/geometry/line/Guard.ts","../src/geometry/line/GetPointsParameter.ts","../src/geometry/line/Length.ts","../src/geometry/line/Reverse.ts","../src/geometry/line/Interpolate.ts","../src/geometry/point/Interpolate.ts","../src/geometry/point/Invert.ts","../src/geometry/point/Multiply.ts","../src/geometry/point/Magnitude.ts","../src/geometry/point/Most.ts","../src/geometry/point/Normalise.ts","../src/geometry/point/NormaliseByRect.ts","../src/geometry/point/Pipeline.ts","../src/geometry/point/ProgressBetween.ts","../src/geometry/point/Project.ts","../src/numbers/Quantise.ts","../src/geometry/point/Quantise.ts","../src/geometry/point/Random.ts","../src/geometry/point/Reduce.ts","../src/geometry/point/Relation.ts","../src/geometry/polar/index.ts","../src/geometry/polar/Guard.ts","../src/data/index.ts","../src/data/Correlate.ts","../src/data/CloneFromFields.ts","../src/data/KeysToNumbers.ts","../src/data/MapObject.ts","../src/data/Filters.ts","../src/data/Pool.ts","../src/data/Process.ts","../src/data/BasicProcessors.ts","../src/data/ResolveFields.ts","../src/data/RecordMerge.ts","../src/data/maps/index.ts","../src/geometry/Angles.ts","../src/geometry/polar/Angles.ts","../src/geometry/polar/Conversions.ts","../src/geometry/polar/Math.ts","../src/geometry/polar/Ray.ts","../src/geometry/polar/Spiral.ts","../src/geometry/point/Rotate.ts","../src/geometry/point/RotatePointArray.ts","../src/geometry/point/Round.ts","../src/geometry/point/To.ts","../src/geometry/point/WithinRange.ts","../src/geometry/point/Wrap.ts","../src/geometry/bezier/index.ts","../node_modules/bezier-js/src/utils.js","../node_modules/bezier-js/src/poly-bezier.js","../node_modules/bezier-js/src/bezier.js","../src/geometry/rect/FromTopLeft.ts","../src/geometry/bezier/Guard.ts","../src/numbers/Scale.ts","../src/modulation/easing/Line.ts","../src/modulation/ModulatorTimed.ts","../src/numbers/Interpolate.ts","../src/rx/ops/Interpolate.ts","../src/rx/ops/Math.ts","../src/rx/ops/Pipe.ts","../src/rx/ops/SingleFromArray.ts","../src/rx/ops/Split.ts","../src/rx/ops/Switcher.ts","../src/rx/ops/SyncToArray.ts","../src/rx/ops/SyncToObject.ts","../src/rx/ops/Tap.ts","../src/rx/ops/Throttle.ts","../src/rx/ops/TimeoutValue.ts","../src/rx/ops/TimeoutPing.ts","../src/rx/ops/ValueToPing.ts","../src/rx/ops/WithValue.ts","../src/collections/graphs/DirectedGraph.ts","../src/collections/queue/PriorityMutable.ts","../src/collections/Table.ts","../src/rx/Graph.ts","../src/rx/Types.ts","../src/rx/ToArray.ts","../src/rx/ToGenerator.ts","../src/rx/Wrap.ts","../src/rx/Dom.ts","../src/rx/sources/index.ts","../src/rx/sources/Array.ts","../src/rx/sources/ArrayObject.ts","../src/rx/sources/Boolean.ts","../src/visual/colour/index.ts","../src/visual/colour/Generate.ts","../node_modules/colorjs.io/src/multiply-matrices.js","../node_modules/colorjs.io/src/util.js","../node_modules/colorjs.io/src/hooks.js","../node_modules/colorjs.io/src/defaults.js","../node_modules/colorjs.io/src/adapt.js","../node_modules/colorjs.io/src/parse.js","../node_modules/colorjs.io/src/getColor.js","../node_modules/colorjs.io/src/space.js","../node_modules/colorjs.io/src/spaces/xyz-d65.js","../node_modules/colorjs.io/src/rgbspace.js","../node_modules/colorjs.io/src/getAll.js","../node_modules/colorjs.io/src/get.js","../node_modules/colorjs.io/src/setAll.js","../node_modules/colorjs.io/src/set.js","../node_modules/colorjs.io/src/spaces/xyz-d50.js","../node_modules/colorjs.io/src/spaces/lab.js","../node_modules/colorjs.io/src/angles.js","../node_modules/colorjs.io/src/spaces/lch.js","../node_modules/colorjs.io/src/deltaE/deltaE2000.js","../node_modules/colorjs.io/src/spaces/oklab.js","../node_modules/colorjs.io/src/deltaE/deltaEOK.js","../node_modules/colorjs.io/src/inGamut.js","../node_modules/colorjs.io/src/clone.js","../node_modules/colorjs.io/src/distance.js","../node_modules/colorjs.io/src/deltaE/deltaE76.js","../node_modules/colorjs.io/src/deltaE/deltaECMC.js","../node_modules/colorjs.io/src/spaces/xyz-abs-d65.js","../node_modules/colorjs.io/src/spaces/jzazbz.js","../node_modules/colorjs.io/src/spaces/jzczhz.js","../node_modules/colorjs.io/src/deltaE/deltaEJz.js","../node_modules/colorjs.io/src/spaces/ictcp.js","../node_modules/colorjs.io/src/deltaE/deltaEITP.js","../node_modules/colorjs.io/src/spaces/cam16.js","../node_modules/colorjs.io/src/spaces/hct.js","../node_modules/colorjs.io/src/deltaE/deltaEHCT.js","../node_modules/colorjs.io/src/deltaE/index.js","../node_modules/colorjs.io/src/toGamut.js","../node_modules/colorjs.io/src/to.js","../node_modules/colorjs.io/src/serialize.js","../node_modules/colorjs.io/src/spaces/rec2020-linear.js","../node_modules/colorjs.io/src/spaces/rec2020.js","../node_modules/colorjs.io/src/spaces/p3-linear.js","../node_modules/colorjs.io/src/spaces/srgb-linear.js","../node_modules/colorjs.io/src/keywords.js","../node_modules/colorjs.io/src/spaces/srgb.js","../node_modules/colorjs.io/src/spaces/p3.js","../node_modules/colorjs.io/src/display.js","../node_modules/colorjs.io/src/equals.js","../node_modules/colorjs.io/src/luminance.js","../node_modules/colorjs.io/src/contrast/WCAG21.js","../node_modules/colorjs.io/src/contrast/APCA.js","../node_modules/colorjs.io/src/contrast/Michelson.js","../node_modules/colorjs.io/src/contrast/Weber.js","../node_modules/colorjs.io/src/contrast/Lstar.js","../node_modules/colorjs.io/src/spaces/lab-d65.js","../node_modules/colorjs.io/src/contrast/deltaPhi.js","../node_modules/colorjs.io/src/contrast.js","../node_modules/colorjs.io/src/chromaticity.js","../node_modules/colorjs.io/src/deltaE.js","../node_modules/colorjs.io/src/variations.js","../node_modules/colorjs.io/src/interpolation.js","../node_modules/colorjs.io/src/spaces/hsl.js","../node_modules/colorjs.io/src/spaces/hsv.js","../node_modules/colorjs.io/src/spaces/hwb.js","../node_modules/colorjs.io/src/spaces/a98rgb-linear.js","../node_modules/colorjs.io/src/spaces/a98rgb.js","../node_modules/colorjs.io/src/spaces/prophoto-linear.js","../node_modules/colorjs.io/src/spaces/prophoto.js","../node_modules/colorjs.io/src/spaces/oklch.js","../node_modules/colorjs.io/src/spaces/luv.js","../node_modules/colorjs.io/src/spaces/lchuv.js","../node_modules/colorjs.io/src/spaces/hsluv.js","../node_modules/colorjs.io/src/spaces/hpluv.js","../node_modules/colorjs.io/src/spaces/rec2100-pq.js","../node_modules/colorjs.io/src/spaces/rec2100-hlg.js","../node_modules/colorjs.io/src/CATs.js","../node_modules/colorjs.io/src/spaces/acescg.js","../node_modules/colorjs.io/src/spaces/acescc.js","../node_modules/colorjs.io/src/color.js","../node_modules/colorjs.io/src/spaces/index.js","../node_modules/colorjs.io/src/space-accessors.js","../node_modules/colorjs.io/src/index.js","../src/visual/colour/Oklch.ts","../src/visual/colour/ResolveCss.ts","../src/visual/colour/Rgb.ts","../src/visual/colour/Hsl.ts","../src/visual/colour/ResolveToColorJs.ts","../src/visual/colour/ToString.ts","../src/visual/colour/Interpolate.ts","../src/visual/colour/Math.ts","../src/rx/sources/Colour.ts","../src/rx/sources/Count.ts","../src/rx/sources/Derived.ts","../src/rx/sources/Event.ts","../src/rx/sources/Dom.ts","../src/rx/sources/Merged.ts","../src/rx/sources/Number.ts","../src/rx/sources/ObjectProxy.ts","../src/rx/sources/Observable.ts","../src/rx/sources/String.ts"],"sourcesContent":["\n//#region imports\nimport type { Reactive, ReactiveOrSource, ReactiveWritable, ReactiveOp, InitStreamOptions, WithValueOptions, CombineLatestOptions, RxValueTypes, RxValueTypeObject, PipeSet, ReactivePingable } from \"./Types.js\";\nimport type { ChunkOptions, DebounceOptions, FieldOptions, SingleFromArrayOptions, SplitOptions, FilterPredicate, SwitcherOptions, SyncOptions, ThrottleOptions } from \"./ops/Types.js\";\nimport type { RankFunction, RankOptions } from \"../data/Types.js\";\nimport type { TimeoutPingOptions, TimeoutValueOptions } from \"./sources/Types.js\";\nimport { type Interval, intervalToMs } from '../flow/IntervalType.js';\nimport { isWritable, messageHasValue, messageIsDoneSignal, opify } from \"./Util.js\";\nimport { initStream } from \"./InitStream.js\";\nimport { resolveSource } from './ResolveSource.js';\nimport * as SinkFns from './sinks/index.js';\nimport * as OpFns from './ops/index.js';\n\n//#endregion\n\nexport * from './ops/index.js';\nexport * from './sinks/index.js';\nexport * from './Graph.js';\nexport * from './Types.js';\nexport * from './ToArray.js';\nexport * from './ToGenerator.js';\nexport * from './Util.js';\nexport * from './Wrap.js';\nexport * from './ResolveSource.js';\nexport * from './Cache.js';\nexport * as Dom from './Dom.js';\nexport * as From from './sources/index.js';\nexport * from './InitStream.js';\n\nexport function run<TIn, TOut>(source: ReactiveOrSource<any>, ...ops: Array<ReactiveOp<any, any>>) {\n  let s = resolveSource(source);\n  for (const op of ops) {\n    // @ts-ignore\n    s = op(s);\n  }\n  return s;\n}\n\nexport function writable<TIn, TOut>(source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<any, any>>): ReactiveWritable<TIn, TOut> {\n  let s = resolveSource(source);\n  const head = s;\n  for (const op of ops) {\n    // @ts-ignore\n    s = op(s);\n  }\n  const ss = s as any as Reactive<TOut>;\n  return {\n    ...ss,\n    set(value: TIn) {\n      if (isWritable(head)) {\n        head.set(value);\n      } else throw new Error(`Original source is not writable`);\n    }\n  } as ReactiveWritable<TIn, TOut>\n  //return s as Reactive<T2 | T3 | T4 | T5 | T6>;\n  //const raw = chainer<T1, T2, T3, T4, T5, T6>(...ops);\n  //return raw(source);\n}\n\n/**\n * Initialises a reactive that pipes values to listeners directly.\n * @returns \n */\nexport function manual<V>(options: Partial<InitStreamOptions> = {}): Reactive<V> & ReactiveWritable<V> {\n  const events = initStream<V>(options);\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    set(value: V) {\n      events.set(value);\n    },\n    on: events.on,\n    onValue: events.onValue\n  };\n}\n\nexport const Sinks = {\n  setHtmlText: (options: SinkFns.SetHtmlOptions) => {\n    return (source: ReactiveOrSource<string>) => {\n      SinkFns.setHtmlText(source, options);\n    }\n  }\n}\n\nexport const Ops = {\n  /**\n * Annotates values with the result of a function.\n * The input value needs to be an object.\n * \n * For every value `input` emits, run it through `annotator`, which should\n * return the original value with additional fields.\n * \n * Conceptually the same as `transform`, just with typing to enforce result\n * values are V & TAnnotation\n * @param annotator \n * @returns \n */\n  annotate: <V, TAnnotation>(annotator: (input: V) => V & TAnnotation) => opify(OpFns.annotate, annotator),\n  /**\n   * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n   * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n   * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n   * \n   * ```js\n   * // Emit values from an array\n   * const r1 = Rx.run(\n   *  Rx.From.array([ 1, 2, 3 ]),\n   *  Rx.Ops.annotateWithOp(\n   *    // Add the 'max' operator to emit the largest-seen value\n   *    Rx.Ops.sum()\n   *  )\n   * );\n   * const data = await Rx.toArray(r1);\n   * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n   * ```\n   * @param annotatorOp \n   * @returns \n   */\n  annotateWithOp: <TIn, TAnnotation>(annotatorOp: ReactiveOp<TIn, TAnnotation>) => opify(OpFns.annotateWithOp, annotatorOp),\n  /**\n   * Takes a stream of values and chunks them up (by quantity or time elapsed),\n   * emitting them as an array.\n   * @param options \n   * @returns \n   */\n  chunk: <V>(options: Partial<ChunkOptions>): ReactiveOp<V, Array<V>> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.chunk(source, options);\n    }\n  },\n\n  cloneFromFields: <V>(): ReactiveOp<V, V> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.cloneFromFields(source);\n    }\n  },\n  /**\n * Merges values from several sources into a single source that emits values as an array.\n * @param options \n * @returns \n */\n  combineLatestToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(options: Partial<CombineLatestOptions> = {}) => {\n    return (sources: T) => {\n      return OpFns.combineLatestToArray(sources, options);\n    }\n  },\n  /**\n   * Merges values from several sources into a single source that emits values as an object.\n   * @param options\n   * @returns \n   */\n  combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(options: Partial<CombineLatestOptions> = {}) => {\n    return (reactiveSources: T) => {\n      return OpFns.combineLatestToObject(reactiveSources, options);\n    }\n  },\n  /**\n * Debounce values from the stream. It will wait until a certain time\n * has elapsed before emitting latest value.\n * \n * Effect is that no values are emitted if input emits faster than the provided\n * timeout.\n * \n * See also: throttle\n * @param options \n * @returns \n */\n  debounce: <V>(options: Partial<DebounceOptions>): ReactiveOp<V, V> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.debounce(source, options);\n    }\n  },\n  /**\n   * Drops values from the input stream that match `predicate`\n   * @param predicate If it returns _true_ value is ignored\n   * @returns \n   */\n  drop: <V>(predicate: (value: V) => boolean) => opify(OpFns.drop, predicate),\n  /**\n   * Every upstream value is considered the target for interpolation.\n   * Output value interpolates by a given amount toward the target.\n   * @returns \n   */\n  elapsed: <V>(): ReactiveOp<V, number> => opify(OpFns.elapsed),\n  /**\n   * Yields the value of a field from an input stream of values.\n   * Eg if the source reactive emits `{ colour: string, size: number }`,\n   * we might use `field` to pluck out the `colour` field, thus returning\n   * a stream of string values.\n   * @param fieldName \n   * @param options \n   * @returns \n   */\n  field: <TSource extends object, TFieldType>(fieldName: keyof TSource, options: FieldOptions<TSource, TFieldType>) => {\n    return (source: ReactiveOrSource<TSource>) => {\n      return OpFns.field(source, fieldName, options);\n    }\n  },\n  /**\n   * Filters the input stream, only re-emitting values that pass the predicate\n   * @param predicate If it returns _true_ value is allowed through\n   * @returns \n   */\n  filter: <V>(predicate: (value: V) => boolean) => opify(OpFns.filter, predicate),\n  /**\n   * Every upstream value is considered the target for interpolation.\n   * Output value interpolates by a given amount toward the target.\n   * @param options \n   * @returns \n   */\n  interpolate: <TIn = number>(options?: Partial<OpFns.OpInterpolateOptions>) => opify<TIn, ReactivePingable<number>>(OpFns.interpolate as any, options),\n  /**\n * Outputs the minimum numerical value of the stream.\n * A value is only emitted when minimum decreases.\n * @returns \n */\n  min: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.min, options),\n  /**\n   * Outputs the maxium numerical value of the stream.\n   * A value is only emitted when maximum increases.\n   * @returns \n   */\n  max: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.max, options),\n  sum: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.sum, options),\n  average: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.average, options),\n  tally: <TIn>(options?: OpFns.TallyOptions) => opify<TIn, Reactive<number>>(OpFns.tally, options),\n  rank: <TIn>(rank: RankFunction<TIn>, options?: RankOptions & OpFns.OpMathOptions) => opify<TIn>(OpFns.rank, rank, options),\n\n  pipe: <TInput, TOutput>(...streams: Array<Reactive<any> & ReactiveWritable<any>>) => {\n    return (source: ReactiveOrSource<TInput>) => {\n      const resolved = resolveSource(source);\n      const s = [ resolved, ...streams ] as PipeSet<TInput, TOutput>;\n      return OpFns.pipe(...s);\n    }\n  },\n\n  singleFromArray: <V>(options: Partial<SingleFromArrayOptions<V>> = {}) => {\n    return (source: ReactiveOrSource<Array<V>>) => {\n      return OpFns.singleFromArray(source, options)\n    }\n  },\n\n  split: <V>(options: Partial<SplitOptions> = {}) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.split(source, options);\n    }\n  },\n  splitLabelled: <V>(labels: Array<string>) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.splitLabelled(source, labels);\n    }\n  },\n  switcher: <TValue, TRec extends Record<string, FilterPredicate<TValue>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions> = {}) => {\n    return (source: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n      return OpFns.switcher(source, cases, options);\n    }\n  },\n  syncToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(options: Partial<SyncOptions> = {}) => {\n    return (reactiveSources: T): Reactive<RxValueTypes<T>> => {\n      return OpFns.syncToArray(reactiveSources, options);\n    }\n  },\n  syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(options: Partial<SyncOptions> = {}) => {\n    return (reactiveSources: T): Reactive<RxValueTypeObject<T>> => {\n      return OpFns.syncToObject(reactiveSources, options);\n    }\n  },\n  tapProcess: <In>(processor: ((value: In) => any)): ReactiveOp<In, In> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapProcess(source, processor);\n    }\n  },\n  tapStream: <In>(divergedStream: ReactiveWritable<In>): ReactiveOp<In, In> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapStream(source, divergedStream);\n    }\n  },\n  tapOps: <In, Out>(...ops: Array<ReactiveOp<In, Out>>) => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapOps(source, ...ops);\n    }\n  },\n\n  /**\n * Throttle values from the stream.\n * Only emits a value if some minimum time has elapsed.\n * @param options \n * @returns \n */\n  throttle: <V>(options: Partial<ThrottleOptions>) => opify<V>(OpFns.throttle, options),\n  /**\n   * Trigger a value if 'source' does not emit a value within an interval.\n   * Trigger value can be a fixed value, result of function, or step through an iterator.\n   * @param options \n   * @returns \n   */\n  timeoutValue: <V, TTriggerValue>(options: TimeoutValueOptions<TTriggerValue>) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.timeoutValue<V, TTriggerValue>(source, options);\n    }\n  },\n\n  timeoutPing: <V>(options: TimeoutPingOptions) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.timeoutPing(source, options);\n    }\n  },\n  transform: <In, Out>(transformer: ((value: In) => Out), options: Partial<OpFns.TransformOpts> = {}): ReactiveOp<In, Out> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.transform(source, transformer, options);\n    }\n  },\n\n  /**\n  * Reactive where last (or a given initial) value is available to read\n  * @param opts \n  * @returns \n  */\n  withValue: <V>(opts: Partial<WithValueOptions<V>>): ReactiveOp<V, V> => {\n    return opify<V>(OpFns.withValue, opts);\n  },\n} as const;\n\n\n// export const chain = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       // @ts-expect-error\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n\n// export const chainStream = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>): ReactiveStream<TIn, TOut> => {\n//   const stream = manual<TIn>();\n//   const c = chain(...ops);\n//   const x = c(stream);\n//   return x;\n// }\n\n\n\n// function chainx<TIn, TOut>(...ops: Array<ReactiveOp<any, any>>) {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n\n\n\n// export function runWithInitial<TIn, TOut>(initial: TOut, source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<any, any>>): ReactiveInitial<TOut> & ReactiveDisposable<TOut> {\n//   let lastValue = initial;\n//   const raw = prepareOps<TIn, TOut>(...ops);\n//   const r = raw(source);\n//   let disposed = false;\n\n//   r.onValue(value => {\n//     lastValue = value;\n//   });\n\n//   return {\n//     ...r,\n//     isDisposed() {\n//       return disposed\n//     },\n//     dispose(reason) {\n//       if (disposed) return;\n//       if (isDisposable(r)) {\n//         r.dispose(reason);\n//       }\n//       disposed = true;\n//     },\n//     last() {\n//       return lastValue;\n//     },\n//   }\n// }\n\n/**\n * Grabs the next value emitted from `source`.\n * By default waits up to a maximum of one second.\n * Handles subscribing and unsubscribing.\n * \n * ```js\n * const value = await Rx.takeNextValue(source);\n * ```\n * \n * Throws an error if the source closes without\n * a value or the timeout is reached.\n * \n * @param source \n * @param maximumWait \n * @returns \n */\nexport async function takeNextValue<V>(source: ReactiveOrSource<V>, maximumWait: Interval = 1000): Promise<V> {\n  const rx = resolveSource(source);\n  let off = () => {/** no-op */ };\n  let watchdog: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  const p = new Promise<V>((resolve, reject) => {\n    off = rx.on(message => {\n      if (watchdog) clearTimeout(watchdog);\n      if (messageHasValue(message)) {\n        off();\n        resolve(message.value);\n      } else {\n        if (messageIsDoneSignal(message)) {\n          reject(new Error(`Source closed. ${ message.context ?? `` }`));\n          off();\n        }\n      }\n    });\n\n    watchdog = setTimeout(() => {\n      watchdog = undefined;\n      off();\n      reject(new Error(`Timeout waiting for value (${ JSON.stringify(maximumWait) })`))\n    }, intervalToMs(maximumWait));\n  });\n  return p;\n}\n\n\n/**\n * Connects reactive A to B, optionally transforming the value as it does so.\n * \n * Returns a function to unsubcribe A->B\n * @param a \n * @param b \n * @param transform \n */\nexport const to = <TA, TB>(a: Reactive<TA>, b: ReactiveWritable<TB>, transform?: (valueA: TA) => TB, closeBonA = false) => {\n  const unsub = a.on(message => {\n    if (messageHasValue(message)) {\n      const value = transform ? transform(message.value) : message.value as TB;\n      b.set(value);\n    } else if (messageIsDoneSignal(message)) {\n      unsub();\n      if (closeBonA) {\n        b.dispose(`Source closed (${ message.context ?? `` })`);\n      }\n    } else {\n      // eslint-disable-nex Unsupported message: ${ JSON.stringify(message) }`);\n    }\n\n  });\n  return unsub;\n}","import { getErrorMessage } from \"../../debug/GetErrorMessage.js\";\nimport { continuously } from \"../../flow/Continuously.js\";\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { sleep } from \"../../flow/Sleep.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport type { ReactivePingable } from \"../Types.js\";\nimport type { FunctionFunction, FunctionOptions } from \"./Types.js\";\n\n\n/**\n * Produces a reactive from the basis of a function. `callback` is executed, with its result emitted via the returned reactive.\n * \n * ```js\n * // Produce a random number every second\n * const r = Rx.From.func(Math.random, { interval: 1000 });\n * ```\n * \n * `callback` can be called repeatedly by providing the `interval` option to set the rate of repeat.\n * Looping can be limited with `options.maximumRepeats`, or passing a signal `options.signal`\n * and then activating it. \n * ```js\n * // Reactive that emits a random number every second, five times\n * const r1 = Rx.From.func(Math.random, { interval: 1000, maximumRepeats: 5 }\n * ```\n * \n * ```js\n * // Generate a random number every second until ac.abort() is called\n * const ac = new AbortController();\n * const r2 = Rx.From.func(Math.random, { interval: 1000, signal: ac.signal });\n * ```\n * \n * The third option is for `callback` to fire the provided abort function.\n * ```js\n * Rx.From.func((abort) => {\n *  if (Math.random() > 0.5) abort('Random exit');\n *  return 1;\n * });\n * ```\n *\n * By default has a laziness of 'very' meaning that `callback` is run only when there's a subscriber \n * By default stream closes if `callback` throws an error. Use `options.closeOnError:'ignore'` to change.\n * @param callback \n * @param options \n * @returns \n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport function func<V>(callback: FunctionFunction<V>, options: Partial<FunctionOptions> = {}): ReactivePingable<V> {\n  const maximumRepeats = options.maximumRepeats ?? Number.MAX_SAFE_INTEGER;\n  const closeOnError = options.closeOnError ?? true;\n  const intervalMs = options.interval ? intervalToMs(options.interval) : -1;\n  let manual = options.manual ?? false;\n\n  // If niether interval or manual is set, assume manual\n  if (options.interval === undefined && options.manual === undefined) manual = true;\n\n  if (manual && options.interval) throw new Error(`If option 'manual' is set, option 'interval' cannot be used`);\n  const predelay = intervalToMs(options.predelay, 0);\n  const lazy = options.lazy ?? `very`;\n  const signal = options.signal;\n\n  const internalAbort = new AbortController();\n  const internalAbortCallback = (reason: string) => { internalAbort.abort(reason) };\n  let sentResults = 0;\n  let enabled = false;\n\n  const done = (reason: string) => {\n    events.dispose(reason);\n    enabled = false;\n    if (run) run.cancel();\n  }\n\n  const ping = async () => {\n    if (!enabled) return false;\n    if (predelay) await sleep(predelay);\n    if (sentResults >= maximumRepeats) {\n      done(`Maximum repeats reached ${ maximumRepeats.toString() }`);\n      return false;\n    }\n    //console.log(`sent: ${ sentResults } max: ${ maximumRepeats }`);\n    try {\n      if (signal?.aborted) {\n        done(`Signal (${ signal.aborted })`);\n        return false;\n      }\n      const value = await callback(internalAbortCallback);\n      sentResults++;\n      events.set(value);\n      return true;\n    } catch (error) {\n      if (closeOnError) {\n        done(`Function error: ${ getErrorMessage(error) }`);\n        return false;\n      } else {\n        events.signal(`warn`, getErrorMessage(error));\n        return true;\n      }\n    }\n  }\n\n  const run = manual ? undefined : continuously(async () => {\n    const pingResult = await ping();\n    if (!pingResult) return false;\n\n    // if (!loop) {\n    //   done(`fromFunction done`);\n    //   return false; // Stop loop\n    // }\n    if (internalAbort.signal.aborted) {\n      done(`callback function aborted (${ internalAbort.signal.reason })`);\n      return false\n    }\n\n  }, intervalMs);\n\n  const events = initLazyStream<V>({\n    lazy,\n    onStart() {\n      enabled = true;\n      if (run) run.start();\n    },\n    onStop() {\n\n      enabled = false;\n      if (run) run.cancel();\n    },\n  });\n\n  if (lazy === `never` && run) run.start();\n  return { ...events, ping };\n}\n\n","import { intervalToMs, type Interval } from '../flow/IntervalType.js';\nimport { type IsEqual } from '../util/IsEqual.js';\nimport { sleep, type SleepOpts } from '../flow/Sleep.js';\nimport { isAsyncIterable, isIterable } from './Iterable.js';\nimport { toStringDefault } from '../util/ToString.js';\nimport type { ForEachOptions, ToArrayOptions } from './Types.js';\n\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * \n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport async function* fromArray<V>(array: Array<V>, interval: Interval = 1): AsyncGenerator<V> {\n  for (const v of array) {\n    yield v;\n    await sleep(interval);\n  }\n}\n\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport async function* fromIterable<V>(iterable: Iterable<V> | AsyncIterable<V>, interval: Interval = 1): AsyncGenerator<V> {\n  for await (const v of iterable) {\n    yield v;\n    await sleep(interval);\n  }\n}\n\nexport async function* chunks<V>(it: AsyncIterable<V>, size: number) {\n  // Source: https://surma.github.io/underdash/\n  let buffer = [];\n  for await (const v of it) {\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      buffer = [];\n    }\n  }\n  if (buffer.length > 0) yield buffer;\n}\n\n\nexport async function* concat<V>(...its: ReadonlyArray<AsyncIterable<V>>) {\n  // Source: https://surma.github.io/underdash/\n  for await (const it of its) yield* it;\n}\n\nexport async function* dropWhile<V>(\n  it: AsyncIterable<V>,\n  f: (v: V) => boolean\n) {\n  for await (const v of it) {\n    if (!f(v)) {\n      yield v;\n    }\n  }\n}\n\n/**\n * Loops over a generator until it finishes, calling `callback`.\n * Useful if you don't care about the value generator produces, just the number of loops.\n * \n * In this version, we do a `for await of` over `gen`, and also `await callback()`. \n\n * ```js\n * await until(count(5), () => {\n * // do something 5 times\n * });\n * ```\n * \n * If you want the value from the generator, use a `for of` loop as usual.\n * \n * If `callback` explicitly returns _false_, the generator is aborted.\n * @param it Generator to run\n * @param callback Code to call for each iteration\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = async (it: AsyncIterable<any> | Iterable<any>, callback: () => (void | Promise<boolean> | undefined | boolean | Promise<undefined> | Promise<void>)): Promise<undefined> => {\n  for await (const _ of it) {\n    const value = await callback();\n    if (typeof value === `boolean` && !value) break;\n  }\n}\n\n/**\n * This generator will repeat another generator up until some condition. This is the version\n * that can handle async generators.\n * \n * For example, {@link count} will count from 0..number and then finish:\n * ```js\n * for (const v of count(5)) {\n *  // v: 0, 1, 2, 3, 4\n * }\n * ```\n * \n * But what if we want to repeat the count? We have to provide a function to create the generator,\n * rather than using the generator directly, since it's \"one time use\"\n * ```js\n * for await (const v of repeat(() => count(5))) {\n *  // v: 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, ...\n *  // warning: never ends\n * }\n * ```\n * \n * Limiting the number of repeats can be done by passing in extra parameters\n * ```js\n * repeat(generator, { count: 5} ); // Iterate over `generator` five times\n * ```\n * \n * ```js\n * const ac = new AbortController();\n * repeat(generator, { signal: ac.signal }); // Pass in signal\n * ...\n * ac.abort(); // Trigger signal at some point\n * ```\n * @param genCreator \n * @param repeatsOrSignal \n */\nexport const repeat = async function*<T>(genCreator: () => Iterable<T> | AsyncIterable<T>, repeatsOrSignal: number | AbortSignal): AsyncGenerator<T> {\n  const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n  const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n  let count = repeats;\n\n  while (true) {\n    for await (const v of genCreator()) {\n      yield v;\n      if (signal?.aborted) break;\n    }\n    if (Number.isFinite(repeats)) {\n      count--;\n      if (count === 0) break;\n    }\n    if (signal?.aborted) break;\n  }\n}\n\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport async function equals<V>(\n  it1: AsyncIterable<V>,\n  it2: AsyncIterable<V>,\n  equality?: IsEqual<V>\n) {\n  // https://surma.github.io/underdash/\n  const iit1 = it1[ Symbol.asyncIterator ]();// it1[ Symbol.iterator ]();\n  const iit2 = it2[ Symbol.asyncIterator ]();\n  while (true) {\n    const index1 = await iit1.next();\n    const index2 = await iit2.next();\n    if (equality !== undefined) {\n      if (!equality(index1.value, index2.value)) return false;\n    } else if (index1.value !== index2.value) return false;\n    if (index1.done ?? index2.done) return index1.done && index2.done;\n  }\n}\n\nexport async function every<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  for await (const v of it) {\n    const result = await f(v);\n    if (!result) return false;\n  }\n  return true;\n}\n\nexport async function* fill<V>(it: AsyncIterable<V>, v: V) {\n  // https://surma.github.io/underdash/\n  for await (const _ of it) yield v;\n}\n\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport async function* filter<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (!await f(v)) continue;\n    yield v;\n  }\n}\n\n\nexport async function find<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (await f(v)) return v;\n  }\n}\n\n\nexport async function* flatten<V>(it: AsyncIterable<V>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (typeof v === `object`) {\n      if (Array.isArray(v)) {\n        for (const vv of v) yield vv;\n      } else if (isAsyncIterable(v)) {\n        for await (const vv of v) {\n          yield vv;\n        }\n      } else if (isIterable(v)) {\n        for (const vv of v) {\n          yield vv;\n        }\n      }\n    } else {\n      yield v;\n    }\n\n  }\n}\n\n/**\n * Iterates over an async iterable or array, calling `fn` for each value, with optional\n * interval between each loop. If the async `fn` returns _false_, iterator cancels.\n *\n * ```\n * import { forEach } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * // Prints items from array every second\n * await forEach([0,1,2,3], i => console.log(i), 1000);\n * ```\n *\n * ```\n * // Retry up to five times, with 5 seconds between each attempt\n * await forEach(count(5), i=> {\n *  try {\n *    await doSomething();\n *    return false; // Succeeded, exit early\n *  } catch (ex) {\n *    console.log(ex);\n *    return true; // Keep trying\n *  }\n * }, 5000);\n * ```\n * @param iterator Iterable thing to loop over\n * @param fn Function to invoke on each item. If it returns _false_ loop ends.\n * @param options Options\n * @typeParam V Type of iterable\n */\nexport const forEach = async function <T>(\n  iterator: AsyncIterable<T> | Array<T>,\n  fn: (v?: T) => Promise<boolean> | Promise<void> | boolean | void,\n  options: Partial<ForEachOptions> = {}\n) {\n  const interval = options.interval;\n  if (Array.isArray(iterator)) {\n    // Handle array\n    for (const x of iterator) {\n      const r = await fn(x);\n      if (typeof r === `boolean` && !r) break;\n      if (interval) await sleep(interval);\n    }\n  } else {\n    // Handle an async iterator\n    for await (const x of iterator) {\n      const r = await fn(x);\n      if (typeof r === `boolean` && !r) break;\n      if (interval) await sleep(interval);\n    }\n  }\n};\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n// export async function forEach<V>(it: AsyncIterable<V>, f: (v: V) => void | boolean | Promise<boolean | void>) {\n//   // https://surma.github.io/underdash/\n//   for await (const v of it) {\n//     const result = await f(v);\n//     if (typeof result === `boolean` && !result) break;\n//   }\n// }\n\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n * \n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\n//eslint-disable-next-line func-style\nexport async function* map<V, X>(it: AsyncIterable<V>, f: (v: V) => X) {\n  // https://surma.github.io/underdash/\n\n  for await (const v of it) {\n    yield f(v);\n  }\n}\n\n\nexport async function* max<V>(it: AsyncIterable<V>, gt = ((a: V, b: V) => a > b)) {\n  let max: V | undefined;\n  for await (const v of it) {\n    if (max === undefined) {\n      max = v;\n      yield (max);\n      continue;\n    }\n    // If V is bigger than max, we have a new max\n    if (gt(v, max)) {\n      max = v;\n      yield v;\n    }\n  }\n}\n\n/**\n * Returns the minimum seen of an iterable as it changes.\n * Streaming result: works with endless iterables.\n * \n * Note that `gt` function returns true if A is _greater_ than B, even\n * though we're looking for the minimum.\n * \n * ```js\n * // Rank objects based on 'v' value\n * const rank = (a,b) => a.v > b.v;\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns\n */\nexport async function* min<V>(it: AsyncIterable<V>, gt = (a: V, b: V) => a > b) {\n  let min: V | undefined;\n  for await (const v of it) {\n    if (min === undefined) {\n      min = v;\n      yield min;\n      continue;\n    }\n    // If min is bigger than V, V is the new min\n    if (gt(min, v)) {\n      min = v;\n      yield v;\n    }\n  }\n  return min;\n}\n\nexport async function reduce<V>(\n  it: AsyncIterable<V>,\n  f: (accumulator: V, current: V) => V,\n  start: V\n) {\n  // https://surma.github.io/underdash/\n\n  for await (const v of it) start = f(start, v);\n  return start;\n}\n\n/**\n * Calls `callback` whenever the async generator produces a value.\n * \n * When using `asCallback`, call it with `await` to let generator \n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n * \n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input \n * @param callback \n */\nexport async function asCallback<V>(input: AsyncIterable<V>, callback: (v: V) => unknown, onDone?: () => void) {\n  for await (const value of input) {\n    callback(value);\n  }\n  if (onDone) onDone();\n}\n\nexport async function* slice<V>(\n  it: AsyncIterable<V>,\n  start = 0,\n  end = Number.POSITIVE_INFINITY\n) {\n  // https://surma.github.io/underdash/\n  const iit = it[ Symbol.asyncIterator ]();\n  if (end < start) throw new Error(`Param 'end' should be more than 'start'`);\n\n  for (; start > 0; start--, end--) await iit.next();\n\n  for await (const v of it) {\n    if (end-- > 0) {\n      yield v;\n    } else {\n      break;\n    }\n  }\n}\n\n/**\n * Enumerates over an input iterable, with a delay between items.\n * @param it \n * @param delay \n */\nexport async function* withDelay<V>(it: Iterable<V>, delay: Interval) {\n  for (const v of it) {\n    await sleep(delay);\n    yield v;\n  }\n}\n\n/***\n * Returns the next IteratorResult,\n * throwing an error if it does not happen\n * within `interval` (default: 1s)\n */\nexport async function nextWithTimeout<V>(it: AsyncIterableIterator<V> | IterableIterator<V>, options: SleepOpts<any>) {\n  const ms = intervalToMs(options, 1000);\n\n  const value: IteratorResult<V> | undefined = await Promise.race([\n    (async () => {\n      await sleep({ millis: ms, signal: options.signal });\n      // eslint-disable-next-line unicorn/no-useless-undefined\n      return undefined;\n    })(),\n    (async () => {\n      return await it.next();\n    })()\n  ]);\n  if (value === undefined) throw new Error(`Timeout`);\n  return value;\n}\n\nexport async function some<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (await f(v)) return true;\n  }\n  return false;\n}\n\n// export async function* takeWhile<V>(\n//   it: AsyncIterable<V>,\n//   f: (v: V) => boolean\n// ) {\n//   // https://surma.github.io/underdash/\n\n//   for await (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\n\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide limits via the options.\n * ```js\n * // Return maximum five items\n * const data = await toArray(iterable, { limit: 5 });\n * // Return results for a maximum of 5 seconds\n * const data = await toArray(iterable, { elapsed: 5000 });\n * ```\n * Note that limits are ORed, `toArray` will finish if either of them is true.\n * \n * @param it Asynchronous iterable\n * @param options Options when converting to array\n * @returns\n */\nexport async function toArray<V>(it: AsyncIterable<V>, options: Partial<ToArrayOptions> = {}): Promise<Array<V>> {\n  // https://2ality.com/2016/10/asynchronous-iteration.html\n  const result = [];\n  const iterator = it[ Symbol.asyncIterator ]();\n  const started = Date.now();\n  const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n  const whileFunc = options.while;\n  const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n\n  while (result.length < maxItems && (Date.now() - started < maxElapsed)) {\n    if (whileFunc) {\n      if (!whileFunc(result.length)) break;\n    }\n    const r = await iterator.next();\n    if (r.done) break;\n    //eslint-disable-next-line functional/immutable-data\n    result.push(r.value);\n  }\n  return result;\n}\n\n\nexport async function* unique<V>(\n  iterable: AsyncIterable<V> | Array<AsyncIterable<V>>\n) {\n  const buffer: Array<any> = [];\n  const itera: Array<AsyncIterable<V>> = Array.isArray(iterable) ? iterable : [ iterable ];\n  for await (const it of itera) {\n    for await (const v of it) {\n      if (buffer.includes(v)) continue;\n      buffer.push(v);\n      yield v;\n    }\n  }\n}\n\nexport async function* uniqueByValue<T>(input: AsyncIterable<T>, toString: (value: T) => string = toStringDefault, seen: Set<string> = new Set<string>()): AsyncGenerator<T> {\n  for await (const v of input) {\n    const key = toString(v);\n    if (seen.has(key)) continue;\n    seen.add(key);\n    yield v;\n  }\n}\n\n/**\n * Returns unique items from iterables, given a particular key function\n * ```js\n * unique([{i:0,v:2},{i:1,v:3},{i:2,v:2}], e => e.v);\n * Yields:  [{i:0,v:2},{i:1,v:3}]\n * @param it\n * @param f\n */\n//eslint-disable-next-line func-style\n// export async function* unique<V>(\n//   it: AsyncIterable<V>,\n//   f: (id: V) => V = (id) => id\n// ) {\n//   // https://surma.github.io/underdash/\n//   const buffer: Array<V> = [];\n\n//   for await (const v of it) {\n//     const fv = f(v);\n//     if (buffer.includes(fv)) continue;\n//     buffer.push(fv);\n//     yield v;\n//   }\n// }\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport async function* zip<V>(...its: ReadonlyArray<AsyncIterable<V>>) {\n  // https://surma.github.io/underdash/\n  const iits = its.map((it) => it[ Symbol.asyncIterator ]());\n\n  while (true) {\n    const vs = await Promise.all(iits.map((it) => it.next()));\n    if (vs.some((v) => v.done)) return;\n    yield vs.map((v) => v.value as V);\n  }\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { nextWithTimeout } from \"../../iterables/IterableAsync.js\";\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport { isAsyncIterable } from \"../../iterables/Iterable.js\";\nimport type { Reactive } from \"../Types.js\";\nimport type { GeneratorOptions } from \"./Types.js\";\nimport { StateMachine } from \"../../flow/index.js\";\n\n/**\n * Creates a Reactive from an AsyncGenerator or Generator\n * @param gen \n * @returns \n */\n// export function readFromGenerator<V>(gen: AsyncGenerator<V> | Generator<V>) {\n//   const rx = initStream<V>();\n//   // eslint-disable-next-line @typescript-eslint/no-misused-promises\n//   setTimeout(async () => {\n//     try {\n//       for await (const value of gen) {\n//         rx.set(value);\n//       }\n//       rx.dispose(`Source generator complete`);\n//     } catch (error) {\n//       console.error(error);\n//       rx.dispose(`Error while iterating`);\n//     }\n//   }, 1);\n//   return rx;\n// }\n\n/**\n * Creates a readable reactive based on a (async)generator or iterator\n * ```js\n * // Generator a random value every 5 seconds\n * const valuesOverTime = Flow.interval(() => Math.random(), 5000);\n * // Wrap the generator\n * const r = Rx.From.iterator(time);\n * // Get notified when there is a new value\n * r.onValue(v => {\n *   console.log(v);\n * });\n * ```\n * \n * Awaiting values could potentially hang code. Thus there is a `readTimeout`, the maximum time to wait for a value from the generator. Default: 5 minutes.\n * If `signal` is given, this will also cancel waiting for the value.\n * @param source \n */\nexport function iterator<V>(source: IterableIterator<V> | Array<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V>, options: Partial<GeneratorOptions> = {}): Reactive<V> {\n  const lazy = options.lazy ?? `very`;\n  const log = options.traceLifecycle ? (message: string) => { console.log(`Rx.From.iterator ${ message }`); } : (_: string) => {/* no-up */ }\n\n  const readIntervalMs = intervalToMs(options.readInterval, 5);\n  const readTimeoutMs = intervalToMs(options.readTimeout, 5 * 60 * 1000);\n  const whenStopped = options.whenStopped ?? `continue`;\n\n  let iterator: IterableIterator<V> | AsyncIterableIterator<V> | undefined;\n  //let reading = false;\n  let ourAc: AbortController | undefined;\n  let sm = StateMachine.init({\n    idle: [ `wait_for_next` ],\n    wait_for_next: [ `processing_result`, `stopping`, `disposed` ],\n    processing_result: [ `queued`, `disposed`, `stopping` ],\n    queued: [ `wait_for_next`, `disposed`, `stopping` ],\n    stopping: `idle`,\n    // eslint-disable-next-line unicorn/no-null\n    disposed: null\n  }, `idle`);\n\n  const onExternalSignal = () => {\n    log(`onExternalSignal`);\n    ourAc?.abort(options.signal?.reason);\n  }\n  if (options.signal) {\n    options.signal.addEventListener(`abort`, onExternalSignal, { once: true });\n  };\n\n  const read = async () => {\n    log(`read. State: ${ sm.value }`);\n    ourAc = new AbortController();\n    try {\n      sm = StateMachine.to(sm, `wait_for_next`);\n      // @ts-expect-error\n      const v = await nextWithTimeout(iterator, { signal: ourAc.signal, millis: readTimeoutMs });\n      sm = StateMachine.to(sm, `processing_result`);\n      ourAc?.abort(`nextWithTimeout completed`);\n\n      if (v.done) {\n        log(`read v.done true`);\n        events.dispose(`Generator complete`);\n        //reading = false;\n        sm = StateMachine.to(sm, `disposed`);\n      }\n      //if (!reading) return;\n      if (sm.value === `stopping`) {\n        log(`read. sm.value = stopping`)\n        sm = StateMachine.to(sm, `idle`);\n        return;\n      }\n      if (sm.value === `disposed`) {\n        log(`read. sm.value = disposed`);\n        return;\n      }\n      events.set(v.value);\n\n    } catch (error) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      events.dispose(`Generator error: ${ (error as any).toString() }`);\n      return;\n    }\n    //if (events.isDisposed()) return;\n    //if (!reading) return;\n\n    if (sm.value === `processing_result`) {\n      sm = StateMachine.to(sm, `queued`);\n      log(`scheduling read. State: ${ sm.value }`);\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      setTimeout(read, readIntervalMs);\n    } else {\n      sm = StateMachine.to(sm, `idle`);\n    }\n  }\n\n  const events = initLazyStream<V>({\n    ...options,\n    lazy,\n    onStart() {\n      log(`onStart state: ${ sm.value } whenStopped: ${ whenStopped }`);\n      if (sm.value !== `idle`) return;\n      if ((sm.value === `idle` && whenStopped === `reset`) || iterator === undefined) {\n        iterator = isAsyncIterable(source) ? source[ Symbol.asyncIterator ]() : source[ Symbol.iterator ]();\n      }\n      //reading = true;\n      void read();\n    },\n    onStop() {\n      log(`onStop state: ${ sm.value } whenStopped: ${ whenStopped }`);\n      //reading = false;\n      sm = StateMachine.to(sm, `stopping`);\n      if (whenStopped === `reset`) {\n        log(`onStop reiniting iterator`);\n        iterator = isAsyncIterable(source) ? source[ Symbol.asyncIterator ]() : source[ Symbol.iterator ]();\n      }\n    },\n    onDispose(reason: string) {\n      log(`onDispose (${ reason })`);\n      ourAc?.abort(`Rx.From.iterator disposed (${ reason })`);\n      if (options.signal) options.signal.removeEventListener(`abort`, onExternalSignal);\n    },\n  });\n\n  // const readingStart = () => {\n\n  // }\n  //if (!lazy) readingStart();\n\n  // return {\n  //   on: events.on,\n  //   value: events.value,\n  //   dispose: events.dispose,\n  //   isDisposed: events.isDisposed\n  // }\n  return events;\n}\n","import { isAsyncIterable, isIterable } from \"../iterables/Iterable.js\";\nimport { func } from \"./sources/Function.js\";\nimport { iterator } from \"./sources/Iterator.js\";\nimport type { GeneratorOptions, FunctionOptions } from \"./sources/Types.js\";\nimport type { Reactive, ReactiveOrSource } from \"./Types.js\";\nimport { isReactive, isWrapped } from \"./Util.js\";\n\nexport type ResolveSourceOptions = {\n  /**\n   * Options when creating a reactive from a generator\n   * Default:  `{ lazy: true, interval: 5 }`\n   */\n  generator: GeneratorOptions\n  /**\n   * Options when creating a reactive from a function.\n   */\n  function: FunctionOptions\n}\n\n/**\n * Resolves various kinds of sources into a Reactive.\n * If `source` is an iterable/generator, it gets wrapped via `generator()`.\n * \n * Default options:\n * * generator: `{ lazy: true, interval: 5 }`\n * @param source \n * @returns \n */\nexport const resolveSource = <V>(source: ReactiveOrSource<V>, options: Partial<ResolveSourceOptions> = {}): Reactive<V> => {\n  if (isReactive(source)) return source;\n  const generatorOptions = options.generator ?? { lazy: `initial`, interval: 5 }\n  const functionOptions = options.function ?? { lazy: `very` }\n  // eslint-disable-next-line unicorn/prefer-ternary\n  if (Array.isArray(source)) {\n    return iterator(source.values(), generatorOptions);\n  } else if (typeof source === `function`) {\n    return func<V>(source, functionOptions)\n  } else if (typeof source === `object`) {\n    //console.log(`resolveSource is object`);\n    if (isWrapped<V>(source)) {\n      //console.log(`resolveSource is object - wrapped`);\n      return source.source;\n    }\n    if (isIterable(source) || isAsyncIterable(source)) {\n      //console.log(`resolveSource is object - iterable`);\n      return iterator(source, generatorOptions);\n    }\n  }\n  throw new TypeError(`Unable to resolve source. Supports: array, Reactive, Async/Iterable. Got type: ${ typeof source }`);\n}","import type { Reactive } from \"./Types.js\";\n\n/**\n * A stream that caches its last value\n */\nexport type CacheStream<T> = {\n  /**\n   * Clears the last cached value\n   * @returns \n   */\n  resetCachedValue: () => void\n  /**\n   * Gets the cached value, if available\n   * @returns \n   */\n  last: () => T | undefined\n}\n\n/**\n * A {@link CacheStream} with an initial value\n */\nexport type CacheStreamInitial<T> = CacheStream<T> & {\n  last: () => T\n}\n\n/**\n * Wraps an input stream to cache values, and provide an initial value\n * @param r Input stream\n * @param initialValue Initial value\n */\nexport function cache<TValue, RT extends Reactive<TValue>>(r: RT, initialValue: TValue): CacheStreamInitial<TValue> & RT;\n\n/**\n * Wrapes an input stream to cache values, optionally providing an initial value\n * @param r \n * @param initialValue \n * @returns \n */\nexport function cache<TValue, RT extends Reactive<TValue>>(r: RT, initialValue: TValue | undefined): CacheStream<TValue> & RT {\n  let lastValue: TValue | undefined = initialValue;\n  r.onValue(value => {\n    lastValue = value;\n  });\n  return {\n    ...r,\n    last() {\n      return lastValue\n    },\n    resetCachedValue() {\n      lastValue = undefined;\n    }\n  }\n}","import { type Dispatch, DispatchList } from \"../flow/DispatchList.js\";\nimport { resolveSource } from \"./ResolveSource.js\";\nimport type { InitLazyStreamInitedOptions, InitLazyStreamOptions, InitStreamOptions, Passed, ReactiveInitialStream, ReactiveOrSource, ReactiveStream, SignalKinds, UpstreamOptions } from \"./Types.js\";\nimport { messageHasValue, messageIsSignal } from \"./Util.js\";\nimport { cache } from \"./Cache.js\";\n\n\n/**\n * Initialise a stream based on an upstream source.\n * Calls initLazyStream under the hood.\n * \n * Options:\n * * onValue: called when upstream emits a value (default: does nothing with upstream value)\n * * lazy: laziness of stream (default: 'initial')\n * * disposeIfSourceDone: disposes stream if upstream disposes (default: true)\n * @ignore\n * @param upstreamSource \n * @param options \n * @returns \n */\nexport function initUpstream<In, Out>(upstreamSource: ReactiveOrSource<In>, options: Partial<UpstreamOptions<In>>): ReactiveStream<Out> {\n  const lazy = options.lazy ?? `initial`;\n  const disposeIfSourceDone = options.disposeIfSourceDone ?? true;\n  const onValue = options.onValue ?? ((_v: In) => {/** no-op */ })\n  const source = resolveSource(upstreamSource);\n  let unsub: undefined | (() => void);\n  const debugLabel = options.debugLabel ? `[${ options.debugLabel }]` : ``;\n  //console.log(`initUpstream${ debugLabel } creating`);\n\n  const onStop = () => {\n    //console.log(`Rx.initStream${ debugLabel } stop`);\n    if (unsub === undefined) return;\n    unsub();\n    unsub = undefined;\n    if (options.onStop) options.onStop();\n  }\n\n  const onStart = () => {\n    //console.log(`Rx.initStream${ debugLabel } start unsub ${ unsub !== undefined }`);\n    if (unsub !== undefined) return;\n    if (options.onStart) options.onStart();\n\n    unsub = source.on(value => {\n      //console.log(`Rx.initStream${ debugLabel } onValue`, value);\n      if (messageIsSignal(value)) {\n        if (value.signal === `done`) {\n          onStop();\n          events.signal(value.signal, value.context);\n          if (disposeIfSourceDone) events.dispose(`Upstream source ${ debugLabel } has completed (${ value.context ?? `` })`);\n        } else {\n          //events.through_(value);\n          events.signal(value.signal, value.context);\n        }\n      } else if (messageHasValue(value)) {\n        //lastValue = value.value;\n        onValue(value.value);\n      }\n    });\n  }\n\n\n\n  //const initOpts = \n  // const events:ReactiveInitialStream<Out>|ReactiveStream<Out> = ((`initialValue` in options) && options.initialValue !== undefined) ?\n  //   initLazyStreamWithInitial<Out>({ ...initOpts, initialValue: options.initialValue }) :\n  //   initLazyStream<Out>(initOpts);\n  //console.log(`initUpstream${ debugLabel } creating initLazyStream`);\n\n  const events = initLazyStream<Out>({\n    ...options,\n    lazy,\n    onStart,\n    onStop\n  });\n  return events;\n}\n\n/**\n * Initialises a lazy stream with an initial value.\n * Uses {@link initLazyStream} and {@link cache} together.\n * @param options \n * @returns \n */\nexport function initLazyStreamWithInitial<V>(options: InitLazyStreamInitedOptions<V>): ReactiveInitialStream<V> {\n  const r = initLazyStream<V>(options);\n  const c = cache<V, typeof r>(r, options.initialValue);\n  return c;\n}\n\n/**\n * Initialises a lazy stream\n * Consider also: {@link initLazyStreamWithInitial}\n * \n * Uses {@link lazyStream} internally.\n * @param options \n * @returns \n */\nexport function initLazyStream<V>(options: InitLazyStreamOptions): ReactiveStream<V> {\n  const lazy = options.lazy ?? `initial`;\n  const onStop = options.onStop ?? (() => { /* no-op*/ })\n  const onStart = options.onStart ?? (() => {/* no-op*/ })\n  const debugLabel = options.debugLabel ? `[${ options.debugLabel }]` : ``;\n  const events = initStream<V>({\n    ...options,\n    onFirstSubscribe() {\n      if (lazy !== `never`) {\n        //console.log(`initLazyStream${ debugLabel } onFirstSubscribe, lazy: ${ lazy }. Calling onStart`);\n        onStart();\n      }\n    },\n    onNoSubscribers() {\n      if (lazy === `very`) {\n        //console.log(`initLazyStream${ debugLabel } onNoSubscribers, lazy: ${ lazy }. Calling onStop`);\n        onStop();\n      }\n    },\n  });\n  if (lazy === `never`) onStart();\n  return events;\n}\n\n/**\n * Initialises a new stream.\n * \n * Options:\n * * onFirstSubscribe: Called when there is a subscriber after there have been no subscribers.\n * * onNoSubscribers: Called when there are no more subscribers. 'onFirstSubscriber' will be called next time a subscriber is added.\n * \n * Alternatives:\n * * {@link initLazyStream} - a stream with callbacks for when there is some/none subscribers\n * @ignore\n * @param options \n * @returns \n */\nexport function initStream<V>(options: Partial<InitStreamOptions> = {}): ReactiveStream<V> {\n  let dispatcher: DispatchList<Passed<V>> | undefined;\n  let disposed = false;\n  let firstSubscribe = false;\n  let emptySubscriptions = true;\n  const onFirstSubscribe = options.onFirstSubscribe ?? undefined;\n  const onNoSubscribers = options.onNoSubscribers ?? undefined;\n  const debugLabel = options.debugLabel ? `[${ options.debugLabel }]` : ``;\n\n  const isEmpty = () => {\n    if (dispatcher === undefined) return;\n    if (!dispatcher.isEmpty) return;\n    if (!emptySubscriptions) {\n      emptySubscriptions = true;\n      firstSubscribe = false;\n      if (onNoSubscribers) onNoSubscribers();\n    }\n  }\n\n  const subscribe = (handler: Dispatch<Passed<V>>) => {\n    if (disposed) throw new Error(`Disposed, cannot subscribe ${ debugLabel }`);\n    if (dispatcher === undefined) dispatcher = new DispatchList();\n    //console.log(`initStream${ debugLabel } subscribe handler:`, handler);\n    const id = dispatcher.add(handler);\n    emptySubscriptions = false;\n    if (!firstSubscribe) {\n      firstSubscribe = true;\n      //if (onFirstSubscribe) setTimeout(() => { onFirstSubscribe() }, 10);\n      if (onFirstSubscribe) onFirstSubscribe();\n    }\n    return () => {\n      dispatcher?.remove(id);\n      isEmpty();\n    }\n  }\n\n  return {\n    dispose: (reason: string) => {\n      if (disposed) return;\n      dispatcher?.notify({ value: undefined, signal: `done`, context: `Disposed: ${ reason }` });\n      disposed = true;\n      if (options.onDispose) options.onDispose(reason);\n    },\n    isDisposed: () => {\n      return disposed\n    },\n    removeAllSubscribers: () => {\n      dispatcher?.clear();\n      isEmpty();\n    },\n    set: (v: V) => {\n      if (disposed) throw new Error(`${ debugLabel } Disposed, cannot set`);\n      dispatcher?.notify({ value: v });\n    },\n    // through: (pass: Passed<V>) => {\n    //   if (disposed) throw new Error(`Disposed, cannot through`);\n    //   dispatcher?.notify(pass)\n    // },\n    signal: (signal: SignalKinds, context?: string) => {\n      if (disposed) throw new Error(`${ debugLabel } Disposed, cannot signal`);\n      dispatcher?.notify({ signal, value: undefined, context });\n    },\n    on: (handler: Dispatch<Passed<V>>) => subscribe(handler),\n    onValue: (handler: (value: V) => void) => {\n      const unsub = subscribe(message => {\n        //console.log(`initStream${ debugLabel } onValue wrapper`, message);\n        if (messageHasValue(message)) {\n          handler(message.value);\n        }\n      });\n      return unsub;\n    }\n  }\n}\n","import { resolveEls, type QueryOrElements } from \"./ResolveEl.js\";\n\nexport function setText(selectors: QueryOrElements): (value: any) => string;\nexport function setText(selectors: QueryOrElements, value?: any): string;\nexport function setText(selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  return setProperty(`textContent`, selectors, value)\n};\n\nexport function setHtml(selectors: QueryOrElements): (value: any) => string;\nexport function setHtml(selectors: QueryOrElements, value?: any): string;\nexport function setHtml(selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  return setProperty(`innerHTML`, selectors, value)\n};\n\nexport function setProperty(property: string, selectors: QueryOrElements): (value: any) => string;\nexport function setProperty(property: string, selectors: QueryOrElements, value: any): string;\n\nexport function setProperty(property: string, selectors: QueryOrElements, value?: any): string | ((value: any) => string) {\n  let elements: Array<HTMLElement> = [];\n  const set = (v: any) => {\n    const typ = typeof v;\n    const vv = (typ === `string` || typ === `number` || typ === `boolean`) ? v as string :\n      JSON.stringify(v);\n\n    if (elements.length === 0) {\n      elements = resolveEls(selectors);\n    }\n    for (const element of elements) {\n      (element as any)[ property ] = vv;\n    }\n    return vv;\n  }\n  return value === undefined ? set : set(value);\n};","import { setProperty } from \"../../dom/SetProperty.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource } from \"../Types.js\";\n\nexport type SetHtmlOptionsQuery = {\n  query: string\n}\n\nexport type SetHtmlOptionsElement = {\n  el: HTMLElement\n}\n\nexport type SetHtmlOptions = (SetHtmlOptionsQuery | SetHtmlOptionsElement) & {\n  /**\n   * If _true_ .innerHTML is used\n   * If _false_ (default) .textContent is used\n   */\n  asHtml?: boolean;\n};\n\n/**\n * Values from `input` are set to the textContent/innerHTML of an element.\n * ```js\n * const rxSource = Rx.From.string('hello');\n * const rxSet = Rx.Sinks.setHtmlText(rxSource, { query: })\n * ```\n * @param rxOrSource \n * @param optionsOrElementOrQuery \n */\nexport const setHtmlText = (rxOrSource: ReactiveOrSource<any>, optionsOrElementOrQuery: SetHtmlOptions | string | HTMLElement) => {\n  let el: HTMLElement | null | undefined;\n  let options: SetHtmlOptions | undefined;\n  if (typeof optionsOrElementOrQuery === `string`) {\n    options = { query: optionsOrElementOrQuery };\n  }\n  if (typeof optionsOrElementOrQuery === `object`) {\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (`nodeName` in optionsOrElementOrQuery) {\n      options = { el: optionsOrElementOrQuery };\n    } else {\n      options = optionsOrElementOrQuery;\n    }\n  }\n  if (options === undefined) throw new TypeError(`Missing element as second parameter or option`);\n  if (`el` in options) {\n    el = options.el;\n  } else if (`query` in options) {\n    el = document.querySelector<HTMLElement>(options.query);\n  } else {\n    throw new TypeError(`Options does not include 'el' or 'query' fields`);\n  }\n  if (el === null || el === undefined) throw new Error(`Element could not be resolved.`);\n\n  const stream = resolveSource(rxOrSource);\n  const setter = setProperty(options.asHtml ? `innerHTML` : `textContent`, el);\n  const off = stream.onValue(value => {\n    setter(value)\n  });\n  return off;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport type { Reactive, ReactiveStream } from \"./Types.js\";\n\n/***\n * Returns a read-only version of `stream`\n */\nexport const toReadable = <V>(stream: ReactiveStream<V>): Reactive<V> => ({\n  on: stream.on,\n  dispose: stream.dispose,\n  isDisposed: stream.isDisposed,\n  onValue: stream.onValue\n});\n","import { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveOp } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { TransformOpts } from \"./Types.js\";\nimport { resolveSource, syncToObject } from \"../index.js\";\n\n/**\n * Annotates values from `source`. Output values will be\n * in the form `{ value: TIn, annotation: TAnnotation }`.\n * Where `TIn` is the type of the input, and `TAnnotation` is\n * the return type of the annotator function.\n * \n * Example calculating area from width & height:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const annotated = Rx.Ops.annotate(data, v => {\n *  return { area: v.w * v.h }\n * });\n * const data = await Rx.toArray(annotated);\n * // Data =  [ { value: { w:1, h:3 }, annotation: { area:3 } } ...]\n * ```\n * \n * If you would rather annotate and have values merge with the input,\n * use `transform`:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const withArea = Rx.Ops.transform(data, v => {\n *  return { ...v, area: v.w * v.h }\n * });\n * const data = await Rx.toArray(withArea);\n * // Data =  [ { w:1, h:3, area:3 }, ...]\n * ```\n */\nexport function annotate<In, TAnnotation>(input: ReactiveOrSource<In>, annotator: (value: In) => TAnnotation, options: Partial<TransformOpts> = {}): Reactive<{ value: In, annotation: TAnnotation }> {\n  const upstream = initUpstream<In, { value: In, annotation: TAnnotation }>(input, {\n    ...options,\n    onValue(value) {\n      const annotation = annotator(value);\n      upstream.set({ value, annotation });\n    },\n  })\n  return toReadable(upstream);\n}\n\n/**\n * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n * \n * ```js\n * const data = Rx.From.array([ 1, 2, 3 ]);\n * const annotated = Rx.Ops.annotateWithOp(data, Rx.Ops.sum());\n * const data = await annotated.toArray(annotated);\n * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n * ```\n * @param annotatorOp Operator to generate annotations\n * @param input Input stream\n * @returns \n */\nexport function annotateWithOp<In, TAnnotation>(input: ReactiveOrSource<In>, annotatorOp: ReactiveOp<In, TAnnotation>): Reactive<{ value: In, annotation: TAnnotation }> {\n\n  const inputStream = resolveSource(input);\n\n  // Create annotations from input\n  const stream = annotatorOp(inputStream);\n\n  const synced = syncToObject({\n    value: inputStream,\n    annotation: stream\n  })\n  return synced as Reactive<{ value: In, annotation: TAnnotation }>;\n}\n\n","import { QueueMutable } from \"../../collections/queue/QueueMutable.js\";\nimport { timeout } from \"../../flow/Timeout.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { ChunkOptions } from \"./Types.js\";\n\n/**\n * Queue from `source`, emitting when thresholds are reached. \n * The resulting Reactive produces arrays.\n * \n * Can use a combination of elapsed time or number of data items.\n * \n * By default options are OR'ed together.\n *\n * ```js\n * // Emit data in chunks of 5 items\n * chunk(source, { quantity: 5 });\n * // Emit a chunk of data every second\n * chunk(source, { elapsed: 1000 });\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport function chunk<V>(source: ReactiveOrSource<V>, options: Partial<ChunkOptions> = {}): Reactive<Array<V>> {\n  const queue = new QueueMutable<V>();\n  const quantity = options.quantity ?? 0;\n  const returnRemainder = options.returnRemainder ?? true;\n\n  const upstreamOpts = {\n    ...options,\n    onStop() {\n      if (returnRemainder && !queue.isEmpty) {\n        const data = queue.toArray();\n        queue.clear();\n        upstream.set(data);\n      }\n    },\n    onValue(value: V) {\n      queue.enqueue(value);\n      if (quantity > 0 && queue.length >= quantity) {\n        // Reached quantity limit\n        send();\n      }\n      // Start timer\n      if (timer !== undefined && timer.runState === `idle`) {\n        timer.start();\n      }\n    },\n  }\n  const upstream = initUpstream<V, Array<V>>(source, upstreamOpts);\n\n  //let testElapsed = performance.now();\n  const send = () => {\n    //console.log(`Elapsed: ${ performance.now() - testElapsed }`);\n    //testElapsed = performance.now();\n    if (queue.isEmpty) return;\n\n    // Reset timer\n    if (timer !== undefined) timer.start();\n\n    // Fire queued data\n    const data = queue.toArray();\n    queue.clear();\n    setTimeout(() => upstream.set(data));\n  }\n\n  const timer = options.elapsed ? timeout(send, options.elapsed) : undefined\n\n  // const trigger = () => {\n  //   const now = performance.now();\n  //   let byElapsed = false;\n  //   let byLimit = false;\n  //   if (elapsed > 0 && (now - lastFire > elapsed)) {\n  //     lastFire = now;\n  //     byElapsed = true;\n  //   }\n  //   if (limit > 0 && queue.length >= limit) {\n  //     byLimit = true;\n  //   }\n  //   if (logic === `or` && (!byElapsed && !byLimit)) return;\n  //   if (logic === `and` && (!byElapsed || !byLimit)) return;\n\n  //   send();\n  // }\n\n  return toReadable(upstream);\n}\n","import { initUpstream } from \"../InitStream.js\";\nimport type { Reactive, ReactiveOrSource } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { TransformOpts } from \"./Types.js\";\n\n/**\n * Transforms values from `source` using the `transformer` function.\n * @param transformer \n * @returns \n */\nexport function transform<In, Out>(input: ReactiveOrSource<In>, transformer: (value: In) => Out, options: Partial<TransformOpts> = {}): Reactive<Out> {\n  const traceInput = options.traceInput ?? false;\n  const traceOutput = options.traceOutput ?? false;\n\n  const upstream = initUpstream<In, Out>(input, {\n    lazy: `initial`,\n    ...options,\n    onValue(value) {\n      const t = transformer(value);\n      if (traceInput && traceOutput) {\n        console.log(`Rx.Ops.transform input: ${ JSON.stringify(value) } output: ${ JSON.stringify(t) }`);\n      } else if (traceInput) {\n        console.log(`Rx.Ops.transform input: ${ JSON.stringify(value) }`);\n      } else if (traceOutput) {\n        console.log(`Rx.Ops.transform output: ${ JSON.stringify(t) }`);\n      }\n\n      upstream.set(t);\n    },\n  })\n  return toReadable(upstream);\n}\n\n","\nimport { isPlainObjectOrPrimitive } from \"../../util/GuardObject.js\";\nimport type { ReactiveOrSource } from \"../Types.js\";\nimport { transform } from \"./Transform.js\";\n\n/**\n * Create a new object from input, based on cloning fields rather than a destructured copy.\n * This is useful for event args.\n * @param source \n * @returns \n */\nexport const cloneFromFields = <In>(source: ReactiveOrSource<In>) => {\n  return transform<In, In>(source, (v): In => {\n    const entries: Array<[ key: string, value: any ]> = [];\n    for (const field in v) {\n      const value = (v)[ field ];\n      if (isPlainObjectOrPrimitive(value as unknown)) {\n        entries.push([ field, value ]);\n      }\n    }\n    return Object.fromEntries(entries) as In;\n  })\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, CombineLatestOptions, Reactive, RxValueTypes } from \"../Types.js\";\nimport { messageIsDoneSignal, messageHasValue } from \"../Util.js\";\n\n/**\n * Monitors input reactive values, storing values as they happen to an array.\n * Whenever a new value is emitted, the whole array is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n * \n * See {@link combineLatestToObject} to combine streams by name into an object, rather than array.\n * \n * ```\n * const sources = [\n *  Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToArray(sources);\n * r.onValue(value => {\n *  // Value will be an array of last value from each source:\n *  // [number,number]  \n * });\n * ```\n * \n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToArray} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n * \n * Set `onSourceDone` to choose behaviour if a source stops. By default it\n * is 'break', meaning the whole merged stream stops.\n * \n * Note: unlike RxJS's `combineLatest`, does not wait for each source to emit once\n * before emitting first value.\n * @param reactiveSources Sources to merge\n * @param options Options for merging \n * @returns \n */\nexport function combineLatestToArray<const T extends ReadonlyArray<ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<CombineLatestOptions> = {}): Reactive<RxValueTypes<T>> {\n  const event = initStream<RxValueTypes<T>>();\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const data: Array<RxValueTypes<T> | undefined> = [];\n  const sources = reactiveSources.map(source => resolveSource(source));\n  const noop = () => {/** no-op */ };\n  const sourceOff = sources.map(_ => noop);\n  const doneSources = sources.map(_ => false);\n\n  const unsub = () => {\n    for (const v of sourceOff) { v() }\n  }\n\n  for (const [ index, v ] of sources.entries()) {\n    data[ index ] = undefined;\n    sourceOff[ index ] = v.on(message => {\n      if (messageIsDoneSignal(message)) {\n        doneSources[ index ] = true;\n        sourceOff[ index ]();\n        sourceOff[ index ] = noop;\n        if (onSourceDone === `break`) {\n          unsub();\n          event.dispose(`Source has completed and 'break' is set`);\n          return;\n        }\n        if (!doneSources.includes(false)) {\n          // All sources are done\n          unsub();\n          event.dispose(`All sources completed`);\n        }\n      } else if (messageHasValue(message)) {\n        data[ index ] = message.value;\n        event.set([ ...data ] as RxValueTypes<T>);\n      }\n    });\n  }\n\n  return {\n    dispose: event.dispose,\n    isDisposed: event.isDisposed,\n    on: event.on,\n    onValue: event.onValue\n  }\n}\n","import * as TraversableObject from '../collections/tree/TraverseObject.js';\nimport { isPrimitive } from '../util/IsPrimitive.js';\nimport { isPlainObjectOrPrimitive } from '../util/GuardObject.js';\nimport { isInteger } from '../util/IsInteger.js';\nimport { isEqualContextString, type IsEqualContext } from './Util.js';\nimport { compareKeys } from './Compare.js';\nimport type { Result } from '../util/Results.js';\n\nexport type PathData<V> = {\n  path: string\n  value: V\n}\n\nexport type PathDataChange<V> = PathData<V> & {\n  previous?: V\n  state: `change` | `added` | `removed`\n}\n\nexport type CompareDataOptions<V> = {\n  /**\n   * If _true_, it treats the B value as a partial\n   * version of B. Only the things present in B are compared.\n   * Omissions from B are not treated as removed keys.\n   */\n  asPartial: boolean\n  /**\n   * If _true_ (default), if a value is undefined,\n   * it signals that the key itself is removed.\n   */\n  undefinedValueMeansRemoved: boolean\n  pathPrefix: string\n  /**\n   * Comparison function for values. By default uses\n   * JSON.stringify() to compare by value.\n   */\n  eq: IsEqualContext<V>\n  /**\n   * If true, inherited fields are also compared.\n   * This is necessary for events, for example.\n   * \n   * Only plain-object values are used, the other keys are ignored.\n   */\n  deepEntries: boolean\n\n  /**\n   * If _true_, includes fields that are present in B, but missing in A.\n   * _False_ by default.\n   */\n  includeMissingFromA: boolean\n\n  /**\n   * If _true_, emits a change under the path of a parent if its child has changed.\n   * If _false_ (default) only changed keys are emitted.\n   * \n   * Eg if data is: \n   * `{ colour: { h:0.5, s: 0.3, l: 0.5 }}`\n   * and we compare with:\n   * `{ colour: { h:1, s: 0.3, l: 0.5 }}`\n   * \n   * By default only 'colour.h' is emitted. If _true_ is set, 'colour' and 'colour.h' is emitted.\n   */\n  includeParents: boolean\n}\n\nconst getEntries = <V extends Record<string, any>>(target: V, deepProbe: boolean) => {\n  if (target === undefined) throw new Error(`Param 'target' is undefined`);\n  if (target === null) throw new Error(`Param 'target' is null`);\n  if (typeof target !== `object`) throw new Error(`Param 'target' is not an object (got: ${ typeof target })`);\n  if (deepProbe) {\n    const entries: Array<[ key: string, value: any ]> = [];\n    for (const field in target) {\n      const value = (target as any)[ field ];\n      if (isPlainObjectOrPrimitive(value as unknown)) {\n        entries.push([ field, value ]);\n      }\n    }\n    return entries;\n  } else {\n    return Object.entries(target);\n  }\n}\n\n/**\n * Scans object, producing a list of changed fields where B's value (newer) differs from A (older).\n * \n * Options:\n * - `deepEntries` (_false_): If _false_ Object.entries are used to scan the object. However this won't work for some objects, eg event args, thus _true_ is needed.\n * - `eq` (JSON.stringify): By-value comparison function\n * - `includeMissingFromA` (_false): If _true_ includes fields present on B but missing on A.\n * - `asPartial` (_false): If _true_, treats B as a partial update to B. This means that things missing from B are not considered removals.\n * @param a 'Old' value\n * @param b 'New' value\n * @param options Options for comparison\n * @returns \n */\nexport function* compareData<V extends Record<string, any>>(a: V, b: Partial<V>, options: Partial<CompareDataOptions<V>> = {}): Generator<PathDataChange<any>> {\n  if (a === undefined) {\n    yield {\n      path: options.pathPrefix ?? ``,\n      value: b,\n      state: `added`\n    };\n    return;\n  }\n  if (b === undefined) {\n    yield { path: options.pathPrefix ?? ``, previous: a, value: undefined, state: `removed` }\n    return;\n  }\n  const asPartial = options.asPartial ?? false;\n  const undefinedValueMeansRemoved = options.undefinedValueMeansRemoved ?? false;\n  const pathPrefix = options.pathPrefix ?? ``;\n  const deepEntries = options.deepEntries ?? false;\n  const eq = options.eq ?? isEqualContextString;\n  const includeMissingFromA = options.includeMissingFromA ?? false;\n  const includeParents = options.includeParents ?? false;\n\n  //console.log(`Pathed.compareData: a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) } prefix: ${ pathPrefix }`);\n\n  if (isPrimitive(a) && isPrimitive(b)) {\n    if (a !== b) yield { path: pathPrefix, value: b, previous: a, state: `change` };\n    return;\n  }\n  if (isPrimitive(b)) {\n    yield { path: pathPrefix, value: b, previous: a, state: `change` };\n    return;\n  }\n  const entriesA = getEntries(a, deepEntries);\n  const entriesAKeys = new Set<string>();\n  for (const [ key, valueA ] of entriesA) {\n    entriesAKeys.add(key);\n\n    const keyOfAInB = key in b;\n    const valueOfKeyInB = b[ key ];\n    //console.log(`Pathed.compareData Pathed.compareDataA key: ${ key } valueA: ${ JSON.stringify(valueA) }`);\n\n    if (typeof valueA === `object` && valueA !== null) {\n      if (keyOfAInB) {\n        //console.log(`Pathed.compareData key ${ key } exists in B. value:`, valueB);\n        if (valueOfKeyInB === undefined) {\n          throw new Error(`Pathed.compareData Value for key ${ key } is undefined`);\n        } else {\n          const sub = [ ...compareData(valueA, valueOfKeyInB, {\n            ...options,\n            pathPrefix: pathPrefix + key + `.`\n          }) ];\n          if (sub.length > 0) {\n            for (const s of sub) yield s;\n            if (includeParents) {\n              yield { path: pathPrefix + key, value: b[ key ], previous: valueA, state: `change` };\n            }\n          }\n        }\n      } else {\n        if (asPartial) continue;\n        //throw new Error(`Key does not exist in B. Key: '${ key }'. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n        yield { path: pathPrefix + key, value: undefined, previous: valueA, state: `removed` }\n      }\n    } else {\n      const subPath = pathPrefix + key;\n      if (keyOfAInB) {\n        // B contains key from A\n        if (valueOfKeyInB === undefined && undefinedValueMeansRemoved) {\n          //console.error(`Pathed.compareData (2) value for B is undefined. key: ${ key }. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n          yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n        } else {\n          if (!eq(valueA, valueOfKeyInB, subPath)) {\n            //console.log(`Pathed.compareData  value changed. A: ${ valueA } B: ${ valueB } subPath: ${ subPath }`)\n            yield { path: subPath, previous: valueA, value: valueOfKeyInB, state: `change` };\n          }\n        }\n      } else {\n        // B does not contain key from A\n        if (asPartial) continue; // Ignore\n        yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n      }\n    }\n  }\n\n  if (includeMissingFromA) {\n    const entriesB = getEntries(b, deepEntries);\n    for (const [ key, valueB ] of entriesB) {\n      if (entriesAKeys.has(key)) continue;\n      // Key in B that's not in A\n      //console.log(`Pathed.compareDataB key: ${ key } value: ${ valueB }`);\n      yield { path: pathPrefix + key, previous: undefined, value: valueB, state: `added` };\n    }\n  }\n}\n\n/**\n * Returns a copy of `source` with `changes` applied.\n * @param source \n * @param changes \n */\nexport const applyChanges = <V extends Record<string, any>>(source: V, changes: Array<PathDataChange<any>>): V => {\n  for (const change of changes) {\n    source = updateByPath(source, change.path, change.value);\n  }\n  return source;\n}\n\n/**\n * Returns a copy of `target` object with a specified path changed to `value`.\n * \n * ```js\n * const a = {\n *  message: `Hello`,\n *  position: { x: 10, y: 20 }\n * }\n * \n * const a1 = updateByPath(a, `message`, `new message`);\n * // a1 = { message: `new message`, position: { x: 10, y: 20 }}\n * const a2 = updateByPath(a, `position.x`, 20);\n * // a2 = { message: `hello`, position: { x: 20, y: 20 }}\n * ```\n * \n * Paths can also be array indexes:\n * ```js\n * updateByPath([`a`,`b`,`c`], 2, `d`);\n * // Yields: [ `a`, `b`, `d` ]\n * ```\n * \n * By default, only existing array indexes can be updated. Use the `allowShapeChange` parameter \n * to allow setting arbitrary indexes.\n * ```js\n * // Throws because array index 3 is undefined\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`);\n * \n * // With allowShapeChange flag\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`, true);\n * // Returns: [ `a`, `b`, `c`, `d` ]\n * ```\n * \n * Throws an error if:\n * * `path` cannot be resolved (eg. `position.z` in the above example)\n * * `value` applied to `target` results in the object having a different shape (eg missing a field, field\n * changing type, or array index out of bounds). Use `allowShapeChange` to suppress this error.\n * * Path is undefined or not a string\n * * Target is undefined/null\n * @param target Object to update\n * @param path Path to set value\n * @param value Value to set\n * @param allowShapeChange By default _false_, throwing an error if an update change the shape of the original object.\n * @returns \n */\nexport const updateByPath = <V extends Record<string, any>>(target: V, path: string, value: any, allowShapeChange = false): V => {\n  if (path === undefined) throw new Error(`Parameter 'path' is undefined`);\n  if (typeof path !== `string`) throw new Error(`Parameter 'path' should be a string. Got: ${ typeof path }`);\n  if (target === undefined) throw new Error(`Parameter 'target' is undefined`);\n  if (target === null) throw new Error(`Parameter 'target' is null`);\n\n  const split = path.split(`.`);\n  const r = updateByPathImpl(target, split, value, allowShapeChange);\n  return r as V;\n}\n\nconst updateByPathImpl = (o: any, split: Array<string>, value: any, allowShapeChange: boolean): any => {\n  if (split.length === 0) {\n    //console.log(`Pathed.updateByPathImpl o: ${ JSON.stringify(o) } value: ${ JSON.stringify(value) }`);\n\n    if (allowShapeChange) return value; // yolo\n\n    if (Array.isArray(o) && !Array.isArray(value)) throw new Error(`Expected array value, got: '${ JSON.stringify(value) }'. Set allowShapeChange=true to ignore.`);\n    if (!Array.isArray(o) && Array.isArray(value)) throw new Error(`Unexpected array value, got: '${ JSON.stringify(value) }'. Set allowShapeChange=true to ignore.`);\n\n    if (typeof o !== typeof value) throw new Error(`Cannot reassign object type. (${ typeof o } -> ${ typeof value }). Set allowShapeChange=true to ignore.`);\n\n    // Make sure new value has the same set of keys\n    if (typeof o === `object` && !Array.isArray(o)) {\n      const c = compareKeys(o, value);\n      if (c.a.length > 0) {\n        throw new Error(`New value is missing key(s): ${ c.a.join(`,`) }`);\n      }\n      if (c.b.length > 0) {\n        throw new Error(`New value cannot add new key(s): ${ c.b.join(`,`) }`);\n      }\n    }\n    return value;\n  }\n  const start = split.shift();\n  if (!start) return value;\n\n  const isInt = isInteger(start);\n  if (isInt && Array.isArray(o)) {\n    const index = Number.parseInt(start);\n    if (index >= o.length && !allowShapeChange) throw new Error(`Array index ${ index.toString() } is outside of the existing length of ${ o.length.toString() }. Use allowShapeChange=true to permit this.`);\n    const copy = [ ...o ];\n    copy[ index ] = updateByPathImpl(copy[ index ], split, value, allowShapeChange);\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    return copy;\n  } else if (start in o) {\n    const copy = { ...o };\n    copy[ start ] = updateByPathImpl(copy[ start ], split, value, allowShapeChange);\n    return copy;\n  } else {\n    throw new Error(`Path ${ start } not found in data`);\n  }\n}\n\n/**\n * Gets the data at `path` in `object`. Assumes '.' separates each segment of path.\n * ```js\n * getField({ name: { first: `Thom`, last: `Yorke` }}, `name.first`); // 'Thom'\n * getField({ colours: [`red`, `green`, `blue` ]}, `colours.1`); // `green`\n * ```\n * \n * Returns _undefined_ if path could not be resolved.\n * \n * Throws if:\n * * `path` is not a string or empty\n * * `object` is _undefined_ or null\n * @param object \n * @param path \n * @returns \n */\nexport const getField = <V>(object: Record<string, any>, path: string): Result<V> => {\n  if (typeof path !== `string`) throw new Error(`Param 'path' ought to be a string. Got: '${ typeof path }'`);\n  if (path.length === 0) throw new Error(`Param string 'path' is empty`);\n  if (object === undefined) throw new Error(`Param 'object' is undefined`);\n  if (object === null) throw new Error(`Param 'object' is null`);\n\n  const split = path.split(`.`);\n  const v = getFieldImpl<V>(object, split);\n  return v;\n}\n\nconst getFieldImpl = <V>(object: Record<string, any>, split: Array<string>): Result<V> => {\n  if (object === undefined) throw new Error(`Param 'object' is undefined`);\n  if (split.length === 0) throw new Error(`Path has run out`);\n  const start = split.shift();\n  if (!start) throw new Error(`Unexpected empty split path`);\n\n  const isInt = isInteger(start);\n  if (isInt && Array.isArray(object)) { //(arrayStart === 0 && arrayEnd === start.length - 1 && Array.isArray(o)) {\n    const index = Number.parseInt(start); //start.slice(1, -1));\n    //console.log(`getFieldImpl index: ${ index } value: ${ object[ index ] }`);\n    if (typeof object[ index ] === `undefined`) {\n      return { success: false, error: `Index '${ index }' does not exist. Length: ${ object.length }` };\n    }\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (split.length === 0) {\n      return { value: object[ index ] as V, success: true };\n    } else {\n      return getFieldImpl(object[ index ], split);\n    }\n  } else if (typeof object === `object` && start in object) {\n    //console.log(`start in object. Start: ${ start } Len: ${ split.length } Object`, object);\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (split.length === 0) {\n      return { value: object[ start ] as V, success: true };\n    } else {\n      return getFieldImpl(object[ start ], split);\n    }\n  } else {\n    return { success: false, error: `Path '${ start }' not found` };\n  }\n}\n\n\n/**\n * Iterates 'paths' for all the fields on `o`\n * ```\n * const d = {\n *  accel: { x: 1, y: 2, z: 3 },\n *  gyro: { x: 4, y: 5, z: 6 }\n * };\n * const paths = [...getFieldPaths(d)];\n * // Yields [ `accel`, `gyro`, `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * Use {@link getField} to fetch data based on a path\n *\n * If object is _null_ or _undefined_, no results are returned.\n * \n * If `onlyLeaves` is _true_ (default: _false_), only 'leaf' nodes are included. \n * Leaf nodes are those that contain a primitive value.\n * ```js\n * const paths = getFieldPaths(d, true);\n * // Yields [ `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * @param object Object to get paths for.\n * @param onlyLeaves If true, only paths with a primitive value are returned.\n * @returns\n */\nexport function* getPaths(object: object | null, onlyLeaves = false): Generator<string> {\n  if (object === undefined || object === null) return;\n  const iter = TraversableObject.depthFirst(object);\n  for (const c of iter) {\n    if (c.nodeValue === undefined && onlyLeaves) continue;\n    let path = c.name;\n    if (c.ancestors.length > 0) path = c.ancestors.join(`.`) + `.` + path;\n    yield path;\n  }\n};\n\n/**\n * Returns a representation of the object as a set of paths and data.\n * ```js\n * const o = { name: `hello`, size: 20, colour: { r:200, g:100, b:40 } }\n * const pd = [...getPathsAndData(o)];\n * // Yields:\n * // [ \n * // { path: `name`, value: `hello` },\n * // { path: `size`, value: `20` },\n * // { path: `colour.r`, value: `200` },\n * // { path: `colour.g`, value: `100` },\n * // { path: `colour.b`, value: `40` }\n * //]\n * ```\n * @param o Object to get paths and data for\n * @param maxDepth Set maximum recursion depth. By default unlimited.\n * @param prefix Manually set a path prefix if it's necessary\n * @returns \n */\nexport function* getPathsAndData(o: object, onlyLeaves = false, maxDepth = Number.MAX_SAFE_INTEGER, prefix = ``): Generator<PathData<any>> {\n  if (o === null) return;\n  if (o === undefined) return;\n  yield* getPathsAndDataImpl(o, prefix, onlyLeaves, maxDepth);\n}\n\nfunction* getPathsAndDataImpl(o: object, prefix: string, onlyLeaves = false, maxDepth: number): Generator<PathData<any>> {\n  if (maxDepth <= 0) return;\n  if (typeof o !== `object`) return;\n  for (const entries of Object.entries(o)) {\n    const sub = (prefix.length > 0 ? prefix + `.` : ``) + entries[ 0 ];\n    const value = entries[ 1 ];\n    const leaf = (typeof value !== `object`);\n\n    if (onlyLeaves && leaf || !onlyLeaves) {\n      yield { path: sub, value };\n    }\n    yield* getPathsAndDataImpl(value, sub, onlyLeaves, maxDepth - 1);\n  }\n}","//import { stringify } from 'json5';\n\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value \n * @returns \n */\nexport const isEmptyEntries = (value: object) => [ ...Object.entries(value) ].length === 0;\n\n/**\n * Return _true_ if `a` and `b` ought to be considered equal\n * at a given path\n */\nexport type IsEqualContext<V> = (a: V, b: V | undefined, path: string) => boolean\n\n/**\n * Returns _true_ if `a` and `b are equal based on their JSON representations.\n * `path` is ignored.\n * @param a \n * @param b \n * @param path \n * @returns \n */\nexport const isEqualContextString: IsEqualContext<any> = (a: any, b: any, _path: string): boolean => {\n  return JSON.stringify(a) === JSON.stringify(b);\n}","\nimport { DispatchList } from \"../../flow/DispatchList.js\";\nimport * as Pathed from \"../../data/Pathed.js\";\nimport { initStream } from \"../InitStream.js\";\nimport type { ObjectFieldHandler, ReactiveDiff, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\nimport type { ObjectOptions } from \"./Types.js\";\nimport { isEqualContextString } from \"../../data/Util.js\";\nimport { throwResult } from \"../../util/Results.js\";\nimport { wildcard } from \"../../text/Text.js\";\n\nexport function object<V extends Record<string, any>>(initialValue: V, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveInitial<V>;\nexport function object<V extends Record<string, any>>(initialValue: undefined, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveNonInitial<V>;\n\n\n/**\n * Creates a Reactive wrapper with the shape of the input object.\n * \n * Changing the wrapped object directly does not update the Reactive. \n * Instead, to update values use:\n * * `set()`, 'resets' the whole object\n * * `update()` changes a particular field\n * \n * Consider using {@link Rx.From.objectProxy} to return a object with properties that can be\n * set in the usual way yet is also Reactive.\n * \n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onValue(changed => {\n * });\n * o.set({ name: `mary`, level: 3 });\n * \n * // `onValue` will get called, with `changed` having a value of:\n * // { name: `mary`, level: 3 }\n * ```\n * \n * Use `last()` to get the most recently set value.\n * \n * `onDiff` subscribes to a rough diff of the object.\n * \n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onDiff(diffValue => {\n *  const diff = diffValue.value;\n * })\n * o.set({ name: `mary`, level: 3 });\n * \n * // onDiff would fire with `diff` of:\n * [\n *  { path: `name`, previous: `bob`, value: `mary` },\n *  { path: `level`, previous: 2, value: 3 }\n * ]\n * ```\n * \n * You can also listen to updates on a field via `onField`.\n * ```js\n * o.onField(`name`, value => {\n *  // Called whenever the 'name' field is updated\n * });\n * ```\n * @param initialValue  Initial value\n * @param options Options\n * @returns \n */\nexport function object<V extends Record<string, any>>(initialValue?: V, options: Partial<ObjectOptions<V>> = {}): ReactiveDiff<V> & (ReactiveInitial<V> | ReactiveNonInitial<V>) {\n  const eq = options.eq ?? isEqualContextString;\n  const setEvent = initStream<V>();\n  const diffEvent = initStream<Array<Pathed.PathDataChange<any>>>();\n\n  //const fieldChangeEvents = new Map<string, DispatchList<ObjectFieldHandler>>;\n  const fieldChangeEvents: Array<[ matcher: (value: string) => boolean, pattern: string, DispatchList<ObjectFieldHandler> ]> = [];\n\n  let value: V | undefined = initialValue;\n  let disposed = false;\n\n  const set = (v: V) => {\n    const diff = [ ...Pathed.compareData(value ?? {} as V, v, { ...options, includeMissingFromA: true }) ];\n    if (diff.length === 0) return;\n    value = v;\n    setEvent.set(v);\n    diffEvent.set(diff);\n  }\n\n  const fireFieldUpdate = (field: string, value: any) => {\n    for (const [ matcher, pattern, list ] of fieldChangeEvents) {\n      if (matcher(field)) {\n        list.notify({ fieldName: field, pattern, value });\n      }\n    }\n    //const l = fieldChangeEvents.get(field.toLowerCase());\n    //if (l === undefined) return;\n    //l.notify(value);\n  }\n\n  const updateCompareOptions: Partial<Pathed.CompareDataOptions<V>> = {\n    asPartial: true,\n    includeParents: true\n  }\n\n  const update = (toMerge: Partial<V>) => {\n    //console.log(`Rx.From.object update: toMerge: ${ JSON.stringify(toMerge) } value: ${ JSON.stringify(value) }`);\n\n    if (value === undefined) {\n      value = toMerge as V;\n      setEvent.set(value);\n      for (const [ k, v ] of Object.entries(toMerge as V)) {\n        fireFieldUpdate(k, v);\n      }\n      return value;\n    } else {\n      const diff = [ ...Pathed.compareData(value, toMerge, updateCompareOptions) ];\n      //const diffWithoutRemoved = diff.filter(d => d.state !== `removed`);\n      if (diff.length === 0) return value; // No changes\n      value = {\n        ...value,\n        ...toMerge\n      }\n      setEvent.set(value);\n      diffEvent.set(diff);\n      //console.log(`diff`, diff);\n      for (const d of diff) {\n        fireFieldUpdate(d.path, d.value);\n      }\n      return value;\n    }\n  }\n\n  const updateField = (path: string, valueForField: any) => {\n    if (value === undefined) throw new Error(`Cannot update value when it has not already been set`);\n    //console.log(`Rx.Sources.Object.updateField path: ${ path } value: ${ JSON.stringify(valueForField) }`);\n\n    const existing = Pathed.getField<any>(value, path);\n    if (!throwResult(existing)) return // Eg if path not found\n\n    //console.log(`Rx.fromObject.updateField path: ${ path } existing: ${ JSON.stringify(existing) }`);\n    if (eq(existing.value, valueForField, path)) {\n      //console.log(`Rx.object.updateField identical existing: ${ existing } value: ${ valueForField } path: ${ path }`);\n      return;\n    }\n    let diff = [ ...Pathed.compareData(existing.value, valueForField, { ...options, includeMissingFromA: true }) ];\n    diff = diff.map(d => {\n      if (d.path.length > 0) return { ...d, path: path + `.` + d.path };\n      return { ...d, path };\n    })\n\n    //console.log(`Rx.fromObject.updateField diff path: ${ path }`, diff);\n    const o = Pathed.updateByPath(value, path, valueForField, true);\n    value = o;\n    //diffEvent.set([ { path, value: valueForField, previous: existing } ]);\n\n    setEvent.set(o);\n    diffEvent.set(diff);\n    fireFieldUpdate(path, valueForField);\n    //console.log(`Rx.fromObject.updateField: path: '${ path }' value: '${ JSON.stringify(valueForField) }' o: ${ JSON.stringify(o) }`);\n  }\n\n  const dispose = (reason: string) => {\n    if (disposed) return;\n    diffEvent.dispose(reason);\n    setEvent.dispose(reason);\n    disposed = true;\n  }\n\n  return {\n    dispose,\n    isDisposed() {\n      return disposed\n    },\n    /**\n     * Update a field.\n     * Exception is thrown if field does not exist\n     */\n    updateField,\n    last: () => value,\n    on: setEvent.on,\n    onValue: setEvent.onValue,\n    onDiff: diffEvent.onValue,\n    onField(fieldPattern: string, handler: (result: ObjectFieldHandler) => void) {\n      const matcher = wildcard(fieldPattern);\n      const listeners = new DispatchList<ObjectFieldHandler>();\n      fieldChangeEvents.push([ matcher, fieldPattern, listeners ]);\n      const id = listeners.add(handler);\n      return () => listeners.remove(id);\n      // let listeners = fieldChangeEvents.get(fieldName.toLowerCase());\n      // if (listeners === undefined) {\n      //   listeners = new DispatchList();\n      //   fieldChangeEvents.set(fieldName.toLowerCase(), listeners);\n      // }\n      // const id = listeners.add((value) => {\n      //   setTimeout(() => { handler(value, fieldName) }, 1);\n      // });\n      // return () => listeners.remove(id);\n    },\n    /**\n     * Set the whole object\n     */\n    set,\n    /**\n     * Update the object with a partial set of fields and values\n     */\n    update\n  }\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport * as MapFns from \"../../data/maps/MapFns.js\"\nimport { initStream } from \"../InitStream.js\"\nimport { resolveSource } from \"../ResolveSource.js\"\nimport type { ReactiveOrSource, CombineLatestOptions, Reactive, RxValueTypeObject, ReactiveInitial, RxValueTypeRx, ReactiveDiff } from \"../Types.js\"\nimport { messageIsDoneSignal, messageHasValue, isWritable } from \"../Util.js\"\nimport { object } from \"../sources/Object.js\"\n\nexport type CombineLatestToObject<T extends Record<string, ReactiveOrSource<any>>> = {\n  hasSource: (field: string) => boolean,\n  replaceSource: (field: Extract<keyof T, string>, source: ReactiveOrSource<any>) => void\n  /**\n   * Reactive sources being combined\n   */\n  sources: RxValueTypeRx<T>\n  /**\n   * Updates writable sources with values.\n   * @param data \n   * @returns Keys and values set to writable source(s)\n   */\n  setWith: (data: Partial<RxValueTypeObject<T>>) => Partial<RxValueTypeObject<T>>\n} & ReactiveDiff<RxValueTypeObject<T>> & ReactiveInitial<RxValueTypeObject<T>>;\n\n/**\n * Monitors input reactive values, storing values as they happen to an object.\n * Whenever a new value is emitted, the whole object is sent out, containing current\n * values from each source (or _undefined_ if not yet emitted)\n * \n * See {@link combineLatestToArray} to combine streams by name into an array instead.\n * \n * ```\n * const sources = {\n *  fast: Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  slow: Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToObject(sources);\n * r.onValue(value => {\n *  // 'value' will be an object containing the labelled latest\n *  // values from each source.\n *  // { fast: number, slow: number }\n * });\n * ```\n * \n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToObject} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n * \n * This source ends if all source streams end.\n * @param reactiveSources Sources to merge\n * @param options Options for merging \n * @returns \n */\nexport function combineLatestToObject<const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<CombineLatestOptions> = {}): CombineLatestToObject<T> {// { sources: RxValueTypeRx<T> } & Reactive<RxValueTypeObject<T>> & ReactiveInitial<RxValueTypeObject<T>> {\n  type State<V> = {\n    source: Reactive<V>\n    done: boolean\n    data: V | undefined\n    off: () => void\n  }\n  const disposeSources = options.disposeSources ?? true;\n  const event = object<RxValueTypeObject<T>>(undefined);\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const emitInitial = options.emitInitial ?? true;\n  let emitInitialDone = false;\n\n  const states = new Map<string, State<any>>();\n  for (const [ key, source ] of Object.entries(reactiveSources)) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const initialData = (`last` in source) ? (source as any).last() : undefined;\n    //console.log(`initialData: ${ initialData } src: ${ (source as any).last() }`);\n    const s: State<any> = {\n      source: resolveSource(source),\n      done: false,\n      data: initialData,\n      off: () => { /** no-op */ }\n    }\n    states.set(key, s);\n  }\n  const sources = Object.fromEntries(Object.entries(states).map(entry => [ entry[ 0 ], entry[ 1 ].source ])) as RxValueTypeRx<T>;\n  // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n  const someUnfinished = () => MapFns.some(states, v => !v.done);\n\n  const unsub = () => {\n    //console.log(`Rx.MergeToObject.unsub states: ${ [ ...states.keys() ].join(`,`) }`);\n    for (const state of states.values()) state.off();\n  }\n\n  const getData = () => {\n    const r = {};\n    for (const [ key, state ] of states) {\n      const d = state.data;\n      if (d !== undefined) {\n        (r as any)[ key ] = state.data;\n      }\n    }\n    //console.log(`Rx.Ops.CombineLatestToObject getData`, r);\n\n    return r as RxValueTypeObject<T>;\n  }\n\n  const trigger = () => {\n    emitInitialDone = true;\n    const d = getData();\n    //console.log(`Rx.Ops.combineLatestToObject trigger`, d);\n    event.set(d);\n  }\n\n  const wireUpState = (state: State<any>) => {\n    state.off = state.source.on(message => {\n      if (messageIsDoneSignal(message)) {\n        state.done = true;\n        state.off();\n        state.off = () => {/**no-op */ }\n        if (onSourceDone === `break`) {\n          unsub();\n          event.dispose(`Source has completed and 'break' is behaviour`);\n          return;\n        }\n        if (!someUnfinished()) {\n          // All sources are done\n          unsub();\n          event.dispose(`All sources completed`);\n        }\n      } else if (messageHasValue(message)) {\n        state.data = message.value;\n        trigger();\n      }\n    });\n  }\n\n  for (const state of states.values()) {\n    wireUpState(state);\n  }\n\n  if (!emitInitialDone && emitInitial) {\n    //console.log(`Rx.Ops.CombineLatestToObject emitting initial`);\n    trigger();\n  }\n  return {\n    ...event,\n    hasSource(field: string) {\n      return states.has(field)\n    },\n    replaceSource(field, source) {\n      const state = states.get(field);\n      if (state === undefined) throw new Error(`Field does not exist: '${ field }'`);\n      state.off();\n      const s = resolveSource(source);\n      state.source = s;\n      wireUpState(state);\n    },\n    setWith(data) {\n      let written = {};\n      for (const [ key, value ] of Object.entries(data)) {\n        const state = states.get(key);\n        if (state !== undefined) {\n          if (isWritable(state.source)) {\n            state.source.set(value);\n            (written as any)[ key ] = value;\n          }\n          state.data = value;\n        }\n      }\n      return written;\n    },\n    sources,\n    last() {\n      return getData()\n    },\n    dispose(reason: string) {\n      unsub();\n      event.dispose(reason);\n      if (disposeSources) {\n        for (const v of states.values()) {\n          v.source.dispose(`Part of disposed mergeToObject`)\n        }\n      }\n    }\n  }\n}","import { initUpstream } from \"../InitStream.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { ReactiveOrSource, Reactive, ReactivePingable } from \"../Types.js\";\nimport { hasLast } from \"../Util.js\";\n\n/**\n * When there is a value from `input`, or the reactive is pinged,\n * this reactive emits the result of `fn`.\n * \n * `fn` is provided the previous value as well as the most recent value.\n * \n * If no previous value is available, the current value is emitted and `fn` is not called.\n * @param input \n * @param fn \n * @returns \n */\nexport function computeWithPrevious<TIn>(input: ReactiveOrSource<TIn>, fn: (previous: TIn, current: TIn) => TIn): ReactivePingable<TIn> {\n  let previousValue: TIn | undefined;\n  let currentValue: TIn | undefined;\n  if (hasLast(input)) {\n    currentValue = previousValue = input.last();\n  }\n\n  const trigger = () => {\n    if (previousValue === undefined && currentValue !== undefined) {\n      previousValue = currentValue;\n      upstream.set(previousValue);\n    } else if (previousValue !== undefined && currentValue !== undefined) {\n      const vv = fn(previousValue, currentValue);\n      //console.log(`vv: ${ vv } prev: ${ previousValue } target: ${ target }`)\n      previousValue = vv;\n      upstream.set(vv);\n    }\n  }\n\n  const upstream = initUpstream<TIn, TIn>(input, {\n    lazy: \"very\",\n    debugLabel: `computeWithPrevious`,\n    onValue(value) {\n      //console.log(`onValue ${ value }`);\n      currentValue = value;\n      trigger();\n    },\n  })\n  if (currentValue) trigger();\n\n  return {\n    ...toReadable(upstream),\n    ping: () => {\n      if (currentValue !== undefined) trigger()\n    }\n  }\n}","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { timeout } from \"../../flow/Timeout.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { DebounceOptions } from \"./Types.js\";\n\n/**\n * Debounce waits for `elapsed` time after the last received value before emitting it.\n * \n * If a flurry of values are received that are within the interval, it won't emit anything. But then\n * as soon as there is a gap in the messages that meets the interval, the last received value is sent out.\n * \n * `debounce` always emits with at least `elapsed` as a delay after a value received. While {@link throttle} potentially\n * sends immediately, if it's outside of the elapsed period.\n * \n * This is a subtly different logic to {@link throttle}. `throttle` more eagerly sends the first value, potentially\n * not sending later values. `debouce` however will send later values, potentially ignoring earlier ones.\n * @param source \n * @param options \n * @returns \n */\nexport function debounce<V>(source: ReactiveOrSource<V>, options: Partial<DebounceOptions> = {}): Reactive<V> {\n  const elapsed = intervalToMs(options.elapsed, 50);\n  let lastValue: V | undefined;\n\n  const timer = timeout(() => {\n    const v = lastValue;\n    if (v) {\n      upstream.set(v);\n      lastValue = undefined;\n    }\n  }, elapsed);\n\n  const upstream = initUpstream<V, V>(source, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      timer.start();\n    }\n  });\n  return toReadable(upstream);\n}\n\n","import type { ReactiveOrSource } from \"../Types.js\";\nimport { transform } from \"./Transform.js\";\n\n/**\n * Emits time in milliseconds since last message.\n * If it is the first value, 0 is used.\n * @param input \n * @returns \n */\nexport const elapsed = <In>(input: ReactiveOrSource<In>) => {\n  let last = 0;\n  return transform<In, number>(input, (_ignored) => {\n    const elapsed = last === 0 ? 0 : Date.now() - last;\n    last = Date.now();\n    return elapsed;\n  });\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { FieldOptions } from \"./Types.js\";\n\n/**\n * From a source value, yields a field from it. Only works\n * if stream values are objects.\n * \n * If a source value doesn't have that field, it is skipped.\n *\n * @returns \n */\nexport function field<TIn extends object, TFieldType>(fieldSource: ReactiveOrSource<TIn>, fieldName: keyof TIn, options: Partial<FieldOptions<TIn, TFieldType>> = {}): Reactive<TFieldType> {\n  const fallbackFieldValue = options.fallbackFieldValue;\n  const fallbackObject = options.fallbackObject;\n\n  const upstream = initUpstream<TIn, TFieldType>(fieldSource, {\n    disposeIfSourceDone: true,\n    ...options,\n    onValue(value) {\n      let v: TFieldType | undefined;\n      // 1. Try to read from value\n      if (fieldName in value) {\n        v = value[ fieldName ] as TFieldType;\n      } else if (fallbackObject && fieldName in fallbackObject) {\n        // 2. Read from fallback object\n        v = fallbackObject[ fieldName ] as TFieldType;\n      }\n      // 3. Use fallback value\n      if (v === undefined) {\n        v = fallbackFieldValue;\n      }\n      if (v !== undefined) {\n        upstream.set(v);\n      }\n    },\n  })\n  return toReadable(upstream);\n}","import { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, InitStreamOptions, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { FilterPredicate } from \"./Types.js\";\n\n/**\n * Passes all values where `predicate` function returns _true_.\n */\nexport function filter<In>(input: ReactiveOrSource<In>, predicate: FilterPredicate<In>, options: Partial<InitStreamOptions>): Reactive<In> {\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      if (predicate(value)) {\n        upstream.set(value);\n      }\n    },\n  })\n  return toReadable(upstream);\n}\n\n\n/**\n * Drops all values where `predicate` function returns _true_.\n */\nexport function drop<In>(input: ReactiveOrSource<In>, predicate: FilterPredicate<In>, options: Partial<InitStreamOptions>): Reactive<In> {\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      if (!predicate(value)) {\n        upstream.set(value);\n      }\n    },\n  })\n  return toReadable(upstream);\n}\n","/* eslint-disable unicorn/prevent-abbreviations */\nimport { throwNumberTest, throwIntegerTest } from '../util/GuardNumbers.js';\n\n/**\n * Wraps an integer number within a specified range, defaulting to degrees (0-360). Use {@link wrap} for floating-point wrapping.\n *\n * This is useful for calculations involving degree angles and hue, which wrap from 0-360.\n * Eg: to add 200 to 200, we don't want 400, but 40.\n *\n * ```js\n * const v = wrapInteger(200+200, 0, 360); // 40\n * ```\n *\n * Or if we minus 100 from 10, we don't want -90 but 270\n * ```js\n * const v = wrapInteger(10-100, 0, 360); // 270\n * ```\n *\n * `wrapInteger` uses 0-360 as a default range, so both of these\n * examples could just as well be:\n *\n * ```js\n * wrapInteger(200+200);  // 40\n * wrapInteger(10-100);  // 270\n * ```\n *\n * Non-zero starting points can be used. A range of 20-70:\n * ```js\n * const v = wrapInteger(-20, 20, 70); // 50\n * ```\n *\n * Note that the minimum value is inclusive, while the maximum is _exclusive_.\n * So with the default range of 0-360, 360 is never reached:\n *\n * ```js\n * wrapInteger(360); // 0\n * wrapInteger(361); // 1\n * ```\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * @param v Value to wrap\n * @param min Integer minimum of range (default: 0). Inclusive\n * @param max Integer maximum of range (default: 360). Exlusive\n * @returns\n */\nexport const wrapInteger = (v: number, min = 0, max = 360) => {\n  throwIntegerTest(v, undefined, `v`);\n  throwIntegerTest(min, undefined, `min`);\n  throwIntegerTest(max, undefined, `max`);\n\n  if (v === min) return min;\n  if (v === max) return min; // Wraps\n  if (v > 0 && v < min) v += min;\n\n  v -= min;\n  max -= min;\n  v = v % max;\n\n  if (v < 0) v = max - Math.abs(v) + min;\n  return v + min;\n};\n\n/**\n * Wraps floating point numbers to be within a range (default: 0..1). Use {@link wrapInteger} if you want to wrap integer values.\n *\n * This logic makes sense for some things like rotation angle.\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * ```js\n * wrap(1.2);   // 0.2\n * wrap(2);     // 1.0\n * wrap(-0.2); // 0.8\n * ```\n *\n * A range can be provided too:\n * ```js\n * wrap(30, 20, 50);  \t // 30\n * wrap(60, 20, 50);    //  30\n * ```\n * @param v\n * @param min\n * @param max\n * @returns\n */\nexport const wrap = (v: number, min = 0, max = 1) => {\n  throwNumberTest(v, ``, `min`);\n  throwNumberTest(min, ``, `min`);\n  throwNumberTest(max, ``, `max`);\n\n  if (v === min) return min;\n  if (v === max) return min; // Wraps\n\n  while (v <= min || v >= max) {\n    if (v === max) break;\n    if (v === min) break;\n    if (v > max) {\n      v = min + (v - max);\n    } else if (v < min) {\n      v = max - (min - v);\n    }\n  }\n  return v;\n};\n\n/**\n * Performs a calculation within a wrapping number range. This is a lower-level function.\n * See also: {@link wrapInteger} for simple wrapping within a range.\n *\n * `min` and `max` define the start and end of the valid range, inclusive. Eg for hue degrees it'd be 0, 360.\n * `a` and `b` is the range you want to work in.\n *\n * For example, let's say you want to get the middle point between a hue of 30 and a hue of 330 (ie warmer colours):\n * ```js\n * wrapRange(0,360, (distance) => {\n *  // for a:0 and b:330, distance would be 90 from 30 degrees to 330 (via zero)\n *  return distance * 0.5; // eg return middle point\n * }, 30, 330);\n * ```\n *\n * The return value of the callback should be in the range of 0-distance. `wrapRange` will subsequently\n * conform it to the `min` and `max` range before it's returned to the caller.\n *\n * @param a Output start (eg. 60)\n * @param b Output end (eg 300)\n * @param min Range start (eg 0)\n * @param max Range end (eg 360)\n * @param fn Returns a computed value from 0 to `distance`.\n * @returns\n */\nexport const wrapRange = (\n  min: number,\n  max: number,\n  fn: (distance: number) => number,\n  a: number,\n  b: number\n) => {\n  //eslint-disable-next-line functional/no-let\n  let r = 0;\n  const distF = Math.abs(b - a);\n  // When b is wrapped forwards\n  const distFwrap = Math.abs(max - a + b);\n  // When b is wrapped backwards (10, 300)\n  const distBWrap = Math.abs(a + (360 - b));\n\n  const distMin = Math.min(distF, distFwrap, distBWrap);\n  if (distMin === distBWrap) {\n    // (10, 300) = 70\n    r = a - fn(distMin);\n  } else if (distMin === distFwrap) {\n    // (300, 60) = 120\n    r = a + fn(distMin);\n  } else {\n    // Forwards or backwards without wrapping\n    // eslint-disable-next-line unicorn/prefer-ternary\n    if (a > b) {\n      // (240,120) -- backwards\n      r = a - fn(distMin);\n    } else {\n      // (120,240) -- forwards\n      r = a + fn(distMin);\n    }\n  }\n  return wrapInteger(r, min, max);\n};\n","import * as Named from './EasingsNamed.js';\nimport { throwStringTest } from '../../util/GuardString.js';\nimport { type Interval } from '../../flow/IntervalType.js';\nimport type { Modulate, ModulatorTimed } from '../Types.js';\nexport * as Named from './EasingsNamed.js';\nexport * from './Line.js';\n\nimport * as ModTimed from '../ModulatorTimed.js';\n\n/**\n * Easing name\n */\nexport type EasingName = keyof typeof Named;\n\nexport type Options = (TickOptions | TimeOptions) & {\n  name?: EasingName\n  fn?: Modulate\n}\n\nexport type TimeOptions = {\n  duration: Interval\n}\nexport type TickOptions = {\n  ticks: number\n}\n\n/**\n * Creates an easing function\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const e = Easings.create({ duration: 1000, name: `quadIn` });\n * const e = Easings.create({ ticks: 100, name: `sineOut` });\n * const e = Easings.create({ \n *  duration: 1000, \n *  fn: (v) => {\n *    // v will be 0..1 based on time\n *    return Math.random() * v\n *  }\n * });\n * ```\n * @param options \n * @returns \n */\nexport const create = (options: Options): () => number => {\n  let name = resolveEasingName(options.name ?? `quintIn`);\n  const fn = name ?? options.fn;\n  if (!fn) throw new Error(`Either 'name' or 'fn' must be set`);\n\n  if (`duration` in options) {\n    return time(fn, options.duration);\n  } else if (`ticks` in options) {\n    return ticks(fn, options.ticks);\n  } else {\n    throw new Error(`Expected 'duration' or 'ticks' in options`);\n  }\n}\n\n/**\n * Creates an easing based on clock time. Time\n * starts being counted when easing function is created.\n * \n * `timeEasing` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n * \n * @example Time based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.timeEasing(`quintIn`, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of easing\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * \n * Thisi function is just a wrapper around Modulator.timedModulator.\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration\n * @returns Easing\n */\nexport const timeEasing = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  duration: Interval\n): ModulatorTimed => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModTimed.timeModulator(fn, duration);\n  // const timer = Timer.elapsedMillisecondsAbsolute();\n  // const durationMs = intervalToMs(duration);\n  // if (durationMs === undefined) throw new Error(`Param 'duration' not provided`);\n  // const relativeTimer = Timer.relative(\n  //   durationMs,\n  //   {\n  //     timer,\n  //     clampValue: true\n  //   });\n  // return Timer.timerWithFunction(fn, relativeTimer);\n};\n\n/**\n * Produce easing values over time. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * If you need to check if an easing is done or reset it, consider {@link timeEasing}.\n * \n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Quad-in easing over one second\n * const e = Easings.time(`quadIn`, 1000);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * \n * This function is just a wrapper around Modulate.time\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param duration Duration\n * @returns \n */\nexport const time = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  duration: Interval\n): () => number => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModTimed.time(fn, duration);\n  // let relative: undefined | (() => number);\n  // return () => {\n  //   if (relative === undefined) relative = Timer.ofTotal(duration, { clampValue: true });\n  //   return fn(relative());\n  // }\n}\n\n\n/**\n * Produce easing values with each invocation. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * If you need to check if an easing is done or reset it, consider {@link tickEasing}.\n * \n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Quad-in easing over 100 ticks\n * const e = Easings.ticks(`quadIn`, 100);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * \n * This is just a wrapper around Modulator.ticks\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns \n */\nexport const ticks = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  totalTicks: number\n): () => number => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModTimed.ticks(fn, totalTicks);\n  // let relative: undefined | (() => number);\n  // return () => {\n  //   if (relative === undefined) relative = Timer.ofTotalTicks(totalTicks, { clampValue: true });\n  //   return fn(relative());\n  // }\n}\n/**\n * Creates an easing based on ticks. \n * \n * `tickEasing` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.tickEasing(`sineIn`, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param durationTicks Duration in ticks\n * @returns Easing\n */\nexport const tickEasing = (\n  nameOrFunction: EasingName | ((v: number) => number),\n  durationTicks: number\n): ModulatorTimed => {\n  const fn = resolveEasingName(nameOrFunction);\n  return ModTimed.tickModulator(fn, durationTicks);\n  // const timer = Timer.elapsedTicksAbsolute();\n  // const relativeTimer = Timer.relative(\n  //   durationTicks,\n  //   {\n  //     timer,\n  //     clampValue: true\n  //   });\n  // return Timer.timerWithFunction(fn, relativeTimer);\n};\n\nconst resolveEasingName = (nameOrFunction: EasingName | ((v: number) => number)): Modulate => {\n  const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n  if (fn === undefined) {\n    const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${ nameOrFunction }'`) : new Error(`Easing function not found`);\n    throw error;\n  }\n  return fn;\n}\n\n\n/**\n * Creates a new easing by name\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const e = Easings.create(`circInOut`, 1000, elapsedMillisecondsAbsolute);\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration (meaning depends on timer source)\n * @param timerSource Timer source\n * @returns\n */\n// const create = function (\n//   nameOrFunction: EasingName | ((v: number) => number),\n//   duration: number,\n//   timerSource: TimerSource\n// ): Easing {\n//   const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n//   if (fn === undefined) {\n//     const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${ nameOrFunction }'`) : new Error(`Easing function not found`);\n//     throw error;\n//   }\n\n//   // Get a relative version of timer\n//   const timer = relativeTimer(duration, {\n//     timer: timerSource(),\n//     clampValue: true,\n//   });\n//   let startCount = 1;\n\n//   return {\n//     get isDone() {\n//       return timer.isDone;\n//     },\n//     get runState() {\n//       if (timer.isDone) return `idle`;\n//       return `scheduled`;\n//     },\n//     /**\n//      * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n//      */\n//     get startCount() {\n//       return startCount;\n//     },\n//     get startCountTotal() {\n//       return startCount;\n//     },\n//     compute: () => {\n//       const relative = timer.elapsed;\n//       return fn(relative);\n//     },\n//     reset: () => {\n//       timer.reset();\n//       startCount++;\n//     },\n//   };\n// };\n\n\nlet easingsMap: Map<string, ((v: number) => number)> | undefined;\n\n/**\n * Returns an easing function by name. Throws an error if\n * easing is not found.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = Easings.get(`sineIn`);\n * // Returns 'eased' transformation of 0.5\n * fn(0.5);\n * ```\n * @param easingName eg `sineIn`\n * @returns Easing function\n */\nexport const get = function (easingName: EasingName): Modulate {\n  throwStringTest(easingName, `non-empty`, `easingName`);\n\n  const found = cacheEasings().get(easingName.toLowerCase());\n  if (found === undefined) throw new Error(`Easing not found: '${ easingName }'`);\n  return found;\n};\n\n// Cache named easings\nfunction cacheEasings() {\n  if (easingsMap === undefined) {\n    easingsMap = new Map();\n    for (const [ k, v ] of Object.entries(Named)) {\n      easingsMap.set(k.toLowerCase(), v);\n    }\n    return easingsMap\n  } else return easingsMap;\n}\n\n/**\n * Iterate over available easings.\n * @private\n * @returns Returns list of available easing names\n */\nexport function* getEasingNames(): Iterable<string> {\n  const map = cacheEasings();\n  yield* map.keys();\n};\n\n","import { gaussian } from \"../Gaussian.js\";\n// Easings from https://easings.net/\n\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst cos = Math.cos;\nconst pi = Math.PI;\nconst sin = Math.sin;\n\n\nexport const bounceOut = (x: number) => {\n  const n1 = 7.5625;\n  const d1 = 2.75;\n\n  if (x < 1 / d1) {\n    return n1 * x * x;\n  } else if (x < 2 / d1) {\n    return n1 * (x -= 1.5 / d1) * x + 0.75;\n  } else if (x < 2.5 / d1) {\n    return n1 * (x -= 2.25 / d1) * x + 0.9375;\n  } else {\n    return n1 * (x -= 2.625 / d1) * x + 0.984_375;\n  }\n};\n\nexport const quintIn = (x: number) => x * x * x * x * x;\nexport const quintOut = (x: number) => 1 - pow(1 - x, 5);\nexport const arch = (x: number) => x * (1 - x) * 4;\n\nexport const smoothstep = (x: number) => x * x * (3 - 2 * x);\nexport const smootherstep = (x: number) => (x * (x * 6 - 15) + 10) * x * x * x;\nexport const sineIn = (x: number) => 1 - cos((x * pi) / 2);\nexport const sineOut = (x: number) => sin((x * pi) / 2);\nexport const quadIn = (x: number) => x * x;\nexport const quadOut = (x: number) => 1 - (1 - x) * (1 - x);\nexport const sineInOut = (x: number) => -(cos(pi * x) - 1) / 2;\nexport const quadInOut = (x: number) => x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2;\nexport const cubicIn = (x: number) => x * x * x;\nexport const cubicOut = (x: number) => 1 - pow(1 - x, 3);\nexport const quartIn = (x: number) => x * x * x * x;\nexport const quartOut = (x: number) => 1 - pow(1 - x, 4);\nexport const expoIn = (x: number) => (x === 0 ? 0 : pow(2, 10 * x - 10));\nexport const expoOut = (x: number) => (x === 1 ? 1 : 1 - pow(2, -10 * x));\nexport const quintInOut = (x: number) =>\n  x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2;\nexport const expoInOut = (x: number) =>\n  x === 0\n    ? 0\n    : x === 1\n      ? 1\n      // eslint-disable-next-line unicorn/no-nested-ternary\n      : x < 0.5\n        ? pow(2, 20 * x - 10) / 2\n        : (2 - pow(2, -20 * x + 10)) / 2;\nexport const circIn = (x: number) => 1 - sqrt(1 - pow(x, 2));\nexport const circOut = (x: number) => sqrt(1 - pow(x - 1, 2));\nexport const backIn = (x: number) => {\n  const c1 = 1.701_58;\n  const c3 = c1 + 1;\n\n  return c3 * x * x * x - c1 * x * x;\n};\nexport const backOut = (x: number) => {\n  const c1 = 1.701_58;\n  const c3 = c1 + 1;\n\n  return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\n};\nexport const circInOut = (x: number) =>\n  x < 0.5\n    ? (1 - sqrt(1 - pow(2 * x, 2))) / 2\n    : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;\n\nexport const backInOut = (x: number) => {\n  const c1 = 1.701_58;\n  const c2 = c1 * 1.525;\n\n  return x < 0.5\n    ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\n    : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n};\nexport const elasticIn = (x: number) => {\n  const c4 = (2 * pi) / 3;\n\n  return x === 0\n    ? 0\n    : (x === 1\n      ? 1\n      : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4));\n};\nexport const elasticOut = (x: number) => {\n  const c4 = (2 * pi) / 3;\n\n  return x === 0\n    ? 0\n    : (x === 1\n      ? 1\n      : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1);\n};\n\nexport const bounceIn = (x: number) => 1 - bounceOut(1 - x);\n\nexport const bell = gaussian();\n\nexport const elasticInOut = (x: number) => {\n  const c5 = (2 * pi) / 4.5;\n\n  return x === 0\n    ? 0\n    : x === 1\n      ? 1\n      // eslint-disable-next-line unicorn/no-nested-ternary\n      : x < 0.5\n        ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2\n        : (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\n};\nexport const bounceInOut = (x: number) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2;\n","//const sqrt = Math.sqrt;\nconst pow = Math.pow;\n//const pi = Math.PI;\n//const piPi = Math.PI*2;\nconst gaussianA = 1 / Math.sqrt(2 * Math.PI);\n\n/**\n * Returns a roughly gaussian easing function\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = Easings.gaussian();\n * ```\n *\n * Try different positive and negative values for `stdDev` to pinch\n * or flatten the bell shape.\n * @param standardDeviation\n * @returns\n */\nexport const gaussian = (standardDeviation = 0.4) => {\n  //const a = 1 / sqrt(2 * pi);\n  const mean = 0.5;\n\n  return (t: number) => {\n    const f = gaussianA / standardDeviation;\n    // p:-8 pinched\n    let p = -2.5; // -1/1.25;\n    let c = (t - mean) / standardDeviation;\n    c *= c;\n    p *= c;\n    const v = f * pow(Math.E, p); // * (2/pi);//0.62;\n    if (v > 1) return 1;\n    if (v < 0) return 0;\n    return v;\n  };\n};","export * from './Abs.js';\nexport * from './Angle.js';\nexport * from './Apply.js';\nexport * from './Averager.js';\nexport * from './Bbox.js';\nexport * from './Centroid.js';\nexport * from './Clamp.js';\nexport * from './Compare.js';\nexport * from './ConvexHull.js';\nexport * from './Distance.js';\nexport * from './DistanceToCenter.js';\nexport * from './DistanceToExterior.js';\nexport * from './Divider.js';\nexport * from './DotProduct.js';\nexport * from './Empty.js';\nexport * from './FindMinimum.js';\nexport * from './From.js';\nexport * from './GetPointParameter.js';\nexport * from './Guard.js';\nexport * from './Interpolate.js';\nexport * from './Invert.js';\nexport * from './IsEqual.js';\nexport * from './Magnitude.js';\nexport * from './Most.js';\nexport * from './Multiply.js';\nexport * from './Normalise.js';\nexport * from './NormaliseByRect.js';\nexport * from './Pipeline.js';\nexport * from './PointRelationTypes.js';\nexport * from './PointType.js';\nexport * from './ProgressBetween.js';\nexport * from './Project.js';\nexport * from './Quantise.js';\nexport * from './Random.js';\nexport * from './Reduce.js';\nexport * from './Relation.js';\nexport * from './Rotate.js';\nexport * from './RotatePointArray.js';\nexport * from './Round.js';\nexport * from './Subtract.js';\nexport * from './Sum.js';\nexport * from './To.js';\nexport * from './ToArray.js';\nexport * from './WithinRange.js';\nexport * from './Wrap.js';\nexport type { Point, Point3d } from './PointType.js';\n","import type { Point, Point3d } from \"./PointType.js\";\nimport { throwNumberTest } from '../../util/GuardNumbers.js';\n\n/**\n * Returns true if xy (and z, if present) are _null_.\n * @param p\n * @returns\n */\nexport const isNull = (p: Point) => {\n  if (isPoint3d(p)) {\n    if (p.z !== null) return false;\n  }\n  return p.x === null && p.y === null;\n}\n\n/***\n * Returns true if either x, y, z isNaN.\n */\nexport const isNaN = (p: Point) => {\n  if (isPoint3d(p)) {\n    if (!Number.isNaN(p.z)) return false;\n  }\n  return Number.isNaN(p.x) || Number.isNaN(p.y)\n}\n\n/**\n * Throws an error if point is invalid\n * @param p\n * @param name\n */\nexport function guard(p: Point, name = `Point`) {\n  if (p === undefined) {\n    throw new Error(\n      `'${ name }' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`\n    );\n  }\n  if (p === null) {\n    throw new Error(\n      `'${ name }' is null. Expected {x,y} got ${ JSON.stringify(p) }`\n    );\n  }\n  if (p.x === undefined) {\n    throw new Error(\n      `'${ name }.x' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`\n    );\n  }\n  if (p.y === undefined) {\n    throw new Error(\n      `'${ name }.y' is undefined. Expected {x,y} got ${ JSON.stringify(p) }`\n    );\n  }\n  if (typeof p.x !== `number`) {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new TypeError(`'${ name }.x' must be a number. Got ${ typeof p.x }`);\n  }\n  if (typeof p.y !== `number`) {\n    // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    throw new TypeError(`'${ name }.y' must be a number. Got ${ typeof p.y }`);\n  }\n  if (p.z !== undefined) {\n    if (typeof p.z !== `number`) throw new TypeError(`${ name }.z must be a number. Got: ${ typeof p.z }`)\n    if (Number.isNaN(p.z)) throw new Error(`'${ name }.z' is NaN. Got: ${ JSON.stringify(p) }`);\n  }\n\n  if (p.x === null) throw new Error(`'${ name }.x' is null`);\n  if (p.y === null) throw new Error(`'${ name }.y' is null`);\n\n  if (Number.isNaN(p.x)) throw new Error(`'${ name }.x' is NaN`);\n  if (Number.isNaN(p.y)) throw new Error(`'${ name }.y' is NaN`);\n}\n\n/**\n * Throws if parameter is not a valid point, or either x or y is 0\n * @param pt\n * @returns\n */\nexport const guardNonZeroPoint = (pt: Point | Point3d, name = `pt`) => {\n  guard(pt, name);\n  throwNumberTest(pt.x, `nonZero`, `${ name }.x`);\n  throwNumberTest(pt.y, `nonZero`, `${ name }.y`);\n  if (typeof pt.z !== `undefined`) {\n    throwNumberTest(pt.z, `nonZero`, `${ name }.z`);\n  }\n\n  return true;\n};\n\n/**\n * Returns _true_ if `p` has x & y properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * Use {@link isPoint3d} to check further check for `z`.\n * @param p \n * @returns \n */\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function isPoint(p: number | unknown): p is Point {\n  if (p === undefined) return false;\n  if (p === null) return false;\n  if ((p as Point).x === undefined) return false;\n  if ((p as Point).y === undefined) return false;\n  return true;\n}\n\n/**\n * Returns _true_ if `p` has x, y, & z properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * @param p \n * @returns \n */\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport const isPoint3d = (p: Point | unknown): p is Point3d => {\n  if (p === undefined) return false;\n  if (p === null) return false;\n  if ((p as Point3d).x === undefined) return false;\n  if ((p as Point3d).y === undefined) return false;\n  if ((p as Point3d).z === undefined) return false;\n  return true;\n};\n\n/**\n * Returns true if both xy (and z, if present) are 0.\n * Use `Points.Empty` to return an empty point.\n * @param p\n * @returns\n */\nexport const isEmpty = (p: Point) => {\n  if (isPoint3d(p)) {\n    if (p.z !== 0) return false;\n  }\n  return p.x === 0 && p.y === 0\n\n}\n\n/**\n * Returns true if point is a placeholder, where xy (and z, if present)\n * are `NaN`.\n *\n * Use Points.Placeholder to return a placeholder point.\n * @param p\n * @returns\n */\nexport const isPlaceholder = (p: Point) => {\n  if (isPoint3d(p)) {\n    if (!Number.isNaN(p.z)) return false;\n  }\n  return Number.isNaN(p.x) && Number.isNaN(p.y);\n}\n","import { isPoint, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\nexport function abs(pt: Point3d): Point3d;\nexport function abs(pt: Point): Point;\n\n/**\n * Returns a point with Math.abs applied to x,y and z if present.\n * ```js\n * Points.abs({ x:1,  y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:-1 }); // { x: 1, y: 1 }\n * ```\n * @param pt\n * @returns\n */\nexport function abs(pt: Point): Point {\n  if (isPoint3d(pt)) {\n    return Object.freeze({\n      ...pt,\n      x: Math.abs(pt.x),\n      y: Math.abs(pt.y),\n      z: Math.abs(pt.z)\n    });\n  } else if (isPoint(pt)) {\n    return Object.freeze({\n      ...pt,\n      x: Math.abs(pt.x),\n      y: Math.abs(pt.y)\n    });\n  } else throw new TypeError(`Param 'pt' is not a point`);\n};","import { piPi } from \"../../numbers/Interpolate.js\";\nimport { guard } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Returns the angle in radians between `a` and `b`.\n *\n * Eg if `a` is the origin, and `b` is another point,\n * in degrees one would get 0 to -180 when `b` was above `a`.\n *  -180 would be `b` in line with `a`.\n * Same for under `a`.\n *\n * Providing a third point `c` gives the interior angle, where `b` is the middle point.\n * \n * See also {@link angleRadianCircle} which returns coordinates on 0..Math.Pi*2\n * range. This avoids negative numbers.\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const angleRadian = (a: Point, b?: Point, c?: Point) => {\n  guard(a, `a`);\n\n  if (b === undefined) {\n    return Math.atan2(a.y, a.x);\n  }\n  guard(b, `b`);\n  if (c === undefined) {\n    return Math.atan2(b.y - a.y, b.x - a.x);\n  }\n\n  guard(c, `c`);\n  return Math.atan2(b.y - a.y, b.x - a.x) - Math.atan2(c.y - a.y, c.x - a.x);\n};\n\n/**\n * Returns the angle between point(s) using a radian circle system.\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport const angleRadianCircle = (a: Point, b?: Point, c?: Point) => {\n  const angle = angleRadian(a, b, c);\n  if (angle < 0) return angle + piPi\n  return angle;\n}","import { guard, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\n// type PointFields = `x` | `y`;\n// type Point3dFields = PointFields & 'z';\n\nexport type PointApplyFn = (v: number, field: `x` | `y`) => number;\nexport type Point3dApplyFn = (v: number, field: `x` | `y` | `z`) => number;\n\nexport function apply(pt: Point3d, fn: Point3dApplyFn): Point3d\nexport function apply(pt: Point, fn: PointApplyFn): Point;\n\n/**\n * Applies `fn` on x,y & z (if present) fields, returning all other fields as well\n * ```js\n * const p = {x:1.234, y:4.9};\n * const p2 = Points.apply(p, Math.round);\n * // Yields: {x:1, y:5}\n * ```\n *\n * The name of the field is provided as well. Here we only round the `x` field:\n *\n * ```js\n * const p = {x:1.234, y:4.9};\n * const p2 = Points.apply(p, (v, field) => {\n *  if (field === `x`) return Math.round(v);\n *  return v;\n * });\n * ```\n * @param pt\n * @param fn\n * @returns\n */\nexport function apply(\n  pt: Point,\n  fn: Point3dApplyFn | PointApplyFn\n): Point {\n  guard(pt, `pt`);\n  if (isPoint3d(pt)) {\n    return Object.freeze<Point3d>({\n      ...pt,\n      x: fn(pt.x, `x`),\n      y: fn(pt.y, `y`),\n      z: (fn as Point3dApplyFn)(pt.z, `z`)\n    });\n  }\n  return Object.freeze<Point>({\n    ...pt,\n    x: fn(pt.x, `x`),\n    y: fn(pt.y, `y`),\n  });\n}","import { zip } from '../data/arrays/Zip.js';\nimport { weight } from './NumericArrays.js';\n/**\n * Computes an average of an array with a set of weights applied.\n *\n * Weights can be provided as an array, expected to be on 0..1 scale, with indexes\n * matched up to input data. Ie. data at index 2 will be weighed by index 2 in the weightings array.\n *\n * ```js\n * import { averageWeighted } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * // All items weighted evenly\n * averageWeighted([1,2,3], [1,1,1]); // 2\n *\n * // First item has full weight, second half, third quarter\n * averageWeighted([1,2,3], [1, 0.5, 0.25]); // 1.57\n *\n * // With reversed weighting of [0.25,0.5,1] value is 2.42\n * ```\n *\n * A function can alternatively be provided to compute the weighting based on array index, via {@link weight}.\n *\n * ```js\n * import { weight,averageWeighted } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * import { gaussian } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * averageWeighted[1,2,3], gaussian()); // 2.0\n * ```\n *\n * This is the same as:\n *\n * ```js\n * import { weight,averageWeighted } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * import { gaussian } from 'https://unpkg.com/ixfx/dist/modulation.js';\n *\n * const data = [1,2,3];\n * const w = weight(data, gaussian());\n * const avg = averageWeighted(data, w); // 2.0\n * ```\n * @param data Data to average\n * @param weightings Array of weightings that match up to data array, or an easing function\n * @see {@link average} Compute averages without weighting.\n */\nexport const averageWeighted = (\n  data: Array<number> | ReadonlyArray<number>,\n  weightings: Array<number> | ReadonlyArray<number> | ((value: number) => number)\n): number => {\n  if (typeof weightings === `function`) weightings = weight(data, weightings);\n  const ww = zip(data, weightings);\n  // eslint-disable-next-line unicorn/no-array-reduce\n  const [ totalV, totalW ] = ww.reduce(\n    (accumulator: Array<number>, v: Array<number>) => [ accumulator[ 0 ] + v[ 0 ] * v[ 1 ], accumulator[ 1 ] + v[ 1 ] ],\n    [ 0, 0 ]\n  );\n  return totalV / totalW;\n};","import type { Interval } from '../flow/IntervalType.js';\nimport { averageWeighted } from '../numbers/AverageWeighted.js';\nimport { average } from '../numbers/NumericArrays.js';\nimport { QueueMutable } from '../collections/queue/QueueMutable.js';\nimport { throwNumberTest, numberTest } from \"../util/GuardNumbers.js\";\nimport { rateMinimum } from '../flow/RateMinimum.js';\nconst PiPi = Math.PI * 2;\n\n/**\n * A moving average calculator (exponential weighted moving average) which does not keep track of\n * previous samples. Less accurate, but uses less system resources.\n *\n * The `scaling` parameter determines smoothing. A value of `1` means that\n * the latest value is used as the average - that is, no smoothing. Higher numbers\n * introduce progressively more smoothing by weighting the accumulated prior average more heavily.\n *\n * ```\n * const ma = movingAverageLight(); // default scaling of 3\n * ma(50);  // 50\n * ma(100); // 75\n * ma(75);  // 75\n * ma(0);   // 50\n * ```\n *\n * Note that the final average of 50 is pretty far from the last value of 0. To make it more responsive,\n * we could use a lower scaling factor: `movingAverageLight(2)`. This yields a final average of `37.5` instead.\n *\n * @param scaling Scaling factor. 1 is no smoothing. Default: 3\n * @returns Function that adds to average.\n */\nexport const movingAverageLight = (scaling = 3): (value?: number) => number => {\n  throwNumberTest(scaling, `aboveZero`, `scaling`);\n  let average = 0;\n  let count = 0;\n\n  return (v?: number) => {\n    const r = numberTest(v, ``, `v`);\n    if (r[ 0 ] && v !== undefined) {\n      // Valid number\n      count++;\n      average = average + (v - average) / Math.min(count, scaling);\n    }\n    return average;\n  }\n};\n\nexport type MovingAverageTimedOptions = Readonly<{\n  interval: Interval\n  default?: number\n  abort?: AbortSignal\n}>\n\n/**\n * Uses the same algorithm as {@link movingAverageLight}, but adds values automatically if\n * nothing has been manually added.\n *\n * ```js\n * // By default, 0 is added if interval elapses\n * const mat = movingAverageTimed({ interval: 1000 });\n * mat(10); // Add value of 10, returns latest average\n * \n * mat(); // Get current average\n * ```\n * \n * This is useful if you are averaging something based on events. For example calculating the\n * average speed of the pointer. If there is no speed, there is no pointer move event. Using\n * this function, `value` is added at a rate of `updateRateMs`. This timer is reset\n * every time a value is added, a bit like the `debounce` function.\n * \n * Use an AbortSignal to cancel the timer associated with the `movingAverageTimed` function.\n * @param options\n * @returns\n */\nexport const movingAverageTimed = (options: MovingAverageTimedOptions) => {\n  const average = movingAverageLight();\n  const rm = rateMinimum({\n    ...options,\n    whatToCall: (distance: number) => {\n      average(distance);\n    },\n    fallback() {\n      return options.default ?? 0;\n    }\n  })\n\n  return (v: number) => {\n    rm(v);\n    return average();\n  }\n};\n\n// export const movingAverageTimed = (\n//   updateRateMs = 200,\n//   value = 0,\n//   scaling = 3\n// ): MovingAverage => {\n//   throwNumberTest(scaling, `aboveZero`, `scaling`);\n//   throwNumberTest(updateRateMs, `aboveZero`, `decayRateMs`);\n\n//   const mal = movingAverageLight(scaling);\n\n//   //eslint-disable-next-line functional/no-let\n//   let timer = 0;\n\n//   const reschedule = () => {\n//     if (timer !== 0) clearTimeout(timer);\n//     // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n//     // @ts-ignore\n//     timer = setTimeout(decay, updateRateMs) as number;\n//   };\n\n//   const decay = () => {\n//     mal.add(value);\n//     if (!mal.isDisposed) setTimeout(decay, updateRateMs);\n//   };\n\n//   const ma: MovingAverage = {\n//     add(v: number) {\n//       reschedule();\n//       return mal.add(v);\n//     },\n\n//     dispose() {\n//       mal.dispose();\n//     },\n//     clear: function (): void {\n//       mal.clear();\n//     },\n//     compute: function (): number {\n//       return mal.compute();\n//     },\n//     isDisposed: false,\n//   };\n\n//   return ma;\n// };\n\n/**\n * Creates a moving average for a set number of `samples`.\n * It returns a function which in turn yields an average value.\n * \n * Moving average are useful for computing the average over a recent set of numbers.\n * A lower number of samples produces a computed value that is lower-latency yet more jittery.\n * A higher number of samples produces a smoother computed value which takes longer to respond to\n * changes in data.\n *\n * Sample size is considered with respect to the level of latency/smoothness trade-off, and also\n * the rate at which new data is added to the moving average.\n *\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const ma = movingAverage(10);\n * ma(10); // 10\n * ma(5);  // 7.5\n * ```\n *\n * A weighting function can be provided to shape how the average is\n * calculated - eg privileging the most recent data over older data.\n * It uses `Arrays.averageWeighted` under the hood.\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n * import { gaussian } from 'https://unpkg.com/ixfx/dist/modulation.js';\n * \n * // Give more weight to data in middle of sampling window\n * const ma = movingAverage(100, gaussian());\n * ```\n *\n * Because it keeps track of `samples` previous data, there is a memory impact. A lighter version is {@link movingAverageLight} which does not keep a buffer of prior data, but can't be as easily fine-tuned.\n * @param samples Number of samples to compute average from\n * @param weighter Optional weighting function\n * @returns\n */\nexport const movingAverage = (\n  samples = 100,\n  weighter?: (v: number) => number\n): (value?: number) => number => {\n  const q = new QueueMutable<number>({\n    capacity: samples,\n    discardPolicy: `older`,\n  });\n\n  return (v?: number | undefined) => {\n    const r = numberTest(v);\n    if (r[ 0 ] && v !== undefined) {\n      q.enqueue(v);\n    }\n    return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n  }\n};\n\n\nconst smoothingFactor = (timeDelta: number, cutoff: number): number => {\n  const r = PiPi * cutoff * timeDelta;\n  return r / (r + 1);\n}\n\nconst exponentialSmoothing = (smoothingFactor: number, value: number, previous: number): number => {\n  return smoothingFactor * value + (1 - smoothingFactor) * previous\n}\n\n/**\n * Noise filtering\n * \n * Algorithm: https://gery.casiez.net/1euro/\n * \n * Based on [Jaan Tollander de Balsch's implementation](https://jaantollander.com/post/noise-filtering-using-one-euro-filter/)\n * @param cutoffMin Default: 1\n * @param speedCoefficient Default: 0\n * @param cutoffDefault Default: 1\n */\nexport const noiseFilter = (cutoffMin = 1, speedCoefficient = 0, cutoffDefault = 1) => {\n  let previousValue = 0;\n  let derivativeLast = 0;\n  let timestampLast = 0;\n\n  const compute = (value: number, timestamp?: number) => {\n    if (timestamp === undefined) timestamp = performance.now();\n    const timeDelta = timestamp - timestampLast;\n\n    // Filtered derivative\n    const s = smoothingFactor(timeDelta, cutoffDefault);\n    const valueDelta = (value - previousValue) / timeDelta;\n    const derivative = exponentialSmoothing(s, valueDelta, derivativeLast);\n\n    // Filtered signal\n    const cutoff = cutoffMin + speedCoefficient * Math.abs(derivative);\n    const a = smoothingFactor(timeDelta, cutoff);\n    const smoothed = exponentialSmoothing(a, value, previousValue);\n\n    previousValue = smoothed;\n    derivativeLast = derivative;\n    timestampLast = timestamp;\n\n    return smoothed;\n  }\n  return compute;\n}","import { movingAverageLight as mal } from \"../../numbers/MovingAverage.js\"\nimport { isPoint3d } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\nexport type PointAverager = (point: Point) => Point;\nexport type PointAverageKinds = `moving-average-light`;\n\n\n/**\n * Uses {@link Numbers.movingAverageLight} to keep track of \n * average x, y and z values.\n * ```js\n * // Create averager\n * const averager = Points.averager(`moving-average-light`);\n * \n * // Call function with a point to add it to average\n * // and return the current average.\n * averager(somePoint); // Yields current average {x,y,z?}\n * ```\n * @param opts Scaling parameter. Higher means more smoothing, lower means less (minimum: 1). Default: 3\n * @returns \n */\nexport function averager(kind: `moving-average-light`, opts: Partial<{ scaling: number }>): PointAverager;\n\nexport function averager(kind: PointAverageKinds, opts: any): PointAverager {\n  let x: (v: number) => number;\n  let y: (v: number) => number;\n  let z: (v: number) => number;\n  switch (kind) {\n    case `moving-average-light`:\n      const scaling = opts.scaling ?? 3;\n      x = mal(scaling);\n      y = mal(scaling);\n      z = mal(scaling);\n      break;\n    default:\n      throw new Error(`Unknown averaging kind '${ kind }'. Expected: 'moving-average-light'`);\n  }\n\n  return (point: Point) => {\n    let ax = x(point.x);\n    let ay = y(point.y);\n    if (isPoint3d(point)) {\n      let az = z(point.z);\n      return Object.freeze({\n        x: ax,\n        y: ay,\n        z: az\n      })\n    } else {\n      return Object.freeze({\n        x: ax,\n        y: ay\n      })\n    }\n  }\n}","import { isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\nexport function findMinimum(\n  comparer: (a: Point, b: Point) => Point,\n  ...points: ReadonlyArray<Point>\n): Point;\n\nexport function findMinimum(\n  comparer: (a: Point3d, b: Point3d) => Point3d,\n  ...points: ReadonlyArray<Point3d>\n): Point3d;\n\n/**\n * Returns the 'minimum' point from an array of points, using a comparison function.\n *\n * @example Find point closest to a coordinate\n * ```js\n * const points = [...];\n * const center = {x: 100, y: 100};\n *\n * const closestToCenter = findMinimum((a, b) => {\n *  const aDist = distance(a, center);\n *  const bDist = distance(b, center);\n *  if (aDistance < bDistance) return a;\n *  return b;\n * }, points);\n * ```\n * @param comparer Compare function returns the smallest of `a` or `b`\n * @param points\n * @returns\n */\nexport function findMinimum(\n  comparer: ((a: Point, b: Point) => Point)|((a: Point3d, b: Point3d) => Point3d),\n  ...points: ReadonlyArray<Point|Point3d>\n): Point|Point3d  {\n  if (points.length === 0) throw new Error(`No points provided`);\n  let min = points[ 0 ];\n  for (const p of points) {\n    if (isPoint3d(min) && isPoint3d(p)) {\n      min = comparer(min, p);\n    } else {\n      min = comparer(min as any, p as any);\n    }\n  }\n  return min;\n};","import type { Point } from \"../point/PointType.js\";\nimport type { RectPositioned } from \"./RectTypes.js\";\n\n/**\n * Returns a rectangle based on provided four corners.\n *\n * To create a rectangle that contains an arbitary set of points, use {@link Geometry.Points.bbox | Geometry.Points.bbox}.\n *\n * Does some sanity checking such as:\n *  - x will be smallest of topLeft/bottomLeft\n *  - y will be smallest of topRight/topLeft\n *  - width will be largest between top/bottom left and right\n *  - height will be largest between left and right top/bottom\n *\n */\nexport const maxFromCorners = (\n  topLeft: Point,\n  topRight: Point,\n  bottomRight: Point,\n  bottomLeft: Point\n): RectPositioned => {\n  if (topLeft.y > bottomRight.y) {\n    throw new Error(`topLeft.y greater than bottomRight.y`);\n  }\n  if (topLeft.y > bottomLeft.y) {\n    throw new Error(`topLeft.y greater than bottomLeft.y`);\n  }\n\n  const w1 = topRight.x - topLeft.x;\n  const w2 = bottomRight.x - bottomLeft.x;\n  const h1 = Math.abs(bottomLeft.y - topLeft.y);\n  const h2 = Math.abs(bottomRight.y - topRight.y);\n  return {\n    x: Math.min(topLeft.x, bottomLeft.x),\n    y: Math.min(topRight.y, topLeft.y),\n    width: Math.max(w1, w2),\n    height: Math.max(h1, h2),\n  };\n};\n","import type { Rect3dPositioned, RectPositioned } from \"../rect/RectTypes.js\";\nimport { findMinimum } from \"./FindMinimum.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\nimport { maxFromCorners as RectsMaxFromCorners } from '../rect/Max.js';\n/**\n * Returns the minimum rectangle that can enclose all provided points\n * @param points\n * @returns\n */\nexport const bbox = (...points: ReadonlyArray<Point>): RectPositioned => {\n  const leftMost = findMinimum((a, b) => {\n    return a.x < b.x ? a : b;\n  }, ...points);\n  const rightMost = findMinimum((a, b) => {\n    return a.x > b.x ? a : b;\n  }, ...points);\n  const topMost = findMinimum((a, b) => {\n    return a.y < b.y ? a : b;\n  }, ...points);\n  const bottomMost = findMinimum((a, b) => {\n    return a.y > b.y ? a : b;\n  }, ...points);\n\n  const topLeft = { x: leftMost.x, y: topMost.y };\n  const topRight = { x: rightMost.x, y: topMost.y };\n  const bottomRight = { x: rightMost.x, y: bottomMost.y };\n  const bottomLeft = { x: leftMost.x, y: bottomMost.y };\n  return RectsMaxFromCorners(topLeft, topRight, bottomRight, bottomLeft);\n};\n\nexport const bbox3d = (...points: ReadonlyArray<Point3d>): Rect3dPositioned => {\n  const box = bbox(...points);\n  const zMin = findMinimum((a:Point3d,b:Point3d) => {\n    return a.z < b.z ? a: b\n  }, ...points);\n  const zMax = findMinimum((a:Point3d,b:Point3d) => {\n    return a.z > b.z ? a: b\n  }, ...points);\n  \n  return {\n    ...box,\n    z:zMin.z,\n    depth:zMax.z-zMin.z\n  }\n}","import { isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Calculates the [centroid](https://en.wikipedia.org/wiki/Centroid#Of_a_finite_set_of_points) of a set of points\n * Undefined values are skipped over.\n *\n * ```js\n * // Find centroid of a list of points\n * const c1 = centroid(p1, p2, p3, ...);\n *\n * // Find centroid of an array of points\n * const c2 = centroid(...pointsArray);\n * ```\n * @param points\n * @returns A single point\n */\nexport const centroid = (...points: ReadonlyArray<Point | undefined>): Point => {\n  if (!Array.isArray(points)) throw new Error(`Expected list of points`);\n  // eslint-disable-next-line unicorn/no-array-reduce\n  const sum = points.reduce<Point>(\n    (previous, p) => {\n      if (p === undefined) return previous; // Ignore undefined\n      if (Array.isArray(p)) {\n        throw new TypeError(\n          `'points' list contains an array. Did you mean: centroid(...myPoints)?`\n        );\n      }\n      if (!isPoint(p)) {\n        throw new Error(\n          `'points' contains something which is not a point: ${ JSON.stringify(\n            p\n          ) }`\n        );\n      }\n      return {\n        x: previous.x + p.x,\n        y: previous.y + p.y,\n      };\n    },\n    { x: 0, y: 0 }\n  );\n\n  return Object.freeze({\n    x: sum.x / points.length,\n    y: sum.y / points.length,\n  });\n};\n\n","import { clamp as clampNumber } from '../../numbers/Clamp.js';\nimport { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport { isPoint, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\nexport function clamp(a: Point, min?: number, max?: number): Point;\nexport function clamp(a: Point3d, min?: number, max?: number): Point3d;\n\n/**\n * Clamps a point to be between `min` and `max` (0 & 1 by default)\n * @param pt Point\n * @param min Minimum value (0 by default)\n * @param max Maximum value (1 by default)\n */\nexport function clamp(\n  a: Point,\n  min: number = 0,\n  max: number = 1\n): Point {\n\n  if (isPoint3d(a)) {\n    return Object.freeze({\n      x: clampNumber(a.x, min, max),\n      y: clampNumber(a.y, min, max),\n      z: clampNumber(a.z, min, max)\n    });\n  } else {\n    return Object.freeze({\n      x: clampNumber(a.x, min, max),\n      y: clampNumber(a.y, min, max),\n    });\n  }\n}\n","import type { Point, Point3d } from \"./PointType.js\";\n\n/**\n * Returns -2 if both x & y of a is less than b\n * Returns -1 if either x/y of a is less than b\n *\n * Returns 2 if both x & y of a is greater than b\n * Returns 1 if either x/y of a is greater than b's x/y\n *\n * Returns 0 if x/y of a and b are equal\n * @param a\n * @param b\n * @returns\n */\nexport const compare = (a: Point, b: Point): number => {\n  if (a.x < b.x && a.y < b.y) return -2;\n  if (a.x > b.x && a.y > b.y) return 2;\n  if (a.x < b.x || a.y < b.y) return -1;\n  if (a.x > b.x || a.y > b.y) return 1;\n  if (a.x === b.x && a.x === b.y) return 0;\n  return Number.NaN;\n};\n\n/**\n * Compares points based on x value. Y value is ignored.\n * \n * Return values:\n * * 0: If a.x === b.x\n * * 1: a is to the right of b (ie. a.x > b.x)\n * * -1: a is to the left of b (ie. a.x < b.x)\n *\n * @example Sorting by x\n * ```js\n * arrayOfPoints.sort(Points.compareByX);\n * ```\n * \n * @param a\n * @param b\n * @returns\n */\nexport const compareByX = (a: Point, b: Point): number => {\n  if (a.x === b.x) return 0;\n  if (a.x < b.x) return -1;\n  return 1;\n\n  // a.x - b.x || a.y - b.y;\n}\n\n/**\n * Compares points based on Y value. X value is ignored.\n * Returns values:\n * * 0: If a.y === b.y\n * * 1: A is below B (ie. a.y > b.y)\n * * -1: A is above B (ie. a.y < b.y)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByY);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByY = (a: Point, b: Point): number => {\n  if (a.y === b.y) return 0;\n  if (a.y < b.y) return -1;\n  return 1;\n}\n\n/**\n * Compares points based on Z value. XY values are ignored.\n * Returns values:\n * * 0: If a.z === b.z\n * * 1: A is below B (ie. a.z > b.z)\n * * -1: A is above B (ie. a.z < b.z)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByZ);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByZ = (a: Point3d, b: Point3d): number => {\n  if (a.z === b.z) return 0;\n  if (a.z < b.z) return -1;\n  return 1;\n}","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns _true_ if the points have identical values\n *\n * ```js\n * const a = {x: 10, y: 10};\n * const b = {x: 10, y: 10;};\n * a === b        // False, because a and be are different objects\n * isEqual(a, b)   // True, because a and b are same value\n * ```\n * @param p Points\n * @returns _True_ if points are equal\n */\nexport const isEqual = (...p: ReadonlyArray<Point>): boolean => {\n  if (p === undefined) throw new Error(`parameter 'p' is undefined`);\n  if (p.length < 2) return true;\n\n  for (let index = 1; index < p.length; index++) {\n    if (p[ index ].x !== p[ 0 ].x) return false;\n    if (p[ index ].y !== p[ 0 ].y) return false;\n  }\n  return true;\n};","import { compareByX } from \"./Compare.js\";\nimport { isEqual } from \"./IsEqual.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Simple convex hull impementation. Returns a set of points which\n * enclose `pts`.\n *\n * For more power, see something like [Hull.js](https://github.com/AndriiHeonia/hull)\n * @param pts\n * @returns\n */\nexport const convexHull = (...pts: ReadonlyArray<Point>): ReadonlyArray<Point> => {\n  const sorted = [ ...pts ].sort(compareByX);\n  if (sorted.length === 1) return sorted;\n\n  const x = (points: Array<Point>) => {\n    const v: Array<Point> = [];\n    for (const p of points) {\n      while (v.length >= 2) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const q = v.at(-1)!;\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        const r = v.at(-2)!;\n        if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) {\n          //eslint-disable-next-line functional/immutable-data\n          v.pop();\n        } else break;\n      }\n      //eslint-disable-next-line functional/immutable-data\n      v.push(p);\n    }\n    //eslint-disable-next-line functional/immutable-data\n    v.pop();\n    return v;\n  };\n\n  const upper = x(sorted);\n  //eslint-disable-next-line functional/immutable-data\n  const lower = x(sorted.reverse());\n\n  if (upper.length === 1 && lower.length === 1 && isEqual(lower[ 0 ], upper[ 0 ])) {\n    return upper;\n  }\n  return [ ...upper, ...lower ];\n};","import { isPoint, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\nexport function getTwoPointParameters(a: Point, b: Point): [ a: Point, b: Point ];\nexport function getTwoPointParameters(a: Point3d, b: Point3d): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(a: Point, x: number, y: number): [ a: Point, b: Point ];\nexport function getTwoPointParameters(a: Point3d, x: number, y: number, z: number): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(ax: number, ay: number, bx: number, by: number): [ a: Point, b: Point ];\nexport function getTwoPointParameters(ax: number, ay: number, az: number, bx: number, by: number, bz: number): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number) {\n  if (isPoint3d(a1) && isPoint3d(ab2)) return [ a1, ab2 ];\n  if (isPoint(a1) && isPoint(ab2)) return [ a1, ab2 ];\n  if (isPoint3d(a1)) {\n    const b = {\n      x: ab2,\n      y: ab3,\n      z: ab4\n    }\n    if (!isPoint3d(b)) throw new Error(`Expected x, y & z parameters`);\n    return [ a1, b ];\n  }\n  if (isPoint(a1)) {\n    const b = {\n      x: ab2,\n      y: ab3\n    }\n    if (!isPoint(b)) throw new Error(`Expected x & y parameters`);\n    return [ a1, b ];\n  }\n\n  if (typeof ab5 !== `undefined` && typeof ab4 !== `undefined`) {\n    const a = {\n      x: a1,\n      y: ab2,\n      z: ab3\n    };\n    const b = {\n      x: ab4,\n      y: ab5,\n      z: ab6\n    }\n    if (!isPoint3d(a)) throw new Error(`Expected x,y,z for first point`);\n    if (!isPoint3d(b)) throw new Error(`Expected x,y,z for second point`);\n    return [ a, b ];\n  }\n\n  const a = {\n    x: a1,\n    y: ab2\n  };\n  const b = {\n    x: ab3,\n    y: ab4\n  }\n  if (!isPoint(a)) throw new Error(`Expected x,y for first point`);\n  if (!isPoint(b)) throw new Error(`Expected x,y for second point`);\n  return [ a, b ];\n\n}\n\n/**\n * Returns a Point form of either a point, x,y params or x,y,z params.\n * If parameters are undefined, an empty point is returned (0, 0)\n * @ignore\n * @param a\n * @param b\n * @returns\n */\nexport function getPointParameter(\n  a?: Point3d | Point | number | Array<number> | ReadonlyArray<number>,\n  b?: number | boolean,\n  c?: number\n): Point | Point3d {\n  if (a === undefined) return { x: 0, y: 0 };\n\n  if (Array.isArray(a)) {\n    if (a.length === 0) return Object.freeze({ x: 0, y: 0 });\n    if (a.length === 1) return Object.freeze({ x: a[ 0 ], y: 0 });\n    if (a.length === 2) return Object.freeze({ x: a[ 0 ], y: a[ 1 ] });\n    if (a.length === 3) return Object.freeze({ x: a[ 0 ], y: a[ 1 ], z: a[ 2 ] });\n    throw new Error(\n      `Expected array to be 1-3 elements in length. Got ${ a.length }.`\n    );\n  }\n\n  if (isPoint(a)) {\n    return a;\n  } else if (typeof a !== `number` || typeof b !== `number`) {\n    throw new TypeError(\n      `Expected point or x,y as parameters. Got: a: ${ JSON.stringify(\n        a\n      ) } b: ${ JSON.stringify(b) }`\n    );\n  }\n\n  // x,y,z\n  if (typeof c === `number`) {\n    return Object.freeze({ x: a, y: b, z: c });\n  }\n  // x,y\n  return Object.freeze({ x: a, y: b });\n}","import { guard, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from './PointType.js';\nimport { getPointParameter } from \"./GetPointParameter.js\";\n\nexport function distance(a: Point, b?: Point): number;\nexport function distance(a: Point, x: number, y: number): number;\n\n/**\n * Calculate distance between two points.\n * If both points have a `z` property, the distance is 3D distance is calculated.\n * If only one point has a `z`, it is ignored.\n *\n * ```js\n * // Distance between two points\n * const ptA = { x: 0.5, y:0.8 };\n * const ptB = { x: 1, y: 0.4 };\n * distance(ptA, ptB);\n * // Or, provide x,y as parameters\n * distance(ptA, 0.4, 0.9);\n *\n * // Distance from ptA to x: 0.5, y:0.8, z: 0.1\n * const ptC = { x: 0.5, y:0.5, z: 0.3 };\n * // With x,y,z as parameters:\n * distance(ptC, 0.5, 0.8, 0.1);\n * ```\n * @param a First point\n * @param xOrB Second point, or x coord\n * @param y y coord, if x coord is given\n * @param z Optional z coord, if x and y are given.\n * @returns\n */\nexport function distance(\n  a: Point | Point3d,\n  xOrB?: Point | Point3d | number,\n  y?: number,\n  z?: number\n): number {\n  const pt = getPointParameter(xOrB, y, z);\n  guard(pt, `b`);\n  guard(a, `a`);\n  return isPoint3d(pt) && isPoint3d(a) ? Math.hypot(pt.x - a.x, pt.y - a.y, pt.z - a.z) : Math.hypot(pt.x - a.x, pt.y - a.y);\n}\n","import { guard as guardPoint } from '../point/Guard.js';\nimport type { Point } from '../point/PointType.js';\nimport type { Circle, CirclePositioned } from './CircleType.js';\n\n/**\n * Throws if radius is out of range. If x,y is present, these will be validated too.\n * @param circle \n * @param parameterName \n */\nexport const guard = (circle: CirclePositioned | Circle, parameterName = `circle`) => {\n  if (isCirclePositioned(circle)) {\n    guardPoint(circle, `circle`);\n  }\n\n  if (Number.isNaN(circle.radius)) throw new Error(`${ parameterName }.radius is NaN`);\n  if (circle.radius <= 0) throw new Error(`${ parameterName }.radius must be greater than zero`);\n};\n\n/**\n * Throws if `circle` is not positioned or has dodgy fields\n * @param circle \n * @param parameterName \n * @returns \n */\nexport const guardPositioned = (circle: CirclePositioned, parameterName = `circle`) => {\n  if (!isCirclePositioned(circle)) throw new Error(`Expected a positioned circle with x,y`);\n  guard(circle, parameterName);\n};\n\n/***\n * Returns true if radius, x or y are NaN\n */\nexport const isNaN = (a: Circle | CirclePositioned): boolean => {\n  if (Number.isNaN(a.radius)) return true;\n  if (isCirclePositioned(a)) {\n    if (Number.isNaN(a.x)) return true;\n    if (Number.isNaN(a.y)) return true;\n  }\n  return false;\n};\n\n\n/**\n * Returns true if parameter has x,y. Does not verify if parameter is a circle or not\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * \n * const circleA = { radius: 5 };\n * Circles.isPositioned(circle); // false\n * \n * const circleB = { radius: 5, x: 10, y: 10 }\n * Circles.isPositioned(circle); // true\n * ```\n * @param p Circle\n * @returns \n */\nexport const isPositioned = (p: Circle | Point): p is Point => (p as Point).x !== undefined && (p as Point).y !== undefined;\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isCircle = (p: any): p is Circle => (p as Circle).radius !== undefined;\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isCirclePositioned = (p: any): p is CirclePositioned => isCircle(p) && isPositioned(p);","import type { CirclePositioned } from \"./CircleType.js\";\nimport { distance as pointsDistance } from '../point/Distance.js';\nimport { guardPositioned, isCirclePositioned } from \"./Guard.js\";\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Returns the distance between two circle centers.\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * Throws an error if either is lacking position.\n * @param a \n * @param b \n * @returns Distance\n */\nexport const distanceCenter = (a: CirclePositioned, b: CirclePositioned | Point): number => {\n  guardPositioned(a, `a`);\n  if (isCirclePositioned(b)) {\n    guardPositioned(b, `b`);\n  }\n  return pointsDistance(a, b);\n};\n","import type { CirclePositioned } from \"./CircleType.js\";\nimport { distanceCenter } from \"./DistanceCenter.js\";\nimport { isPoint as PointsIsPoint } from \"../point/Guard.js\";\nimport { distance as PointsDistance } from \"../point/Distance.js\";\nimport { guardPositioned, isCirclePositioned } from \"./Guard.js\";\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Returns the distance between the exterior of two circles, or between the exterior of a circle and point.\n * If `b` overlaps or is enclosed by `a`, distance is 0.\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * @param a\n * @param b \n */\nexport const distanceFromExterior = (a: CirclePositioned, b: CirclePositioned | Point): number => {\n  guardPositioned(a, `a`);\n  if (isCirclePositioned(b)) {\n    return Math.max(0, distanceCenter(a, b) - a.radius - b.radius);\n  } else if (PointsIsPoint(b)) {\n    const distribution = PointsDistance(a, b);\n    if (distribution < a.radius) return 0;\n    return distribution;\n  } else throw new Error(`Second parameter invalid type`);\n};","import type { RectPositioned, Rect } from \"./RectTypes.js\";\nimport { guard as PointsGuard } from '../point/Guard.js';\nimport type { Point } from '../point/PointType.js';\n\n/**\n * Throws an error if the dimensions of the rectangle are undefined, NaN or negative.\n * @param d \n * @param name \n */\nexport const guardDim = (d: number, name = `Dimension`) => {\n  if (d === undefined) throw new Error(`${ name } is undefined`);\n  if (Number.isNaN(d)) throw new Error(`${ name } is NaN`);\n  if (d < 0) throw new Error(`${ name } cannot be negative`);\n};\n\n/**\n * Throws an error if rectangle is missing fields or they\n * are not valid.\n * \n * Checks:\n * * `width` and `height` must be defined on `rect`\n * * dimensions (w & h) must not be NaN\n * * dimensions (w & h) must not be negative\n * \n * If `rect` has x,y, this value is checked as well.\n * @param rect\n * @param name\n */\nexport const guard = (rect: Rect, name = `rect`) => {\n  if (rect === undefined) throw new Error(`{$name} undefined`);\n  if (isPositioned(rect)) PointsGuard(rect, name);\n  guardDim(rect.width, name + `.width`);\n  guardDim(rect.height, name + `.height`);\n};\n\n/**\n * Returns a positioned rect or if it's not possible, throws an error.\n * \n * If `rect` does not have a position, `origin` is used.\n * If `rect` is positioned and `origin` is provided, returned result uses `origin` as x,y instead.\n * ```js\n * // Returns input because it's positioned\n * getRectPositioned({ x:1, y:2, width:10, height:20 });\n * \n * // Returns { x:1, y:2, width:10, height:20 }\n * getRectPositioned({ width:10, height:20 }, { x:1, y:2 });\n *  \n * // Throws, because we have no point\n * getRectPositioned({width:10,height:20})\n * ```\n * @param rect \n * @param origin \n * @returns \n */\nexport const getRectPositioned = (rect: Rect | RectPositioned, origin?: Point): RectPositioned => {\n  guard(rect);\n  if (isPositioned(rect) && origin === undefined) {\n    return rect;\n  }\n  if (origin === undefined) throw new Error(`Unpositioned rect needs origin parameter`);\n  return Object.freeze({ ...rect, ...origin });\n\n}\n\n/**\n * Throws an error if `rect` is does not have a position, or\n * is an invalid rectangle\n * @param rect \n * @param name \n */\nexport const guardPositioned = (rect: RectPositioned, name = `rect`) => {\n  if (!isPositioned(rect)) throw new Error(`Expected ${ name } to have x,y`);\n  guard(rect, name);\n};\n\n/**\n * Returns _true_ if `rect` has width and height values of 0.\n * Use Rects.Empty or Rects.EmptyPositioned to generate an empty rectangle.\n * @param rect \n * @returns \n */\nexport const isEmpty = (rect: Rect): boolean =>\n  rect.width === 0 && rect.height === 0;\n\n/**\n * Returns _true_ if `rect` is a placeholder, with both width and height values of NaN.\n * Use Rects.Placeholder or Rects.PlaceholderPositioned to generate a placeholder.\n * @param rect \n * @returns \n */\nexport const isPlaceholder = (rect: Rect): boolean =>\n  Number.isNaN(rect.width) && Number.isNaN(rect.height);\n\n/**\n * Returns _true_ if `rect` has position (x,y) fields.\n * @param rect Point, Rect or RectPositiond\n * @returns\n */\nexport const isPositioned = (\n  rect: Point | Rect | RectPositioned\n): rect is Point =>\n  (rect as Point).x !== undefined && (rect as Point).y !== undefined;\n\n/**\n * Returns _true_ if `rect` has width and height fields.\n * @param rect\n * @returns\n */\nexport const isRect = (rect: unknown): rect is Rect => {\n  if (rect === undefined) return false;\n  if ((rect as Rect).width === undefined) return false;\n  if ((rect as Rect).height === undefined) return false;\n  return true;\n};\n\n/**\n * Returns _true_ if `rect` is a positioned rectangle\n * Having width, height, x and y properties.\n * @param rect\n * @returns\n */\nexport const isRectPositioned = (\n  rect: any\n): rect is RectPositioned => isRect(rect) && isPositioned(rect);\n","import type { Circle, CirclePositioned } from \"./CircleType.js\";\nimport { isCirclePositioned } from \"./Guard.js\";\n\n/**\n * Returns true if the two objects have the same values\n *\n * ```js\n * const circleA = { radius: 10, x: 5, y: 5 };\n * const circleB = { radius: 10, x: 5, y: 5 };\n * \n * circleA === circleB; // false, because identity of objects is different\n * Circles.isEqual(circleA, circleB); // true, because values are the same\n * ```\n * \n * Circles must both be positioned or not.\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a: CirclePositioned | Circle, b: CirclePositioned | Circle): boolean => {\n  if (a.radius !== b.radius) return false;\n\n  if (isCirclePositioned(a) && isCirclePositioned(b)) {\n    if (a.x !== b.x) return false;\n    if (a.y !== b.y) return false;\n    if (a.z !== b.z) return false;\n    return true;\n  } else if (!isCirclePositioned(a) && !isCirclePositioned(b)) {\n    // no-op\n  } else return false; // one is positioned one not\n\n  return false;\n};","import { getTwoPointParameters } from \"./GetPointParameter.js\";\nimport { guard, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\nimport type { Writeable } from \"../../TsUtil.js\";\n\nexport function sum(a: Point, b: Point): Point;\nexport function sum(a: Point3d, b: Point3d): Point3d;\nexport function sum(a: Point, x: number, y: number): Point;\nexport function sum(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function sum(ax: number, ay: number, bx: number, by: number): Point;\nexport function sum(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points added.\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when adding a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * sum(ptA, ptB);\n * sum(x1, y1, x2, y2);\n * sum(ptA, x2, y2);\n * ```\n */\nexport function sum(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  let pt: Writeable<Point> = {\n    x: ptA.x + ptB.x,\n    y: ptA.y + ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) + (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n","import { getTwoPointParameters } from \"./GetPointParameter.js\";\nimport { guard, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\nimport type { Writeable } from \"../../TsUtil.js\";\n\nexport function subtract(a: Point, b: Point): Point;\nexport function subtract(a: Point3d, b: Point3d): Point3d;\nexport function subtract(a: Point, x: number, y: number): Point;\nexport function subtract(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function subtract(ax: number, ay: number, bx: number, by: number): Point;\nexport function subtract(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points subtracted (a-b).\n * \n * `z` parameter is used if present. Uses a default value of 0 for 'z' when subtracting a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * subtract(ptA, ptB);\n * subtract(x1, y1, x2, y2);\n * subtract(ptA, x2, y2);\n * ```\n */\nexport function subtract(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  let pt: Writeable<Point> = {\n    x: ptA.x - ptB.x,\n    y: ptA.y - ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) - (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n","import { isEqual } from \"./IsEqual.js\";\nimport { sum as PointsSum } from \"../point/Sum.js\";\nimport { subtract as PointsSubtract } from \"../point/Subtract.js\";\nimport type { Point } from '../point/PointType.js';\nimport type { CirclePositioned } from \"./CircleType.js\";\nimport type { Line } from \"../line/LineType.js\";\n\n/**\n * Returns the point(s) of intersection between a circle and line.\n * \n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\" \n * const circle = { radius: 5, x: 5, y: 5 };\n * const line = { a: { x: 0, y: 0 }, b: { x: 10, y: 10 } };\n * const pts = Circles.intersectionLine(circle, line);\n * ```\n * @param circle \n * @param line \n * @returns Point(s) of intersection, or empty array\n */\nexport const intersectionLine = (circle: CirclePositioned, line: Line): ReadonlyArray<Point> => {\n  const v1 = {\n    x: line.b.x - line.a.x,\n    y: line.b.y - line.a.y\n  };\n  const v2 = {\n    x: line.a.x - circle.x,\n    y: line.a.y - circle.y\n  };\n\n  const b = (v1.x * v2.x + v1.y * v2.y) * -2;\n  const c = 2 * (v1.x * v1.x + v1.y * v1.y);\n\n  const d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - circle.radius * circle.radius));\n  if (Number.isNaN(d)) return []; // no intercept\n\n  const u1 = (b - d) / c;  // these represent the unit distance of point one and two on the line\n  const u2 = (b + d) / c;\n\n  const returnValue = [];\n  if (u1 <= 1 && u1 >= 0) {  // add point if on the line segment\n    //eslint-disable-next-line functional/immutable-data\n    returnValue.push({\n      x: line.a.x + v1.x * u1,\n      y: line.a.y + v1.y * u1\n    });\n  }\n  if (u2 <= 1 && u2 >= 0) {  // second add point if on the line segment\n    //eslint-disable-next-line functional/immutable-data\n    returnValue.push({\n      x: line.a.x + v1.x * u2,\n      y: line.a.y + v1.y * u2\n    });\n  }\n  return returnValue;\n};\n\n\n/**\n * \n * Returns the points of intersection betweeen `a` and `b`.\n * \n * Returns an empty array if circles are equal, one contains the other or if they don't touch at all.\n *\n * @param a Circle\n * @param b Circle\n * @returns Points of intersection, or an empty list if there are none\n */\nexport const intersections = (a: CirclePositioned, b: CirclePositioned): ReadonlyArray<Point> => {\n  const vector = PointsSubtract(b, a);\n  const centerD = Math.hypot((vector.y), (vector.x));\n\n  // Do not intersect\n  if (centerD > a.radius + b.radius) return [];\n\n  // Circle contains another\n  if (centerD < Math.abs(a.radius - b.radius)) return [];\n\n  // Circles are the same\n  if (isEqual(a, b)) return [];\n\n  const centroidD = ((a.radius * a.radius) - (b.radius * b.radius) + (centerD * centerD)) / (2 * centerD);\n  const centroid = {\n    x: a.x + (vector.x * centroidD / centerD),\n    y: a.y + (vector.y * centroidD / centerD)\n  };\n\n  const centroidIntersectionD = Math.sqrt((a.radius * a.radius) - (centroidD * centroidD));\n\n  const intersection = {\n    x: -vector.y * (centroidIntersectionD / centerD),\n    y: vector.x * (centroidIntersectionD / centerD)\n  };\n  return [\n    PointsSum(centroid, intersection),\n    PointsSubtract(centroid, intersection)\n  ];\n};\n","import { intersections as circleIntersections } from \"./circle/Intersections.js\";\nimport type { CirclePositioned } from \"./circle/CircleType.js\";\nimport type { RectPositioned } from \"./rect/index.js\";\n\nexport const circleRect = (a: CirclePositioned, b: RectPositioned) => {\n  // https://yal.cc/rectangle-circle-intersection-test/\n  const deltaX = a.x - Math.max(b.x, Math.min(a.x, b.x + b.width));\n  const deltaY = a.y - Math.max(b.y, Math.min(a.y, b.y + b.height));\n  return (deltaX * deltaX + deltaY * deltaY) < (a.radius * a.radius);\n};\n\nexport const circleCircle = (a: CirclePositioned, b: CirclePositioned) => circleIntersections(a, b).length === 2;","import { guard } from \"./Guard.js\";\nimport { isPositioned, isRectPositioned } from \"./Guard.js\";\nimport { isCirclePositioned } from '../circle/Guard.js';\nimport * as Intersects from '../Intersects.js';\nimport { isPoint } from \"../point/Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { CirclePositioned } from \"../circle/CircleType.js\";\n/**\n * Returns _true_ if `point` is within, or on boundary of `rect`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * ```\n * @param rect\n * @param point\n */\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  point: Point\n): boolean;\n\n/**\n * Returns true if x,y coordinate is within, or on boundary of `rect`.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param x\n * @param y\n */\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  x: number,\n  y: number\n): boolean;\n\n/**\n * Returns true if point is within or on boundary of `rect`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param a\n * @param b\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function intersectsPoint(\n  rect: Rect | RectPositioned,\n  a: Point | number,\n  b?: number\n): boolean {\n  guard(rect, `rect`);\n  //eslint-disable-next-line functional/no-let\n  let x = 0;\n  //eslint-disable-next-line functional/no-let\n  let y = 0;\n  if (typeof a === `number`) {\n    if (b === undefined) throw new Error(`x and y coordinate needed`);\n    x = a;\n    y = b;\n  } else {\n    x = a.x;\n    y = a.y;\n  }\n  if (isPositioned(rect)) {\n    if (x - rect.x > rect.width || x < rect.x) return false;\n    if (y - rect.y > rect.height || y < rect.y) return false;\n  } else {\n    // Assume 0,0\n    if (x > rect.width || x < 0) return false;\n    if (y > rect.height || y < 0) return false;\n  }\n  return true;\n}\n\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A rectangle can be checked for intersections with another RectPositioned, CirclePositioned or Point.\n *\n */\nexport const isIntersecting = (\n  a: RectPositioned,\n  // eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\n  b: CirclePositioned | Point\n): boolean => {\n  if (!isRectPositioned(a)) {\n    throw new Error(`a parameter should be RectPositioned`);\n  }\n\n  if (isCirclePositioned(b)) {\n    return Intersects.circleRect(b, a);\n  } else if (isPoint(b)) {\n    return intersectsPoint(a, b);\n  }\n  throw new Error(`Unknown shape for b: ${ JSON.stringify(b) }`);\n};","import { isPoint } from \"../point/Guard.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport { getRectPositioned, guard } from \"./Guard.js\";\nimport type { Rect, RectPositioned } from \"./RectTypes.js\";\n\n/**\n * Returns the center of a rectangle as a {@link Geometry.Point}.\n *  If the rectangle lacks a position and `origin` parameter is not provided, 0,0 is used instead.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const p = Rects.center({x:10, y:20, width:100, height:50});\n * const p2 = Rects.center({width: 100, height: 50}); // Assumes 0,0 for rect x,y\n * ```\n * @param rect Rectangle\n * @param origin Optional origin. Overrides `rect` position if available. If no position is available 0,0 is used by default.\n * @returns\n */\nexport const center = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): Point => {\n  guard(rect);\n  if (origin === undefined && isPoint(rect)) origin = rect;\n  else if (origin === undefined) origin = { x: 0, y: 0 }; // throw new Error(`Unpositioned rect needs origin param`);\n\n  const r = getRectPositioned(rect, origin);\n  return Object.freeze({\n    x: origin.x + rect.width / 2,\n    y: origin.y + rect.height / 2,\n  });\n};","/**\n * A point, consisting of x, y and maybe z fields.\n */\nexport type Point = {\n  readonly x: number;\n  readonly y: number;\n  readonly z?: number;\n};\n\nexport type Point3d = Point & {\n  readonly z: number;\n};\n\n/**\n * Placeholder point: `{ x: NaN, y: NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder3d` get a point with `z` property.\n */\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Placeholder = Object.freeze({ x: Number.NaN, y: Number.NaN });\n\n/**\n * Placeholder point: `{x: NaN, y:NaN, z:NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder` to get a point without `z` property.\n */\nexport const Placeholder3d = Object.freeze({ x: Number.NaN, y: Number.NaN, z: Number.NaN });","import { guardPositioned } from \"./Guard.js\";\nimport { intersectsPoint } from \"./Intersects.js\";\nimport { center } from \"./Center.js\";\nimport type { RectPositioned } from \"./RectTypes.js\";\nimport { type Point } from '../point/PointType.js';\nimport { guard as PointsGuard } from '../point/Guard.js';\nimport { distance as PointsDistance } from '../point/Distance.js';\n\n/**\n * Returns the distance from the perimeter of `rect` to `pt`.\n * If the point is within the rectangle, 0 is returned.\n *\n * If `rect` does not have an x,y it's assumed to be 0,0\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromExterior(rect, { x: 20, y: 20 });\n * ```\n * @param rect Rectangle\n * @param pt Point\n * @returns Distance\n */\nexport const distanceFromExterior = (\n  rect: RectPositioned,\n  pt: Point\n): number => {\n  guardPositioned(rect, `rect`);\n  PointsGuard(pt, `pt`);\n  if (intersectsPoint(rect, pt)) return 0;\n  const dx = Math.max(rect.x - pt.x, 0, pt.x - rect.x + rect.width);\n  const dy = Math.max(rect.y - pt.y, 0, pt.y - rect.y + rect.height);\n  return Math.hypot(dx, dy);\n};\n\n/**\n * Return the distance of `pt` to the center of `rect`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromCenter(rect, { x: 20, y: 20 });\n * ```\n * @param rect\n * @param pt\n * @returns\n */\nexport const distanceFromCenter = (\n  rect: RectPositioned,\n  pt: Point\n): number => PointsDistance(center(rect), pt);\n","import { distanceFromExterior as circleDistanceFromExterior } from \"../circle/DistanceFromExterior.js\";\nimport { distance } from \"./Distance.js\";\nimport { isPoint } from \"./Guard.js\";\nimport { distanceFromExterior as rectDistanceFromExterior } from \"../rect/Distance.js\";\nimport type { Point } from \"./PointType.js\";\nimport { isCirclePositioned } from \"../circle/Guard.js\";\nimport { isRectPositioned } from \"../rect/Guard.js\";\nimport type { PointCalculableShape } from \"../shape/index.js\";\n\n/**\n * Returns the distance from point `a` to the center of `shape`.\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport const distanceToCenter = (\n  a: Point,\n  shape: PointCalculableShape\n): number => {\n  if (isRectPositioned(shape)) {\n    return rectDistanceFromExterior(shape, a);\n  }\n  if (isCirclePositioned(shape)) {\n    return circleDistanceFromExterior(shape, a);\n  }\n  if (isPoint(shape)) return distance(a, shape);\n  throw new Error(`Unknown shape`);\n};","import { distanceFromExterior as circleDistanceFromExterior } from \"../circle/DistanceFromExterior.js\";\nimport { distance, isPoint } from \"./index.js\";\nimport type { Point, PointCalculableShape } from \"../Types.js\";\nimport { distanceFromExterior as rectDistanceFromExterior } from \"../rect/Distance.js\";\nimport { isCirclePositioned } from \"../circle/Guard.js\";\nimport { isRectPositioned } from \"../rect/Guard.js\";\n\n/**\n * Returns the distance from point `a` to the exterior of `shape`.\n *\n * @example Distance from point to rectangle\n * ```\n * const distance = distanceToExterior(\n *  {x: 50, y: 50},\n *  {x: 100, y: 100, width: 20, height: 20}\n * );\n * ```\n *\n * @example Find closest shape to point\n * ```\n * import {minIndex} from '../data/arrays.js';\n * const shapes = [ some shapes... ]; // Shapes to compare against\n * const pt = { x: 10, y: 10 };       // Comparison point\n * const distances = shapes.map(v => distanceToExterior(pt, v));\n * const closest = shapes[minIndex(...distances)];\n * ```\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport const distanceToExterior = (\n  a: Point,\n  shape: PointCalculableShape\n): number => {\n  if (isRectPositioned(shape)) {\n    return rectDistanceFromExterior(shape, a);\n  }\n  if (isCirclePositioned(shape)) {\n    return circleDistanceFromExterior(shape, a);\n  }\n  if (isPoint(shape)) return distance(a, shape);\n  throw new Error(`Unknown shape`);\n};","import { getPointParameter, getTwoPointParameters } from \"./GetPointParameter.js\";\nimport { guard, guardNonZeroPoint, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\nimport type { Writeable } from \"../../TsUtil.js\";\n\nexport function divide(a: Point, b: Point): Point;\nexport function divide(a: Point3d, b: Point3d): Point3d;\nexport function divide(a: Point, x: number, y: number): Point;\nexport function divide(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function divide(ax: number, ay: number, bx: number, by: number): Point;\nexport function divide(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points divide (a/b).\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when dividing a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * divide(ptA, ptB);\n * divide(x1, y1, x2, y2);\n * divide(ptA, x2, y2);\n * ```\n */\nexport function divide(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  if (ptB.x === 0) throw new TypeError('Cannot divide by zero (b.x is 0)');\n  if (ptB.y === 0) throw new TypeError('Cannot divide by zero (b.y is 0)');\n\n  let pt: Writeable<Point> = {\n    x: ptA.x / ptB.x,\n    y: ptA.y / ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    if (ptB.z === 0) throw new TypeError('Cannot divide by zero (b.z is 0)');\n\n    pt.z = (ptA.z ?? 0) / (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n\n\n/**\n * Returns a function that divides a point:\n * ```js\n * const f = divider(100, 200);\n * f(50,100); // Yields: { x: 0.5, y: 0.5 }\n * ```\n *\n * Input values can be Point, separate x,y and optional z values or an array:\n * ```js\n * const f = divider({ x: 100, y: 100 });\n * const f = divider( 100, 100 );\n * const f = divider([ 100, 100 ]);\n * ```\n *\n * Likewise the returned function an take these as inputs:\n * ```js\n * f({ x: 100, y: 100});\n * f( 100, 100 );\n * f([ 100, 100 ]);\n * ```\n *\n * Function throws if divisor has 0 for any coordinate (since we can't divide by 0)\n * @param a Divisor point, array of points or x\n * @param b Divisor y value\n * @param c Divisor z value\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport function divider(a: Point3d | Point | number | Array<number>, b?: number, c?: number) {\n  const divisor = getPointParameter(a, b, c);\n  guardNonZeroPoint(divisor, `divisor`);\n\n  return (\n    aa: Point3d | Point | number | Array<number>,\n    bb?: number,\n    cc?: number\n  ): Point => {\n    const dividend = getPointParameter(aa, bb, cc);\n\n    return typeof dividend.z === `undefined` ? Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n    }) : Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n      z: dividend.z / (divisor.z ?? 1),\n    });\n  };\n}\n","import type { Point } from \"./PointType.js\";\n\n/**\n * Returns point as an array in the form [x,y]. This can be useful for some libraries\n * that expect points in array form.\n *\n * ```\n * const p = {x: 10, y:5};\n * const p2 = toArray(p); // yields [10,5]\n * ```\n * @param p\n * @returns\n */\nexport const toArray = (p: Point): ReadonlyArray<number> => [ p.x, p.y ];\n","import { dotProduct as ArraysDotProduct } from '../../numbers/NumericArrays.js';\nimport type { Point } from './PointType.js';\nimport { toArray } from './ToArray.js';\n\nexport const dotProduct = (...pts: ReadonlyArray<Point>): number => {\n  const a = pts.map(p => toArray(p));\n  return ArraysDotProduct(a);\n};","/**\n * An empty point of `{ x: 0, y: 0 }`.\n *\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty3d` to get an empty point with `z`.\n */\nexport const Empty = { x: 0, y: 0 } as const;\n\n/**\n * Returns { x:1, y:1 }\n */\nexport const Unit = { x: 1, y: 1 } as const;\n\n/**\n * An empty Point of `{ x: 0, y: 0, z: 0}`\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty` to get an empty point without `z`.\n */\nexport const Empty3d = { x: 0, y: 0, z: 0 } as const;\n\n/**\n * Returns { x:1,y:1,z:1 }\n */\nexport const Unit3d = { x: 1, y: 1, z: 1 } as const;","import { guard } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\nexport function from(x: number, y: number, z: number): Point3d;\nexport function from(x: number, y: number): Point;\nexport function from(arr: [ x: number, y: number, z: number ]): Point3d;\nexport function from(arr: [ x: number, y: number ]): Point;\n\n/**\n * Returns a point from two or three coordinates or an array of [x,y] or [x,y,z].\n * @example\n * ```js\n * let p = from([10, 5]);    // yields {x:10, y:5}\n * let p = from([10, 5, 2]); // yields: {x:10, y:5, z:2}\n * let p = from(10, 5);      // yields {x:10, y:5}\n * let p = from(10, 5, 2);   // yields: {x:10, y:5, z:2}\n * ```\n * @param xOrArray\n * @param [y]\n * @returns Point\n */\nexport function from(\n  xOrArray?: number | ReadonlyArray<number>,\n  y?: number,\n  z?: number\n): Point {\n  if (Array.isArray(xOrArray)) {\n    if (xOrArray.length === 3) {\n      return Object.freeze({\n        x: xOrArray[ 0 ],\n        y: xOrArray[ 1 ],\n        z: xOrArray[ 2 ]\n      });\n    } else if (xOrArray.length === 2) {\n      return Object.freeze({\n        x: xOrArray[ 0 ],\n        y: xOrArray[ 1 ],\n      });\n    } else {\n      throw new Error(`Expected array of length two or three, got ${ xOrArray.length }`);\n    }\n  } else {\n    if (xOrArray === undefined) throw new Error(`Requires an array of [x,y] or x,y parameters at least`)\n    else if (Number.isNaN(xOrArray)) throw new Error(`x is NaN`);\n    if (y === undefined) throw new Error(`Param 'y' is missing`);\n    else if (Number.isNaN(y)) throw new Error(`y is NaN`);\n    if (z === undefined) {\n      return Object.freeze({ x: xOrArray as number, y: y });\n    } else {\n      return Object.freeze({ x: xOrArray as number, y, z })\n    }\n  }\n};\n\n/**\n * Parses a point as a string, in the form 'x,y' or 'x,y,z'.\n * eg '10,15' will be returned as `{ x: 10, y: 15 }`.\n * \n * Throws an error if `str` is not a string.\n * \n * ```js\n * Points.fromString(`10,15`);  // { x:10, y:15 }\n * Points.fromString(`a,10`);   // { x:NaN, y:10 }\n * ```\n * \n * Use {@link Points.isNaN} to check if returned point has NaN for either coordinate.\n * @param str \n */\nexport const fromString = (str: string): Point => {\n  if (typeof str !== `string`) throw new TypeError(`Param 'str' ought to be a string. Got: ${ typeof str }`);\n  const comma = str.indexOf(`,`);\n  const x = Number.parseFloat(str.substring(0, comma));\n  const nextComma = str.indexOf(',', comma + 1);\n  if (nextComma > 0) {\n    // z component\n    const y = Number.parseFloat(str.substring(comma + 1, nextComma - comma + 2));\n    const z = Number.parseFloat(str.substring(nextComma + 1));\n    return { x, y, z };\n  } else {\n    const y = Number.parseFloat(str.substring(comma + 1));\n    return { x, y };\n  }\n}\n\n\n/**\n * Returns an array of points from an array of numbers.\n *\n * Array can be a continuous series of x, y values:\n * ```\n * [1,2,3,4] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n *\n * Or it can be an array of arrays:\n * ```\n * [[1,2], [3,4]] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n * @param coords\n * @returns\n */\nexport const fromNumbers = (\n  ...coords: ReadonlyArray<ReadonlyArray<number>> | ReadonlyArray<number>\n): ReadonlyArray<Point> => {\n  const pts: Array<Point> = [];\n\n  if (Array.isArray(coords[ 0 ])) {\n    // [[x,y],[x,y]...]\n    for (const coord of (coords as Array<Array<number>>)) {\n      if (!(coord.length % 2 === 0)) {\n        throw new Error(`coords array should be even-numbered`);\n      }\n      //eslint-disable-next-line  functional/immutable-data\n      pts.push(Object.freeze({ x: coord[ 0 ], y: coord[ 1 ] }));\n    }\n  } else {\n    // [x,y,x,y,x,y]\n    if (coords.length % 2 !== 0) {\n      throw new Error(`Expected even number of elements: [x,y,x,y...]`);\n    }\n\n    for (let index = 0; index < coords.length; index += 2) {\n      //eslint-disable-next-line  functional/immutable-data\n      pts.push(\n        Object.freeze({ x: coords[ index ] as number, y: coords[ index + 1 ] as number })\n      );\n    }\n  }\n  return pts;\n};\n","import { isPoint } from \"../point/Guard.js\";\nimport type { Line, PolyLine } from \"./LineType.js\";\n\n/**\n * Returns true if `p` is a valid line, containing `a` and `b` Points.\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.isLine(l);\n * ```\n * @param p Value to check\n * @returns True if a valid line.\n */\nexport const isLine = (p: any): p is Line => {\n  if (p === undefined) return false;\n  if ((p as Line).a === undefined) return false;\n  if ((p as Line).b === undefined) return false;\n  if (!isPoint((p as Line).a)) return false;\n  if (!isPoint((p as Line).b)) return false;\n  return true;\n};\n\n/**\n * Returns true if `p` is a {@link PolyLine}, ie. an array of {@link Line}s.\n * Validates all items in array.\n * @param p \n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isPolyLine = (p: any): p is PolyLine => {\n  if (!Array.isArray(p)) return false;\n\n  const valid = !p.some(v => !isLine(v));\n  return valid;\n};\n\n/**\n * Throws an exception if:\n * * line is undefined\n * * a or b parameters are missing\n * \n * Does not validate points\n * @param line \n * @param name \n */\nexport const guard = (line: Line, name = `line`) => {\n  if (line === undefined) throw new Error(`${ name } undefined`);\n  if (line.a === undefined) throw new Error(`${ name }.a undefined. Expected {a:Point, b:Point}. Got: ${ JSON.stringify(line) }`);\n  if (line.b === undefined) throw new Error(`${ name }.b undefined. Expected {a:Point, b:Point} Got: ${ JSON.stringify(line) }`);\n};","import type { Point } from \"../point/PointType.js\";\nimport { isLine } from \"./Guard.js\";\nimport type { Line } from \"./LineType.js\";\nimport { guard as guardPoint } from '../point/Guard.js';\n\n/**\n * Returns [a,b] points from either a line parameter, or two points.\n * It additionally applies the guardPoint function to ensure validity.\n * This supports function overloading.\n * @ignore\n * @param aOrLine \n * @param b \n * @returns \n */\nexport const getPointParameter = (aOrLine: Point | Line, b?: Point): readonly [ Point, Point ] => {\n\n  let a;\n  if (isLine(aOrLine)) {\n    b = aOrLine.b;\n    a = aOrLine.a;\n  } else {\n    a = aOrLine;\n    if (b === undefined) throw new Error(`Since first parameter is not a line, two points are expected. Got a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) }`);\n  }\n  guardPoint(a, `a`);\n  guardPoint(a, `b`);\n\n  return [ a, b ];\n};","import type { Point } from \"../point/PointType.js\";\nimport { getPointParameter } from \"./GetPointsParameter.js\";\nimport { isPolyLine } from \"./Guard.js\";\nimport type { Line, PolyLine } from \"./LineType.js\";\n\n/**\n * Returns the length between two points\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.length(ptA, ptB);\n * ```\n * @param a First point\n * @param b Second point\n * @returns \n */\nexport function length(a: Point, b: Point): number;\n\n/**\n * Returns length of line. If a polyline (array of lines) is provided,\n * it is the sum total that is returned.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.length(a: {x:0, y:0}, b: {x: 100, y:100});\n * Lines.length(lines);\n * ```\n * @param line Line\n */\nexport function length(line: Line | PolyLine): number;\n\n/**\n * Returns length of line, polyline or between two points\n * \n * @param aOrLine Point A, line or polyline (array of lines)\n * @param pointB Point B, if first parameter is a point\n * @returns Length (total accumulated length for arrays)\n */\n//eslint-disable-next-line func-style\nexport function length(aOrLine: Point | Line | PolyLine, pointB?: Point): number {\n  if (isPolyLine(aOrLine)) {\n    const sum = aOrLine.reduce((accumulator, v) => length(v) + accumulator, 0);\n    return sum;\n  }\n  if (aOrLine === undefined) throw new TypeError(`Parameter 'aOrLine' is undefined`);\n  const [ a, b ] = getPointParameter(aOrLine, pointB);\n  const x = b.x - a.x;\n  const y = b.y - a.y;\n  if (a.z !== undefined && b.z !== undefined) {\n    const z = b.z - a.z;\n    return Math.hypot(x, y, z);\n  } else {\n    return Math.hypot(x, y);\n  }\n}\n","import { guard } from \"./Guard.js\";\nimport type { Line } from \"./LineType.js\";\n\n/**\n * Reverses a line.\n * ````js\n * const a = { x: 10, y: 20 };\n * const b = { x: 100, y: 200 };\n * const line = reverse({ a, b });\n * // { a: { x: 100, y: 200 }, b: { x: 10, y: 20 } }\n * ```\n * @param line \n * @returns \n */\nexport function reverse(line: Line): Line {\n  guard(line, `line`);\n  return { a: line.b, b: line.a };\n}","import { throwNumberTest, throwPercentTest } from \"../../util/GuardNumbers.js\";\nimport type { Point } from \"../point/PointType.js\";\nimport type { Line } from \"./LineType.js\";\nimport { getPointParameter } from \"./GetPointsParameter.js\";\nimport { length } from \"./Length.js\";\nimport { reverse } from \"./Reverse.js\";\n/**\n * Calculates a point in-between `a` and `b`.\n * \n * If an interpolation amount below 0 or above 1 is given, _and_\n * `allowOverflow_ is true, a point will be returned that is extended\n * past `line`. This is useful for easing functions which might\n * briefly go past the limits.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Get {x,y} at 50% along line\n * Lines.interpolate(0.5, line);\n * \n * // Get {x,y} at 80% between point A and B\n * Lines.interpolate(0.8, ptA, ptB);\n * ```\n * @param amount Relative position, 0 being at a, 0.5 being halfway, 1 being at b\n * @param a Start\n * @param pointB End\n * @returns Point between a and b\n */\nexport function interpolate(amount: number, a: Point, pointB: Point, allowOverflow?: boolean): Point;\n\n/**\n * Calculates a point in-between `line`'s start and end points.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * \n * // Get {x, y } at 50% along line\n * Lines.interpolate(0.5, line);\n * ```\n * \n * Any additional properties from `b`  are returned on the result as well.\n * @param amount 0..1 \n * @param line Line\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line\n */\nexport function interpolate(amount: number, line: Line, allowOverflow?: boolean): Point;\n\n/**\n * Calculates a point in-between a line's start and end points.\n * \n * @param amount Interpolation amount\n * @param aOrLine Line, or first point\n * @param pointBOrAllowOverflow Second point (if needed) or allowOverflow.\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line.\n * @returns \n */\nexport function interpolate(amount: number, aOrLine: Point | Line, pointBOrAllowOverflow?: Point | boolean, allowOverflow?: boolean): Point {\n\n  if (typeof pointBOrAllowOverflow === `boolean`) {\n    allowOverflow = pointBOrAllowOverflow;\n    pointBOrAllowOverflow = undefined;\n  }\n\n\n  if (!allowOverflow) throwPercentTest(amount, `amount`);\n  else throwNumberTest(amount, ``, `amount`);\n\n  const [ a, b ] = getPointParameter(aOrLine, pointBOrAllowOverflow);\n\n  const d = length(a, b);\n  const d2 = d * (1 - amount);\n\n  // Points are identical, return a copy of b\n  if (d === 0 && d2 === 0) return Object.freeze({ ...b });\n\n  const x = b.x - (d2 * (b.x - a.x) / d);\n  const y = b.y - (d2 * (b.y - a.y) / d);\n\n  return Object.freeze({\n    ...b,\n    x: x,\n    y: y\n  });\n}\n\n/**\n * Returns the point along a line from its start (A)\n * @param line Line\n * @param distance Distance\n * @param fromA If _true_ (default) returns from A. Use _false_ to calculate from end\n * @returns \n */\nexport function pointAtDistance(line: Line, distance: number, fromA = true): Point {\n  if (!fromA) line = reverse(line);\n\n  const dx = line.b.x - line.a.x;\n  const dy = line.b.y - line.a.y;\n  const theta = Math.atan2(dy, dx);\n  const xp = distance * Math.cos(theta);\n  const yp = distance * Math.sin(theta);\n  return { x: xp + line.a.x, y: yp + line.a.y };\n}","import type { Point } from \"./PointType.js\";\nimport { interpolate as lineInterpolate } from '../line/Interpolate.js';\n\n/**\n * Returns a relative point between two points\n * ```js\n * interpolate(0.5, a, b); // Halfway point between a and b\n * ```\n *\n * Alias for Lines.interpolate(amount, a, b);\n *\n * @param amount Relative amount, 0-1\n * @param a\n * @param b\n * @param allowOverflow If true, length of line can be exceeded for `amount` of below 0 and above `1`.\n * @returns {@link Point}\n */\nexport const interpolate = (\n  amount: number,\n  a: Point,\n  b: Point,\n  allowOverflow = false\n): Point => lineInterpolate(amount, a, b, allowOverflow); //({x: (1-amt) * a.x + amt * b.x, y:(1-amt) * a.y + amt * b.y });\n","import { isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\n/**\n * Inverts one or more axis of a point\n * ```js\n * invert({x:10, y:10}); // Yields: {x:-10, y:-10}\n * invert({x:10, y:10}, `x`); // Yields: {x:-10, y:10}\n * ```\n * @param pt Point to invert\n * @param what Which axis. If unspecified, both axies are inverted\n * @returns\n */\nexport const invert = (\n  pt: Point | Point3d,\n  what: `both` | `x` | `y` | `z` = `both`\n): Point => {\n  switch (what) {\n    case `both`: {\n      return isPoint3d(pt) ? Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n        y: pt.y * -1,\n        z: pt.z * -1,\n      }) : Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n        y: pt.y * -1,\n      });\n    }\n    case `x`: {\n      return Object.freeze({\n        ...pt,\n        x: pt.x * -1,\n      });\n    }\n    case `y`: {\n      return Object.freeze({\n        ...pt,\n        y: pt.y * -1,\n      });\n    }\n    case `z`: {\n      if (isPoint3d(pt)) {\n        return Object.freeze({\n          ...pt,\n          z: pt.z * -1,\n        });\n      } else throw new Error(`pt parameter is missing z`);\n    }\n    default: {\n      throw new Error(`Unknown what parameter. Expecting 'both', 'x' or 'y'`);\n    }\n  }\n};","import { getTwoPointParameters } from \"./GetPointParameter.js\";\nimport { guard, isPoint3d } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\nimport type { Writeable } from \"../../TsUtil.js\";\n\nexport function multiply(a: Point, b: Point): Point;\nexport function multiply(a: Point3d, b: Point3d): Point3d;\nexport function multiply(a: Point, x: number, y: number): Point;\nexport function multiply(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function multiply(ax: number, ay: number, bx: number, by: number): Point;\nexport function multiply(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points multiply (a/b).\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when multiplying a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * multiply(ptA, ptB);\n * multiply(x1, y1, x2, y2);\n * multiply(ptA, x2, y2);\n * ```\n */\nexport function multiply(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  let pt: Writeable<Point> = {\n    x: ptA.x * ptB.x,\n    y: ptA.y * ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) * (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n\n/**\n * Multiplies all components by `v`.\n * Existing properties of `pt` are maintained.\n *\n * ```js\n * multiplyScalar({ x:2, y:4 }, 2);\n * // Yields: { x:4, y:8 }\n * ```\n * @param pt Point\n * @param v Value to multiply by\n * @returns\n */\nexport const multiplyScalar = (\n  pt: Point | Point3d,\n  v: number\n): Point | Point3d => {\n  return isPoint3d(pt) ? Object.freeze({\n    ...pt,\n    x: pt.x * v,\n    y: pt.y * v,\n    z: pt.z * v,\n  }) : Object.freeze({\n    ...pt,\n    x: pt.x * v,\n    y: pt.y * v,\n  });\n};\n\n","import { distance } from \"./Distance.js\";\nimport { multiply } from \"./Multiply.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Clamps the magnitude of a point.\n * This is useful when using a Point as a vector, to limit forces.\n * @param pt\n * @param max Maximum magnitude (1 by default)\n * @param min Minimum magnitude (0 by default)\n * @returns\n */\nexport const clampMagnitude = (pt: Point, max = 1, min = 0): Point => {\n  const length = distance(pt);\n  let ratio = 1;\n  if (length > max) {\n    ratio = max / length;\n  } else if (length < min) {\n    ratio = min / length;\n  }\n  return ratio === 1 ? pt : multiply(pt, ratio, ratio);\n};","import { findMinimum } from \"./FindMinimum.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Returns the left-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x <= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport const leftmost = (...points: ReadonlyArray<Point>): Point =>\n  findMinimum((a, b) => (a.x <= b.x ? a : b), ...points);\n\n/**\n * Returns the right-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x >= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport const rightmost = (...points: ReadonlyArray<Point>): Point =>\n  findMinimum((a, b) => (a.x >= b.x ? a : b), ...points);\n","import { Empty } from \"./Empty.js\";\nimport { getPointParameter } from \"./GetPointParameter.js\";\nimport { isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\nconst length = (ptOrX: Point | number, y?: number): number => {\n  if (isPoint(ptOrX)) {\n    y = ptOrX.y;\n    ptOrX = ptOrX.x;\n  }\n  if (y === undefined) throw new Error(`Expected y`);\n  return Math.hypot(ptOrX, y);\n};\n\n\n\n/**\n * Normalise point as a unit vector.\n *\n * ```js\n * normalise({x:10, y:20});\n * normalise(10, 20);\n * ```\n * @param ptOrX Point, or x value\n * @param y y value if first param is x\n * @returns\n */\nexport const normalise = (ptOrX: Point | number, y?: number): Point => {\n  const pt = getPointParameter(ptOrX, y);\n  const l = length(pt);\n  if (l === 0) return Empty;\n  return Object.freeze({\n    ...pt,\n    x: pt.x / l,\n    y: pt.y / l,\n  });\n};","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport type { Rect } from \"../rect/RectTypes.js\";\nimport { isRect } from \"../rect/Guard.js\";\nimport { isPoint } from \"./Guard.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Normalises a point by a given width and height\n * @param point Point\n * @param width Width\n * @param height Height\n */\nexport function normaliseByRect(\n  point: Point,\n  width: number,\n  height: number\n): Point;\n\n/**\n * Normalises a point by a given rect's width and height\n * @param pt \n * @param rect \n */\nexport function normaliseByRect(pt: Point, rect: Rect): Point;\n\n/**\n * Normalises x,y by width and height so it is on a 0..1 scale\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport function normaliseByRect(\n  x: number,\n  y: number,\n  width: number,\n  height: number\n): Point;\n\n/**\n * Normalises a point so it is on a 0..1 scale\n * @param a Point, or x\n * @param b y coord or width\n * @param c height or width\n * @param d height\n * @returns Point\n */\nexport function normaliseByRect(\n  a: Point | number,\n  b: number | Rect,\n  c?: number,\n  d?: number\n): Point {\n  //  Unit tested\n  if (isPoint(a)) {\n    if (typeof b === `number` && c !== undefined) {\n      throwNumberTest(b, `positive`, `width`);\n      throwNumberTest(c, `positive`, `height`);\n    } else {\n      if (!isRect(b)) {\n        throw new Error(`Expected second parameter to be a rect`);\n      }\n      c = b.height;\n      b = b.width;\n    }\n    return Object.freeze({\n      x: a.x / b,\n      y: a.y / c,\n    });\n  } else {\n    throwNumberTest(a, `positive`, `x`);\n    if (typeof b !== `number`) {\n      throw new TypeError(`Expecting second parameter to be a number (width)`);\n    }\n    if (typeof c !== `number`) {\n      throw new TypeError(`Expecting third parameter to be a number (height)`);\n    }\n\n    throwNumberTest(b, `positive`, `y`);\n    throwNumberTest(c, `positive`, `width`);\n    if (d === undefined) throw new Error(`Expected height parameter`);\n    throwNumberTest(d, `positive`, `height`);\n    return Object.freeze({\n      x: a / c,\n      y: b / d,\n    });\n  }\n}","import type { Point } from \"./PointType.js\";\n\n/**\n * Runs a sequential series of functions on `pt`. The output from one feeding into the next.\n * ```js\n * const p = Points.pipelineApply(somePoint, Points.normalise, Points.invert);\n * ```\n *\n * If you want to make a reusable pipeline of functions, consider {@link pipeline} instead.\n * @param point\n * @param pipelineFns\n * @returns\n */\nexport const pipelineApply = (\n  point: Point,\n  ...pipelineFns: ReadonlyArray<(pt: Point) => Point>\n): Point => pipeline(...pipelineFns)(point); // pipeline.reduce((prev, curr) => curr(prev), pt);\n\n/**\n * Returns a pipeline function that takes a point to be transformed through a series of functions\n * ```js\n * // Create pipeline\n * const p = Points.pipeline(Points.normalise, Points.invert);\n *\n * // Now run it on `somePoint`.\n * // First we normalised, and then invert\n * const changedPoint = p(somePoint);\n * ```\n *\n * If you don't want to create a pipeline, use {@link pipelineApply}.\n * @param pipeline Pipeline of functions\n * @returns\n */\nexport const pipeline =\n  (...pipeline: ReadonlyArray<(pt: Point) => Point>) =>\n    (pt: Point) =>\n      // eslint-disable-next-line unicorn/no-array-reduce\n      pipeline.reduce((previous, current) => current(previous), pt);\n","\nimport { isPoint3d } from \"./Guard.js\";\nimport type { Point3d, Point } from \"./PointType.js\";\nimport { subtract } from \"./Subtract.js\";\n\n/**\n * Computes the progress between two waypoints, given `position`.\n * \n * [Source](https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09)\n * @param position Current position\n * @param waypointA Start\n * @param waypointB End\n * @returns \n */\nexport const progressBetween = (\n  position: Point | Point3d,\n  waypointA: Point | Point3d,\n  waypointB: Point | Point3d\n) => {\n  // Via: https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09\n  // from -> current\n  const a = subtract(position, waypointA);\n\n  // from -> to\n  const b = subtract(waypointB, waypointA);\n\n  return isPoint3d(a) && isPoint3d(b) ? (\n    (a.x * b.x + a.y * b.y + a.z * b.z) / (b.x * b.x + b.y * b.y + b.z * b.z)\n  ) : (a.x * b.x + a.y * b.y) / (b.x * b.x + b.y * b.y);\n};","import type { Point } from \"./PointType.js\";\n\n/**\n * Project `origin` by `distance` and `angle` (radians).\n *\n * To figure out rotation, imagine a horizontal line running through `origin`.\n * * Rotation = 0 deg puts the point on the right of origin, on same y-axis\n * * Rotation = 90 deg/3:00 puts the point below origin, on the same x-axis\n * * Rotation = 180 deg/6:00 puts the point on the left of origin on the same y-axis\n * * Rotation = 270 deg/12:00 puts the point above the origin, on the same x-axis\n *\n * ```js\n * // Yields a point 100 units away from 10,20 with 10 degrees rotation (ie slightly down)\n * const a = Points.project({x:10, y:20}, 100, degreeToRadian(10));\n * ```\n * @param origin\n * @param distance\n * @param angle\n * @returns\n */\nexport const project = (origin: Point, distance: number, angle: number) => {\n  const x = Math.cos(angle) * distance + origin.x;\n  const y = Math.sin(angle) * distance + origin.y;\n  return { x, y };\n};","import { throwIntegerTest, throwNumberTest } from \"../util/GuardNumbers.js\";\n\n/**\n * Rounds `v` by `every`. Middle values are rounded up by default.\n *\n * ```js\n * quantiseEvery(11, 10);  // 10\n * quantiseEvery(25, 10);  // 30\n * quantiseEvery(0, 10);   // 0\n * quantiseEvery(4, 10);   // 0\n * quantiseEvery(100, 10); // 100\n * ```\n * \n * Also works with decimals\n * ```js\n * quantiseEvery(1.123, 0.1); // 1.1\n * quantiseEvery(1.21, 0.1);  // 1.2\n * ```\n *\n * @param v Value to quantise\n * @param every Number to quantise to\n * @param middleRoundsUp If _true_ (default), the exact middle rounds up to next step.\n * @returns\n */\nexport const quantiseEvery = (\n  v: number,\n  every: number,\n  middleRoundsUp = true\n) => {\n\n  const everyString = every.toString();\n  const decimal = everyString.indexOf(`.`);\n  let multiplier = 1;\n  if (decimal >= 0) {\n    const d = everyString.substring(decimal + 1).length;\n    multiplier = 10 * d;\n    every = Math.floor(multiplier * every);\n    v = v * multiplier;\n  }\n  throwNumberTest(v, ``, `v`);\n  throwIntegerTest(every, ``, `every`);\n\n  let div = v / every;\n  const divModule = div % 1;\n  div = Math.floor(div);\n  if ((divModule === 0.5 && middleRoundsUp) || divModule > 0.5) div++;\n  const vv = (every * div) / multiplier;\n  return vv;\n};","import { quantiseEvery as quantiseEveryNumber } from '../../numbers/Quantise.js';\nimport { guard, isPoint3d } from './Guard.js';\nimport type { Point, Point3d } from './PointType.js';\n\nexport function quantiseEvery(pt: Point3d, snap: Point3d, middleRoundsUp?: boolean): Point3d;\nexport function quantiseEvery(pt: Point, snap: Point, middleRoundsUp?: boolean): Point;\n\n/**\n * Quantises a point.\n * @param pt \n * @param snap \n * @param middleRoundsUp \n * @returns \n */\nexport function quantiseEvery(pt: Point, snap: Point, middleRoundsUp = true): Point {\n  guard(pt, `pt`);\n  guard(snap, `snap`);\n  if (isPoint3d(pt)) {\n    if (!isPoint3d(snap)) throw new TypeError(`Param 'snap' is missing 'z' field`);\n    return Object.freeze({\n      x: quantiseEveryNumber(pt.x, snap.x, middleRoundsUp),\n      y: quantiseEveryNumber(pt.y, snap.y, middleRoundsUp),\n      z: quantiseEveryNumber(pt.z, snap.z, middleRoundsUp)\n    });\n  }\n\n  return Object.freeze({\n    x: quantiseEveryNumber(pt.x, snap.x, middleRoundsUp),\n    y: quantiseEveryNumber(pt.y, snap.y, middleRoundsUp),\n  });\n}","import { type RandomSource, defaultRandom } from '../../random/Types.js';\nimport type { Point, Point3d } from './PointType.js';\n\n/**\n * Returns a random 2D point on a 0..1 scale.\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * import { weightedSource } from \"https://unpkg.com/ixfx/dist/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random = (rando?: RandomSource): Point => {\n  if (rando === undefined) rando = defaultRandom;\n\n  return Object.freeze({\n    x: rando(),\n    y: rando(),\n  });\n};\n\n/**\n * Returns a random 3D point on a 0..1 scale.\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * import { weightedSource } from \"https://unpkg.com/ixfx/dist/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random3d = (rando?: RandomSource): Point3d => {\n  if (rando === undefined) rando = defaultRandom;\n\n  return Object.freeze({\n    x: rando(),\n    y: rando(),\n    z: rando()\n  });\n};","import type { Point } from \"./PointType.js\";\n\n/**\n * Reduces over points, treating _x_ and _y_ separately.\n *\n * ```\n * // Sum x and y values\n * const total = Points.reduce(points, (p, acc) => {\n *  return {x: p.x + acc.x, y: p.y + acc.y}\n * });\n * ```\n * @param pts Points to reduce\n * @param fn Reducer\n * @param initial Initial value, uses `{ x:0, y:0 }` by default\n * @returns\n */\nexport const reduce = (\n  pts: ReadonlyArray<Point>,\n  fn: (p: Point, accumulated: Point) => Point,\n  initial?: Point\n): Point => {\n  if (initial === undefined) initial = { x: 0, y: 0 }\n  let accumulator = initial;\n  for (const p of pts) {\n    accumulator = fn(p, accumulator);\n  };\n  return accumulator;\n};","import { angleRadian } from \"./Angle.js\";\nimport { centroid } from \"./Centroid.js\";\nimport { distance } from \"./Distance.js\";\nimport { getPointParameter } from \"./GetPointParameter.js\";\nimport type { PointRelation } from \"./PointRelationTypes.js\";\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Tracks the relation between two points.\n * \n * 1. Call `Points.relation` with the initial reference point\n * 2. You get back a function\n * 3. Call the function with a new point to compute relational information.\n * \n * It computes angle, average, centroid, distance and speed.\n * \n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Reference point: 50,50\n * const t = Points.relation({x:50,y:50}); // t is a function\n *\n * // Invoke the returned function with a point\n * const relation = t({ x:0, y:0 }); // Juicy relational data\n * ```\n * \n * Or with destructuring:\n * \n * ```js\n * const { angle, distanceFromStart, distanceFromLast, average, centroid, speed } = t({ x:0,y:0 });\n * ```\n *\n * x & y coordinates can also be used as parameters:\n * ```js\n * const t = Points.relation(50, 50);\n * const result = t(0, 0);\n * // result.speed, result.angle ...\n * ```\n *\n * Note that intermediate values are not stored. It keeps the initial\n * and most-recent point. If you want to compute something over a set\n * of prior points, you may want to use {@link Trackers.points}\n * @param a Initial point, or x value\n * @param b y value, if first option is a number.\n * @returns\n */\nexport const relation = (a: Point | number, b?: number): PointRelation => {\n  const start = getPointParameter(a, b);\n  let totalX = 0;\n  let totalY = 0;\n  let count = 0;\n  let lastUpdate = performance.now();\n  let lastPoint = start;\n  const update = (aa: Point | number, bb?: number) => {\n    const p = getPointParameter(aa, bb);\n    totalX += p.x;\n    totalY += p.y;\n    count++;\n\n    const distanceFromStart = distance(p, start);\n    const distanceFromLast = distance(p, lastPoint);\n\n    // Track speed\n    const now = performance.now();\n    const speed = distanceFromLast / (now - lastUpdate);\n    lastUpdate = now;\n\n    lastPoint = p;\n\n    return Object.freeze({\n      angle: angleRadian(p, start),\n      distanceFromStart,\n      distanceFromLast,\n      speed,\n      centroid: centroid(p, start),\n      average: {\n        x: totalX / count,\n        y: totalY / count,\n      },\n    });\n  };\n\n  return update;\n};\n\n","// import { degreeToRadian, radianToDegree } from '../Angles.js';\n\n// import type { Point } from '../point/PointType.js';\n// import { subtract } from '../point/Subtract.js';\n// import { Empty } from '../point/Empty.js';\n// import { isPoint, guard as PointGuard } from '../point/Guard.js';\n// import type { Coord } from './Types.js';\n\n//const EmptyCartesian = Object.freeze({ x: 0, y: 0 });\n\nexport type * from './Types.js';\nexport * from './Angles.js';\nexport * from './Conversions.js';\nexport * from './Guard.js';\nexport * from './Math.js';\nexport * as Ray from './Ray.js';\nexport * from './Spiral.js'\n\n\n","import type { Coord } from \"./Types.js\";\n\n/**\n * Returns true if `p` seems to be a {@link Polar.Coord} (ie has both distance & angleRadian fields)\n * @param p\n * @returns True if `p` seems to be a PolarCoord\n */\nexport const isPolarCoord = (p: unknown): p is Coord => {\n  if ((p as Coord).distance === undefined) return false;\n  if ((p as Coord).angleRadian === undefined) return false;\n  return true;\n};\n\n/**\n * Throws an error if Coord is invalid\n * @param p\n * @param name\n */\nexport const guard = (p: Coord, name = `Point`) => {\n  if (p === undefined) {\n    throw new Error(\n      `'${ name }' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p === null) {\n    throw new Error(\n      `'${ name }' is null. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.angleRadian === undefined) {\n    throw new Error(\n      `'${ name }.angleRadian' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (p.distance === undefined) {\n    throw new Error(\n      `'${ name }.distance' is undefined. Expected {distance, angleRadian} got ${ JSON.stringify(\n        p\n      ) }`\n    );\n  }\n  if (typeof p.angleRadian !== `number`) {\n    throw new TypeError(\n\n      `'${ name }.angleRadian' must be a number. Got ${ p.angleRadian }`\n    );\n  }\n  if (typeof p.distance !== `number`) {\n\n    throw new TypeError(`'${ name }.distance' must be a number. Got ${ p.distance }`);\n  }\n\n  if (p.angleRadian === null) throw new Error(`'${ name }.angleRadian' is null`);\n  if (p.distance === null) throw new Error(`'${ name }.distance' is null`);\n\n  if (Number.isNaN(p.angleRadian)) {\n    throw new TypeError(`'${ name }.angleRadian' is NaN`);\n  }\n  if (Number.isNaN(p.distance)) throw new Error(`'${ name }.distance' is NaN`);\n};","\nexport * from './Compare.js';\nexport * as Correlate from './Correlate.js';\nexport * from './CloneFromFields.js';\nexport * from './KeysToNumbers.js';\nexport * from './MapObject.js';\nexport * from './Filters.js';\n\n/**\n * Means of accessing, creating and comparing objects\n * based on 'paths'. This is useful for serialisation.\n * \n */\nexport * as Pathed from './Pathed.js'\nexport * as Pool from './Pool.js';\nexport * as Process from './Process.js';\nexport * from './Pull.js';\nexport * from './Resolve.js';\nexport * from './ResolveFields.js';\nexport * from './Types.js';\nexport * from './Util.js';\nexport * from './RecordMerge.js';\nexport const piPi = Math.PI * 2;\n\n/**\n * These array functions do not change the input data, unless noted.\n * \n * Import example:\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n * ```\n * \n * For arrays of numbers:\n * * {@link minMaxAvg}: Find smallest, largest and average\n * * See also {@link Numbers} module for working with numbers in general.\n *\n * Randomisation\n * * {@link randomIndex}: Return a random array index\n * * {@link randomElement}: Return a random value\n * * {@link randomPluck}: Remove a random element from an array, returning it and the new array\n * * {@link shuffle}: Returns a randomly-sorted copy of arra\n *\n * Comparing\n * * {@link contains}: compare overlap of arrays\n * * {@link isEqual}: _true_ if two arrays contain same values at same locations\n * * {@link unique}: Returns values from two arrays, without duplicates.\n * \n * Iterating\n * * {@link pairwise}: loop in sets of two\n * \n * Finding/accessing\n * * {@link cycle}: every time function is called, the next item from array is returned\n * * {@link filterBetween}: Same as `Array.filter` but only looks within a specified index range\n * * {@link filterAB}: Like array.filter, but returns two arrays. One containing values that the predicate gives _true_, another for _false.\n * * {@link sample}: Returns a new array with a random sampling of input\n*  * {@link until}: Returns items from input until predicate returns _true_\n* \n* Sort\n* * {@link sortByNumericProperty}: Sort objects by a given numeric field\n* * {@link sortByProperty}: Sort objects by a given field\n* \n* Duplicates\n* * {@link containsDuplicateValues}: _true_ if array has at least one value is repeated\n * * {@link containsDuplicateInstances}: _true_ if array has at least one object appears twice\n * * {@link isContentsTheSame}: _true_ if all values in array are the same\n * \n * Changing the shape\n * * {@link chunks}: Chunk into sub-arrays\n * * {@link ensureLength}: Returns a copy of array with designated length, either padding it out or truncating as necessary\n * * {@link groupBy}: Groups data into a new Map\n * * {@link flatten}\n * * {@link filterBetween}: Like array.filter, but only checks within given range\n * * {@link interleave}: Flattens several arrays into one, interleaving their values.\n * * {@link remove}: Remove an item by index\n * * {@link pairwiseReduce}: Reducer that operates in pairwise fashion\n * * {@link mergeByKey}+: Merges two arrays left-to-right, using a reconcile function\n * * {@link without}: Returns an array with specified value omitted\n * * {@link zip}: Groups together elements from several arrays based on their index\n */\nexport * as Arrays from './arrays/index.js';\n\n/**\n * Maps associate keys with values. Several helper functions are provided\n * for working with the standard JS Map class.\n *\n * Import example\n * ```js\n * import { Maps } from 'https://unpkg.com/ixfx/dist/data.js';\n * ```\n * \n * Adding\n * * {@link addKeepingExisting} Adds items to a map only if their key does not exist already\n * * {@link addObject}: Adds an object, assuming each top-level property of an object is a key\n * * {@link getOrGenerate}: Solves a common scenario of wanting a value by a particular key, or generating it if it doesn't exist\n * \n * Deleting\n * * {@link deleteByValue}\n * \n * Finding/Iterating\n * * {@link filter}: Yield values that return _true_ for predicate\n * * {@link find}: Finds the first value that matches a predicate, or _undefined_ if nothing found\n * * {@link hasAnyValue}: Searches through all keys, returning true if any occurence of _value_ was found\n * * {@link hasKeyValue}: _true_ if value is stored under a key\n * * {@link firstEntryByPredicate}: Returns first entry which matches predicate\n * * {@link firstEntryByValue}: Returns first entry where value matches\n * * {@link getClosestIntegerKey}: Assuming numeric keys, find the closest to a target value\n * * {@link getFromKeys}: Given an iterable of keys, returns the first value where the key is present\n * * {@link some}: _true_ if predicate is true for any value in map\n * \n * Transforming values\n * * {@link mapToArray}: Applies a function to convert a map's values to an array\n * * {@link mapToObjectTransform}: Converts a map to a plain object, but applying a function to values\n * * {@link transformMap}: Like `Array.map`, but for Maps. Useful for generating a map as a transform of an input map.\n * \n * Creating\n * * {@link fromIterable}: Generates a map from an interable\n * * {@link fromObject}\n * * {@link zipKeyValue}: Given an array of keys and values, combines them together into a map\n * \n * To some other data\n * * {@link toArray}: Returns the values of the map as an array\n * * {@link toObject}: Coverts a Map to a plain object, useful for JSON serialising.\n * \n * Etc\n * * {@link sortByValue}: Returns a sorted set of entries\n * * {@link sortByValueProperty}: Returns a sorted set of entries\n * \n * See also ixfx's Collections module for custom map implementations.\n */\nexport * as Maps from './maps/index.js'\n","/**\n * Returns the similarity of `a` and `b` to each other,\n * where higher similarity should be a higher number.\n * @param a\n * @param b\n */\nexport type Similarity<V> = (a: V, b: V) => number;\n\ntype Scored = {\n  readonly score: number;\n};\n\nconst orderScore = (a: Scored, b: Scored) => {\n  if (a.score > b.score) return -1;\n  else if (a.score < b.score) return 1;\n  return 0;\n};\n\n/**\n * Options for alignmnent\n */\nexport type AlignOpts = {\n  /**\n   * If the similarity score is above this threshold,\n   * consider them the same\n   */\n  readonly matchThreshold?: number;\n  /**\n   * If true, additional console messages are printed during\n   * execution.\n   */\n  readonly debug?: boolean;\n};\n\n/**\n * Some data with an id property.\n */\nexport type DataWithId<V> = V & {\n  readonly id: string;\n};\n\n/**\n * Attempts to align prior data with new data, based on a provided similarity function.\n *\n * See also `alignById` for a version which encloses parameters.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const newData = [\n *  { id:`2`, x:101, y:200 }\n * ]\n * const aligned = Correlate.align(fn, lastdata, newData, opts);\n *\n * // Result:\n * [\n *  { id:`1`, x:101, y:200 }\n * ]\n * ```\n * @param similarityFn Function to compute similarity\n * @param lastData Old data\n * @param newData New data\n * @param options Options\n * @returns\n */\n//eslint-disable-next-line functional/immutable-data\nexport const align = <V>(\n  similarityFn: Similarity<V>,\n  lastData: readonly DataWithId<V>[] | undefined,\n  newData: readonly DataWithId<V>[],\n  options: AlignOpts = {}\n): readonly DataWithId<V>[] => {\n  const matchThreshold = options.matchThreshold ?? 0;\n  const debug = options.debug ?? false;\n  const results = new Map();\n  const newThings: DataWithId<V>[] = [];\n\n  const lastMap = new Map();\n  lastData?.forEach((d, index) => {\n    if (d === undefined) {\n      throw new Error(`'lastData' contains undefined (index: ${ index })`);\n    }\n    lastMap.set(d.id, d);\n  });\n\n  //eslint-disable-next-line functional/no-let\n  for (let i = 0; i < newData.length; i++) {\n    const newD = newData[ i ];\n\n    if (!lastData || lastData.length === 0) {\n      // No last data to compare to\n      if (debug) console.debug(`Correlate.align() new id: ${ newD.id }`);\n\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n\n    // Which of the old data does the new data match up to best?\n    const scoredLastValues = Array.from(lastMap.values()).map((last) => ({\n      id: last.id,\n      score: last === null ? -1 : similarityFn(last, newD),\n      last,\n    }));\n\n    if (scoredLastValues.length === 0) {\n      if (debug) {\n        console.debug(`Correlate.align() no valid last values id: ${ newD.id }`);\n      }\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n    //eslint-disable-next-line functional/immutable-data\n    scoredLastValues.sort(orderScore);\n\n    // Top-ranked match is pretty low, must be something new\n    const top = scoredLastValues[ 0 ];\n    if (top.score < matchThreshold) {\n      if (debug) {\n        console.debug(\n          `Correlate.align() new item does not reach threshold. Top score: ${ top.score } id: ${ newD.id }`\n        );\n      }\n      //eslint-disable-next-line functional/immutable-data\n      newThings.push(newD);\n      continue;\n    }\n\n    // TODO: If there are close options to pick, need a pluggable\n    // function to determine which is the winner.\n\n    //    console.log(`updating prior ${top.score}. top: ${top.id} newD: ${newD.id}`);\n\n    // The new item is considered the same as top ranked\n    if (debug && top.id !== newD.id) {\n      console.log(\n        `Correlate.align() Remapped ${ newD.id } -> ${ top.id } (score: ${ top.score })`\n      );\n    }\n    //eslint-disable-next-line functional/immutable-data\n    results.set(top.id, { ...newD, id: top.id });\n\n    // Remove that old one from the list\n    //eslint-disable-next-line functional/immutable-data\n    lastMap.delete(top.id);\n  }\n\n  //eslint-disable-next-line functional/immutable-data\n  newThings.forEach((t) => results.set(t.id, t));\n  return Array.from(results.values());\n};\n\n/**\n * Returns a function that attempts to align a series of data by its id.\n * See also {@link align} for a version with no internal storage.\n *\n * ```js\n * // Compare data based on x,y distance\n * const fn = (a, b) => {\n *  return 1-Points.distance(a, b);\n * }\n * const aligner = Correlate.alignById(fn, opts);\n *\n * const lastData = [\n *  { id:`1`, x:100, y:200 }\n *  ...\n * ]\n * const aligned = aligner(lastData);\n *\n * ```\n * @param fn Function to compute similarity\n * @param options Options\n * @returns\n */\nexport const alignById = <V>(fn: Similarity<V>, options: AlignOpts = {}) => {\n  let lastData: readonly DataWithId<V>[] = [];\n\n  const compute = (newData: DataWithId<V>[]) => {\n    lastData = align(fn, lastData, newData, options);\n    return [ ...lastData ];\n  };\n  return compute;\n};\n","import { isPlainObjectOrPrimitive } from \"../util/GuardObject.js\";\n\nexport const cloneFromFields = <T extends object>(source: T) => {\n  const entries: Array<[ key: string, value: any ]> = [];\n  for (const field in source) {\n    const value = (source)[ field ];\n    if (isPlainObjectOrPrimitive(value as unknown)) {\n      entries.push([ field, value ]);\n    }\n  }\n  return Object.fromEntries(entries) as T;\n}","/**\n * Returns a copy of `object` with integer numbers as keys instead of whatever it has.\n * ```js\n * keysToNumbers({ '1': true }); // Yields: { 1: true }\n * ```\n * \n * The `onInvalidKey` sets how to handle keys that cannot be converted to integers.\n * * 'throw' (default): throws an exception\n * * 'ignore': that key & value is ignored\n * * 'keep': uses the string key instead\n * \n * \n * ```js\n * keysToNumber({ hello: 'there' }, `ignore`); // Yields: {  }\n * keysToNumber({ hello: 'there' }, `throw`);  // Exception\n * keysToNumber({ hello: 'there' }, `keep`);   // Yields: { hello: 'there' }\n * ```\n * \n * Floating-point numbers will be converted to integer by rounding.\n * ```js\n * keysToNumbers({ '2.4': 'hello' }); // Yields: { 2: 'hello' }\n * ```\n * @param object \n * @param onInvalidKey \n * @returns \n */\nexport const keysToNumbers = <T>(object: Record<any, T>, onInvalidKey: `throw` | `ignore` | `keep` = `throw`): Record<number, T> => {\n  const returnObject: Record<number, T> = {};\n  for (const entry of Object.entries(object)) {\n    const asNumber = Number.parseInt(entry[ 0 ]);\n    if (Number.isNaN(asNumber)) {\n      switch (onInvalidKey) {\n        case `throw`: {\n          throw new TypeError(`Cannot convert key '${ entry[ 0 ] }' to an integer`);\n        }\n        case `ignore`: {\n          continue;\n        }\n        case `keep`: {\n          (returnObject as any)[ entry[ 0 ] ] = entry[ 1 ];\n          continue;\n        }\n        default: {\n          throw new Error(`Param 'onInvalidKey' should be: 'throw', 'ignore' or 'keep'.`);\n        }\n      }\n    }\n    returnObject[ asNumber ] = entry[ 1 ];\n  }\n  return returnObject;\n}\n","import type { RemapObjectPropertyType } from \"../TsUtil.js\";\n\n/**\n * Maps the top-level properties of an object through a map function.\n * That is, run each of the values of an object through a function,\n * setting the result onto the same key structure as original.\n * \n * It is NOT recursive.\n *\n * The mapping function gets a single args object, consisting of `{ value, field, index }`,\n * where 'value' is the value of the field, 'field' the name, and 'index' a numeric count.\n * @example Double the value of all fields\n * ```js\n * const rect = { width: 100, height: 250 };\n * const doubled = mapObjectShallow(rect, args => {\n *  return args.value*2;\n * });\n * // Yields: { width: 200, height: 500 }\n * ```\n *\n * Since the map callback gets the name of the property, it can do context-dependent things.\n * ```js\n * const rect = { width: 100, height: 250, colour: 'red' }\n * const doubled = mapObjectShallow(rect, args => {\n *  if (args.field === 'width') return args.value*3;\n *  else if (typeof args.value === 'number') return args.value*2;\n *  return args.value;\n * });\n * // Yields: { width: 300, height: 500, colour: 'red' }\n * ```\n * In addition to bulk processing, it allows remapping of property types.\n *\n * In terms of type-safety, the mapped properties are assumed to have the\n * same type.\n *\n * ```js\n * const o = {\n *  x: 10,\n *  y: 20,\n *  width: 200,\n *  height: 200\n * }\n *\n * // Make each property use an averager instead\n * const oAvg = mapObjectShallow(o, args => {\n *  return movingAverage(10);\n * });\n *\n * // Instead of { x:number, y:number... }, we now have { x:movingAverage(), y:movingAverage()... }\n * // Add a value to the averager\n * oAvg.x.add(20);\n * ```\n */\nexport const mapObjectShallow = <\n  TSource extends Record<string, any>,\n  TFieldValue,\n>(\n  // eslint-disable-next-line indent\n  object: TSource,\n  // eslint-disable-next-line indent\n  mapFunction: (args: MapObjectArgs) => TFieldValue\n  // eslint-disable-next-line indent\n): RemapObjectPropertyType<TSource, TFieldValue> => {\n  type MapResult = [ field: string, value: TFieldValue ];\n  const entries = Object.entries(object);\n  const mapped = entries.map(([ sourceField, sourceFieldValue ], index) => [\n    sourceField,\n    mapFunction({ value: sourceFieldValue, field: sourceField, index, path: sourceField }),\n  ]) as Array<MapResult>;\n  // @ts-expect-error\n  return Object.fromEntries(mapped);\n};\n\nexport type MapObjectArgs = {\n  field: string\n  path: string\n  value: any\n  index: number\n}\n\n/**\n * Maps the contents of `data` using `mapper` as a structured set of map functions.\n * ```js\n * const a = {\n *  person: {\n *    size: 20\n *  }\n *  hello: `there`\n * }\n * mapObjectByObject(a, {\n *  person: {\n *    size: (value, context) => {\n *      return value * 2\n *    }\n *  }\n * });\n * // Yields: { person: { size: 40 }, hello: `there` }\n * ```\n * @param data \n * @param mapper \n * @returns \n */\nexport function mapObjectByObject(data: any, mapper: Record<string, (value: any, context: any) => any>) {\n  const entries = Object.entries(data);\n  for (let i = 0; i < entries.length; i++) {\n    const e = entries[ i ];\n    if (e[ 0 ] in mapper) {\n      const m = mapper[ e[ 0 ] ];\n      e[ 1 ] = (typeof m === `object`) ?\n        mapObjectByObject(e[ 1 ], m) :\n        m(e[ 1 ], data);\n    }\n  }\n  return Object.fromEntries(entries);\n}","\n/**\n * Returns `v` if `predicate` returns _true_,\n * alternatively returning `skipValue`.\n * \n * ```js\n * // Return true if value is less than 10\n * const p = v => v < 10;\n * \n * filterValue(5, p, 0);   // 5\n * filterValue(20, p, 0);  // 0\n * ```\n * @param v Value to test\n * @param predicate Predicate\n * @param skipValue Value to return if predicate returns false\n * @returns Input value if predicate is _true_, or `skipValue` if not.\n */\nexport const filterValue = <V>(v: V, predicate: (v: V) => boolean, skipValue: V | undefined): V | undefined => {\n  if (predicate(v)) return v;\n  return skipValue;\n};\n","import { SimpleEventEmitter } from '../Events.js';\nimport * as Debug from '../debug/index.js';\n/**\n * Policy for when the pool is fully used\n */\nexport type FullPolicy = `error` | `evictOldestUser`;\n\n/**\n * Pool options\n */\nexport type Opts<V> = {\n  /**\n   * Maximum number of resources for this pool\n   */\n  readonly capacity?: number;\n  /**\n   * If above 0, users will be removed if there is no activity after this interval.\n   * Activity is marked whenever `use` us called with that user key.\n   * Default: disabled\n   */\n  readonly userExpireAfterMs?: number;\n  /**\n   * If above 0, resources with no users will be automatically removed after this interval.\n   * Default: disabled\n   */\n  readonly resourcesWithoutUserExpireAfterMs?: number;\n  /**\n   * Maximum number of users per resource. Defaults to 1\n   */\n  readonly capacityPerResource?: number;\n  /**\n   * What to do if pool is full and a new resource allocation is requested.\n   * Default is `error`, throwing an error when pool is full.\n   */\n  readonly fullPolicy?: FullPolicy;\n  /**\n   * If true, additional logging will trace activity of pool.\n   * Default: false\n   */\n  readonly debug?: boolean;\n  /**\n   * If specified, this function will generate new resources as needed.\n   */\n  readonly generate?: () => V;\n  /**\n   * If specified, this function will be called when a resource is disposed\n   */\n  readonly free?: (v: V) => void;\n};\n\n/**\n * Function that initialises a pool item\n */\n//export type InitPoolItem_ = <V>(id:string)=>V;\n\n/**\n * State of pool\n */\nexport type PoolState = `idle` | `active` | `disposed`;\n\nexport type PoolUserEventMap<V> = {\n  readonly disposed: { readonly data: V; readonly reason: string };\n  readonly released: { readonly data: V; readonly reason: string };\n};\n\n/**\n * A use of a pool resource\n *\n * Has two events, _disposed_ and _released_.\n */\nexport class PoolUser<V> extends SimpleEventEmitter<PoolUserEventMap<V>> {\n  private _lastUpdate: number;\n  private _pool: Pool<V>;\n  private _state: PoolState;\n  private _userExpireAfterMs: number;\n\n  /**\n   * Constructor\n   * @param key User key\n   * @param resource Resource being used\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  constructor(readonly key: string, readonly resource: Resource<V>) {\n    super();\n    this._lastUpdate = performance.now();\n    this._pool = resource.pool;\n    this._userExpireAfterMs = this._pool.userExpireAfterMs;\n    this._state = `idle`;\n    this._pool.log.log(`PoolUser ctor key: ${ this.key }`);\n  }\n\n  /**\n   * Returns a human readable debug string\n   * @returns\n   */\n  toString() {\n    if (this.isDisposed) return `PoolUser. State: disposed`;\n\n    return `PoolUser. State: ${ this._state } Elapsed: ${ performance.now() - this._lastUpdate } Data: ${ JSON.stringify(this.resource.data) }`;\n  }\n\n  /**\n   * Resets countdown for instance expiry.\n   * Throws an error if instance is disposed.\n   */\n  keepAlive() {\n    if (this._state === `disposed`) throw new Error(`PoolItem disposed`);\n    this._lastUpdate = performance.now();\n  }\n\n  /**\n   * @internal\n   * @param reason\n   * @returns\n   */\n  _dispose(reason: string, data: V) {\n    if (this._state === `disposed`) return;\n    const resource = this.resource;\n    //const data = resource.data;\n    this._state = `disposed`;\n    resource._release(this);\n    this._pool.log.log(`PoolUser dispose key: ${ this.key } reason: ${ reason }`);\n    this.fireEvent(`disposed`, { data, reason });\n    super.clearEventListeners();\n  }\n\n  /**\n   * Release this instance\n   * @param reason\n   */\n  release(reason: string) {\n    if (this.isDisposed) throw new Error(`User disposed`);\n    const resource = this.resource;\n    const data = resource.data;\n    this._pool.log.log(`PoolUser release key: ${ this.key } reason: ${ reason }`);\n    this.fireEvent(`released`, { data, reason });\n    this._dispose(`release-${ reason }`, data);\n  }\n\n  // #region Properties\n  get data(): V {\n    if (this.isDisposed) throw new Error(`User disposed`);\n    return this.resource.data;\n  }\n\n  /**\n   * Returns true if this instance has expired.\n   * Expiry counts if elapsed time is greater than `userExpireAfterMs`\n   */\n  get isExpired() {\n    if (this._userExpireAfterMs > 0) {\n      return performance.now() > this._lastUpdate + this._userExpireAfterMs;\n    }\n    return false;\n  }\n\n  /**\n   * Returns elapsed time since last 'update'\n   */\n  get elapsed() {\n    return performance.now() - this._lastUpdate;\n  }\n\n  /**\n   * Returns true if instance is disposed\n   */\n  get isDisposed() {\n    return this._state === `disposed`;\n  }\n\n  /**\n   * Returns true if instance is neither disposed nor expired\n   */\n  get isValid() {\n    if (this.isDisposed || this.isExpired) return false;\n    if (this.resource.isDisposed) return false;\n    return true;\n  }\n  // #endregion\n}\n\n/**\n * A resource allocated in the Pool\n */\nexport class Resource<V> {\n  #state: PoolState;\n  #data: V;\n  #users: Array<PoolUser<V>>;\n  readonly #capacityPerResource;\n  readonly #resourcesWithoutUserExpireAfterMs;\n  #lastUsersChange: number;\n\n  /**\n   * Constructor.\n   * @param pool Pool\n   * @param data Data\n   */\n  constructor(readonly pool: Pool<V>, data: V) {\n    if (data === undefined) throw new Error(`Parameter 'data' is undefined`);\n    if (pool === undefined) throw new Error(`Parameter 'pool' is undefined`);\n\n    this.#data = data;\n    this.#lastUsersChange = 0;\n    this.#resourcesWithoutUserExpireAfterMs =\n      pool.resourcesWithoutUserExpireAfterMs;\n    this.#capacityPerResource = pool.capacityPerResource;\n    this.#users = [];\n    this.#state = `idle`;\n  }\n\n  /**\n   * Gets data associated with resource.\n   * Throws an error if disposed\n   */\n  get data() {\n    if (this.#state === `disposed`) throw new Error(`Resource disposed`);\n    return this.#data;\n  }\n\n  /**\n   * Changes the data associated with this resource.\n   * Throws an error if disposed or `data` is undefined.\n   * @param data\n   */\n  updateData(data: V) {\n    if (this.#state === `disposed`) throw new Error(`Resource disposed`);\n    if (data === undefined) throw new Error(`Parameter 'data' is undefined`);\n    this.#data = data;\n  }\n\n  /**\n   * Returns a human-readable debug string for resource\n   * @returns\n   */\n  toString() {\n    return `Resource (expired: ${ this.isExpiredFromUsers } users: ${ this.#users.length }, state: ${ this.#state }) data: ${ JSON.stringify(this.data) }`;\n  }\n\n  /**\n   * Assigns a user to this resource.\n   * @internal\n   * @param user\n   */\n  _assign(user: PoolUser<V>) {\n    const existing = this.#users.find((u) => u === user || u.key === user.key);\n    if (existing) throw new Error(`User instance already assigned to resource`);\n    this.#users.push(user);\n    this.#lastUsersChange = performance.now();\n  }\n\n  /**\n   * Releases a user from this resource\n   * @internal\n   * @param user\n   */\n  _release(user: PoolUser<V>) {\n    this.#users = this.#users.filter((u) => u !== user);\n    this.pool._release(user);\n    this.#lastUsersChange = performance.now();\n  }\n\n  /**\n   * Returns true if resource can have additional users allocated\n   */\n  get hasUserCapacity() {\n    return this.usersCount < this.#capacityPerResource;\n  }\n\n  /**\n   * Returns number of uses of the resource\n   */\n  get usersCount() {\n    return this.#users.length;\n  }\n\n  /**\n   * Returns true if automatic expiry is enabled, and that interval\n   * has elapsed since the users list has changed for this resource\n   */\n  get isExpiredFromUsers() {\n    if (this.#resourcesWithoutUserExpireAfterMs <= 0) return false;\n    if (this.#users.length > 0) return false;\n    return (\n      performance.now() >\n      this.#resourcesWithoutUserExpireAfterMs + this.#lastUsersChange\n    );\n  }\n\n  /**\n   * Returns true if instance is disposed\n   */\n  get isDisposed() {\n    return this.#state === `disposed`;\n  }\n\n  /**\n   * Disposes the resource.\n   * If it is already disposed, it does nothing.\n   * @param reason\n   * @returns\n   */\n  dispose(reason: string) {\n    if (this.#state === `disposed`) return;\n    const data = this.#data;\n    this.#state = `disposed`;\n    this.pool.log.log(`Resource disposed (${ reason })`);\n    for (const u of this.#users) {\n      u._dispose(`resource-${ reason }`, data);\n    }\n    this.#users = [];\n    this.#lastUsersChange = performance.now();\n    this.pool._releaseResource(this, reason);\n\n    if (this.pool.freeResource) this.pool.freeResource(data);\n  }\n}\n\n/**\n * Resource pool\n * It does the housekeeping of managing a limited set of resources which are shared by 'users'. \n * All resources in the Pool are meant to be the same kind of object.\n * \n * An example is an audio sketch driven by TensorFlow. We might want to allocate a sound oscillator per detected human body. A naive implementation would be to make an oscillator for each detected body. However, because poses appear/disappear unpredictably, it's a lot of extra work to maintain the binding between pose and oscillator.\n * \n * Instead, we might use the Pool to allocate oscillators to poses. This will allow us to limit resources and clean up automatically if they haven't been used for a while.\n * \n * Resources can be added manually with `addResource()`, or automatically by providing a `generate()` function in the Pool options. They can then be accessed via a _user key_. This is meant to associated with a single 'user' of a resource. For example, if we are associating oscillators with TensorFlow poses, the 'user key' might be the id of the pose.\n */\nexport class Pool<V> {\n  private _resources: Array<Resource<V>>;\n  private _users: Map<string, PoolUser<V>>;\n\n  readonly capacity: number;\n  readonly userExpireAfterMs: number;\n  readonly resourcesWithoutUserExpireAfterMs: number;\n\n  readonly capacityPerResource: number;\n  readonly fullPolicy: FullPolicy;\n  private generateResource?: () => V;\n  readonly freeResource?: (v: V) => void;\n\n  readonly log: Debug.LogSet;\n\n  /**\n   * Constructor.\n   *\n   * By default, no capacity limit, one user per resource\n   * @param options Pool options\n   */\n  constructor(options: Opts<V> = {}) {\n    this.capacity = options.capacity ?? -1;\n    this.fullPolicy = options.fullPolicy ?? `error`;\n    this.capacityPerResource = options.capacityPerResource ?? 1;\n    this.userExpireAfterMs = options.userExpireAfterMs ?? -1;\n    this.resourcesWithoutUserExpireAfterMs =\n      options.resourcesWithoutUserExpireAfterMs ?? -1;\n\n    this.generateResource = options.generate;\n    this.freeResource = options.free;\n\n    this._users = new Map();\n    this._resources = [];\n\n    this.log = Debug.logSet(`Pool`, options.debug ?? false);\n\n    // If we have a time-based expiry, set an interval to\n    // automatically do the housekeeping\n    const timer = Math.max(\n      this.userExpireAfterMs,\n      this.resourcesWithoutUserExpireAfterMs\n    );\n    if (timer > 0) {\n      setInterval(() => {\n        this.maintain();\n      }, timer * 1.1);\n    }\n  }\n\n  /**\n   * Returns a debug string of Pool state\n   * @returns\n   */\n  dumpToString() {\n    //eslint-disable-next-line functional/no-let\n    let r = `Pool\n    capacity: ${ this.capacity } userExpireAfterMs: ${ this.userExpireAfterMs } capacityPerResource: ${ this.capacityPerResource }\n    resources count: ${ this._resources.length }`;\n\n    const resource = this._resources.map((r) => r.toString()).join(`\\r\\n\\t`);\n    r += `\\r\\nResources:\\r\\n\\t` + resource;\n\n    r += `\\r\\nUsers: \\r\\n`;\n    for (const [ k, v ] of this._users.entries()) {\n      r += `\\tk: ${ k } v: ${ v.toString() }\\r\\n`;\n    }\n    return r;\n  }\n\n  /**\n   * Sorts users by longest elapsed time since update\n   * @returns\n   */\n  getUsersByLongestElapsed() {\n    return [ ...this._users.values() ].sort((a, b) => {\n      const aa = a.elapsed;\n      const bb = b.elapsed;\n      if (aa === bb) return 0;\n      if (aa < bb) return 1;\n      return -1;\n    });\n  }\n\n  /**\n   * Returns resources sorted with least used first\n   * @returns\n   */\n  getResourcesSortedByUse() {\n    return [ ...this._resources ].sort((a, b) => {\n      if (a.usersCount === b.usersCount) return 0;\n      if (a.usersCount < b.usersCount) return -1;\n      return 1;\n    });\n  }\n\n  /**\n   * Adds a shared resource to the pool\n   * @throws Error if the capacity limit is reached or resource is null\n   * @param resource\n   * @returns\n   */\n  addResource(resource: V) {\n    if (resource === undefined) {\n      throw new Error(`Cannot add undefined resource`);\n    }\n    if (resource === null) throw new TypeError(`Cannot add null resource`);\n\n    if (this.capacity > 0 && this._resources.length === this.capacity) {\n      throw new Error(\n        `Capacity limit (${ this.capacity }) reached. Cannot add more.`\n      );\n    }\n\n    this.log.log(`Adding resource: ${ JSON.stringify(resource) }`);\n    const pi = new Resource<V>(this, resource);\n    this._resources.push(pi);\n    return pi;\n  }\n\n  /**\n   * Performs maintenance, removing disposed/expired resources & users.\n   * This is called automatically when using a resource.\n   */\n  maintain() {\n    //eslint-disable-next-line functional/no-let\n    let changed = false;\n\n    // Find all disposed resources\n    const nuke: Array<Resource<V>> = [];\n    for (const p of this._resources) {\n      if (p.isDisposed) {\n        this.log.log(`Maintain, disposed resource: ${ JSON.stringify(p.data) }`);\n        nuke.push(p);\n      } else if (p.isExpiredFromUsers) {\n        this.log.log(`Maintain, expired resource: ${ JSON.stringify(p.data) }`);\n        nuke.push(p);\n      }\n    }\n\n    // Remove them\n    if (nuke.length > 0) {\n      for (const resource of nuke) {\n        resource.dispose(`diposed/expired`);\n      }\n      changed = true;\n    }\n\n    // Find 'users' to clean up\n    const userKeysToRemove: Array<string> = [];\n    for (const [ key, user ] of this._users.entries()) {\n      if (!user.isValid) {\n        this.log.log(\n          `Maintain. Invalid user: ${ user.key } (Disposed: ${ user.isDisposed } Expired: ${ user.isExpired } Resource disposed: ${ user.resource.isDisposed })`\n        );\n\n        userKeysToRemove.push(key);\n        user._dispose(`invalid`, user.data);\n      }\n    }\n\n    for (const userKey of userKeysToRemove) {\n      this._users.delete(userKey);\n      changed = true;\n    }\n\n    if (changed) {\n      this.log.log(\n        `End: resource len: ${ this._resources.length } users: ${ this.usersLength }`\n      );\n    }\n  }\n\n  /**\n   * Iterate over resources in the pool.\n   * To iterate over the data associated with each resource, use\n   * `values`.\n   */\n  *resources() {\n    const resource = [ ...this._resources ];\n    for (const r of resource) {\n      yield r;\n    }\n  }\n\n  /**\n   * Iterate over resource values in the pool.\n   * to iterate over the resources, use `resources`.\n   *\n   * Note that values may be returned even though there is no\n   * active user.\n   */\n  *values() {\n    const resource = [ ...this._resources ];\n    for (const r of resource) {\n      yield r.data;\n    }\n  }\n\n  /**\n   * Unassociate a key with a pool item\n   * @param userKey\n   */\n  release(userKey: string, reason?: string): void {\n    const pi = this._users.get(userKey);\n    if (!pi) return;\n    pi.release(reason ?? `Pool.release`);\n  }\n\n  /**\n   * @internal\n   * @param user\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  _release(user: PoolUser<V>) {\n    this._users.delete(user.key);\n  }\n\n  /**\n   * @internal\n   * @param resource\n   * @param _\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  _releaseResource(resource: Resource<V>, _: string) {\n    this._resources = this._resources.filter((v) => v !== resource);\n  }\n\n  /**\n   * Returns true if `v` has an associted resource in the pool\n   * @param resource\n   * @returns\n   */\n  hasResource(resource: V): boolean {\n    const found = this._resources.find((v) => v.data === resource);\n    return found !== undefined;\n  }\n\n  /**\n   * Returns true if a given `userKey` is in use.\n   * @param userKey\n   * @returns\n   */\n  hasUser(userKey: string): boolean {\n    return this._users.has(userKey);\n  }\n\n  /**\n   * @internal\n   * @param key\n   * @param resource\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-immutable-types\n  private _assign(key: string, resource: Resource<V>) {\n    const u = new PoolUser<V>(key, resource);\n    this._users.set(key, u);\n    resource._assign(u);\n    return u;\n  }\n\n  /**\n   * Allocates a resource for `userKey`\n   * @internal\n   * @param userKey\n   * @returns\n   */\n  #allocateResource(userKey: string): PoolUser<V> | undefined {\n    // Sort items by number of users per pool item\n    const sorted = this.getResourcesSortedByUse();\n    //eslint-disable-next-line functional/no-let\n    // for (let i=0;i<sorted.length;i++) {\n    //   console.log(i +`. users: ` + sorted[i].usersCount);\n    // }\n    if (sorted.length > 0 && sorted[ 0 ].hasUserCapacity) {\n      // No problem, resource has capacity\n      //this.log.log(`resource has capacity: ${ sorted[ 0 ].data }`);\n      const u = this._assign(userKey, sorted[ 0 ]);\n      return u;\n    }\n\n    // If resource count is below capacity, can we generate more?\n    if (\n      this.generateResource &&\n      (this.capacity < 0 || this._resources.length < this.capacity)\n    ) {\n      this.log.log(\n        `capacity: ${ this.capacity } resources: ${ this._resources.length }`\n      );\n      const resourceGenerated = this.addResource(this.generateResource());\n      const u = this._assign(userKey, resourceGenerated);\n      return u;\n    }\n  }\n\n  /**\n   * Return the number of users\n   */\n  get usersLength() {\n    return [ ...this._users.values() ].length;\n  }\n\n  /**\n   * 'Uses' a resource, returning the value\n   * @param userKey\n   * @returns\n   */\n  useValue(userKey: string): V {\n    const resource = this.use(userKey);\n    return resource.resource.data;\n  }\n\n  /**\n   * Gets a pool item based on a 'user' key.\n   * \n   * The same key should return the same pool item,\n   * for as long as it still exists.\n   * \n   * If a 'user' already has a resource, it will 'keep alive' their use.\n   * If a 'user' does not already have resource\n   *  - if there is capacity, a resource is allocated to user\n   *  - if pool is full\n   *    - fullPolicy = 'error': an error is thrown\n   *    - fullPolicy = 'evictOldestUser': evicts an older user\n   *    - Throw error\n   * @param userKey\n   * @throws Error If all resources are used and fullPolicy = 'error'\n   * @returns\n   */\n  use(userKey: string): PoolUser<V> {\n    const pi = this._users.get(userKey);\n    if (pi) {\n      pi.keepAlive();\n      return pi;\n    }\n\n    this.maintain();\n\n    const match = this.#allocateResource(userKey);\n    if (match) return match;\n\n    // Throw an error if all items are being used\n    if (this.fullPolicy === `error`) {\n      //console.log(this.dumpToString());\n      throw new Error(\n        `Pool is fully used (fullPolicy: ${ this.fullPolicy }, capacity: ${ this.capacity })`\n      );\n    }\n    // Evict oldest user\n    if (this.fullPolicy === `evictOldestUser`) {\n      const users = this.getUsersByLongestElapsed();\n      if (users.length > 0) {\n        this.release(users[ 0 ].key, `evictedOldestUser`);\n\n        const match2 = this.#allocateResource(userKey);\n        if (match2) return match2;\n      }\n    }\n\n    // Evict newest user\n\n    // Evict from random pool item\n    throw new Error(`Pool is fully used (${ this.fullPolicy })`);\n  }\n}\n\n/**\n * Creates an instance of a Pool\n * @param options\n * @returns\n */\nexport const create = <V>(options: Opts<V> = {}): Pool<V> => new Pool<V>(options);\n","import { toStringDefault } from \"../util/ToString.js\";\nimport { isEqualDefault } from \"../util/IsEqual.js\";\nexport { average, max, min, tally, sum, rank } from './BasicProcessors.js';\n\nexport type Process<TIn, TOut> = (value: TIn) => TOut;\nexport type ProcessFactory<TIn, TOut> = () => Process<TIn, TOut>;\n\nexport type Processors1<T1, T2> = [\n  Process<T1, T2>\n]\n\nexport type Processors2<T1, T2, T3> = [\n  Process<T1, T2>,\n  Process<T2, T3>\n]\n\nexport type Processors3<T1, T2, T3, T4> = [\n  Process<T1, T2>,\n  Process<T2, T3>,\n  Process<T3, T4>\n]\n\nexport type Processors4<T1, T2, T3, T4, T5> = [\n  Process<T1, T2>,\n  Process<T2, T3>,\n  Process<T3, T4>,\n  Process<T4, T5>\n]\n\nexport type Processors5<T1, T2, T3, T4, T5, T6> = [\n  Process<T1, T2>,\n  Process<T2, T3>,\n  Process<T3, T4>,\n  Process<T4, T5>,\n  Process<T5, T6>\n]\nexport type Processors<T1, T2, T3, T4, T5, T6> = Processors1<T1, T2> | Processors2<T1, T2, T3> | Processors3<T1, T2, T3, T4> | Processors4<T1, T2, T3, T4, T5> | Processors5<T1, T2, T3, T4, T5, T6>;\n\nexport function flow<T1, T2>(...processors: [ Process<T1, T2> ]): (value: T1) => T2;\nexport function flow<T1, T2, T3>(...processors: [ Process<T1, T2>, Process<T2, T3> ]): (value: T1) => T3;\nexport function flow<T1, T2, T3, T4>(...processors: [ Process<T1, T2>, Process<T2, T3>, Process<T3, T4> ]): (value: T1) => T4;\nexport function flow<T1, T2, T3, T4, T5>(...processors: [ Process<T1, T2>, Process<T2, T3>, Process<T3, T4>, Process<T4, T5> ]): (value: T1) => T5;\nexport function flow<T1, T2, T3, T4, T5, T6>(...processors: [ Process<T1, T2>, Process<T2, T3>, Process<T3, T4>, Process<T4, T5>, Process<T5, T6> ]): (value: T1) => T6;\n\n/**\n * Creates a flow of data processors (up to 5 are supported).\n * The flow is encapsulated in a function that accepts an input value an returns an output.\n * \n * ```js\n * const p = flow(\n *  (value:string) => value.toUpperCase(), // Convert to uppercase\n *  (value:string) => value.at(0) === 'A') // If first letter is an A, return true\n * );\n * p('apple'); // True\n * ```\n * \n * Each processing function is expected to take in one input value and return one value.\n * @param processors \n * @returns \n */\nexport function flow<T1, T2, T3, T4, T5, T6>(...processors: Processors<T1, T2, T3, T4, T5, T6>): (value: T1) => T2 | T3 | T4 | T5 | T6 {\n  return (value: T1) => {\n    let v = value;\n    for (const p of processors) {\n      try {\n        // @ts-expect-error\n        v = p(v);\n      } catch (err) {\n        if (err instanceof CancelError) {\n          break;\n        } else {\n          throw err;\n        }\n      }\n    }\n    return v as T2 | T3 | T4 | T5 | T6;\n  }\n}\n\n/**\n * If a value is same as the previous value, _undefined_ is emitted instead.\n * @param eq Equality function. If not specified, === semantics are used.\n * @returns \n */\nexport function seenLastToUndefined<TIn>(eq?: (a: TIn, b: TIn) => boolean): Process<TIn, TIn | undefined> {\n  if (eq === undefined) eq = isEqualDefault;\n  let lastValue: TIn | undefined;\n  return (value: TIn) => {\n    if (value !== lastValue) {\n      lastValue = value;\n      return value;\n    }\n    return undefined;\n  }\n}\n\n/**\n * If a value is same as any previously-seen value, _undefined_ is emitted instead.\n * It stores all previous values and compares against them for each new value. \n * This would likely be not very efficient compared to {@link seenToUndefinedByKey} which uses a one-time computed\n * key and efficient storage of only the keys (using a Set).\n *  \n * @param eq Equality function. If not specified, === semantics are used.\n * @returns \n */\nexport function seenToUndefined<TIn>(eq?: (a: TIn, b: TIn) => boolean): Process<TIn, TIn | undefined> {\n  let seen: TIn[] = [];\n  if (eq === undefined) eq = isEqualDefault;\n  return (value: TIn) => {\n    if (value === undefined) return;\n    for (const s of seen) {\n      if (eq(s, value)) return;\n    }\n    seen.push(value);\n    return value;\n  }\n}\n\n/**\n * If a value is the same as any previously-seen value, _undefined_ is emitted instead.\n * This version uses a function to create a string key of the object, by default JSON.stringify.\n * Thus we don't need to store all previously seen objects, just their keys.\n * \n * Alternatively, if a key function doesn't make sense for the value, use\n * {@link seenToUndefined}, which stores the values (less efficient).\n * \n * @param toString \n * @returns \n */\nexport function seenToUndefinedByKey<TIn>(toString?: (value: TIn) => string): Process<TIn, TIn | undefined> {\n  let seen = new Set<string>();\n  if (toString === undefined) toString = toStringDefault;\n  return (value: TIn) => {\n    if (value === undefined) return;\n    const key = toString(value);\n    if (seen.has(key)) return;\n    seen.add(key);\n    return value;\n  }\n}\n/**\n * Calls a function if the input value is not undefined.\n * Return value from function is passed to next function in flow.\n * \n * ```js\n * const flow = Process.flow(\n *  Process.max(),\n *  Process.seenLastToUndefined(),\n *  Process.ifNotUndefined(v => {\n *    console.log(`v:`, v);\n *  })\n * );\n * flow(100); // Prints 'v:100'\n * flow(90);  // Nothing happens max value has not changed\n * flow(110); // Prints 'v:110'\n * ```\n * @param fn \n * @returns \n */\nexport function ifNotUndefined<TIn, TOut>(fn: (value: Exclude<TIn, undefined>) => TOut) {\n  return (value: TIn) => {\n    if (value === undefined) return value;\n    const v = fn(value as Exclude<TIn, undefined>);\n    return v;\n  }\n}\n\nexport class CancelError extends Error {\n  constructor(message: any) {\n    super(message);\n    this.name = `CancelError`;\n  }\n}\n\n/**\n * Cancels the remaining flow operations if _undefined_ is an input.\n * See also {@link ifUndefined} or {@link ifNotUndefined}.\n * \n * ```js\n * const c3 = Process.flow(\n *  Basic.max(),\n *  Process.seenLastToUndefined(),\n *  Process.cancelIfUndefined(),\n *  (v => {\n *   console.log(v);\n *  })\n * );\n * c3(100); // Prints '100'\n * c3(90);  // Doesn't print anything since max does not change\n * c3(110); // Prints '110'\n * ```\n * @returns \n */\nexport function cancelIfUndefined<TIn>() {\n  return (value: TIn | undefined) => {\n    if (value === undefined) throw new CancelError(`cancel`);\n    return value as TIn;\n  }\n}\n/**\n * Returns the output of `fn` if the input value is _undefined_.\n * See also: {@link ifNotUndefined} and {@link cancelIfUndefined}.\n * @param fn \n * @returns \n */\nexport function ifUndefined<TIn, TOut>(fn: () => TOut) {\n  return (value: TIn) => {\n    if (value === undefined) return fn();\n    else return value;\n  }\n}","import type { Process } from \"./Process.js\";\nimport type { RankFunction, RankOptions } from \"./Types.js\";\n\n/**\n * Outputs the current largest-seen value\n * @returns \n */\nexport const max = (): Process<number | Array<number>, number> => {\n  let max = Number.MIN_SAFE_INTEGER;\n  const compute = (value: number | Array<number>) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) break;\n      max = Math.max(subValue, max);\n    }\n    return max;\n  }\n  return compute;\n}\n\n/**\n * Outputs the current smallest-seen value\n * @returns\n */\nexport const min = (): Process<number | Array<number>, number> => {\n  let min = Number.MAX_SAFE_INTEGER;\n  const compute = (value: number | Array<number>) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) break;\n      min = Math.min(subValue, min);\n    }\n    return min;\n  }\n  return compute;\n}\n\n/**\n * Returns a sum of values\n * @returns \n */\nexport const sum = (): Process<number | Array<number>, number> => {\n  let t = 0;\n  const compute = (value: number | Array<number>) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) continue;\n      t += subValue;\n    }\n    return t;\n  }\n  return compute;\n}\n\n/**\n * Returns the current average of input values\n * @returns \n */\nexport const average = (): Process<number | Array<number>, number> => {\n  let total = 0;\n  let tally = 0;\n  const compute = (value: number | Array<number>) => {\n    const valueArray = Array.isArray(value) ? value : [ value ];\n    for (const subValue of valueArray) {\n      if (typeof subValue !== `number`) continue;\n      tally++;\n      total += subValue;\n    }\n    return total / tally;\n  }\n  return compute;\n}\n\n/**\n * Returns the tally (ie number of) values\n * @param countArrayItems \n * @returns \n */\nexport const tally = (countArrayItems: boolean): Process<any, number> => {\n  let t = 0;\n  const compute = (value: number | Array<number>) => {\n    if (countArrayItems) {\n      if (Array.isArray(value)) t += value.length;\n      else t++;\n    } else {\n      t++;\n    }\n    return t;\n  }\n  return compute;\n}\n\n\n\n/**\n * Returns the 'best' value seen so far as determined by a ranking function.\n * This is similar to min/max but usable for objects.\n * @param r \n * @param options \n * @returns \n */\nexport function rank<In>(r: RankFunction<In>, options: Partial<RankOptions> = {}) {\n  const includeType = options.includeType;\n  const emitEqualRanked = options.emitEqualRanked ?? false;\n  const emitRepeatHighest = options.emitRepeatHighest ?? false;\n  let best: In | undefined;\n  return (value: In) => {\n    if (includeType && typeof value !== includeType) return;\n    if (best === undefined) {\n      best = value;\n      return best;\n    } else {\n      const result = r(value, best);\n      //console.log(`result: ${ result } value: ${ JSON.stringify(value) } best: ${ JSON.stringify(best) }`);\n      if (result == `a`) {\n        // New value is the current best\n        best = value;\n        return best;\n      } else if (result === `eq` && emitEqualRanked) {\n        // New value is same rank as previous, but we have flag on\n        return best;\n      } else if (emitRepeatHighest) {\n        // Emit current highest due to flag\n        return best;\n      }\n    }\n  }\n}\n\n\n","import type { ReactiveNonInitial } from \"src/rx/Types.js\";\nimport { resolve, resolveSync, type ResolveToValue } from \"./Resolve.js\";\nimport { zip } from \"./arrays/Zip.js\";\n\nexport type ResolvedObject<T extends Record<string, ResolveToValue<any>>> =\n  { [ K in keyof T ]:\n    T[ K ] extends number ? number :\n    T[ K ] extends string ? string :\n    T[ K ] extends boolean ? boolean :\n    T[ K ] extends bigint ? bigint :\n    T[ K ] extends () => Promise<any> ? Awaited<ReturnType<T[ K ]>> :\n    T[ K ] extends () => any ? ReturnType<T[ K ]> :\n    T[ K ] extends ReactiveNonInitial<infer V> ? V :\n    T[ K ] extends Generator<infer V> ? V :\n    T[ K ] extends AsyncGenerator<infer V> ? V :\n    T[ K ] extends IterableIterator<infer V> ? V :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V :\n    T[ K ] extends Array<infer V> ? V : // array needed?\n    T[ K ] extends object ? T[ K ] : never\n  };\n\n\n/**\n * Returns a copy of `object`, with the same properties. For each property\n * that has a basic value (string, number, boolean, object), the value is set\n * for the return object. If the property is a function or generator, its value\n * is used instead. Async functions and generators are also usable.\n * \n * Use {@link resolveFieldsSync} for a synchronous version.\n * \n * Not recursive.\n * \n * In the below example, the function for the property `random` is invoked.\n * ```js\n * const state = {\n *  length: 10,\n *  random: () => Math.random();\n * }\n * const x = resolveFields(state);\n * // { length: 10, random: 0.1235 }\n * ```\n * \n * It also works with generators\n * ```js\n * import { count } from './numbers.js';\n * \n * const state = {\n *  length: 10,\n *  index: count(2) // Generator that yields: 0, 1 and then ends\n * }\n * resolveFields(state); // { length: 10, index: 0 }\n * resolveFields(state); // { length: 10, index: 1 }\n * // Generator finishes after counting twice:\n * resolveFields(state); // { length: 10, index: undefined }\n * ```\n * @param object \n * @returns \n */\nexport async function resolveFields<T extends Record<string, ResolveToValue<any>>>(object: T): Promise<ResolvedObject<T>> {\n  const resolvers = [];\n  const keys = [];\n  for (const entry of Object.entries(object)) {\n    const resolvable = entry[ 1 ] as ResolveToValue<typeof entry[ 1 ]>;\n    resolvers.push(resolve(resolvable));\n    keys.push(entry[ 0 ]);\n  }\n  const results = await Promise.all(resolvers);\n  const entries = zip(keys, results);\n  return Object.fromEntries(entries) as ResolvedObject<T>;\n}\n\nexport function resolveFieldsSync<T extends Record<string, ResolveToValue<any>>>(object: T): ResolvedObject<T> {\n  const entries: [ key: string, value: any ][] = [];\n  for (const entry of Object.entries(object)) {\n    const resolvable = entry[ 1 ] as ResolveToValue<typeof entry[ 1 ]>;\n    const value = resolveSync(resolvable);\n    entries.push([ entry[ 0 ], value ]);\n  }\n  return Object.fromEntries(entries) as ResolvedObject<T>;\n}\n\n\n/**\n * Returns a function that resolves `object`.\n *\n * Use {@link resolveFields} to resolve an object directly.\n * @param object\n * @returns\n */\n// export function resolverFields<V extends object>(object: V) {\n//   return () => resolveFields(object);\n// }\n","// Source: https://stackoverflow.com/questions/49682569/typescript-merge-object-types\n// jcalz 2021-09-09\n\ntype OptionalPropertyNames<T> =\n  { [ K in keyof T ]-?: ({} extends { [ P in K ]: T[ K ] } ? K : never) }[ keyof T ];\n\ntype SpreadProperties<L, R, K extends keyof L & keyof R> =\n  { [ P in K ]: L[ P ] | Exclude<R[ P ], undefined> };\n\ntype Id<T> = T extends infer U ? { [ K in keyof U ]: U[ K ] } : never\n\ntype SpreadTwo<L, R> = Id<\n  & Pick<L, Exclude<keyof L, keyof R>>\n  & Pick<R, Exclude<keyof R, OptionalPropertyNames<R>>>\n  & Pick<R, Exclude<OptionalPropertyNames<R>, keyof L>>\n  & SpreadProperties<L, R, OptionalPropertyNames<R> & keyof L>\n>;\n\nexport type Spread<A extends readonly [ ...any ]> = A extends [ infer L, ...infer R ] ?\n  SpreadTwo<L, Spread<R>> : unknown\n\nexport function mergeObjects<A extends object[]>(...a: [ ...A ]) {\n  return Object.assign({}, ...a) as Spread<A>;\n}","export * from './GetOrGenerate.js';\nexport type * from './IMappish.js';\nexport * from './MapFns.js';","import { piPi } from '../data/index.js';\nimport type { Point } from './point/PointType.js';\n/**\n * Convert angle in degrees to angle in radians.\n * @param angleInDegrees \n * @returns \n */\nexport function degreeToRadian(angleInDegrees: number): number;\n\n/**\n * Convert angles in degrees to angles in radians\n * @param angleInDegrees \n */\nexport function degreeToRadian(angleInDegrees: ReadonlyArray<number>): ReadonlyArray<number>;\n\n \nexport function degreeToRadian(angleInDegrees: number | ReadonlyArray<number>): number | ReadonlyArray<number> {\n  return Array.isArray(angleInDegrees) ? angleInDegrees.map(v => v * (Math.PI / 180)) : (angleInDegrees as number) * (Math.PI / 180);\n}\n\n/**\n * Inverts the angle so it points in the opposite direction of a unit circle\n * @param angleInRadians \n * @returns \n */\nexport function radianInvert(angleInRadians: number) {\n  return (angleInRadians + Math.PI) % (2 * Math.PI);\n}\n\n/**\n * Convert angle in radians to angle in degrees\n * @param angleInRadians\n * @returns \n */\nexport function radianToDegree(angleInRadians: number): number;\n\n/**\n * Convert angles in radians to angles in degrees\n * @param angleInRadians \n */\nexport function radianToDegree(angleInRadians: ReadonlyArray<number>): ReadonlyArray<number>;\n\n \nexport function radianToDegree(angleInRadians: number | ReadonlyArray<number>): number | ReadonlyArray<number> {\n  return Array.isArray(angleInRadians) ? angleInRadians.map(v => v * 180 / Math.PI) : (angleInRadians as number) * 180 / Math.PI;\n}\n\n\n/**\n * Angle from x-axis to point (ie. `Math.atan2`)\n * @param point \n * @returns \n */\nexport const radiansFromAxisX = (point: Point): number => Math.atan2(point.x, point.y);\n\n/**\n * Sum angles together, accounting for the 'wrap around'.\n * \n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n * \n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(Math.PI, Math.PI/2, true);\n * ```\n * \n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * {@link degreesSum} is the same, but uses degrees (0..360)\n * @param start Starting angle, in radian\n * @param amount Angle to add, in radian\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in radians\n */\nexport const radiansSum = (start: number, amount: number, clockwise = true) => {\n  if (clockwise) {\n    let x = start + amount;\n    if (x >= piPi) x = x % piPi;\n    return x;\n  } else {\n    const x = start - amount;\n    if (x < 0) {\n      return piPi + x;\n    }\n    return x;\n  }\n}\n\n/**\n * Sum angles together, accounting for the 'wrap around'.\n * \n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n * \n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(180, 90, true);\n * ```\n * \n * {@link radiansSum} is the same, but uses radians (0..2 Pi)\n * \n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Starting angle, in degrees\n * @param amount Angle to add, in degrees\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in degrees\n */\nexport const degreesSum = (start: number, amount: number, clockwise = true) => radianToDegree(radiansSum(degreeToRadian(start), degreeToRadian(amount), clockwise));\n\n/**\n * Computes the angle arc between a start and end angle,\n * given in radians. It properly accounts for the wrap-around\n * values.\n * \n * ```js\n * // Between 0-90deg in clockwise direction\n * radianArc(0, Math.PI/2, true); // Yields: 3Pi/2 (270 deg)\n * \n * // In counter-clockwise direction\n * radianArc(0, Math.PI/2, false); // Yields: Math.PI/2 (90deg)\n * ```\n * \n * See {@link degreeArc} to operate in degrees.\n * \n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param start Start angle, in radians\n * @param end End angle, in radians\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in radians.\n */\nexport const radianArc = (start: number, end: number, clockwise = true) => {\n  let s = start;\n  if (end < s) {\n    s = 0;\n    end = piPi - start + end;\n  }\n  let d = end - s;\n  if (clockwise) d = piPi - d;\n  if (d >= piPi) return d % piPi;\n  return d;\n}\n\n/**\n * Computes the angle arc between a start and end angle,\n * given in degrees. It properly accounts for the wrap-around\n * values.\n * \n * ```js\n * // Between 0-90 in clockwise direction\n * degreeArc(0, 90, true); // Yields: 270\n * \n * // In counter-clockwise direction\n * degreeArc(0, 90, false); // Yields: 90\n * ```\n * \n * See {@link radianArc} to operate in radians.\n * \n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Start angle, in degrees\n * @param end End angle, in degrees\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in degrees.\n */\nexport const degreeArc = (start: number, end: number, clockwise = true) => radianToDegree(radianArc(degreeToRadian(start), degreeToRadian(end), clockwise));","import { guard } from \"./Guard.js\";\nimport type { Coord } from \"./Types.js\";\nimport { degreeToRadian } from '../Angles.js';\n\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountRadian Amount to rotate, in radians\n * @returns\n */\nexport const rotate = (c: Coord, amountRadian: number): Coord =>\n  Object.freeze({\n    ...c,\n    angleRadian: c.angleRadian + amountRadian,\n  });\n\n/**\n * Inverts the direction of coordinate. Ie if pointing north, will point south.\n * @param p\n * @returns\n */\nexport const invert = (p: Coord): Coord => {\n  guard(p, `c`);\n  return Object.freeze({\n    ...p,\n    angleRadian: p.angleRadian - Math.PI,\n  });\n};\n\n/**\n * Returns true if PolarCoords have same magnitude but opposite direction\n * @param a\n * @param b\n * @returns\n */\nexport const isOpposite = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  if (a.distance !== b.distance) return false;\n  return a.angleRadian === -b.angleRadian;\n};\n\n/**\n * Returns true if Coords have the same direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport const isParallel = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.angleRadian === b.angleRadian;\n};\n\n/**\n * Returns true if coords are opposite direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport const isAntiParallel = (a: Coord, b: Coord): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.angleRadian === -b.angleRadian;\n};\n\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountDeg Amount to rotate, in degrees\n * @returns\n */\nexport const rotateDegrees = (c: Coord, amountDeg: number): Coord =>\n  Object.freeze({\n    ...c,\n    angleRadian: c.angleRadian + degreeToRadian(amountDeg),\n  });\n\n","import type { Point } from \"../point/PointType.js\";\nimport { guard, isPolarCoord } from \"./Guard.js\";\nimport type { Coord } from \"./Types.js\";\nimport { subtract as subtractPoint } from \"../point/Subtract.js\";\nimport { guard as guardPoint } from \"../point/Guard.js\";\nimport { Empty as EmptyPoint } from '../point/Empty.js';\nimport { isPoint } from \"../point/Guard.js\";\nimport { radianToDegree } from \"../Angles.js\";\n/**\n * Converts to Cartesian coordiantes\n */\ntype ToCartesian = {\n  (point: Coord, origin?: Point): Point;\n  (distance: number, angleRadians: number, origin?: Point): Point;\n};\n/**\n * Converts to Cartesian coordinate from polar.\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * const origin = { x: 50, y: 50}; // Polar origin\n * // Yields: { x, y }\n * const polar = Polar.toCartesian({ distance: 10, angleRadian: 0 }, origin);\n * ```\n *\n * Distance and angle can be provided as numbers intead:\n *\n * ```\n * // Yields: { x, y }\n * const polar = Polar.toCartesian(10, 0, origin);\n * ```\n *\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const toCartesian: ToCartesian = (\n  a: Coord | number,\n  b?: Point | number,\n  c?: Point\n): Point => {\n  if (isPolarCoord(a)) {\n    if (b === undefined) b = EmptyPoint;\n    if (isPoint(b)) {\n      return polarToCartesian(a.distance, a.angleRadian, b);\n    }\n    throw new Error(\n      `Expecting (Coord, Point). Second parameter is not a point`\n    );\n  } else if (typeof a === `object`) {\n    throw new TypeError(\n      `First param is an object, but not a Coord: ${ JSON.stringify(a) }`\n    );\n  } else {\n    if (typeof a === `number` && typeof b === `number`) {\n      if (c === undefined) c = EmptyPoint;\n      if (!isPoint(c)) {\n        throw new Error(\n          `Expecting (number, number, Point). Point param wrong type`\n        );\n      }\n      return polarToCartesian(a, b, c);\n    } else {\n      throw new TypeError(\n        `Expecting parameters of (number, number). Got: (${ typeof a }, ${ typeof b }, ${ typeof c }). a: ${ JSON.stringify(\n          a\n        ) }`\n      );\n    }\n  }\n};\n\n/**\n * Converts a Cartesian coordinate to polar\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * // Yields: { angleRadian, distance }\n * const polar = Polar.fromCartesian({x: 50, y: 50}, origin);\n * ```\n *\n * Any additional properties of `point` are copied to object.\n * @param point Point\n * @param origin Origin\n * @returns\n */\nexport const fromCartesian = (\n  point: Point,\n  origin: Point\n): Coord => {\n  point = subtractPoint(point, origin);\n\n  const angle = Math.atan2(point.y, point.x);\n  return Object.freeze({\n    ...point,\n    angleRadian: angle,\n    distance: Math.hypot(point.x, point.y),\n  });\n};\n\n/**\n * Converts a polar coordinate to Cartesian\n * @param distance Distance\n * @param angleRadians Angle in radians\n * @param origin Origin, or 0,0 by default.\n * @returns\n */\nconst polarToCartesian = (\n  distance: number,\n  angleRadians: number,\n  origin: Point = EmptyPoint\n): Point => {\n  guardPoint(origin);\n  return Object.freeze({\n    x: origin.x + distance * Math.cos(angleRadians),\n    y: origin.y + distance * Math.sin(angleRadians),\n  });\n};\n\n/**\n * Returns a human-friendly string representation `(distance, angleDeg)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport const toString = (p: Coord, digits?: number): string => {\n  if (p === undefined) return `(undefined)`;\n  if (p === null) return `(null)`;\n\n  const angleDeg = radianToDegree(p.angleRadian);\n  const d = digits ? p.distance.toFixed(digits) : p.distance;\n  const a = digits ? angleDeg.toFixed(digits) : angleDeg;\n  return `(${ d },${ a })`;\n};\n\nexport const toPoint = (v: Coord, origin = EmptyPoint): Point => {\n  guard(v, `v`);\n  return Object.freeze({\n    x: origin.x + v.distance * Math.cos(v.angleRadian),\n    y: origin.y + v.distance * Math.sin(v.angleRadian),\n  });\n};","import { guard } from \"./Guard.js\";\nimport type { Coord } from \"./Types.js\";\nimport { throwNumberTest } from \"../../util/GuardNumbers.js\";\n\nexport const normalise = (c: Coord): Coord => {\n  //guard(v, `v`);\n  if (c.distance === 0) throw new Error(`Cannot normalise vector of length 0`);\n  return Object.freeze({\n    ...c,\n    distance: 1,\n  });\n};\n\n\n\n/**\n * Clamps the magnitude of a vector\n * @param v\n * @param max\n * @param min\n * @returns\n */\nexport const clampMagnitude = (v: Coord, max = 1, min = 0): Coord => {\n  let mag = v.distance;\n  if (mag > max) mag = max;\n  if (mag < min) mag = min;\n  return Object.freeze({\n    ...v,\n    distance: mag,\n  });\n};\n\n/**\n * Calculate dot product of two PolarCoords.\n *\n * Eg, power is the dot product of force and velocity\n *\n * Dot products are also useful for comparing similarity of\n *  angle between two unit PolarCoords.\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a: Coord, b: Coord): number => {\n  guard(a, `a`);\n  guard(b, `b`);\n  return a.distance * b.distance * Math.cos(b.angleRadian - a.angleRadian);\n};\n\n\n/**\n * Multiplies the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport const multiply = (v: Coord, amt: number): Coord => {\n  guard(v);\n  throwNumberTest(amt, ``, `amt`);\n  return Object.freeze({\n    ...v,\n    distance: v.distance * amt,\n  });\n};\n\n/**\n * Divides the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport const divide = (v: Coord, amt: number): Coord => {\n  guard(v);\n  throwNumberTest(amt, ``, `amt`);\n  return Object.freeze({\n    ...v,\n    distance: v.distance / amt,\n  });\n};\n","import { type Line } from \"../line/LineType.js\";\nimport { type Point } from '../point/PointType.js';\nimport { distance } from '../point/Distance.js';\nimport { angleRadian } from '../point/Angle.js';\nimport { type PolarRay } from \"./Types.js\";\nimport { toCartesian as polarToCartesian } from \"./Conversions.js\";\n\n/**\n * Converts a ray to a Line in cartesian coordinates.\n * \n * @param ray \n * @param origin Override or provide origin point\n * @returns \n */\nexport const toCartesian = (ray: PolarRay, origin?: Point): Line => {\n  const o = getOrigin(ray, origin);\n  const a = polarToCartesian(ray.offset, ray.angleRadian, o);\n  const b = polarToCartesian(ray.offset + ray.length, ray.angleRadian, o);\n  return { a, b }\n}\n\nconst getOrigin = (ray: PolarRay, origin?: Point): Point => {\n  if (origin !== undefined) return origin;\n  if (ray.origin !== undefined) return ray.origin;\n  return { x: 0, y: 0 };\n}\n\n/**\n * Returns a copy of `ray` ensuring it has an origin.\n * If the `origin` parameter is provided, it will override the existing origin.\n * If no origin information is available, 0,0 is used.\n * @param ray \n * @param origin \n * @returns \n */\n// const withOrigin = (ray: PolarRay, origin?: Point): PolarRayWithOrigin => {\n//   if (origin) {\n//     return {\n//       ...ray,\n//       origin\n//     };\n//   }\n//   if (ray.origin !== undefined) return { ...ray } as PolarRayWithOrigin;\n//   return {\n//     ...ray,\n//     origin: { x: 0, y: 0 }\n//   }\n// }\n\n\n\n// function getAngle(a: Point, b: Point) {\n//   const angle = Math.atan2(b.y - a.y, b.x - a.x);// * (180 / Math.PI) + 90;\n//   return angle;//return (angle < 0) ? scale(angle, -90, 0, 0, piPi) : angle;\n// }\n\nexport const toString = (ray: PolarRay): string => {\n  return `PolarRay(angle: ${ ray.angleRadian } offset: ${ ray.offset } len: ${ ray.length })`\n}\n\n/**\n * Returns a PolarRay based on a line and origin.\n * If `origin` is omitted, the origin is taken to be the 'a' point of the line.\n * @param line \n * @param origin \n * @returns \n */\nexport const fromLine = (line: Line, origin?: Point): PolarRay => {\n  const o = origin ?? line.a;\n  return {\n    angleRadian: angleRadian(line.b, o),\n    offset: distance(line.a, o),\n    length: distance(line.b, line.a),\n    origin: o\n  }\n}\n\n","/**\n * Produces an Archimedean spiral. It's a generator.\n *\n * ```js\n * const s = spiral(0.1, 1);\n * for (const coord of s) {\n *  // Use Polar coord...\n *  if (coord.step === 1000) break; // Stop after 1000 iterations\n * }\n * ```\n *\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n */\n\nimport type { Coord } from \"./Types.js\";\n\nexport function* spiral(\n  smoothness: number,\n  zoom: number\n): IterableIterator<Coord & { readonly step: number }> {\n  let step = 0;\n\n  while (true) {\n    const a = smoothness * step++;\n    yield {\n      distance: zoom * a,\n      angleRadian: a,\n      step: step,\n    };\n  }\n}\n\n/**\n * Produces an Archimedian spiral with manual stepping.\n * @param step Step number. Typically 0, 1, 2 ...\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n * @returns\n */\nexport const spiralRaw = (\n  step: number,\n  smoothness: number,\n  zoom: number\n): Coord => {\n  const a = smoothness * step;\n  return Object.freeze({\n    distance: zoom * a,\n    angleRadian: a,\n  });\n};","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport type { Point } from \"./PointType.js\";\nimport { guard } from \"./Guard.js\";\nimport { fromCartesian as PolarFromCartesian } from \"../polar/index.js\";\nimport { rotate as PolarRotate, toCartesian as PolarToCartesian } from \"../polar/index.js\";\n/**\n * Rotate a single point by a given amount in radians\n * @param pt\n * @param amountRadian\n * @param origin\n */\nexport function rotate(pt: Point, amountRadian: number, origin?: Point): Point;\n\n/**\n * Rotate several points by a given amount in radians\n * @param pt Points\n * @param amountRadian Amount to rotate in radians. If 0 is given, a copy of the input array is returned\n * @param origin Origin to rotate around. Defaults to 0,0\n */\nexport function rotate(\n  pt: ReadonlyArray<Point>,\n  amountRadian: number,\n  origin?: Point\n): ReadonlyArray<Point>;\n\nexport function rotate(\n  pt: Point | ReadonlyArray<Point>,\n  amountRadian: number,\n  origin?: Point\n): Point | ReadonlyArray<Point> {\n  if (origin === undefined) origin = { x: 0, y: 0 };\n  guard(origin, `origin`);\n  throwNumberTest(amountRadian, ``, `amountRadian`);\n  const arrayInput = Array.isArray(pt);\n\n  // no-op\n  if (amountRadian === 0) return pt;\n\n  if (!arrayInput) {\n    pt = [ pt as Point ];\n  }\n\n  const ptAr = pt as ReadonlyArray<Point>;\n  for (const [ index, p ] of ptAr.entries()) guard(p, `pt[${ index }]`);\n\n  const asPolar = ptAr.map((p) => PolarFromCartesian(p, origin));\n  const rotated = asPolar.map((p) => PolarRotate(p, amountRadian));\n  const asCartesisan = rotated.map((p) => PolarToCartesian(p, origin));\n  return arrayInput ? asCartesisan : asCartesisan[ 0 ];\n}","\n//eslint-disable-next-line functional/prefer-readonly-type\nexport const rotatePointArray = (\n  v: ReadonlyArray<ReadonlyArray<number>>,\n  amountRadian: number\n): Array<Array<number>> => {\n  const mat = [\n    [ Math.cos(amountRadian), -Math.sin(amountRadian) ],\n    [ Math.sin(amountRadian), Math.cos(amountRadian) ],\n  ];\n  const result = [];\n  for (const [ index, element ] of v.entries()) {\n    //eslint-disable-next-line functional/immutable-data\n    result[ index ] = [\n      mat[ 0 ][ 0 ] * element[ 0 ] + mat[ 0 ][ 1 ] * element[ 1 ],\n      mat[ 1 ][ 0 ] * element[ 0 ] + mat[ 1 ][ 1 ] * element[ 1 ],\n    ];\n  }\n  return result;\n};","import { round as roundNumber } from '../../numbers/Round.js';\nimport { getPointParameter } from './GetPointParameter.js';\nimport type { Point } from './PointType.js';\n\n/**\n * Round the point's _x_ and _y_ to given number of digits\n * @param ptOrX \n * @param yOrDigits \n * @param digits \n * @returns \n */\nexport const round = (ptOrX: Point | number, yOrDigits?: number, digits?: number): Point => {\n  const pt = getPointParameter(ptOrX, yOrDigits);\n  digits = digits ?? yOrDigits;\n  digits = digits ?? 2;\n  return Object.freeze({\n    ...pt,\n    x: roundNumber(digits, pt.x),\n    y: roundNumber(digits, pt.y)\n  })\n}","import { guard } from \"./Guard.js\";\nimport type { Point, Point3d } from \"./PointType.js\";\n\n/**\n * Returns a point with rounded x,y coordinates. By default uses `Math.round` to round.\n * ```js\n * toIntegerValues({x:1.234, y:5.567}); // Yields: {x:1, y:6}\n * ```\n *\n * ```js\n * toIntegerValues(pt, Math.ceil); // Use Math.ceil to round x,y of `pt`.\n * ```\n * @param pt Point to round\n * @param rounder Rounding function, or Math.round by default\n * @returns\n */\nexport const toIntegerValues = (\n  pt: Point,\n  rounder: (x: number) => number = Math.round\n): Point => {\n  guard(pt, `pt`);\n  return Object.freeze({\n    x: rounder(pt.x),\n    y: rounder(pt.y),\n  });\n};\n\n/**\n * Returns a copy of `pt` with `z` field omitted.\n * If it didn't have one to begin within, a copy is still returned.\n * @param pt \n * @returns \n */\nexport const to2d = (pt: Point): Point => {\n  guard(pt, `pt`);\n  let copy = {\n    ...pt\n  };\n  delete copy.z;\n  return Object.freeze(copy);\n}\n\n/**\n * Returns a copy of `pt` with a `z` field set.\n * Defaults to a z value of 0.\n * @param pt Point\n * @param z Z-value, defaults to 0\n * @returns \n */\nexport const to3d = (pt: Point, z: number = 0): Point3d => {\n  guard(pt, `pt`);\n  return Object.freeze({\n    ...pt,\n    z\n  });\n}\n\n/**\n * Returns a human-friendly string representation `(x, y)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport function toString(p: Point, digits?: number): string {\n  if (p === undefined) return `(undefined)`;\n  if (p === null) return `(null)`;\n  guard(p, `pt`);\n\n  const x = digits ? p.x.toFixed(digits) : p.x;\n  const y = digits ? p.y.toFixed(digits) : p.y;\n\n  if (p.z === undefined) {\n    return `(${ x },${ y })`;\n  } else {\n    const z = digits ? p.z.toFixed(digits) : p.z;\n    return `(${ x },${ y },${ z })`;\n  }\n}","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport type { Point } from \"./PointType.js\";\nimport { guard } from \"./Guard.js\";\n\n/**\n * Returns true if two points are within a specified range on both axes.\n * \n * Provide a point for the range to set different x/y range, or pass a number\n * to use the same range for both axis.\n *\n * Note this simply compares x,y values it does not calcuate distance.\n *\n * @example\n * ```js\n * withinRange({x:100,y:100}, {x:101, y:101}, 1); // True\n * withinRange({x:100,y:100}, {x:105, y:101}, {x:5, y:1}); // True\n * withinRange({x:100,y:100}, {x:105, y:105}, {x:5, y:1}); // False - y axis too far\n * ```\n * @param a\n * @param b\n * @param maxRange\n * @returns\n */\nexport const withinRange = (\n  a: Point,\n  b: Point,\n  maxRange: Point | number\n): boolean => {\n  guard(a, `a`);\n  guard(b, `b`);\n\n  if (typeof maxRange === `number`) {\n    throwNumberTest(maxRange, `positive`, `maxRange`);\n    maxRange = { x: maxRange, y: maxRange };\n  } else {\n    guard(maxRange, `maxRange`);\n  }\n  const x = Math.abs(b.x - a.x);\n  const y = Math.abs(b.y - a.y);\n  return x <= maxRange.x && y <= maxRange.y;\n};","import { wrap as wrapNumber } from '../../numbers/Wrap.js';\nimport { guard } from './Guard.js';\nimport type { Point } from \"./PointType.js\";\n\n/**\n * Wraps a point to be within `ptMin` and `ptMax`.\n * Note that max values are _exclusive_, meaning the return value will always be one less.\n *\n * Eg, if a view port is 100x100 pixels, wrapping the point 150,100 yields 50,99.\n *\n * ```js\n * // Wraps 150,100 to on 0,0 -100,100 range\n * wrap({x:150,y:100}, {x:100,y:100});\n * ```\n *\n * Wrap normalised point:\n * ```js\n * wrap({x:1.2, y:1.5}); // Yields: {x:0.2, y:0.5}\n * ```\n * @param pt Point to wrap\n * @param ptMax Maximum value, or `{ x:1, y:1 }` by default\n * @param ptMin Minimum value, or `{ x:0, y:0 }` by default\n * @returns Wrapped point\n */\nexport const wrap = (\n  pt: Point,\n  ptMax?: Point,\n  ptMin?: Point\n): Point => {\n\n  if (ptMax === undefined) ptMax = { x: 1, y: 1 };\n  if (ptMin === undefined) ptMin = { x: 0, y: 0 };\n\n  //  Unit tested\n  guard(pt, `pt`);\n  guard(ptMax, `ptMax`);\n  guard(ptMin, `ptMin`);\n\n  return Object.freeze({\n    x: wrapNumber(pt.x, ptMin.x, ptMax.x),\n    y: wrapNumber(pt.y, ptMin.y, ptMax.y),\n  });\n};\n","import { Bezier as BezierLibrary } from 'bezier-js';\nimport { interpolate as LinesInterpolate } from '../line/Interpolate.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/FromTopLeft.js';\nimport type { Point } from '../point/PointType.js';\nimport type { CubicBezier, CubicBezierPath, QuadraticBezier, QuadraticBezierPath } from './BezierType.js';\nimport { isCubicBezier, isQuadraticBezier } from './Guard.js';\nimport { to2d } from '../point/To.js';\nexport * from './BezierType.js';\nexport * from './Guard.js';\n/**\n * Returns a new quadratic bezier with specified bend amount\n *\n * @param {QuadraticBezier} b Curve\n * @param {number} [bend=0] Bend amount, from -1 to 1\n * @returns {QuadraticBezier}\n */\n// export const quadraticBend = (a: Point, b: Point, bend = 0): QuadraticBezier => quadraticSimple(a, b, bend);\n\n/**\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve.\n * \n * Use {@link interpolator} to calculate a point along the curve.\n * @param {Point} start Start of curve\n * @param {Point} end End of curve\n * @param {number} [bend=0] Bend amount, -1 to 1\n * @returns {QuadraticBezier}\n */\nexport const quadraticSimple = (start: Point, end: Point, bend = 0): QuadraticBezier => {\n  if (Number.isNaN(bend)) throw new Error(`bend is NaN`);\n  if (bend < -1 || bend > 1) throw new Error(`Expects bend range of -1 to 1`);\n\n  const middle = LinesInterpolate(0.5, start, end);\n  let target = middle;\n  if (end.y < start.y) {\n    // Upward slope\n    target = bend > 0 ? { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.max(start.x, end.x), y: Math.max(start.y, end.y) };\n  } else {\n    // Downward slope\n    target = bend > 0 ? { x: Math.max(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.min(start.x, end.x), y: Math.max(start.y, end.y) };\n  }\n\n  const handle = LinesInterpolate(Math.abs(bend), middle, target,);\n  return quadratic(start, end, handle);\n};\n\n/**\n * Returns a relative point on a simple quadratic \n * @param start Start\n * @param end  End\n * @param bend Bend (-1 to 1)\n * @param amt Amount\n * @returns Point\n */\n// export const computeQuadraticSimple = (start: Point, end: Point, bend: number, amt: number): Point => {\n//   const q = quadraticSimple(start, end, bend);\n//   const bzr = new BezierLibrary(q.a, q.quadratic, q.b);\n//   return bzr.compute(amt);\n// };\n\n/**\n * Interpolate cubic or quadratic bezier\n * ```js\n * const i = interpolator(myBezier);\n * \n * // Get point at 50%\n * i(0.5); // { x, y }\n * ```\n * @param q \n * @returns \n */\nexport const interpolator = (q: QuadraticBezier | CubicBezier): (amount: number) => Point => {\n  //console.log(q);\n  //if (isCubicBezier(q)) console.log(`is cubic`);\n  //const bzr = isCubicBezier(q) ? new BezierLibrary(to2d(q.a), to2d(q.cubic1), to2d(q.cubic2), to2d(q.b)) : new BezierLibrary(q.a, q.quadratic, q.b);\n  const bzr = isCubicBezier(q) ?\n    new BezierLibrary(q.a.x, q.a.y, q.cubic1.x, q.cubic1.y, q.cubic2.x, q.cubic2.y, q.b.x, q.b.y) :\n    new BezierLibrary(q.a, q.quadratic, q.b);\n\n  return (amount: number) => bzr.compute(amount);\n};\n\n//https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\nexport const quadraticToSvgString = (start: Point, end: Point, handle: Point): ReadonlyArray<string> => [ `M ${ start.x } ${ start.y } Q ${ handle.x } ${ handle.y } ${ end.x } ${ end.y }` ];\n\nexport const toPath = (cubicOrQuadratic: CubicBezier | QuadraticBezier): CubicBezierPath | QuadraticBezierPath => {\n  if (isCubicBezier(cubicOrQuadratic)) {\n    return cubicToPath(cubicOrQuadratic);\n  } else if (isQuadraticBezier(cubicOrQuadratic)) {\n    return quadratictoPath(cubicOrQuadratic);\n  } else {\n    throw new Error(`Unknown bezier type`);\n  }\n};\n\nexport const cubic = (start: Point, end: Point, cubic1: Point, cubic2: Point): CubicBezier => (\n  {\n    a: Object.freeze(start),\n    b: Object.freeze(end),\n    cubic1: Object.freeze(cubic1),\n    cubic2: Object.freeze(cubic2)\n  });\n\nconst cubicToPath = (cubic: CubicBezier): CubicBezierPath => {\n  const { a, cubic1, cubic2, b } = cubic;\n\n  const bzr = new BezierLibrary(a, cubic1, cubic2, b);\n  return Object.freeze({\n    ...cubic,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n    },\n    toSvgString: () => [ `brrup` ],\n    kind: `bezier/cubic`\n  });\n};\n\nexport const quadratic = (start: Point, end: Point, handle: Point): QuadraticBezier => ({\n  a: Object.freeze(start),\n  b: Object.freeze(end),\n  quadratic: Object.freeze(handle)\n});\n\n\nconst quadratictoPath = (quadraticBezier: QuadraticBezier): QuadraticBezierPath => {\n  const { a, b, quadratic } = quadraticBezier;\n  const bzr = new BezierLibrary(a, quadratic, b);\n  return Object.freeze({\n    ...quadraticBezier,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    toString: () => bzr.toString(),\n    toSvgString: () => quadraticToSvgString(a, b, quadratic),\n    kind: `bezier/quadratic`\n  });\n};\n\n","import { Bezier } from \"./bezier.js\";\n\n// math-inlining.\nconst { abs, cos, sin, acos, atan2, sqrt, pow } = Math;\n\n// cube root function yielding real roots\nfunction crt(v) {\n  return v < 0 ? -pow(-v, 1 / 3) : pow(v, 1 / 3);\n}\n\n// trig constants\nconst pi = Math.PI,\n  tau = 2 * pi,\n  quart = pi / 2,\n  // float precision significant decimal\n  epsilon = 0.000001,\n  // extremas used in bbox calculation and similar algorithms\n  nMax = Number.MAX_SAFE_INTEGER || 9007199254740991,\n  nMin = Number.MIN_SAFE_INTEGER || -9007199254740991,\n  // a zero coordinate, which is surprisingly useful\n  ZERO = { x: 0, y: 0, z: 0 };\n\n// Bezier utility functions\nconst utils = {\n  // Legendre-Gauss abscissae with n=24 (x_i values, defined at i=n as the roots of the nth order Legendre polynomial Pn(x))\n  Tvalues: [\n    -0.0640568928626056260850430826247450385909,\n    0.0640568928626056260850430826247450385909,\n    -0.1911188674736163091586398207570696318404,\n    0.1911188674736163091586398207570696318404,\n    -0.3150426796961633743867932913198102407864,\n    0.3150426796961633743867932913198102407864,\n    -0.4337935076260451384870842319133497124524,\n    0.4337935076260451384870842319133497124524,\n    -0.5454214713888395356583756172183723700107,\n    0.5454214713888395356583756172183723700107,\n    -0.6480936519369755692524957869107476266696,\n    0.6480936519369755692524957869107476266696,\n    -0.7401241915785543642438281030999784255232,\n    0.7401241915785543642438281030999784255232,\n    -0.8200019859739029219539498726697452080761,\n    0.8200019859739029219539498726697452080761,\n    -0.8864155270044010342131543419821967550873,\n    0.8864155270044010342131543419821967550873,\n    -0.9382745520027327585236490017087214496548,\n    0.9382745520027327585236490017087214496548,\n    -0.9747285559713094981983919930081690617411,\n    0.9747285559713094981983919930081690617411,\n    -0.9951872199970213601799974097007368118745,\n    0.9951872199970213601799974097007368118745,\n  ],\n\n  // Legendre-Gauss weights with n=24 (w_i values, defined by a function linked to in the Bezier primer article)\n  Cvalues: [\n    0.1279381953467521569740561652246953718517,\n    0.1279381953467521569740561652246953718517,\n    0.1258374563468282961213753825111836887264,\n    0.1258374563468282961213753825111836887264,\n    0.121670472927803391204463153476262425607,\n    0.121670472927803391204463153476262425607,\n    0.1155056680537256013533444839067835598622,\n    0.1155056680537256013533444839067835598622,\n    0.1074442701159656347825773424466062227946,\n    0.1074442701159656347825773424466062227946,\n    0.0976186521041138882698806644642471544279,\n    0.0976186521041138882698806644642471544279,\n    0.086190161531953275917185202983742667185,\n    0.086190161531953275917185202983742667185,\n    0.0733464814110803057340336152531165181193,\n    0.0733464814110803057340336152531165181193,\n    0.0592985849154367807463677585001085845412,\n    0.0592985849154367807463677585001085845412,\n    0.0442774388174198061686027482113382288593,\n    0.0442774388174198061686027482113382288593,\n    0.0285313886289336631813078159518782864491,\n    0.0285313886289336631813078159518782864491,\n    0.0123412297999871995468056670700372915759,\n    0.0123412297999871995468056670700372915759,\n  ],\n\n  arcfn: function (t, derivativeFn) {\n    const d = derivativeFn(t);\n    let l = d.x * d.x + d.y * d.y;\n    if (typeof d.z !== \"undefined\") {\n      l += d.z * d.z;\n    }\n    return sqrt(l);\n  },\n\n  compute: function (t, points, _3d) {\n    // shortcuts\n    if (t === 0) {\n      points[0].t = 0;\n      return points[0];\n    }\n\n    const order = points.length - 1;\n\n    if (t === 1) {\n      points[order].t = 1;\n      return points[order];\n    }\n\n    const mt = 1 - t;\n    let p = points;\n\n    // constant?\n    if (order === 0) {\n      points[0].t = t;\n      return points[0];\n    }\n\n    // linear?\n    if (order === 1) {\n      const ret = {\n        x: mt * p[0].x + t * p[1].x,\n        y: mt * p[0].y + t * p[1].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = mt * p[0].z + t * p[1].z;\n      }\n      return ret;\n    }\n\n    // quadratic/cubic curve?\n    if (order < 4) {\n      let mt2 = mt * mt,\n        t2 = t * t,\n        a,\n        b,\n        c,\n        d = 0;\n      if (order === 2) {\n        p = [p[0], p[1], p[2], ZERO];\n        a = mt2;\n        b = mt * t * 2;\n        c = t2;\n      } else if (order === 3) {\n        a = mt2 * mt;\n        b = mt2 * t * 3;\n        c = mt * t2 * 3;\n        d = t * t2;\n      }\n      const ret = {\n        x: a * p[0].x + b * p[1].x + c * p[2].x + d * p[3].x,\n        y: a * p[0].y + b * p[1].y + c * p[2].y + d * p[3].y,\n        t: t,\n      };\n      if (_3d) {\n        ret.z = a * p[0].z + b * p[1].z + c * p[2].z + d * p[3].z;\n      }\n      return ret;\n    }\n\n    // higher order curves: use de Casteljau's computation\n    const dCpts = JSON.parse(JSON.stringify(points));\n    while (dCpts.length > 1) {\n      for (let i = 0; i < dCpts.length - 1; i++) {\n        dCpts[i] = {\n          x: dCpts[i].x + (dCpts[i + 1].x - dCpts[i].x) * t,\n          y: dCpts[i].y + (dCpts[i + 1].y - dCpts[i].y) * t,\n        };\n        if (typeof dCpts[i].z !== \"undefined\") {\n          dCpts[i].z = dCpts[i].z + (dCpts[i + 1].z - dCpts[i].z) * t;\n        }\n      }\n      dCpts.splice(dCpts.length - 1, 1);\n    }\n    dCpts[0].t = t;\n    return dCpts[0];\n  },\n\n  computeWithRatios: function (t, points, ratios, _3d) {\n    const mt = 1 - t,\n      r = ratios,\n      p = points;\n\n    let f1 = r[0],\n      f2 = r[1],\n      f3 = r[2],\n      f4 = r[3],\n      d;\n\n    // spec for linear\n    f1 *= mt;\n    f2 *= t;\n\n    if (p.length === 2) {\n      d = f1 + f2;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to quadratic\n    f1 *= mt;\n    f2 *= 2 * mt;\n    f3 *= t * t;\n\n    if (p.length === 3) {\n      d = f1 + f2 + f3;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y) / d,\n        z: !_3d ? false : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z) / d,\n        t: t,\n      };\n    }\n\n    // upgrade to cubic\n    f1 *= mt;\n    f2 *= 1.5 * mt;\n    f3 *= 3 * mt;\n    f4 *= t * t * t;\n\n    if (p.length === 4) {\n      d = f1 + f2 + f3 + f4;\n      return {\n        x: (f1 * p[0].x + f2 * p[1].x + f3 * p[2].x + f4 * p[3].x) / d,\n        y: (f1 * p[0].y + f2 * p[1].y + f3 * p[2].y + f4 * p[3].y) / d,\n        z: !_3d\n          ? false\n          : (f1 * p[0].z + f2 * p[1].z + f3 * p[2].z + f4 * p[3].z) / d,\n        t: t,\n      };\n    }\n  },\n\n  derive: function (points, _3d) {\n    const dpoints = [];\n    for (let p = points, d = p.length, c = d - 1; d > 1; d--, c--) {\n      const list = [];\n      for (let j = 0, dpt; j < c; j++) {\n        dpt = {\n          x: c * (p[j + 1].x - p[j].x),\n          y: c * (p[j + 1].y - p[j].y),\n        };\n        if (_3d) {\n          dpt.z = c * (p[j + 1].z - p[j].z);\n        }\n        list.push(dpt);\n      }\n      dpoints.push(list);\n      p = list;\n    }\n    return dpoints;\n  },\n\n  between: function (v, m, M) {\n    return (\n      (m <= v && v <= M) ||\n      utils.approximately(v, m) ||\n      utils.approximately(v, M)\n    );\n  },\n\n  approximately: function (a, b, precision) {\n    return abs(a - b) <= (precision || epsilon);\n  },\n\n  length: function (derivativeFn) {\n    const z = 0.5,\n      len = utils.Tvalues.length;\n\n    let sum = 0;\n\n    for (let i = 0, t; i < len; i++) {\n      t = z * utils.Tvalues[i] + z;\n      sum += utils.Cvalues[i] * utils.arcfn(t, derivativeFn);\n    }\n    return z * sum;\n  },\n\n  map: function (v, ds, de, ts, te) {\n    const d1 = de - ds,\n      d2 = te - ts,\n      v2 = v - ds,\n      r = v2 / d1;\n    return ts + d2 * r;\n  },\n\n  lerp: function (r, v1, v2) {\n    const ret = {\n      x: v1.x + r * (v2.x - v1.x),\n      y: v1.y + r * (v2.y - v1.y),\n    };\n    if (v1.z !== undefined && v2.z !== undefined) {\n      ret.z = v1.z + r * (v2.z - v1.z);\n    }\n    return ret;\n  },\n\n  pointToString: function (p) {\n    let s = p.x + \"/\" + p.y;\n    if (typeof p.z !== \"undefined\") {\n      s += \"/\" + p.z;\n    }\n    return s;\n  },\n\n  pointsToString: function (points) {\n    return \"[\" + points.map(utils.pointToString).join(\", \") + \"]\";\n  },\n\n  copy: function (obj) {\n    return JSON.parse(JSON.stringify(obj));\n  },\n\n  angle: function (o, v1, v2) {\n    const dx1 = v1.x - o.x,\n      dy1 = v1.y - o.y,\n      dx2 = v2.x - o.x,\n      dy2 = v2.y - o.y,\n      cross = dx1 * dy2 - dy1 * dx2,\n      dot = dx1 * dx2 + dy1 * dy2;\n    return atan2(cross, dot);\n  },\n\n  // round as string, to avoid rounding errors\n  round: function (v, d) {\n    const s = \"\" + v;\n    const pos = s.indexOf(\".\");\n    return parseFloat(s.substring(0, pos + 1 + d));\n  },\n\n  dist: function (p1, p2) {\n    const dx = p1.x - p2.x,\n      dy = p1.y - p2.y;\n    return sqrt(dx * dx + dy * dy);\n  },\n\n  closest: function (LUT, point) {\n    let mdist = pow(2, 63),\n      mpos,\n      d;\n    LUT.forEach(function (p, idx) {\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        mpos = idx;\n      }\n    });\n    return { mdist: mdist, mpos: mpos };\n  },\n\n  abcratio: function (t, n) {\n    // see ratio(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const bottom = pow(t, n) + pow(1 - t, n),\n      top = bottom - 1;\n    return abs(top / bottom);\n  },\n\n  projectionratio: function (t, n) {\n    // see u(t) note on http://pomax.github.io/bezierinfo/#abc\n    if (n !== 2 && n !== 3) {\n      return false;\n    }\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    } else if (t === 0 || t === 1) {\n      return t;\n    }\n    const top = pow(1 - t, n),\n      bottom = pow(t, n) + top;\n    return top / bottom;\n  },\n\n  lli8: function (x1, y1, x2, y2, x3, y3, x4, y4) {\n    const nx =\n        (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4),\n      ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4),\n      d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n    if (d == 0) {\n      return false;\n    }\n    return { x: nx / d, y: ny / d };\n  },\n\n  lli4: function (p1, p2, p3, p4) {\n    const x1 = p1.x,\n      y1 = p1.y,\n      x2 = p2.x,\n      y2 = p2.y,\n      x3 = p3.x,\n      y3 = p3.y,\n      x4 = p4.x,\n      y4 = p4.y;\n    return utils.lli8(x1, y1, x2, y2, x3, y3, x4, y4);\n  },\n\n  lli: function (v1, v2) {\n    return utils.lli4(v1, v1.c, v2, v2.c);\n  },\n\n  makeline: function (p1, p2) {\n    return new Bezier(\n      p1.x,\n      p1.y,\n      (p1.x + p2.x) / 2,\n      (p1.y + p2.y) / 2,\n      p2.x,\n      p2.y\n    );\n  },\n\n  findbbox: function (sections) {\n    let mx = nMax,\n      my = nMax,\n      MX = nMin,\n      MY = nMin;\n    sections.forEach(function (s) {\n      const bbox = s.bbox();\n      if (mx > bbox.x.min) mx = bbox.x.min;\n      if (my > bbox.y.min) my = bbox.y.min;\n      if (MX < bbox.x.max) MX = bbox.x.max;\n      if (MY < bbox.y.max) MY = bbox.y.max;\n    });\n    return {\n      x: { min: mx, mid: (mx + MX) / 2, max: MX, size: MX - mx },\n      y: { min: my, mid: (my + MY) / 2, max: MY, size: MY - my },\n    };\n  },\n\n  shapeintersections: function (\n    s1,\n    bbox1,\n    s2,\n    bbox2,\n    curveIntersectionThreshold\n  ) {\n    if (!utils.bboxoverlap(bbox1, bbox2)) return [];\n    const intersections = [];\n    const a1 = [s1.startcap, s1.forward, s1.back, s1.endcap];\n    const a2 = [s2.startcap, s2.forward, s2.back, s2.endcap];\n    a1.forEach(function (l1) {\n      if (l1.virtual) return;\n      a2.forEach(function (l2) {\n        if (l2.virtual) return;\n        const iss = l1.intersects(l2, curveIntersectionThreshold);\n        if (iss.length > 0) {\n          iss.c1 = l1;\n          iss.c2 = l2;\n          iss.s1 = s1;\n          iss.s2 = s2;\n          intersections.push(iss);\n        }\n      });\n    });\n    return intersections;\n  },\n\n  makeshape: function (forward, back, curveIntersectionThreshold) {\n    const bpl = back.points.length;\n    const fpl = forward.points.length;\n    const start = utils.makeline(back.points[bpl - 1], forward.points[0]);\n    const end = utils.makeline(forward.points[fpl - 1], back.points[0]);\n    const shape = {\n      startcap: start,\n      forward: forward,\n      back: back,\n      endcap: end,\n      bbox: utils.findbbox([start, forward, back, end]),\n    };\n    shape.intersections = function (s2) {\n      return utils.shapeintersections(\n        shape,\n        shape.bbox,\n        s2,\n        s2.bbox,\n        curveIntersectionThreshold\n      );\n    };\n    return shape;\n  },\n\n  getminmax: function (curve, d, list) {\n    if (!list) return { min: 0, max: 0 };\n    let min = nMax,\n      max = nMin,\n      t,\n      c;\n    if (list.indexOf(0) === -1) {\n      list = [0].concat(list);\n    }\n    if (list.indexOf(1) === -1) {\n      list.push(1);\n    }\n    for (let i = 0, len = list.length; i < len; i++) {\n      t = list[i];\n      c = curve.get(t);\n      if (c[d] < min) {\n        min = c[d];\n      }\n      if (c[d] > max) {\n        max = c[d];\n      }\n    }\n    return { min: min, mid: (min + max) / 2, max: max, size: max - min };\n  },\n\n  align: function (points, line) {\n    const tx = line.p1.x,\n      ty = line.p1.y,\n      a = -atan2(line.p2.y - ty, line.p2.x - tx),\n      d = function (v) {\n        return {\n          x: (v.x - tx) * cos(a) - (v.y - ty) * sin(a),\n          y: (v.x - tx) * sin(a) + (v.y - ty) * cos(a),\n        };\n      };\n    return points.map(d);\n  },\n\n  roots: function (points, line) {\n    line = line || { p1: { x: 0, y: 0 }, p2: { x: 1, y: 0 } };\n\n    const order = points.length - 1;\n    const aligned = utils.align(points, line);\n    const reduce = function (t) {\n      return 0 <= t && t <= 1;\n    };\n\n    if (order === 2) {\n      const a = aligned[0].y,\n        b = aligned[1].y,\n        c = aligned[2].y,\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2].filter(reduce);\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * b - 2 * c)].filter(reduce);\n      }\n      return [];\n    }\n\n    // see http://www.trans4mind.com/personal_development/mathematics/polynomials/cubicAlgebra.htm\n    const pa = aligned[0].y,\n      pb = aligned[1].y,\n      pc = aligned[2].y,\n      pd = aligned[3].y;\n\n    let d = -pa + 3 * pb - 3 * pc + pd,\n      a = 3 * pa - 6 * pb + 3 * pc,\n      b = -3 * pa + 3 * pb,\n      c = pa;\n\n    if (utils.approximately(d, 0)) {\n      // this is not a cubic curve.\n      if (utils.approximately(a, 0)) {\n        // in fact, this is not a quadratic curve either.\n        if (utils.approximately(b, 0)) {\n          // in fact in fact, there are no solutions.\n          return [];\n        }\n        // linear solution:\n        return [-c / b].filter(reduce);\n      }\n      // quadratic solution:\n      const q = sqrt(b * b - 4 * a * c),\n        a2 = 2 * a;\n      return [(q - b) / a2, (-b - q) / a2].filter(reduce);\n    }\n\n    // at this point, we know we need a cubic solution:\n\n    a /= d;\n    b /= d;\n    c /= d;\n\n    const p = (3 * b - a * a) / 3,\n      p3 = p / 3,\n      q = (2 * a * a * a - 9 * a * b + 27 * c) / 27,\n      q2 = q / 2,\n      discriminant = q2 * q2 + p3 * p3 * p3;\n\n    let u1, v1, x1, x2, x3;\n    if (discriminant < 0) {\n      const mp3 = -p / 3,\n        mp33 = mp3 * mp3 * mp3,\n        r = sqrt(mp33),\n        t = -q / (2 * r),\n        cosphi = t < -1 ? -1 : t > 1 ? 1 : t,\n        phi = acos(cosphi),\n        crtr = crt(r),\n        t1 = 2 * crtr;\n      x1 = t1 * cos(phi / 3) - a / 3;\n      x2 = t1 * cos((phi + tau) / 3) - a / 3;\n      x3 = t1 * cos((phi + 2 * tau) / 3) - a / 3;\n      return [x1, x2, x3].filter(reduce);\n    } else if (discriminant === 0) {\n      u1 = q2 < 0 ? crt(-q2) : -crt(q2);\n      x1 = 2 * u1 - a / 3;\n      x2 = -u1 - a / 3;\n      return [x1, x2].filter(reduce);\n    } else {\n      const sd = sqrt(discriminant);\n      u1 = crt(-q2 + sd);\n      v1 = crt(q2 + sd);\n      return [u1 - v1 - a / 3].filter(reduce);\n    }\n  },\n\n  droots: function (p) {\n    // quadratic roots are easy\n    if (p.length === 3) {\n      const a = p[0],\n        b = p[1],\n        c = p[2],\n        d = a - 2 * b + c;\n      if (d !== 0) {\n        const m1 = -sqrt(b * b - a * c),\n          m2 = -a + b,\n          v1 = -(m1 + m2) / d,\n          v2 = -(-m1 + m2) / d;\n        return [v1, v2];\n      } else if (b !== c && d === 0) {\n        return [(2 * b - c) / (2 * (b - c))];\n      }\n      return [];\n    }\n\n    // linear roots are even easier\n    if (p.length === 2) {\n      const a = p[0],\n        b = p[1];\n      if (a !== b) {\n        return [a / (a - b)];\n      }\n      return [];\n    }\n\n    return [];\n  },\n\n  curvature: function (t, d1, d2, _3d, kOnly) {\n    let num,\n      dnm,\n      adk,\n      dk,\n      k = 0,\n      r = 0;\n\n    //\n    // We're using the following formula for curvature:\n    //\n    //              x'y\" - y'x\"\n    //   k(t) = ------------------\n    //           (x' + y')^(3/2)\n    //\n    // from https://en.wikipedia.org/wiki/Radius_of_curvature#Definition\n    //\n    // With it corresponding 3D counterpart:\n    //\n    //          sqrt( (y'z\" - y\"z') + (z'x\" - z\"x') + (x'y\" - x\"y'))\n    //   k(t) = -------------------------------------------------------\n    //                     (x' + y' + z')^(3/2)\n    //\n\n    const d = utils.compute(t, d1);\n    const dd = utils.compute(t, d2);\n    const qdsum = d.x * d.x + d.y * d.y;\n\n    if (_3d) {\n      num = sqrt(\n        pow(d.y * dd.z - dd.y * d.z, 2) +\n          pow(d.z * dd.x - dd.z * d.x, 2) +\n          pow(d.x * dd.y - dd.x * d.y, 2)\n      );\n      dnm = pow(qdsum + d.z * d.z, 3 / 2);\n    } else {\n      num = d.x * dd.y - d.y * dd.x;\n      dnm = pow(qdsum, 3 / 2);\n    }\n\n    if (num === 0 || dnm === 0) {\n      return { k: 0, r: 0 };\n    }\n\n    k = num / dnm;\n    r = dnm / num;\n\n    // We're also computing the derivative of kappa, because\n    // there is value in knowing the rate of change for the\n    // curvature along the curve. And we're just going to\n    // ballpark it based on an epsilon.\n    if (!kOnly) {\n      // compute k'(t) based on the interval before, and after it,\n      // to at least try to not introduce forward/backward pass bias.\n      const pk = utils.curvature(t - 0.001, d1, d2, _3d, true).k;\n      const nk = utils.curvature(t + 0.001, d1, d2, _3d, true).k;\n      dk = (nk - k + (k - pk)) / 2;\n      adk = (abs(nk - k) + abs(k - pk)) / 2;\n    }\n\n    return { k: k, r: r, dk: dk, adk: adk };\n  },\n\n  inflections: function (points) {\n    if (points.length < 4) return [];\n\n    // FIXME: TODO: add in inflection abstraction for quartic+ curves?\n\n    const p = utils.align(points, { p1: points[0], p2: points.slice(-1)[0] }),\n      a = p[2].x * p[1].y,\n      b = p[3].x * p[1].y,\n      c = p[1].x * p[2].y,\n      d = p[3].x * p[2].y,\n      v1 = 18 * (-3 * a + 2 * b + 3 * c - d),\n      v2 = 18 * (3 * a - b - 3 * c),\n      v3 = 18 * (c - a);\n\n    if (utils.approximately(v1, 0)) {\n      if (!utils.approximately(v2, 0)) {\n        let t = -v3 / v2;\n        if (0 <= t && t <= 1) return [t];\n      }\n      return [];\n    }\n\n    const d2 = 2 * v1;\n\n    if (utils.approximately(d2, 0)) return [];\n\n    const trm = v2 * v2 - 4 * v1 * v3;\n\n    if (trm < 0) return [];\n\n    const sq = Math.sqrt(trm);\n\n    return [(sq - v2) / d2, -(v2 + sq) / d2].filter(function (r) {\n      return 0 <= r && r <= 1;\n    });\n  },\n\n  bboxoverlap: function (b1, b2) {\n    const dims = [\"x\", \"y\"],\n      len = dims.length;\n\n    for (let i = 0, dim, l, t, d; i < len; i++) {\n      dim = dims[i];\n      l = b1[dim].mid;\n      t = b2[dim].mid;\n      d = (b1[dim].size + b2[dim].size) / 2;\n      if (abs(l - t) >= d) return false;\n    }\n    return true;\n  },\n\n  expandbox: function (bbox, _bbox) {\n    if (_bbox.x.min < bbox.x.min) {\n      bbox.x.min = _bbox.x.min;\n    }\n    if (_bbox.y.min < bbox.y.min) {\n      bbox.y.min = _bbox.y.min;\n    }\n    if (_bbox.z && _bbox.z.min < bbox.z.min) {\n      bbox.z.min = _bbox.z.min;\n    }\n    if (_bbox.x.max > bbox.x.max) {\n      bbox.x.max = _bbox.x.max;\n    }\n    if (_bbox.y.max > bbox.y.max) {\n      bbox.y.max = _bbox.y.max;\n    }\n    if (_bbox.z && _bbox.z.max > bbox.z.max) {\n      bbox.z.max = _bbox.z.max;\n    }\n    bbox.x.mid = (bbox.x.min + bbox.x.max) / 2;\n    bbox.y.mid = (bbox.y.min + bbox.y.max) / 2;\n    if (bbox.z) {\n      bbox.z.mid = (bbox.z.min + bbox.z.max) / 2;\n    }\n    bbox.x.size = bbox.x.max - bbox.x.min;\n    bbox.y.size = bbox.y.max - bbox.y.min;\n    if (bbox.z) {\n      bbox.z.size = bbox.z.max - bbox.z.min;\n    }\n  },\n\n  pairiteration: function (c1, c2, curveIntersectionThreshold) {\n    const c1b = c1.bbox(),\n      c2b = c2.bbox(),\n      r = 100000,\n      threshold = curveIntersectionThreshold || 0.5;\n\n    if (\n      c1b.x.size + c1b.y.size < threshold &&\n      c2b.x.size + c2b.y.size < threshold\n    ) {\n      return [\n        (((r * (c1._t1 + c1._t2)) / 2) | 0) / r +\n          \"/\" +\n          (((r * (c2._t1 + c2._t2)) / 2) | 0) / r,\n      ];\n    }\n\n    let cc1 = c1.split(0.5),\n      cc2 = c2.split(0.5),\n      pairs = [\n        { left: cc1.left, right: cc2.left },\n        { left: cc1.left, right: cc2.right },\n        { left: cc1.right, right: cc2.right },\n        { left: cc1.right, right: cc2.left },\n      ];\n\n    pairs = pairs.filter(function (pair) {\n      return utils.bboxoverlap(pair.left.bbox(), pair.right.bbox());\n    });\n\n    let results = [];\n\n    if (pairs.length === 0) return results;\n\n    pairs.forEach(function (pair) {\n      results = results.concat(\n        utils.pairiteration(pair.left, pair.right, threshold)\n      );\n    });\n\n    results = results.filter(function (v, i) {\n      return results.indexOf(v) === i;\n    });\n\n    return results;\n  },\n\n  getccenter: function (p1, p2, p3) {\n    const dx1 = p2.x - p1.x,\n      dy1 = p2.y - p1.y,\n      dx2 = p3.x - p2.x,\n      dy2 = p3.y - p2.y,\n      dx1p = dx1 * cos(quart) - dy1 * sin(quart),\n      dy1p = dx1 * sin(quart) + dy1 * cos(quart),\n      dx2p = dx2 * cos(quart) - dy2 * sin(quart),\n      dy2p = dx2 * sin(quart) + dy2 * cos(quart),\n      // chord midpoints\n      mx1 = (p1.x + p2.x) / 2,\n      my1 = (p1.y + p2.y) / 2,\n      mx2 = (p2.x + p3.x) / 2,\n      my2 = (p2.y + p3.y) / 2,\n      // midpoint offsets\n      mx1n = mx1 + dx1p,\n      my1n = my1 + dy1p,\n      mx2n = mx2 + dx2p,\n      my2n = my2 + dy2p,\n      // intersection of these lines:\n      arc = utils.lli8(mx1, my1, mx1n, my1n, mx2, my2, mx2n, my2n),\n      r = utils.dist(arc, p1);\n\n    // arc start/end values, over mid point:\n    let s = atan2(p1.y - arc.y, p1.x - arc.x),\n      m = atan2(p2.y - arc.y, p2.x - arc.x),\n      e = atan2(p3.y - arc.y, p3.x - arc.x),\n      _;\n\n    // determine arc direction (cw/ccw correction)\n    if (s < e) {\n      // if s<m<e, arc(s, e)\n      // if m<s<e, arc(e, s + tau)\n      // if s<e<m, arc(e, s + tau)\n      if (s > m || m > e) {\n        s += tau;\n      }\n      if (s > e) {\n        _ = e;\n        e = s;\n        s = _;\n      }\n    } else {\n      // if e<m<s, arc(e, s)\n      // if m<e<s, arc(s, e + tau)\n      // if e<s<m, arc(s, e + tau)\n      if (e < m && m < s) {\n        _ = e;\n        e = s;\n        s = _;\n      } else {\n        e += tau;\n      }\n    }\n    // assign and done.\n    arc.s = s;\n    arc.e = e;\n    arc.r = r;\n    return arc;\n  },\n\n  numberSort: function (a, b) {\n    return a - b;\n  },\n};\n\nexport { utils };\n","import { utils } from \"./utils.js\";\n\n/**\n * Poly Bezier\n * @param {[type]} curves [description]\n */\nclass PolyBezier {\n  constructor(curves) {\n    this.curves = [];\n    this._3d = false;\n    if (!!curves) {\n      this.curves = curves;\n      this._3d = this.curves[0]._3d;\n    }\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return (\n      \"[\" +\n      this.curves\n        .map(function (curve) {\n          return utils.pointsToString(curve.points);\n        })\n        .join(\", \") +\n      \"]\"\n    );\n  }\n\n  addCurve(curve) {\n    this.curves.push(curve);\n    this._3d = this._3d || curve._3d;\n  }\n\n  length() {\n    return this.curves\n      .map(function (v) {\n        return v.length();\n      })\n      .reduce(function (a, b) {\n        return a + b;\n      });\n  }\n\n  curve(idx) {\n    return this.curves[idx];\n  }\n\n  bbox() {\n    const c = this.curves;\n    var bbox = c[0].bbox();\n    for (var i = 1; i < c.length; i++) {\n      utils.expandbox(bbox, c[i].bbox());\n    }\n    return bbox;\n  }\n\n  offset(d) {\n    const offset = [];\n    this.curves.forEach(function (v) {\n      offset.push(...v.offset(d));\n    });\n    return new PolyBezier(offset);\n  }\n}\n\nexport { PolyBezier };\n","/**\n  A javascript Bezier curve library by Pomax.\n\n  Based on http://pomax.github.io/bezierinfo\n\n  This code is MIT licensed.\n**/\n\nimport { utils } from \"./utils.js\";\nimport { PolyBezier } from \"./poly-bezier.js\";\n\n// math-inlining.\nconst { abs, min, max, cos, sin, acos, sqrt } = Math;\nconst pi = Math.PI;\n// a zero coordinate, which is surprisingly useful\nconst ZERO = { x: 0, y: 0, z: 0 };\n\n/**\n * Bezier curve constructor.\n *\n * ...docs pending...\n */\nclass Bezier {\n  constructor(coords) {\n    let args =\n      coords && coords.forEach ? coords : Array.from(arguments).slice();\n    let coordlen = false;\n\n    if (typeof args[0] === \"object\") {\n      coordlen = args.length;\n      const newargs = [];\n      args.forEach(function (point) {\n        [\"x\", \"y\", \"z\"].forEach(function (d) {\n          if (typeof point[d] !== \"undefined\") {\n            newargs.push(point[d]);\n          }\n        });\n      });\n      args = newargs;\n    }\n\n    let higher = false;\n    const len = args.length;\n\n    if (coordlen) {\n      if (coordlen > 4) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n        higher = true;\n      }\n    } else {\n      if (len !== 6 && len !== 8 && len !== 9 && len !== 12) {\n        if (arguments.length !== 1) {\n          throw new Error(\n            \"Only new Bezier(point[]) is accepted for 4th and higher order curves\"\n          );\n        }\n      }\n    }\n\n    const _3d = (this._3d =\n      (!higher && (len === 9 || len === 12)) ||\n      (coords && coords[0] && typeof coords[0].z !== \"undefined\"));\n\n    const points = (this.points = []);\n    for (let idx = 0, step = _3d ? 3 : 2; idx < len; idx += step) {\n      var point = {\n        x: args[idx],\n        y: args[idx + 1],\n      };\n      if (_3d) {\n        point.z = args[idx + 2];\n      }\n      points.push(point);\n    }\n    const order = (this.order = points.length - 1);\n\n    const dims = (this.dims = [\"x\", \"y\"]);\n    if (_3d) dims.push(\"z\");\n    this.dimlen = dims.length;\n\n    // is this curve, practically speaking, a straight line?\n    const aligned = utils.align(points, { p1: points[0], p2: points[order] });\n    const baselength = utils.dist(points[0], points[order]);\n    this._linear = aligned.reduce((t, p) => t + abs(p.y), 0) < baselength / 50;\n\n    this._lut = [];\n    this._t1 = 0;\n    this._t2 = 1;\n    this.update();\n  }\n\n  static quadraticFromPoints(p1, p2, p3, t) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    // shortcuts, although they're really dumb\n    if (t === 0) {\n      return new Bezier(p2, p2, p3);\n    }\n    if (t === 1) {\n      return new Bezier(p1, p2, p2);\n    }\n    // real fitting.\n    const abc = Bezier.getABC(2, p1, p2, p3, t);\n    return new Bezier(p1, abc.A, p3);\n  }\n\n  static cubicFromPoints(S, B, E, t, d1) {\n    if (typeof t === \"undefined\") {\n      t = 0.5;\n    }\n    const abc = Bezier.getABC(3, S, B, E, t);\n    if (typeof d1 === \"undefined\") {\n      d1 = utils.dist(B, abc.C);\n    }\n    const d2 = (d1 * (1 - t)) / t;\n\n    const selen = utils.dist(S, E),\n      lx = (E.x - S.x) / selen,\n      ly = (E.y - S.y) / selen,\n      bx1 = d1 * lx,\n      by1 = d1 * ly,\n      bx2 = d2 * lx,\n      by2 = d2 * ly;\n    // derivation of new hull coordinates\n    const e1 = { x: B.x - bx1, y: B.y - by1 },\n      e2 = { x: B.x + bx2, y: B.y + by2 },\n      A = abc.A,\n      v1 = { x: A.x + (e1.x - A.x) / (1 - t), y: A.y + (e1.y - A.y) / (1 - t) },\n      v2 = { x: A.x + (e2.x - A.x) / t, y: A.y + (e2.y - A.y) / t },\n      nc1 = { x: S.x + (v1.x - S.x) / t, y: S.y + (v1.y - S.y) / t },\n      nc2 = {\n        x: E.x + (v2.x - E.x) / (1 - t),\n        y: E.y + (v2.y - E.y) / (1 - t),\n      };\n    // ...done\n    return new Bezier(S, nc1, nc2, E);\n  }\n\n  static getUtils() {\n    return utils;\n  }\n\n  getUtils() {\n    return Bezier.getUtils();\n  }\n\n  static get PolyBezier() {\n    return PolyBezier;\n  }\n\n  valueOf() {\n    return this.toString();\n  }\n\n  toString() {\n    return utils.pointsToString(this.points);\n  }\n\n  toSVG() {\n    if (this._3d) return false;\n    const p = this.points,\n      x = p[0].x,\n      y = p[0].y,\n      s = [\"M\", x, y, this.order === 2 ? \"Q\" : \"C\"];\n    for (let i = 1, last = p.length; i < last; i++) {\n      s.push(p[i].x);\n      s.push(p[i].y);\n    }\n    return s.join(\" \");\n  }\n\n  setRatios(ratios) {\n    if (ratios.length !== this.points.length) {\n      throw new Error(\"incorrect number of ratio values\");\n    }\n    this.ratios = ratios;\n    this._lut = []; //  invalidate any precomputed LUT\n  }\n\n  verify() {\n    const print = this.coordDigest();\n    if (print !== this._print) {\n      this._print = print;\n      this.update();\n    }\n  }\n\n  coordDigest() {\n    return this.points\n      .map(function (c, pos) {\n        return \"\" + pos + c.x + c.y + (c.z ? c.z : 0);\n      })\n      .join(\"\");\n  }\n\n  update() {\n    // invalidate any precomputed LUT\n    this._lut = [];\n    this.dpoints = utils.derive(this.points, this._3d);\n    this.computedirection();\n  }\n\n  computedirection() {\n    const points = this.points;\n    const angle = utils.angle(points[0], points[this.order], points[1]);\n    this.clockwise = angle > 0;\n  }\n\n  length() {\n    return utils.length(this.derivative.bind(this));\n  }\n\n  static getABC(order = 2, S, B, E, t = 0.5) {\n    const u = utils.projectionratio(t, order),\n      um = 1 - u,\n      C = {\n        x: u * S.x + um * E.x,\n        y: u * S.y + um * E.y,\n      },\n      s = utils.abcratio(t, order),\n      A = {\n        x: B.x + (B.x - C.x) / s,\n        y: B.y + (B.y - C.y) / s,\n      };\n    return { A, B, C, S, E };\n  }\n\n  getABC(t, B) {\n    B = B || this.get(t);\n    let S = this.points[0];\n    let E = this.points[this.order];\n    return Bezier.getABC(this.order, S, B, E, t);\n  }\n\n  getLUT(steps) {\n    this.verify();\n    steps = steps || 100;\n    if (this._lut.length === steps + 1) {\n      return this._lut;\n    }\n    this._lut = [];\n    // n steps means n+1 points\n    steps++;\n    this._lut = [];\n    for (let i = 0, p, t; i < steps; i++) {\n      t = i / (steps - 1);\n      p = this.compute(t);\n      p.t = t;\n      this._lut.push(p);\n    }\n    return this._lut;\n  }\n\n  on(point, error) {\n    error = error || 5;\n    const lut = this.getLUT(),\n      hits = [];\n    for (let i = 0, c, t = 0; i < lut.length; i++) {\n      c = lut[i];\n      if (utils.dist(c, point) < error) {\n        hits.push(c);\n        t += i / lut.length;\n      }\n    }\n    if (!hits.length) return false;\n    return (t /= hits.length);\n  }\n\n  project(point) {\n    // step 1: coarse check\n    const LUT = this.getLUT(),\n      l = LUT.length - 1,\n      closest = utils.closest(LUT, point),\n      mpos = closest.mpos,\n      t1 = (mpos - 1) / l,\n      t2 = (mpos + 1) / l,\n      step = 0.1 / l;\n\n    // step 2: fine check\n    let mdist = closest.mdist,\n      t = t1,\n      ft = t,\n      p;\n    mdist += 1;\n    for (let d; t < t2 + step; t += step) {\n      p = this.compute(t);\n      d = utils.dist(point, p);\n      if (d < mdist) {\n        mdist = d;\n        ft = t;\n      }\n    }\n    ft = ft < 0 ? 0 : ft > 1 ? 1 : ft;\n    p = this.compute(ft);\n    p.t = ft;\n    p.d = mdist;\n    return p;\n  }\n\n  get(t) {\n    return this.compute(t);\n  }\n\n  point(idx) {\n    return this.points[idx];\n  }\n\n  compute(t) {\n    if (this.ratios) {\n      return utils.computeWithRatios(t, this.points, this.ratios, this._3d);\n    }\n    return utils.compute(t, this.points, this._3d, this.ratios);\n  }\n\n  raise() {\n    const p = this.points,\n      np = [p[0]],\n      k = p.length;\n    for (let i = 1, pi, pim; i < k; i++) {\n      pi = p[i];\n      pim = p[i - 1];\n      np[i] = {\n        x: ((k - i) / k) * pi.x + (i / k) * pim.x,\n        y: ((k - i) / k) * pi.y + (i / k) * pim.y,\n      };\n    }\n    np[k] = p[k - 1];\n    return new Bezier(np);\n  }\n\n  derivative(t) {\n    return utils.compute(t, this.dpoints[0], this._3d);\n  }\n\n  dderivative(t) {\n    return utils.compute(t, this.dpoints[1], this._3d);\n  }\n\n  align() {\n    let p = this.points;\n    return new Bezier(utils.align(p, { p1: p[0], p2: p[p.length - 1] }));\n  }\n\n  curvature(t) {\n    return utils.curvature(t, this.dpoints[0], this.dpoints[1], this._3d);\n  }\n\n  inflections() {\n    return utils.inflections(this.points);\n  }\n\n  normal(t) {\n    return this._3d ? this.__normal3(t) : this.__normal2(t);\n  }\n\n  __normal2(t) {\n    const d = this.derivative(t);\n    const q = sqrt(d.x * d.x + d.y * d.y);\n    return { t, x: -d.y / q, y: d.x / q };\n  }\n\n  __normal3(t) {\n    // see http://stackoverflow.com/questions/25453159\n    const r1 = this.derivative(t),\n      r2 = this.derivative(t + 0.01),\n      q1 = sqrt(r1.x * r1.x + r1.y * r1.y + r1.z * r1.z),\n      q2 = sqrt(r2.x * r2.x + r2.y * r2.y + r2.z * r2.z);\n    r1.x /= q1;\n    r1.y /= q1;\n    r1.z /= q1;\n    r2.x /= q2;\n    r2.y /= q2;\n    r2.z /= q2;\n    // cross product\n    const c = {\n      x: r2.y * r1.z - r2.z * r1.y,\n      y: r2.z * r1.x - r2.x * r1.z,\n      z: r2.x * r1.y - r2.y * r1.x,\n    };\n    const m = sqrt(c.x * c.x + c.y * c.y + c.z * c.z);\n    c.x /= m;\n    c.y /= m;\n    c.z /= m;\n    // rotation matrix\n    const R = [\n      c.x * c.x,\n      c.x * c.y - c.z,\n      c.x * c.z + c.y,\n      c.x * c.y + c.z,\n      c.y * c.y,\n      c.y * c.z - c.x,\n      c.x * c.z - c.y,\n      c.y * c.z + c.x,\n      c.z * c.z,\n    ];\n    // normal vector:\n    const n = {\n      t,\n      x: R[0] * r1.x + R[1] * r1.y + R[2] * r1.z,\n      y: R[3] * r1.x + R[4] * r1.y + R[5] * r1.z,\n      z: R[6] * r1.x + R[7] * r1.y + R[8] * r1.z,\n    };\n    return n;\n  }\n\n  hull(t) {\n    let p = this.points,\n      _p = [],\n      q = [],\n      idx = 0;\n    q[idx++] = p[0];\n    q[idx++] = p[1];\n    q[idx++] = p[2];\n    if (this.order === 3) {\n      q[idx++] = p[3];\n    }\n    // we lerp between all points at each iteration, until we have 1 point left.\n    while (p.length > 1) {\n      _p = [];\n      for (let i = 0, pt, l = p.length - 1; i < l; i++) {\n        pt = utils.lerp(t, p[i], p[i + 1]);\n        q[idx++] = pt;\n        _p.push(pt);\n      }\n      p = _p;\n    }\n    return q;\n  }\n\n  split(t1, t2) {\n    // shortcuts\n    if (t1 === 0 && !!t2) {\n      return this.split(t2).left;\n    }\n    if (t2 === 1) {\n      return this.split(t1).right;\n    }\n\n    // no shortcut: use \"de Casteljau\" iteration.\n    const q = this.hull(t1);\n    const result = {\n      left:\n        this.order === 2\n          ? new Bezier([q[0], q[3], q[5]])\n          : new Bezier([q[0], q[4], q[7], q[9]]),\n      right:\n        this.order === 2\n          ? new Bezier([q[5], q[4], q[2]])\n          : new Bezier([q[9], q[8], q[6], q[3]]),\n      span: q,\n    };\n\n    // make sure we bind _t1/_t2 information!\n    result.left._t1 = utils.map(0, 0, 1, this._t1, this._t2);\n    result.left._t2 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t1 = utils.map(t1, 0, 1, this._t1, this._t2);\n    result.right._t2 = utils.map(1, 0, 1, this._t1, this._t2);\n\n    // if we have no t2, we're done\n    if (!t2) {\n      return result;\n    }\n\n    // if we have a t2, split again:\n    t2 = utils.map(t2, t1, 1, 0, 1);\n    return result.right.split(t2).left;\n  }\n\n  extrema() {\n    const result = {};\n    let roots = [];\n\n    this.dims.forEach(\n      function (dim) {\n        let mfn = function (v) {\n          return v[dim];\n        };\n        let p = this.dpoints[0].map(mfn);\n        result[dim] = utils.droots(p);\n        if (this.order === 3) {\n          p = this.dpoints[1].map(mfn);\n          result[dim] = result[dim].concat(utils.droots(p));\n        }\n        result[dim] = result[dim].filter(function (t) {\n          return t >= 0 && t <= 1;\n        });\n        roots = roots.concat(result[dim].sort(utils.numberSort));\n      }.bind(this)\n    );\n\n    result.values = roots.sort(utils.numberSort).filter(function (v, idx) {\n      return roots.indexOf(v) === idx;\n    });\n\n    return result;\n  }\n\n  bbox() {\n    const extrema = this.extrema(),\n      result = {};\n    this.dims.forEach(\n      function (d) {\n        result[d] = utils.getminmax(this, d, extrema[d]);\n      }.bind(this)\n    );\n    return result;\n  }\n\n  overlaps(curve) {\n    const lbbox = this.bbox(),\n      tbbox = curve.bbox();\n    return utils.bboxoverlap(lbbox, tbbox);\n  }\n\n  offset(t, d) {\n    if (typeof d !== \"undefined\") {\n      const c = this.get(t),\n        n = this.normal(t);\n      const ret = {\n        c: c,\n        n: n,\n        x: c.x + n.x * d,\n        y: c.y + n.y * d,\n      };\n      if (this._3d) {\n        ret.z = c.z + n.z * d;\n      }\n      return ret;\n    }\n    if (this._linear) {\n      const nv = this.normal(0),\n        coords = this.points.map(function (p) {\n          const ret = {\n            x: p.x + t * nv.x,\n            y: p.y + t * nv.y,\n          };\n          if (p.z && nv.z) {\n            ret.z = p.z + t * nv.z;\n          }\n          return ret;\n        });\n      return [new Bezier(coords)];\n    }\n    return this.reduce().map(function (s) {\n      if (s._linear) {\n        return s.offset(t)[0];\n      }\n      return s.scale(t);\n    });\n  }\n\n  simple() {\n    if (this.order === 3) {\n      const a1 = utils.angle(this.points[0], this.points[3], this.points[1]);\n      const a2 = utils.angle(this.points[0], this.points[3], this.points[2]);\n      if ((a1 > 0 && a2 < 0) || (a1 < 0 && a2 > 0)) return false;\n    }\n    const n1 = this.normal(0);\n    const n2 = this.normal(1);\n    let s = n1.x * n2.x + n1.y * n2.y;\n    if (this._3d) {\n      s += n1.z * n2.z;\n    }\n    return abs(acos(s)) < pi / 3;\n  }\n\n  reduce() {\n    // TODO: examine these var types in more detail...\n    let i,\n      t1 = 0,\n      t2 = 0,\n      step = 0.01,\n      segment,\n      pass1 = [],\n      pass2 = [];\n    // first pass: split on extrema\n    let extrema = this.extrema().values;\n    if (extrema.indexOf(0) === -1) {\n      extrema = [0].concat(extrema);\n    }\n    if (extrema.indexOf(1) === -1) {\n      extrema.push(1);\n    }\n\n    for (t1 = extrema[0], i = 1; i < extrema.length; i++) {\n      t2 = extrema[i];\n      segment = this.split(t1, t2);\n      segment._t1 = t1;\n      segment._t2 = t2;\n      pass1.push(segment);\n      t1 = t2;\n    }\n\n    // second pass: further reduce these segments to simple segments\n    pass1.forEach(function (p1) {\n      t1 = 0;\n      t2 = 0;\n      while (t2 <= 1) {\n        for (t2 = t1 + step; t2 <= 1 + step; t2 += step) {\n          segment = p1.split(t1, t2);\n          if (!segment.simple()) {\n            t2 -= step;\n            if (abs(t1 - t2) < step) {\n              // we can never form a reduction\n              return [];\n            }\n            segment = p1.split(t1, t2);\n            segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n            segment._t2 = utils.map(t2, 0, 1, p1._t1, p1._t2);\n            pass2.push(segment);\n            t1 = t2;\n            break;\n          }\n        }\n      }\n      if (t1 < 1) {\n        segment = p1.split(t1, 1);\n        segment._t1 = utils.map(t1, 0, 1, p1._t1, p1._t2);\n        segment._t2 = p1._t2;\n        pass2.push(segment);\n      }\n    });\n    return pass2;\n  }\n\n  translate(v, d1, d2) {\n    d2 = typeof d2 === \"number\" ? d2 : d1;\n\n    // TODO: make this take curves with control points outside\n    //       of the start-end interval into account\n\n    const o = this.order;\n    let d = this.points.map((_, i) => (1 - i / o) * d1 + (i / o) * d2);\n    return new Bezier(\n      this.points.map((p, i) => ({\n        x: p.x + v.x * d[i],\n        y: p.y + v.y * d[i],\n      }))\n    );\n  }\n\n  scale(d) {\n    const order = this.order;\n    let distanceFn = false;\n    if (typeof d === \"function\") {\n      distanceFn = d;\n    }\n    if (distanceFn && order === 2) {\n      return this.raise().scale(distanceFn);\n    }\n\n    // TODO: add special handling for non-linear degenerate curves.\n\n    const clockwise = this.clockwise;\n    const points = this.points;\n\n    if (this._linear) {\n      return this.translate(\n        this.normal(0),\n        distanceFn ? distanceFn(0) : d,\n        distanceFn ? distanceFn(1) : d\n      );\n    }\n\n    const r1 = distanceFn ? distanceFn(0) : d;\n    const r2 = distanceFn ? distanceFn(1) : d;\n    const v = [this.offset(0, 10), this.offset(1, 10)];\n    const np = [];\n    const o = utils.lli4(v[0], v[0].c, v[1], v[1].c);\n\n    if (!o) {\n      throw new Error(\"cannot scale this curve. Try reducing it first.\");\n    }\n\n    // move all points by distance 'd' wrt the origin 'o',\n    // and move end points by fixed distance along normal.\n    [0, 1].forEach(function (t) {\n      const p = (np[t * order] = utils.copy(points[t * order]));\n      p.x += (t ? r2 : r1) * v[t].n.x;\n      p.y += (t ? r2 : r1) * v[t].n.y;\n    });\n\n    if (!distanceFn) {\n      // move control points to lie on the intersection of the offset\n      // derivative vector, and the origin-through-control vector\n      [0, 1].forEach((t) => {\n        if (order === 2 && !!t) return;\n        const p = np[t * order];\n        const d = this.derivative(t);\n        const p2 = { x: p.x + d.x, y: p.y + d.y };\n        np[t + 1] = utils.lli4(p, p2, o, points[t + 1]);\n      });\n      return new Bezier(np);\n    }\n\n    // move control points by \"however much necessary to\n    // ensure the correct tangent to endpoint\".\n    [0, 1].forEach(function (t) {\n      if (order === 2 && !!t) return;\n      var p = points[t + 1];\n      var ov = {\n        x: p.x - o.x,\n        y: p.y - o.y,\n      };\n      var rc = distanceFn ? distanceFn((t + 1) / order) : d;\n      if (distanceFn && !clockwise) rc = -rc;\n      var m = sqrt(ov.x * ov.x + ov.y * ov.y);\n      ov.x /= m;\n      ov.y /= m;\n      np[t + 1] = {\n        x: p.x + rc * ov.x,\n        y: p.y + rc * ov.y,\n      };\n    });\n    return new Bezier(np);\n  }\n\n  outline(d1, d2, d3, d4) {\n    d2 = d2 === undefined ? d1 : d2;\n\n    if (this._linear) {\n      // TODO: find the actual extrema, because they might\n      //       be before the start, or past the end.\n\n      const n = this.normal(0);\n      const start = this.points[0];\n      const end = this.points[this.points.length - 1];\n      let s, mid, e;\n\n      if (d3 === undefined) {\n        d3 = d1;\n        d4 = d2;\n      }\n\n      s = { x: start.x + n.x * d1, y: start.y + n.y * d1 };\n      e = { x: end.x + n.x * d3, y: end.y + n.y * d3 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const fline = [s, mid, e];\n\n      s = { x: start.x - n.x * d2, y: start.y - n.y * d2 };\n      e = { x: end.x - n.x * d4, y: end.y - n.y * d4 };\n      mid = { x: (s.x + e.x) / 2, y: (s.y + e.y) / 2 };\n      const bline = [e, mid, s];\n\n      const ls = utils.makeline(bline[2], fline[0]);\n      const le = utils.makeline(fline[2], bline[0]);\n      const segments = [ls, new Bezier(fline), le, new Bezier(bline)];\n      return new PolyBezier(segments);\n    }\n\n    const reduced = this.reduce(),\n      len = reduced.length,\n      fcurves = [];\n\n    let bcurves = [],\n      p,\n      alen = 0,\n      tlen = this.length();\n\n    const graduated = typeof d3 !== \"undefined\" && typeof d4 !== \"undefined\";\n\n    function linearDistanceFunction(s, e, tlen, alen, slen) {\n      return function (v) {\n        const f1 = alen / tlen,\n          f2 = (alen + slen) / tlen,\n          d = e - s;\n        return utils.map(v, 0, 1, s + f1 * d, s + f2 * d);\n      };\n    }\n\n    // form curve oulines\n    reduced.forEach(function (segment) {\n      const slen = segment.length();\n      if (graduated) {\n        fcurves.push(\n          segment.scale(linearDistanceFunction(d1, d3, tlen, alen, slen))\n        );\n        bcurves.push(\n          segment.scale(linearDistanceFunction(-d2, -d4, tlen, alen, slen))\n        );\n      } else {\n        fcurves.push(segment.scale(d1));\n        bcurves.push(segment.scale(-d2));\n      }\n      alen += slen;\n    });\n\n    // reverse the \"return\" outline\n    bcurves = bcurves\n      .map(function (s) {\n        p = s.points;\n        if (p[3]) {\n          s.points = [p[3], p[2], p[1], p[0]];\n        } else {\n          s.points = [p[2], p[1], p[0]];\n        }\n        return s;\n      })\n      .reverse();\n\n    // form the endcaps as lines\n    const fs = fcurves[0].points[0],\n      fe = fcurves[len - 1].points[fcurves[len - 1].points.length - 1],\n      bs = bcurves[len - 1].points[bcurves[len - 1].points.length - 1],\n      be = bcurves[0].points[0],\n      ls = utils.makeline(bs, fs),\n      le = utils.makeline(fe, be),\n      segments = [ls].concat(fcurves).concat([le]).concat(bcurves);\n\n    return new PolyBezier(segments);\n  }\n\n  outlineshapes(d1, d2, curveIntersectionThreshold) {\n    d2 = d2 || d1;\n    const outline = this.outline(d1, d2).curves;\n    const shapes = [];\n    for (let i = 1, len = outline.length; i < len / 2; i++) {\n      const shape = utils.makeshape(\n        outline[i],\n        outline[len - i],\n        curveIntersectionThreshold\n      );\n      shape.startcap.virtual = i > 1;\n      shape.endcap.virtual = i < len / 2 - 1;\n      shapes.push(shape);\n    }\n    return shapes;\n  }\n\n  intersects(curve, curveIntersectionThreshold) {\n    if (!curve) return this.selfintersects(curveIntersectionThreshold);\n    if (curve.p1 && curve.p2) {\n      return this.lineIntersects(curve);\n    }\n    if (curve instanceof Bezier) {\n      curve = curve.reduce();\n    }\n    return this.curveintersects(\n      this.reduce(),\n      curve,\n      curveIntersectionThreshold\n    );\n  }\n\n  lineIntersects(line) {\n    const mx = min(line.p1.x, line.p2.x),\n      my = min(line.p1.y, line.p2.y),\n      MX = max(line.p1.x, line.p2.x),\n      MY = max(line.p1.y, line.p2.y);\n    return utils.roots(this.points, line).filter((t) => {\n      var p = this.get(t);\n      return utils.between(p.x, mx, MX) && utils.between(p.y, my, MY);\n    });\n  }\n\n  selfintersects(curveIntersectionThreshold) {\n    // \"simple\" curves cannot intersect with their direct\n    // neighbour, so for each segment X we check whether\n    // it intersects [0:x-2][x+2:last].\n\n    const reduced = this.reduce(),\n      len = reduced.length - 2,\n      results = [];\n\n    for (let i = 0, result, left, right; i < len; i++) {\n      left = reduced.slice(i, i + 1);\n      right = reduced.slice(i + 2);\n      result = this.curveintersects(left, right, curveIntersectionThreshold);\n      results.push(...result);\n    }\n    return results;\n  }\n\n  curveintersects(c1, c2, curveIntersectionThreshold) {\n    const pairs = [];\n    // step 1: pair off any overlapping segments\n    c1.forEach(function (l) {\n      c2.forEach(function (r) {\n        if (l.overlaps(r)) {\n          pairs.push({ left: l, right: r });\n        }\n      });\n    });\n    // step 2: for each pairing, run through the convergence algorithm.\n    let intersections = [];\n    pairs.forEach(function (pair) {\n      const result = utils.pairiteration(\n        pair.left,\n        pair.right,\n        curveIntersectionThreshold\n      );\n      if (result.length > 0) {\n        intersections = intersections.concat(result);\n      }\n    });\n    return intersections;\n  }\n\n  arcs(errorThreshold) {\n    errorThreshold = errorThreshold || 0.5;\n    return this._iterate(errorThreshold, []);\n  }\n\n  _error(pc, np1, s, e) {\n    const q = (e - s) / 4,\n      c1 = this.get(s + q),\n      c2 = this.get(e - q),\n      ref = utils.dist(pc, np1),\n      d1 = utils.dist(pc, c1),\n      d2 = utils.dist(pc, c2);\n    return abs(d1 - ref) + abs(d2 - ref);\n  }\n\n  _iterate(errorThreshold, circles) {\n    let t_s = 0,\n      t_e = 1,\n      safety;\n    // we do a binary search to find the \"good `t` closest to no-longer-good\"\n    do {\n      safety = 0;\n\n      // step 1: start with the maximum possible arc\n      t_e = 1;\n\n      // points:\n      let np1 = this.get(t_s),\n        np2,\n        np3,\n        arc,\n        prev_arc;\n\n      // booleans:\n      let curr_good = false,\n        prev_good = false,\n        done;\n\n      // numbers:\n      let t_m = t_e,\n        prev_e = 1,\n        step = 0;\n\n      // step 2: find the best possible arc\n      do {\n        prev_good = curr_good;\n        prev_arc = arc;\n        t_m = (t_s + t_e) / 2;\n        step++;\n\n        np2 = this.get(t_m);\n        np3 = this.get(t_e);\n\n        arc = utils.getccenter(np1, np2, np3);\n\n        //also save the t values\n        arc.interval = {\n          start: t_s,\n          end: t_e,\n        };\n\n        let error = this._error(arc, np1, t_s, t_e);\n        curr_good = error <= errorThreshold;\n\n        done = prev_good && !curr_good;\n        if (!done) prev_e = t_e;\n\n        // this arc is fine: we can move 'e' up to see if we can find a wider arc\n        if (curr_good) {\n          // if e is already at max, then we're done for this arc.\n          if (t_e >= 1) {\n            // make sure we cap at t=1\n            arc.interval.end = prev_e = 1;\n            prev_arc = arc;\n            // if we capped the arc segment to t=1 we also need to make sure that\n            // the arc's end angle is correct with respect to the bezier end point.\n            if (t_e > 1) {\n              let d = {\n                x: arc.x + arc.r * cos(arc.e),\n                y: arc.y + arc.r * sin(arc.e),\n              };\n              arc.e += utils.angle({ x: arc.x, y: arc.y }, d, this.get(1));\n            }\n            break;\n          }\n          // if not, move it up by half the iteration distance\n          t_e = t_e + (t_e - t_s) / 2;\n        } else {\n          // this is a bad arc: we need to move 'e' down to find a good arc\n          t_e = t_m;\n        }\n      } while (!done && safety++ < 100);\n\n      if (safety >= 100) {\n        break;\n      }\n\n      // console.log(\"L835: [F] arc found\", t_s, prev_e, prev_arc.x, prev_arc.y, prev_arc.s, prev_arc.e);\n\n      prev_arc = prev_arc ? prev_arc : arc;\n      circles.push(prev_arc);\n      t_s = prev_e;\n    } while (t_e < 1);\n    return circles;\n  }\n}\n\nexport { Bezier };\n","import type { Point } from \"../point/PointType.js\";\nimport { guardDim } from \"./Guard.js\";\nimport type { RectPositioned } from \"./RectTypes.js\";\nimport { guard as PointsGuard } from '../point/Guard.js';\n\n/**\n * Creates a rectangle from its top-left coordinate, a width and height.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Rectangle at 50,50 with width of 100, height of 200.\n * const rect = Rects.fromTopLeft({ x: 50, y:50 }, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromTopLeft = (\n  origin: Point,\n  width: number,\n  height: number\n): RectPositioned => {\n  guardDim(width, `width`);\n  guardDim(height, `height`);\n  PointsGuard(origin, `origin`);\n\n  return { x: origin.x, y: origin.y, width: width, height: height };\n};\n","import type { Path } from \"../path/PathType.js\";\nimport type { QuadraticBezier, CubicBezier } from \"./BezierType.js\";\n\nexport const isQuadraticBezier = (path: Path | QuadraticBezier | CubicBezier): path is QuadraticBezier => (path as QuadraticBezier).quadratic !== undefined;\n\nexport const isCubicBezier = (path: Path | CubicBezier | QuadraticBezier): path is CubicBezier => (path as CubicBezier).cubic1 !== undefined && (path as CubicBezier).cubic2 !== undefined;\n","import { clamp, clamper } from './Clamp.js';\nimport { throwNumberTest } from '../util/GuardNumbers.js';\nimport type { NumberScaler, NumberScalerTwoWay } from './Types.js';\n\n/**\n * Scales `v` from an input range to an output range (aka `map`)\n *\n * For example, if a sensor's useful range is 100-500, scale it to a percentage:\n *\n * ```js\n * import { scale } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * scale(sensorReading, 100, 500, 0, 1);\n * ```\n *\n * `scale` defaults to a percentage-range output, so you can get away with:\n * ```js\n * scale(sensorReading, 100, 500);\n * ```\n *\n * If `v` is outside of the input range, it will likewise be outside of the output range.\n * Use {@link scaleClamped} to clip value to range.\n *\n * If inMin and inMax are equal, outMax will be returned.\n *\n * An easing function can be provided for non-linear scaling. In this case\n * the input value is 'pre scaled' using the function before it is applied to the\n * output range.\n *\n * ```js\n * scale(sensorReading, 100, 500, 0, 1, Easings.gaussian());\n * ```\n * @param v Value to scale\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @returns Scaled value\n */\nexport const scale = (\n  v: number,\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number\n): number => scaler(inMin, inMax, outMin, outMax, easing)(v);\n\n/**\n * Returns a scaling function\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @param clamped If true, value is clamped. Default: false\n * @returns\n */\nexport const scaler = (\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number,\n  clamped?: boolean\n): NumberScaler => {\n\n  throwNumberTest(inMin, `finite`, `inMin`);\n  throwNumberTest(inMax, `finite`, `inMax`);\n\n  const oMax = outMax ?? 1;\n  const oMin = outMin ?? 0;\n  const clampFunction = clamped ? clamper(outMin, outMax) : undefined;\n\n  return (v: number): number => {\n    if (inMin === inMax) return oMax;\n\n    let a = (v - inMin) / (inMax - inMin);\n    if (easing !== undefined) a = easing(a);\n    const x = a * (oMax - oMin) + oMin;\n    if (clampFunction) return clampFunction(x);\n    return x;\n  };\n};\n\n/**\n * Returns a 'null' scaler that does nothing - the input value is returned as output.\n * @returns \n */\nexport const scalerNull = (): NumberScaler => (v: number) => v;\n\n/**\n * As {@link scale}, but result is clamped to be\n * within `outMin` and `outMax`.\n *\n * @param v\n * @param inMin\n * @param inMax\n * @param outMin 1 by default\n * @param outMax 0 by default d\n * @param easing\n * @returns\n */\nexport const scaleClamped = (\n  v: number,\n  inMin: number,\n  inMax: number,\n  outMin?: number,\n  outMax?: number,\n  easing?: (v: number) => number\n): number => {\n  if (outMax === undefined) outMax = 1;\n  if (outMin === undefined) outMin = 0;\n  if (inMin === inMax) return outMax;\n\n  const x = scale(v, inMin, inMax, outMin, outMax, easing);\n  return clamp(x, outMin, outMax);\n};\n\n/**\n * Scales an input percentage to a new percentage range.\n *\n * If you have an input percentage (0-1), `scalePercentageOutput` maps it to an\n * _output_ percentage of `outMin`-`outMax`.\n *\n * ```js\n * import { scalePercentages } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Scales 50% to a range of 0-10%\n * scalePercentages(0.5, 0, 0.10); // 0.05 - 5%\n * ```\n *\n * An error is thrown if any parameter is outside of percentage range. This added\n * safety is useful for catching bugs. Otherwise, you could just as well call\n * `scale(percentage, 0, 1, outMin, outMax)`.\n *\n * If you want to scale some input range to percentage output range, just use `scale`:\n * ```js\n * import { scale } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Yields 0.5\n * scale(2.5, 0, 5);\n * ```\n * @param percentage Input value, within percentage range\n * @param outMin Output minimum, between 0-1\n * @param outMax Output maximum, between 0-1\n * @returns Scaled value between outMin-outMax.\n */\nexport const scalePercentages = (\n  percentage: number,\n  outMin: number,\n  outMax = 1\n): number => {\n  throwNumberTest(percentage, `percentage`, `v`);\n  throwNumberTest(outMin, `percentage`, `outMin`);\n  throwNumberTest(outMax, `percentage`, `outMax`);\n  return scale(percentage, 0, 1, outMin, outMax);\n};\n\n/**\n * Scales an input percentage value to an output range\n * If you have an input percentage (0-1), `scalePercent` maps it to an output range of `outMin`-`outMax`.\n * ```js\n * import { scalePercent } from 'https://unpkg.com/ixfx/dist/data.js';\n * scalePercent(0.5, 10, 20); // 15\n * ```\n *\n * @see {@link scalerPercent} Returns a function\n * @param v Value to scale\n * @param outMin Minimum for output\n * @param outMax Maximum for output\n * @returns\n */\nexport const scalePercent = (\n  v: number,\n  outMin: number,\n  outMax: number\n): number => scalerPercent(outMin, outMax)(v);\n\n/**\n * Returns a function that scales an input percentage value to an output range\n * @see {@link scalePercent} Calculates value\n * @param outMin\n * @param outMax\n * @returns Function that takes a single argument\n */\nexport const scalerPercent = (outMin: number, outMax: number) => {\n  return (v: number) => {\n    throwNumberTest(v, `percentage`, `v`);\n    return scale(v, 0, 1, outMin, outMax);\n  };\n};\n\n\n\n/**\n * Returns a two-way scaler\n * ```js\n * // Input range 0..100, output range 0..1\n * const s = scalerTwoWay(0,100,0,1);\n * \n * // Scale from input to output\n * s.out(50); // 0.5\n * \n * // Scale from output range to input\n * s.in(1); // 100\n * ```\n * @param inMin \n * @param inMax \n * @param outMin \n * @param outMax \n * @returns \n */\nexport const scalerTwoWay = (inMin: number, inMax: number, outMin: number = 0, outMax: number = 1, clamped = false, easing?: (v: number) => number): NumberScalerTwoWay => {\n  const toOut = scaler(inMin, inMax, outMin, outMax, easing, clamped);\n  const toIn = scaler(outMin, outMax, inMin, inMax, easing, clamped);\n  return { out: toOut, in: toIn };\n}","import * as Points from '../../geometry/point/index.js';\nimport * as Bezier from '../../geometry/bezier/index.js';\nimport { scale } from '../../numbers/Scale.js';\n\n/**\n * Interpolates points along a line.\n * By default it's a straight line, so use `bend` to make a non-linear curve.\n * @param bend -1...1. -1 will pull line up, 1 will push it down.\n * @returns \n */\nexport const line = (bend: number = 0, warp: number = 0) => {\n  const max = 1;\n  const cubicB = {\n    x: scale(bend, -1, 1, 0, max),\n    y: scale(bend, -1, 1, max, 0),\n  }\n\n  // Add in bend as 'drive'\n  let cubicA = Points.interpolate(Math.abs(bend), Points.Empty, cubicB);\n\n  // Warp\n  if (bend !== 0 && warp > 0) {\n    if (bend > 0) {\n      cubicA = Points.interpolate(warp, cubicA, { x: 0, y: cubicB.x * 2 });\n    } else {\n      cubicA = Points.interpolate(warp, cubicA, { x: cubicB.y * 2, y: 0 });\n    }\n  }\n\n  const bzr = Bezier.cubic(Points.Empty, Points.Unit,\n    cubicA, cubicB\n  );\n\n  const inter = Bezier.interpolator(bzr);\n  return (value: number) => inter(value);\n}","import { intervalToMs, type Interval } from \"../flow/IntervalType.js\";\nimport type { Modulate, ModulatorTimed } from \"./Types.js\";\nimport * as Timer from '../flow/Timer.js';\nimport { throwFunctionTest } from \"../util/GuardFunction.js\";\n\n/**\n * Produce values over time. When the modulate function is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * ```js\n * const fn = (t) => {\n *  // 't' will be values 0..1 where 1 represents end of time period.\n *  // Return some computed value based on 't'\n *  return t*Math.random();\n * }\n * const e = Modulate.time(fn, 1000);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * @param fn Modulate function\n * @param duration Duration\n * @returns \n */\nexport const time = (\n  fn: Modulate,\n  duration: Interval\n): () => number => {\n  throwFunctionTest(fn, `fn`);\n  let relative: undefined | (() => number);\n  return () => {\n    if (relative === undefined) relative = Timer.ofTotal(duration, { clampValue: true });\n    return fn(relative());\n  }\n}\n\n/**\n * Creates an modulator based on clock time. Time\n * starts being counted when modulate function is created.\n * \n * `timeModulator` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n * @example Time based easing\n * ```\n * import { timeModulator } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = (t) => {\n *  // 't' will be a value 0..1 representing time elapsed. 1 being end of period.\n *  return t*Math.random();\n * }\n * const t = timeModulator(fn, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of modulator\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param fn Modulator\n * @param duration Duration\n * @returns ModulatorTimed\n */\nexport const timeModulator = (\n  fn: Modulate,\n  duration: Interval\n): ModulatorTimed => {\n  throwFunctionTest(fn, `fn`);\n\n  const timer = Timer.elapsedMillisecondsAbsolute();\n  const durationMs = intervalToMs(duration);\n  if (durationMs === undefined) throw new Error(`Param 'duration' not provided`);\n  const relativeTimer = Timer.relative(\n    durationMs,\n    {\n      timer,\n      clampValue: true\n    });\n  return Timer.timerWithFunction(fn, relativeTimer);\n};\n\n/**\n * Produce modulate values with each invocation. When the time is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n * \n * If you need to check if a modulator is done or reset it, consider {@link tickModulator}.\n * \n * ```js\n * const fn = (t) => {\n *  // 't' will be values 0..1 representing elapsed ticks toward totwal\n * }\n * const e = ticks(fn, 100);\n * \n * // Keep calling e() to get the current value\n * e();\n * ```\n * @param fn Function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns \n */\nexport const ticks = (\n  fn: Modulate,\n  totalTicks: number\n): () => number => {\n  throwFunctionTest(fn, `fn`);\n\n  let relative: undefined | (() => number);\n  return () => {\n    if (relative === undefined) relative = Timer.ofTotalTicks(totalTicks, { clampValue: true });\n    return fn(relative());\n  }\n}\n\n/**\n * Creates an modulator based on ticks. \n * \n * `tickModulator` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based modulator\n * ```\n * import { tickModulator } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = (t) => {\n *  // 't' will be values 0..1 based on completion\n *  return Math.random() * t;\n * }\n * const t = tickModulator(fn, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param fn Modulate function that returns 0..1\n * @param durationTicks Duration in ticks\n * @returns ModulatorTimed\n */\nexport const tickModulator = (\n  fn: Modulate,\n  durationTicks: number\n): ModulatorTimed => {\n  throwFunctionTest(fn, `fn`);\n  const timer = Timer.elapsedTicksAbsolute();\n  const relativeTimer = Timer.relative(\n    durationTicks,\n    {\n      timer,\n      clampValue: true\n    });\n  return Timer.timerWithFunction(fn, relativeTimer);\n};","import type { Interval } from '../flow/IntervalType.js';\nimport { wrap } from './Wrap.js';\nimport { ofTotal } from '../flow/Timer.js';\nimport { throwNumberTest } from '../util/GuardNumbers.js';\nimport { clamp } from '../numbers/Clamp.js';\nimport { get as getEasing, type EasingName } from '../modulation/easing/index.js';\nexport const piPi = Math.PI * 2;\n\n/**\n * Interpolation options.\n * \n * Limit: What to do if interpolation amount exceeds 0..1 range\n * * clamp: lock to A & B (inclusive) Default.\n * * wrap: wrap from end to start again\n * * ignore: allow return values outside of A..B range\n * \n * Easing: name of easing function for non-linear interpolation\n * \n * Transform: name of function to transform `amount` prior to interpolate. This is useful for creating non-linear interpolation results.\n * \n * For example:\n * ```js\n * // Divide interpolation amount in half\n * const interpolatorInterval({ mins: 1 }, 10, 100, {\n *  transform: (amount) => amount * Math.random()\n * });\n * ```\n * In the above example, the results would get more random over time.\n * `interpolatorInterval` will still step through the interpolation range of 0..1 in an orderly fashion, but we're transforming that range using a custom function before producing the result. \n * \n */\nexport type InterpolateOptions = {\n  limits: `clamp` | `wrap` | `ignore`\n  easing: EasingName,\n  transform: (v: number) => number\n}\n\n/**\n * Returns an interpolation function with a fixed interpolation amount. This\n * function will need the A and B values to interpolate between (ie start and end)\n * \n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * \n * // Create function\n * const fn = interpolate(0.1);\n * \n * // Later, use to interpolate between a and b\n * fn(50, 100); // 10% of 50..100 range\n * ```\n * \n * This is useful if you have a fixed interpolation amount, but varying A and B values.\n * @param amount Interpolation value (0..1 usually)\n * @param options Options\n */\nexport function interpolate(amount: number, options?: Partial<InterpolateOptions>): (a: number, b: number) => number;\n\n/**\n * Interpolates between `a` and `b` by `amount`.\n * \n * Interpolation amount is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * \n * // Get the value at 10% of range between 50-100\n * const fn = interpolate(0.1, 50, 100);\n * ```\n * \n * This is useful if you have dynamic interpolation amount as well as A & B values.\n * Consider using `interpolate(amount)` if you have a fixed interpolation amount.\n * @param amount Interpolation value (0..1 usually)\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport function interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n\n/**\n * Returns an interpolation function with a fixed A and B values.\n * The returned function requires an interpolation amount. This is usually 0..1, where 0 will return the A value, 1 will return the B value, 0.5 will be halfway between the two etc.\n * \n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * \n * // Create function to interpolate between 50..100\n * const fn = interpolate(50, 100);\n * \n * // Later, use to interpolate\n * fn(0.1); // 10% of 50..100 range\n * ```\n * @param a Starting value (corresponding to an interpolation of 0)\n * @param b End value (corresponding to an interpolation value of 1)\n * @param options Options\n */\nexport function interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide on Interpolation](https://ixfx.fun/data/interpolation/overview/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * import { interpolate } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * interpolate(0.5, 30, 60);\n * ```\n *\n * See also {@link interpolatorStepped} and {@link interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n * \n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n * \n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n * \n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * To interpolate certain types: {@link Visual.Colour.interpolator | Visual.Colour.interpolator }, {@link Geometry.Points.interpolate | Points.interpolate}.\n * \n * There are a few variations when calling `interpolate`, depending on what parameters are fixed.\n * * `interpolate(amount)`: returns a function that needs a & b \n * * `interpolate(a, b)`:  returns a function that needs the interpolation amount\n */\nexport function interpolate(pos1: number, pos2?: number | Partial<InterpolateOptions>, pos3?: number | Partial<InterpolateOptions>, pos4?: Partial<InterpolateOptions>) {\n  let amountProcess: undefined | ((v: number) => number);\n  let limits: InterpolateOptions[ 'limits' ] = `clamp`;\n\n  const handleAmount = (amount: number) => {\n    if (amountProcess) amount = amountProcess(amount);\n    if (limits === undefined || limits === `clamp`) {\n      amount = clamp(amount);\n    } else if (limits === `wrap`) {\n      if (amount > 1) amount = amount % 1;\n      else if (amount < 0) {\n        amount = 1 + (amount % 1);\n      }\n    }\n    return amount;\n  }\n\n  const doTheEase = (_amt: number, _a: number, _b: number) => {\n    throwNumberTest(_a, ``, `a`);\n    throwNumberTest(_b, ``, `b`);\n    throwNumberTest(_amt, ``, `amount`);\n    _amt = handleAmount(_amt);\n    return (1 - _amt) * _a + _amt * _b\n  }\n\n\n  const readOpts = (o: Partial<InterpolateOptions> = {}) => {\n    if (o.easing) {\n      const easer = getEasing(o.easing);\n      if (!easer) throw new Error(`Easing function '${ o.easing }' not found`);\n      amountProcess = easer;\n    } else if (o.transform) {\n      if (typeof o.transform !== `function`) throw new Error(`Param 'transform' is expected to be a function. Got: ${ typeof o.transform }`);\n      amountProcess = o.transform;\n    }\n    limits = o.limits ?? `clamp`;\n  }\n\n  const rawEase = (_amt: number, _a: number, _b: number) => (1 - _amt) * _a + _amt * _b\n\n  if (typeof pos1 !== `number`) throw new TypeError(`First param is expected to be a number. Got: ${ typeof pos1 }`);\n  if (typeof pos2 === `number`) {\n    let a: number;\n    let b: number;\n    if (pos3 === undefined || typeof pos3 === `object`) {\n      //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n      a = pos1;\n      b = pos2;\n      readOpts(pos3);\n      return (amount: number) => doTheEase(amount, a, b);\n    } else if (typeof pos3 === `number`) {\n      //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n      a = pos2;\n      b = pos3;\n      readOpts(pos4);\n      return doTheEase(pos1, a, b);\n    } else {\n      throw new Error(`Values for 'a' and 'b' not defined`);\n    }\n  } else if (pos2 === undefined || typeof pos2 === `object`) {\n    //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n    const amount = handleAmount(pos1);\n    readOpts(pos2);\n    throwNumberTest(amount, ``, `amount`);\n    return (aValue: number, bValue: number) => rawEase(amount, aValue, bValue);\n  }\n};\n\n\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link interpolatorInterval}\n * which steps on the basis of clock time.\n * \n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n * \n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n * \n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n * \n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n * \n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorStepped = (incrementAmount: number, a = 0, b = 1, startInterpolationAt = 0, options?: Partial<InterpolateOptions>) => {\n  let amount = startInterpolationAt;\n  return (retargetB?: number, retargetA?: number) => {\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    amount += incrementAmount;\n    return value;\n  }\n}\n\n/**\n * Interpolates between A->B over `duration`.\n * Given the same A & B values, steps will be larger if it's a longer\n * duration, and shorter if it's a smaller duration.\n * \n * A function is returned, which when invoked yields a value between A..B.\n * \n * Alternatively to step through by the same amount regardless\n * of time, use {@link interpolatorStepped}.\n * \n * ```js\n * // Interpolate from 0..1 over one minute\n * const v = interpolatorInterval({mins:1});\n * v(); // Compute current value\n * ```\n * \n * Use start and end points:\n * ```js\n * // Interpolate from 100-200 over 10 seconds\n * const v = interpolatorInterval({secs:10}, 100, 200);\n * v(); // Compute current value\n * ```\n * @param duration Duration for interpolation\n * @param a Start point\n * @param b End point\n * @param options Options for interpolation\n * @returns \n */\nexport const interpolatorInterval = (duration: Interval, a = 0, b = 1, options?: Partial<InterpolateOptions>) => {\n  const durationProgression = ofTotal(duration, { clampValue: true });\n  return (retargetB?: number, retargetA?: number) => {\n    const amount = durationProgression();\n    if (retargetB !== undefined) b = retargetB;\n    if (retargetA !== undefined) a = retargetA;\n    if (amount >= 1) return b;\n    const value = interpolate(amount, a, b, options);\n    return value;\n  }\n}\n\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (\n  amount: number,\n  aRadians: number,\n  bRadians: number,\n  options?: Partial<InterpolateOptions>\n): number => {\n  const t = wrap(bRadians - aRadians, 0, piPi);\n  return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n\n","import type { ReactiveOrSource, ReactivePingable } from \"../Types.js\";\nimport { interpolate as interpolateFunction, type InterpolateOptions } from \"../../numbers/Interpolate.js\";\nimport { computeWithPrevious } from \"./ComputeWithPrevious.js\";\n\nexport type OpInterpolateOptions = InterpolateOptions & {\n  amount: number\n  /**\n   * Percentage of value that we consider 'done'.\n   * Since interpolation can never converge to target exactly, this allows us to snap to completion.\n   * Default: 0.99, meaning if value gets to within 99%, return the target.\n   */\n  snapAt: number\n}\n\n/**\n * Interpolates to the source value.\n * \n * Outputs one value for every input value. Thus, to interpolation\n * over time, it's necessary to get the source to emit values at the desired rate.\n * \n * Options can specify an easing name or custom transform of easing progress.\n * @param input \n * @param options \n * @returns \n */\nexport function interpolate(input: ReactiveOrSource<number>, options: Partial<OpInterpolateOptions> = {}): ReactivePingable<number> {\n  const amount = options.amount ?? 0.1;\n  const snapAt = options.snapAt ?? 0.99;\n\n  const i = interpolateFunction(amount, options);\n\n  return computeWithPrevious<number>(input, (previous, target) => {\n    const v = i(previous, target);\n    if (target > previous) {\n      if (v / target >= snapAt) return target;\n    }\n    return v;\n  });\n}\n\n\n/**\n * From the basis of an input stream of values, run a function over\n * each value. The function takes in the last value from the stream as well as the current.\n * @param input\n * @param fn\n * @returns\n */\n// export function interpolateToTarget<TIn>(input: ReactiveOrSource<TIn>, fn: (previous: TIn, target: TIn) => TIn): ReactivePingable<TIn> {\n//   let previousValue: TIn | undefined;\n//   let target: TIn | undefined;\n//   if (hasLast(input)) {\n//     target = previousValue = input.last();\n//   }\n\n//   const ping = () => {\n//     if (previousValue === undefined && target !== undefined) {\n//       previousValue = target;\n//     } else if (previousValue !== undefined && target !== undefined) {\n//       previousValue = fn(previousValue, target);\n//     }\n//     upstream.set(previousValue!);\n//   }\n\n//   const upstream = initUpstream<TIn, TIn>(input, {\n//     lazy: \"very\",\n//     debugLabel: `computeWithPrevious`,\n//     onValue(value) {\n//       target = value;\n//       ping();\n//     },\n//   })\n//   if (target) ping();\n\n//   return {\n//     ...toReadable(upstream),\n//     ping: () => {\n//       if (target !== undefined) ping()\n//     }\n//   }\n// }","import { initUpstream } from \"../InitStream.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { Reactive, ReactiveOrSource } from \"../Types.js\";\nimport * as BasicProcessors from '../../data/BasicProcessors.js';\nimport type { Process } from \"../../data/Process.js\";\nimport type { OpAsAnnotation, OpMathOptions } from \"./Types.js\";\nimport type { RankFunction, RankOptions } from \"../../data/Types.js\";\n\nexport function max(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function max(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, max: number }>;\nexport function max(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, max: number }> {\n  const p = BasicProcessors.max();\n  return process(p, `max`, input, options);\n}\n\nexport function min(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function min(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, min: number }>;\nexport function min(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, min: number }> {\n  const p = BasicProcessors.min();\n  return process(p, `min`, input, options);\n}\n\nexport function average(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function average(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, average: number }>;\nexport function average(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, average: number }> {\n  const p = BasicProcessors.average();\n  return process(p, `average`, input, options);\n}\n\nexport function sum(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function sum(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, sum: number }>;\nexport function sum(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, sum: number }> {\n  const p = BasicProcessors.sum();\n  return process(p, `sum`, input, options);\n}\n\nexport type TallyOptions = OpMathOptions & {\n  countArrayItems: boolean\n}\n\nexport function tally(input: ReactiveOrSource<any>, options: Partial<TallyOptions>): Reactive<number>;\nexport function tally<TIn>(input: ReactiveOrSource<TIn>, options: OpAsAnnotation & Partial<TallyOptions>): Reactive<{ value: TIn, tally: number }>;\nexport function tally<TIn>(input: ReactiveOrSource<TIn>, options: Partial<TallyOptions> = {}): Reactive<number> | Reactive<{ value: TIn, tally: number }> {\n  const countArrayItems = options.countArrayItems ?? true;\n  const p = BasicProcessors.tally(countArrayItems);\n  return process(p, `tally`, input, options);\n}\n\nexport function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: Partial<RankOptions & OpMathOptions>): Reactive<TIn>;\nexport function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: OpAsAnnotation & Partial<RankOptions & OpMathOptions>): Reactive<{ value: TIn, rank: TIn }>;\nexport function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: Partial<RankOptions & OpMathOptions>): Reactive<TIn> | Reactive<{ value: TIn, rank: TIn }> {\n  const p = BasicProcessors.rank(rank, options);\n  return process(p, `rank`, input, options);\n}\n\nfunction process(processor: Process<any, any>, annotationField: string, input: ReactiveOrSource<any>, options: OpMathOptions = {}) {\n  const annotate = options.annotate;\n  let previous: number | undefined;\n  const skipUndefined = options.skipUndefined ?? true;\n  const skipIdentical = options.skipIdentical ?? true;\n  const upstream = initUpstream<any, any>(input, {\n    ...options,\n    onValue(value) {\n      const x = processor(value);\n      if (x === undefined && skipUndefined) return;\n      if (skipIdentical && x === previous) return;\n      previous = x;\n      if (annotate) {\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        const ret: any = { value };\n        ret[ annotationField ] = x;\n        upstream.set(ret);\n      } else {\n        upstream.set(x);\n      }\n    },\n  })\n  return toReadable(upstream);\n}\n\n//todo testing for annotation and non - annotated\n\n\n// rankArray\n\n// chunk, reduce\n\n// debounce, delay\n\n// duration, take","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { PipeSet, Reactive, Passed } from \"../Types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../Util.js\";\n\n/**\n * Pipes the output of one stream into another, in order.\n * The stream returned is a new stream which captures the final output.\n * \n * If any stream in the pipe closes the whole pipe is closed.\n * @param streams \n * @returns \n */\nexport const pipe = <TInput, TOutput>(...streams: PipeSet<TInput, TOutput>): Reactive<TOutput> => {\n  const event = initStream<TOutput>();\n  const unsubs: Array<() => void> = [];\n  const performDispose = (reason: string) => {\n    for (const s of streams) {\n      if (!s.isDisposed) s.dispose(reason);\n    }\n    for (const s of unsubs) {\n      s();\n    }\n    event.dispose(reason);\n  }\n\n  for (let index = 0; index < streams.length; index++) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    unsubs.push(streams[ index ].on((message: Passed<unknown>) => {\n      const isLast = index === streams.length - 1;\n      if (messageHasValue(message)) {\n        if (isLast) {\n          // Last stream, send to output\n          event.set(message.value as TOutput);\n        } else {\n          // @ts-expect-error\n          // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n          streams[ index + 1 ].set(message.value);\n        }\n      } else if (messageIsDoneSignal(message)) {\n        performDispose(`Upstream disposed`);\n      }\n    }));\n  }\n  return {\n    on: event.on,\n    onValue: event.onValue,\n    dispose(reason) {\n      performDispose(reason);\n    },\n    isDisposed() {\n      return event.isDisposed();\n    },\n  };\n}","import { shuffle } from \"../../data/arrays/Random.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport type { SingleFromArrayOptions } from \"./Types.js\";\n\n/**\n * For a stream that emits arrays of values, this op will select a single value.\n * \n * Can select based on:\n * * predicate: a function that returns _true_ for a value\n * * at: selection based on array index (can be combined with random ordering to select a random value)\n * \n * ```js\n * // If source is Reactive<Array<number>>, picks the first even number\n * singleFromArray(source, { \n *  predicate: v => v % 2 === 0\n * });\n * \n * // Selects a random value from source\n * singleFromArray(source, { \n *  order: `random`,\n *  at: 0\n * });\n * ```\n * \n * If neither `predicate` or `at` options are given, exception is thrown.\n * @param source Source to read from\n * @param options Options for selection\n * @returns \n */\nexport function singleFromArray<V>(source: ReactiveOrSource<Array<V>>, options: Partial<SingleFromArrayOptions<V>> = {}): Reactive<V> {\n  const order = options.order ?? `default`;\n  if (!options.at && !options.predicate) throw new Error(`Options must have 'predicate' or 'at' fields`);\n\n  let preprocess = (values: Array<V>) => values;\n  if (order === `random`) preprocess = shuffle;\n  else if (typeof order === `function`) preprocess = (values) => values.toSorted(order);\n\n  const upstream = initUpstream<Array<V>, V>(source, {\n    onValue(values) {\n      values = preprocess(values);\n      if (options.predicate) {\n        for (const v of values) {\n          if (options.predicate(v)) {\n            upstream.set(v);\n          }\n        }\n      } else if (options.at) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        upstream.set(values.at(options.at)!);\n      }\n    },\n  });\n  return upstream;\n}\n","import { initUpstream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, ReactiveStream, Reactive } from \"../Types.js\";\nimport type { SplitOptions } from \"./Types.js\";\n\n/**\n * Creates a set of streams each of which receives data from `source`.\n * By default these are lazy and dispose if the upstream source closes.\n * \n * See also {@link splitLabelled} to split into named streams.\n * @param rxOrSource \n * @param options \n * @returns \n */\nexport const split = <T>(rxOrSource: ReactiveOrSource<T>, options: Partial<SplitOptions> = {}) => {\n  const quantity = options.quantity ?? 2;\n  const outputs: Array<ReactiveStream<T>> = [];\n  const source = resolveSource(rxOrSource);\n  for (let index = 0; index < quantity; index++) {\n    outputs.push(initUpstream(source, { disposeIfSourceDone: true, lazy: `initial` }));\n  }\n  return outputs;\n}\n\n/**\n * Splits `source` into several duplicated streams. \n * Returns an object with keys according to `labels`.\n * Each value is a stream which echos the values from `source`.\n * ```js\n * const { a, b, c} = splitLabelled(source, `a`, `b`, `c`);\n * // a, b, c are Reactive types\n * ```\n * \n * See also {@link split} to get an unlabelled split\n * @param rxOrSource \n * @param labels \n * @returns \n */\nexport const splitLabelled = <T, K extends PropertyKey>(rxOrSource: ReactiveOrSource<T>, labels: Array<K>): Record<K, Reactive<T>> => {\n  const source = resolveSource(rxOrSource);\n  const t: Partial<Record<K, Reactive<T>>> = {}\n  for (const label of labels) {\n    t[ label ] = initUpstream(source, { lazy: `initial`, disposeIfSourceDone: true });\n  }\n  return t as Record<K, Reactive<T>>;\n}","import { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveStream } from \"../Types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../Util.js\";\nimport type { FilterPredicate, SwitcherOptions } from \"./Types.js\";\n\n/**\n * Switcher generates several output streams, labelled according to the values of `cases`.\n * Values from `source` are fed to the output streams if their associated predicate function returns _true_.\n * \n * In this way, we can split one input stream into several output streams, each potentially getting a different\n * subset of the input.\n * \n * With `options`, you can specify whether to send to multiple outputs if several match, or just the first (default behaviour).\n * \n * The below example shows setting up a switcher and consuming the output streams.\n * @example\n * ```js\n * // Initialise a reactive number, starting at 0\n * const switcherSource = Reactive.number(0);\n * // Set up the switcher\n * const x = Reactive.switcher(switcherSource, {\n *  even: v => v % 2 === 0,\n *  odd: v => v % 2 !== 0\n * });\n * // Listen for outputs from each of the resulting streams\n * x.even.on(msg => {\n *   log(`even: ${msg.value}`);\n * });\n * x.odd.on(msg => {\n *   log(`odd: ${msg.value}`);\n * })\n * // Set new values to the number source, counting upwards\n * // ...this will in turn trigger the outputs above\n * setInterval(() => {\n *   switcherSource.set(switcherSource.last() + 1);\n * }, 1000);\n * ```\n * \n * If `source` closes, all the output streams will be closed as well.\n * @param reactiveOrSource \n * @param cases \n * @param options \n * @returns \n */\nexport const switcher = <TValue, TRec extends Record<string, FilterPredicate<TValue>>, TLabel extends keyof TRec>(reactiveOrSource: ReactiveOrSource<TValue>, cases: TRec, options: Partial<SwitcherOptions> = {}): Record<TLabel, Reactive<TValue>> => {\n  // return (r: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n  const match = options.match ?? `first`;\n  const source = resolveSource(reactiveOrSource);\n  let disposed = false;\n  // Setup output streams\n  const t: Partial<Record<TLabel, ReactiveStream<TValue>>> = {}\n  for (const label of Object.keys(cases)) {\n    (t as any)[ label ] = initStream<TValue>();\n  }\n\n  const performDispose = () => {\n    if (disposed) return;\n    unsub();\n    disposed = true;\n    for (const stream of Object.values(t)) {\n      (stream as ReactiveStream<any>).dispose(`switcher source dispose`);\n    }\n  }\n\n  // Listen to source\n  const unsub = source.on(message => {\n    // Got a value\n    if (messageHasValue(message)) {\n      for (const [ lbl, pred ] of Object.entries(cases)) {\n        if (pred(message.value)) {\n          ((t as any)[ lbl ] as ReactiveStream<TValue>).set(message.value);\n          if (match === `first`) break;\n        }\n      }\n    } else if (messageIsDoneSignal(message)) {\n      performDispose();\n    }\n  })\n  return t as Record<TLabel, Reactive<TValue>>;\n  // }\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, Reactive, RxValueTypes } from \"../Types.js\";\nimport { messageIsSignal } from \"../Util.js\";\nimport type { SyncOptions } from \"./Types.js\";\n\n/**\n * Waits for all sources to produce a value, sending the combined results as an array.\n * After sending, it waits again for each source to send at least one value.\n * \n * Use {@link syncToObject} to output objects based on labelled sources rather than an array of values.\n * \n * Pace will be set by the slowest source. Alternatively, use {@link combineLatestToArray} where the rate is determined by fastest source.\n * \n * Only complete results are sent. For example if source A & B finish and source C is still producing values,\n * synchronisation is not possible because A & B stopped producing values. Thus the stream will self-terminate\n * after `maximumWait` (2 seconds). The newer values from C are lost.\n */\nexport function syncToArray<const T extends ReadonlyArray<ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<SyncOptions> = {}): Reactive<RxValueTypes<T>> {\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const finalValue = options.finalValue ?? `undefined`;\n  const maximumWait = intervalToMs(options.maximumWait, 2000);\n\n  let watchdog: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  type State<V> = {\n    done: boolean,\n    finalData: V | undefined,\n    source: Reactive<V>\n    unsub: () => void\n  }\n\n  const data: Array<RxValueTypes<T> | undefined> = [];\n  //const finalData: Array<RxValueTypes<T> | undefined> = [];\n\n  // Resolve sources\n  //const sources = reactiveSources.map(source => resolveSource(source));\n  //const noop = () => {/*no-op*/ }\n  //const sourcesUnsub: Array<Unsubscriber> = sources.map(_ => noop);\n\n  const states: Array<State<any>> = reactiveSources.map(source => ({\n    finalData: undefined,\n    done: false,\n    source: resolveSource(source),\n    unsub: () => {/**no-op */ }\n  }));\n\n\n  const unsubscribe = () => {\n    for (const s of states) {\n      s.unsub();\n      s.unsub = () => {/**no-op */ }\n    }\n  }\n\n  const isDataSetComplete = () => {\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let index = 0; index < data.length; index++) {\n      if (onSourceDone === `allow` && states[ index ].done) continue;\n      if (data[ index ] === undefined) return false;\n    }\n    return true;\n  }\n\n  const hasIncompleteSource = () => states.some(s => !s.done);\n  const resetDataSet = () => {\n    for (let index = 0; index < data.length; index++) {\n      if (finalValue === `last` && states[ index ].done) continue; // Don't overwrite\n      data[ index ] = undefined;\n    }\n  }\n\n  const onWatchdog = () => {\n    done(`Sync timeout exceeded (${ maximumWait.toString() })`);\n  }\n\n  const done = (reason: string) => {\n    if (watchdog) clearTimeout(watchdog);\n    unsubscribe();\n    event.dispose(reason);\n  }\n\n  const init = () => {\n    watchdog = setTimeout(onWatchdog, maximumWait);\n\n    for (const [ index, state ] of states.entries()) {\n      data[ index ] = undefined; // init array positions to be undefined\n\n      state.unsub = state.source.on(valueChanged => {\n        if (messageIsSignal(valueChanged)) {\n          if (valueChanged.signal === `done`) {\n            state.finalData = data[ index ];\n            state.unsub();\n            state.done = true;\n            state.unsub = () => { /** no-op */ }\n            if (finalValue === `undefined`) data[ index ] = undefined;\n            if (onSourceDone === `break`) {\n              done(`Source '${ index.toString() }' done, and onSourceDone:'break' is set`);\n              return;\n            }\n            if (!hasIncompleteSource()) {\n              done(`All sources done`);\n              return;\n            }\n          }\n          return;\n        }\n        data[ index ] = valueChanged.value;\n\n        if (isDataSetComplete()) {\n          // All array elements contain values\n          // Emit data and reset\n          event.set([ ...data ] as RxValueTypes<T>);\n          resetDataSet();\n          if (watchdog) clearTimeout(watchdog);\n          watchdog = setTimeout(onWatchdog, maximumWait);\n        }\n      });\n    }\n  }\n\n  const event = initStream<RxValueTypes<T>>({\n    onFirstSubscribe() {\n      unsubscribe();\n      init();\n    },\n    onNoSubscribers() {\n      if (watchdog) clearTimeout(watchdog);\n      unsubscribe();\n\n    },\n  });\n\n  return {\n    dispose: event.dispose,\n    isDisposed: event.isDisposed,\n    on: event.on,\n    onValue: event.onValue\n  }\n\n}\n","import { zipKeyValue } from \"../../data/maps/MapFns.js\";\nimport type { ReactiveOrSource, Reactive, RxValueTypeObject } from \"../Types.js\";\nimport { syncToArray } from \"./SyncToArray.js\";\nimport { transform } from \"./Transform.js\";\nimport type { SyncOptions } from \"./Types.js\";\n\nexport function syncToObject<const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<SyncOptions> = {}): Reactive<RxValueTypeObject<T>> {\n  const keys = Object.keys(reactiveSources)\n  const values = Object.values(reactiveSources);\n\n  const s = syncToArray(values, options);\n  const st = transform(s, (streamValues) => {\n    return zipKeyValue(keys, streamValues);\n  });\n  return st as Reactive<RxValueTypeObject<T>>;\n}","import * as Process from \"../../data/Process.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveWritable, ReactiveOp } from \"../Types.js\";\n\n/**\n * 'Taps' the values from 'input', passing them to the 'process' function.\n * Return stream is the input stream, unaffected by what 'process' does.\n * @param input Input stream\n * @param processors List of processors\n * @returns \n */\nexport function tapProcess<In, T2, T3, T4, T5, T6>(input: ReactiveOrSource<In>, ...processors: Process.Processors<In, T2, T3, T4, T5, T6>): Reactive<In> {\n  const inputStream = resolveSource(input);\n  // @ts-expect-error\n  const chain = Process.flow(...processors);\n  inputStream.onValue(value => {\n    chain(value);\n  });\n  return inputStream;\n}\n\n/**\n * 'Taps' the values from 'input', passing them to 'diverged'\n * Returns the original input stream, unaffected by what 'diverged' does.\n * @param input Input stream\n * @param diverged Stream to write to \n * @returns \n */\nexport function tapStream<In>(input: ReactiveOrSource<In>, diverged: ReactiveWritable<In>): Reactive<In> {\n  const inputStream = resolveSource(input);\n  inputStream.onValue(value => {\n    diverged.set(value);\n  });\n  return inputStream;\n}\n\n/**\n * Create a parallel 'tap' of processing\n * @param input Input stream\n * @param ops Series of ops to process data\n * @returns \n */\nexport const tapOps = <TIn, TOut>(input: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<TIn, TOut>>): Reactive<TOut> => {\n  for (const op of ops) {\n    // @ts-expect-error\n    input = op(input);\n  }\n  return input as any as Reactive<TOut>;\n}","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\nimport type { ThrottleOptions } from \"./Types.js\";\n\n/**\n * Only allow a value through if a minimum amount of time has elapsed.\n * since the last value. This effectively slows down a source to a given number\n * of values/ms. Values emitted by the source which are too fast are discarded.\n * \n * Throttle will fire on the first value received.\n * \n * In more detail:\n * Every time throttle passes a value, it records the time it allowed something through. For every\n * value received, it checks the elapsed time against this timestamp, throwing away values if\n * the period hasn't elapsed.\n * \n * With this logic, a fury of values of the source might be discarded if they fall within the elapsed time\n * window. But then if there is not a new value for a while, the actual duration between values can be longer\n * than expected. This is in contrast to {@link debounce}, which will emit the last value received after a duration, \n * even if the source stops sending.\n * @param options \n * @returns \n */\nexport function throttle<V>(throttleSource: ReactiveOrSource<V>, options: Partial<ThrottleOptions> = {}): Reactive<V> {\n  const elapsed = intervalToMs(options.elapsed, 0);\n  let lastFire = performance.now();\n  let lastValue: V | undefined;\n\n  const upstream = initUpstream<V, V>(throttleSource, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      trigger();\n    },\n  });\n\n  const trigger = () => {\n    const now = performance.now();\n    if (elapsed > 0 && (now - lastFire > elapsed)) {\n      lastFire = now;\n      if (lastValue !== undefined) {\n        upstream.set(lastValue);\n      }\n    }\n  }\n\n\n  return toReadable(upstream);\n\n}\n","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../Types.js\";\nimport { isTrigger, resolveTriggerValue } from \"../Util.js\";\nimport type { TimeoutValueOptions } from \"../sources/Types.js\";\n\n/**\n * Emits a value if `source` does not emit a value after `interval`\n * has elapsed. This can be useful to reset a reactive to some\n * 'zero' state if nothing is going on.\n * \n * If `source` emits faster than the `interval`, it won't get triggered.\n * \n * Default for 'timeout': 1000s.\n * \n * ```js\n * // Emit 'hello' if 'source' doesn't emit a value after 1 minute\n * const r = Rx.timeoutValue(source, { value: 'hello', interval: { mins: 1 } });\n * ```\n * \n * Can also emit results from a function or generator\n * ```js\n * // Emits a random number if 'source' doesn't emit a value after 500ms\n * const r = Rx.timeoutValue(source, { fn: Math.random, interval: 500 });\n * ```\n * \n * If `immediate` option is _true_ (default), the timer starts from stream initialisation.\n * Otherwise it won't start until it observes the first value from `source`.\n * @param source \n * @param options \n */\nexport function timeoutValue<TSource, TTriggerValue>(source: ReactiveOrSource<TSource>, options: TimeoutValueOptions<TTriggerValue>): Reactive<TSource | TTriggerValue> {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  const immediate = options.immediate ?? true;\n  const repeat = options.repeat ?? false;\n  const timeoutMs = intervalToMs(options.interval, 1000);\n  if (!isTrigger(options)) {\n    throw new Error(`Param 'options' does not contain trigger 'value' or 'fn' fields`);\n  }\n\n  // Send value from trigger\n  const sendFallback = () => {\n    const [ value, done ] = resolveTriggerValue(options);\n    if (done) {\n      events.dispose(`Trigger completed`);\n    } else {\n      if (events.isDisposed()) return;\n      events.set(value);\n      if (repeat) {\n        timer = setTimeout(sendFallback, timeoutMs);\n      }\n    }\n  }\n\n  const events = initUpstream<TSource, TSource | TTriggerValue>(source, {\n    disposeIfSourceDone: true,\n    // Received a value from upstream source\n    onValue(v) {\n      // Reset timeout\n      if (timer) clearTimeout(timer);\n      timer = setTimeout(sendFallback, timeoutMs);\n      // Emit value\n      events.set(v);\n    },\n    onDispose() {\n      if (timer) clearTimeout(timer);\n    },\n  });\n\n  if (immediate && !timer) {\n    timer = setTimeout(sendFallback, timeoutMs);\n  }\n  return events;\n}\n","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ReactiveOrSource, Reactive, ReactivePingable } from \"../Types.js\";\nimport { isPingable, isTrigger, messageHasValue, messageIsDoneSignal, resolveTriggerValue } from \"../Util.js\";\nimport type { TimeoutPingOptions, TimeoutValueOptions } from \"../sources/Types.js\";\n\n/**\n * Pings a reactive if no value is emitted at after `interval`.\n * Returns `source`.\n * \n * ```js\n * // Ping `source` if no value is emitted after one minute\n * const r = Rx.timeoutPing(source, { mins: 1 });\n * ```\n * \n * Behavior can be stopped using an abort signal.\n * @see {@link ReactivePingable}\n * @param source \n * @param options \n */\nexport function timeoutPing<TSource>(source: ReactiveOrSource<TSource>, options: TimeoutPingOptions): Reactive<TSource> {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  const rx = resolveSource(source);\n  const abort = options.abort;\n  const timeoutMs = intervalToMs(options, 1000);\n\n  // Send ping\n  const sendPing = () => {\n    if (abort?.aborted || rx.isDisposed()) {\n      off();\n      return;\n    }\n    if (isPingable(rx)) rx.ping(); // ignore if not pingable\n    timer = setTimeout(sendPing, timeoutMs);\n  }\n\n  const cancel = () => {\n    if (timer) clearTimeout(timer);\n  }\n\n  const off = rx.on(msg => {\n    if (messageHasValue(msg)) {\n      // Reset timeout\n      cancel();\n      timer = setTimeout(sendPing, timeoutMs);\n    } else if (messageIsDoneSignal(msg)) {\n      off();\n      cancel();\n    }\n  });\n\n  timer = setTimeout(sendPing, timeoutMs);\n  return rx;\n}\n","import { initStream } from \"../InitStream.js\";\nimport { resolveSource } from \"../ResolveSource.js\";\nimport type { ValueToPingOptions } from \"../sources/Types.js\";\nimport type { Reactive, ReactiveOrSource, ReactivePingable, Unsubscriber } from \"../Types.js\";\nimport { messageHasValue, messageIsDoneSignal, messageIsSignal } from \"../Util.js\";\n\n/**\n * Pings `target` whenever `source` emits a value. The value itself is ignored, it just\n * acts as a trigger.\n * \n * Returns a new stream capturing the output of `target`.\n * \n * It `source` or `target` closes, output stream closes too.\n * \n * @returns \n */\nexport function valueToPing<TSource, TTarget>(source: ReactiveOrSource<TSource>, target: ReactivePingable<TTarget>, options: Partial<ValueToPingOptions<TSource>> = {}): Reactive<TTarget> {\n  const lazy = options.lazy ?? `initial`;\n  const signal = options.signal;\n  const sourceRx = resolveSource(source);\n  const gate = options.gate ?? ((value: TSource) => true);\n  let upstreamOff: Unsubscriber | undefined;\n  let downstreamOff: Unsubscriber | undefined;\n\n  if (signal) {\n    signal.addEventListener(`abort`, () => {\n      done(`Abort signal ${ signal.reason }`);\n    }, { once: true });\n  }\n\n  const events = initStream<TTarget>({\n    onFirstSubscribe() {\n      if (lazy !== `never` && upstreamOff === undefined) start();\n    },\n    onNoSubscribers() {\n      // Unsubscribe from source if we're very lazy\n      // Stay subscribed if we're only initially lazy or not lazy at all\n      if (lazy === `very` && upstreamOff !== undefined) {\n        upstreamOff();\n        upstreamOff = undefined;\n      }\n    },\n  })\n\n  const start = () => {\n    //console.log(`Rx.valueToPing  start`);\n\n    upstreamOff = sourceRx.on(message => {\n      if (messageIsDoneSignal(message)) {\n        done(`Upstream closed`);\n      } else if (messageIsSignal(message)) {\n        events.signal(message.signal);\n      } else if (messageHasValue(message)) {\n        //console.log(`Rx.valueToPing got value: ${ message.value }`);\n        if (gate(message.value)) {\n          target.ping();\n        }\n      }\n    });\n    downstreamOff = target.on(message => {\n      if (messageIsDoneSignal(message)) {\n        done(`Downstream closed`);\n      } else if (messageIsSignal(message)) {\n        events.signal(message.signal, message.context);\n      } else if (messageHasValue(message)) {\n        events.set(message.value);\n      }\n    });\n  }\n\n  const done = (reason: string) => {\n    events.dispose(reason);\n    if (upstreamOff) upstreamOff();\n    if (downstreamOff) downstreamOff();\n  }\n\n  if (lazy === `never`) start();\n  return events;\n}","import { initUpstream } from \"../InitStream.js\";\nimport type { ReactiveOrSource, WithValueOptions, ReactiveInitial } from \"../Types.js\";\nimport { toReadable } from \"../ToReadable.js\";\n\n/**\n * A reactive where the last value can be read at any time.\n * An initial value must be provided.\n * ```js\n * const r = Rx.withValue(source, { initial: `hello` });\n * r.last(); // Read last value\n * ```\n * \n * Warning: Since most reactives only active when subscribed to, it's important to also subscribe\n * to the results of `r` for this flow to happen. Alternatively, use `lazy: 'never'` as an option.\n * @param input \n * @param options \n * @returns \n */\nexport function withValue<In>(input: ReactiveOrSource<In>, options: WithValueOptions<In>): ReactiveInitial<In> {\n  let lastValue: In | undefined = options.initial;\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      //console.log(`Rx.Ops.WithValue onValue: ${ value }`);\n      lastValue = value;\n      upstream.set(value);\n    },\n  })\n\n  const readable = toReadable(upstream);\n  return {\n    ...readable,\n    last() {\n      return lastValue!;\n    },\n  }\n}","/* eslint-disable @typescript-eslint/no-non-null-assertion */\nimport { StackMutable } from \"../stack/StackMutable.js\"\nimport { QueueMutable } from \"../queue/QueueMutable.js\"\nimport { PriorityMutable } from \"../../collections/queue/PriorityMutable.js\"\nimport { immutable as immutableMap, type IMapImmutable } from \"../../collections/map/Map.js\"\nimport { NumberMap } from \"../../collections/map/NumberMap.js\"\nimport * as Sync from \"../../iterables/IterableSync.js\"\nimport { Table } from \"../Table.js\"\nimport { throwStringTest } from \"../../util/GuardString.js\"\n\nexport type DistanceCompute = (graph: DirectedGraph, edge: Edge) => number;\n\n/**\n * Vertex. These are the _nodes_ of the graph. Immutable.\n * \n * They keep track of all of their outgoing edges, and\n * a unique id.\n * \n * Ids are used for accessing/updating vertices as well as in the\n * {@link Edge} type. They must be unique.\n */\nexport type Vertex = Readonly<{\n  out: ReadonlyArray<Edge>\n  id: string\n}>\n\n/**\n * Edge. Immutable.\n * \n * Only encodes the destination vertex. The from\n * is known since edges are stored on the from vertex.\n */\nexport type Edge = Readonly<{\n  /**\n   * Vertex id edge connects to (ie. destination)\n   */\n  id: string,\n  /**\n   * Optional weight of edge\n   */\n  weight?: number\n}>\n\n/**\n * Create a vertex with given id\n * @param id \n * @returns \n */\nexport const createVertex = (id: string): Vertex => {\n  return {\n    id,\n    out: []\n  }\n}\n\n/**\n * Options for connecting vertices\n */\nexport type ConnectOptions = Readonly<{\n  /**\n   * From, or source of connection\n   */\n  from: string\n  /**\n   * To, or destination of connection. Can be multiple vertices for quick use\n   */\n  to: string | Array<string>\n  /**\n   * If true, edges in opposite direction are made as well\n   */\n  bidi?: boolean\n  /**\n   * Weight for this connection (optional)\n   */\n  weight?: number\n}>\n\n/**\n * Directed graph. Immutable.\n * \n * Consists of {@link Vertex|vertices}, which all have zero or more outgoing {@link Edge|Edges}.\n */\nexport type DirectedGraph = Readonly<{\n  vertices: IMapImmutable<string, Vertex>\n}>\n\n/**\n * Returns _true_ if graph contains `key`.\n * \n * ```js\n * // Same as\n * g.vertices.has(key)\n * ```\n * @param graph\n * @param key \n * @returns \n */\nexport function hasKey(graph: DirectedGraph, key: string): boolean {\n  throwGraphTest(graph);\n  return graph.vertices.has(key);\n}\n\n/**\n * Returns {@link Vertex} under `key`, or _undefined_\n * if not found.\n * \n * ```js\n * // Same as\n * g.vertices.get(key)\n * ```\n * @param graph \n * @param key \n * @returns \n */\nexport function get(graph: DirectedGraph, key: string): Vertex | undefined {\n  throwGraphTest(graph);\n  throwStringTest(key, `non-empty`, `key`);\n  return graph.vertices.get(key);\n\n}\n\n// export function fromAdjacenyMatrix(m: Array<Array<boolean>>): DirectedGraph {\n//   let g = graph();\n//   for (const row of m) {\n//     connect(g, { from, to })\n//   }\n//   return g;\n// }\n\n/**\n * Returns the graph connections as an adjacency matrix\n * @param graph \n * @returns \n */\nexport function toAdjacencyMatrix(graph: DirectedGraph): Table<boolean> {\n  throwGraphTest(graph);\n\n  const v = [ ...graph.vertices.values() ];\n  //const m: Array<Array<boolean>> = [];\n  const table = new Table<boolean>();\n  table.labelColumns(...v.map(vv => vv.id));\n  table.labelRows(...v.map(vv => vv.id));\n\n  // const row: Array<boolean> = [];\n  // for (let index = 0; index < v.length; index++) {\n  //   row[ index ] = false;\n  // }\n\n  // eslint-disable-next-line @typescript-eslint/prefer-for-of, unicorn/prevent-abbreviations\n  for (let i = 0; i < v.length; i++) {\n    //m[ i ] = [ ...row ];\n    table.setRow(i, v.length, false);\n    const ii = v[ i ];\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    for (const [ j, jj ] of v.entries()) {\n      if (ii.out.some(o => o.id === jj.id)) {\n        //m[ i ][ j ] = true;\n        table.set(i, j, true);\n      }\n    }\n  }\n  return table;\n}\n\n/**\n * Return a string representation of the graph for debug inspection\n * @param graph \n * @returns \n */\nexport const dumpGraph = (graph: DirectedGraph | Iterable<Vertex>): string => {\n  const lines = debugGraphToArray(graph);\n  return lines.join(`\\n`);\n}\n\n/**\n * Return an array of a debug-print of every vertex.\n * @param graph \n * @returns \n */\nconst debugGraphToArray = (graph: DirectedGraph | Iterable<Vertex>): Array<string> => {\n\n  const r: Array<string> = [];\n  const vertices = (`vertices` in graph) ? graph.vertices.values() : graph;\n\n  for (const v of vertices) {\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    const str = debugDumpVertex(v);\n    r.push(...str.map(line => ` ${ line }`));\n  }\n  return r;\n}\n\n\nexport const distance = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Iterate over all the edges in the graph\n * @param graph \n */\nexport function* edges(graph: DirectedGraph) {\n  throwGraphTest(graph);\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    for (const edge of vertex.out) {\n      yield edge;\n    }\n  }\n}\n\n/**\n * Iterate over all the vertices of the graph\n * @param graph \n */\nexport function* vertices(graph: DirectedGraph) {\n  throwGraphTest(graph);\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const vertex of vertices) {\n    yield vertex;\n  }\n}\n\nfunction testGraph(g: DirectedGraph, paramName = `graph`) {\n  if (g === undefined) return [ false, `Param '${ paramName }' is undefined. Expected Graph` ];\n  if (g === null) return [ false, `Param '${ paramName }' is null. Expected Graph` ];\n  if (typeof g === `object`) {\n    if (!(`vertices` in g)) return [ false, `Param '${ paramName }.vertices' does not exist. Is it a Graph type?` ]\n  } else {\n    return [ false, `Param '${ paramName } is type '${ typeof g }'. Expected an object Graph` ];\n  }\n  return [ true ];\n}\n\nfunction throwGraphTest(g: DirectedGraph, paramName = `graph`) {\n  const r = testGraph(g, paramName);\n  if (r[ 0 ]) return;\n  throw new Error(r[ 1 ] as string)\n}\n/**\n * Iterate over all the vertices connected to `context` vertex\n * @param graph Graph\n * @param context id or Vertex.\n * @returns \n */\nexport function* adjacentVertices(graph: DirectedGraph, context: Vertex | string | undefined) {\n  throwGraphTest(graph);\n  if (context === undefined) return;\n  const vertex = typeof context === `string` ? graph.vertices.get(context) : context;\n  if (vertex === undefined) throw new Error(`Vertex not found ${ JSON.stringify(context) }`);\n\n  for (const edge of vertex.out) {\n    const edgeV = graph.vertices.get(edge.id);\n    if (edgeV === undefined) throw new Error(`Could not find vertex: ${ edge.id }`);\n    yield edgeV;\n  }\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to\n * the supplied id or vertex.\n * \n * If `vertex` is undefined, _false_ is returned.\n * @param vertex From vertex\n * @param outIdOrVertex To vertex\n * @returns \n */\nexport const vertexHasOut = (vertex: Vertex, outIdOrVertex: string | Vertex): boolean => {\n  if (vertex === undefined) return false;\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return vertex.out.some(edge => edge.id === outId);\n}\n\n/**\n * Returns _true_ if `vertex` has no outgoing connections\n * @param graph \n * @param vertex \n * @returns \n */\nexport const hasNoOuts = (graph: DirectedGraph, vertex: string | Vertex): boolean => {\n  throwGraphTest(graph);\n\n  const context = typeof vertex === `string` ? graph.vertices.get(vertex) : vertex;\n  if (context === undefined) return false;\n  return context.out.length === 0;\n}\n\n/**\n * Returns _true_ if `vertex` only has the given list of vertices.\n * Returns _false_ early if the length of the list does not match up with `vertex.out`\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOnlyOuts = (graph: DirectedGraph, vertex: string | Vertex, ...outIdOrVertex: Array<string | Vertex>): boolean => {\n  throwGraphTest(graph);\n\n  const context = resolveVertex(graph, vertex);\n  const outs = outIdOrVertex.map(o => resolveVertex(graph, o));\n\n  if (outs.length !== context.out.length) {\n    //console.log(`length mismatch. context: ${ JSON.stringify(context.out) } out ${ JSON.stringify(outIdOrVertex) }`);\n    return false;\n  }\n  for (const out of outs) {\n    //console.log(`Testing ${ context.id } -> ${ out.id }`);\n    if (!hasOut(graph, context, out)) {\n      //console.log(`  no`);\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Returns _true_ if `vertex` has an outgoing connection to the given vertex.\n * @param graph \n * @param vertex \n * @param outIdOrVertex \n * @returns \n */\nexport const hasOut = (graph: DirectedGraph, vertex: string | Vertex, outIdOrVertex: string | Vertex): boolean => {\n  throwGraphTest(graph);\n\n  const context = resolveVertex(graph, vertex);\n  const outId = typeof outIdOrVertex === `string` ? outIdOrVertex : outIdOrVertex.id;\n  return context.out.some(edge => edge.id === outId);\n}\n\n// export const hasIn = (graph: Graph, contextIdOrVertex: string | Vertex, id: string): boolean => {\n//   const context = typeof contextIdOrVertex === `string` ? graph.vertices.get(contextIdOrVertex) : contextIdOrVertex;\n\n//   if (context === undefined) return false;\n//   if (context.in === undefined) return false;\n//   return context.in.some(edge => edge.id === id);\n// }\n\n/**\n * Gets a vertex by id, creating it if it does not exist.\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrCreate = (graph: DirectedGraph, id: string): Readonly<{ graph: DirectedGraph, vertex: Vertex }> => {\n  throwGraphTest(graph);\n\n  const v = graph.vertices.get(id);\n  if (v !== undefined) return { graph, vertex: v };\n\n  const vv = createVertex(id);\n  const gg = updateGraphVertex(graph, vv);\n  return { graph: gg, vertex: vv };\n}\n\n/**\n * Gets a vertex by id, throwing an error if it does not exist\n * @param graph \n * @param id \n * @returns \n */\nexport const getOrFail = (graph: DirectedGraph, id: string): Vertex => {\n  throwGraphTest(graph);\n\n  const v = graph.vertices.get(id);\n  if (v === undefined) throw new Error(`Vertex '${ id }' not found in graph`);\n  return v;\n}\n\n/**\n * Updates a vertex by returning a mutated graph\n * @param graph Graph\n * @param vertex Newly changed vertex\n * @returns \n */\nexport const updateGraphVertex = (graph: DirectedGraph, vertex: Vertex): DirectedGraph => {\n  throwGraphTest(graph);\n\n  const gr = {\n    ...graph,\n    vertices: graph.vertices.set(vertex.id, vertex)\n  }\n  return gr;\n}\n\n/**\n * Default distance computer. Uses `weight` property of edge, or `1` if not found.\n * @param graph \n * @param edge \n * @returns \n */\nexport const distanceDefault = (graph: DirectedGraph, edge: Edge): number => {\n  if (edge.weight !== undefined) return edge.weight;\n  return 1;\n}\n\n/**\n * Returns a mutation of `graph`, with a given edge removed.\n * \n * If edge was not there, original graph is returned.\n * @param graph \n * @param from \n * @param to \n * @returns \n */\nexport function disconnect(graph: DirectedGraph, from: string | Vertex, to: string | Vertex): DirectedGraph {\n  throwGraphTest(graph);\n\n  const fromV = resolveVertex(graph, from);\n  const toV = resolveVertex(graph, to);\n\n  return hasOut(graph, fromV, toV) ? updateGraphVertex(graph, {\n    ...fromV,\n    out: fromV.out.filter(t => t.id !== toV.id)\n  }) : graph;\n}\n\n/**\n * Make a connection between two vertices with a given weight.\n * It returns the new graph as wll as the created edge.\n * @param graph \n * @param from \n * @param to \n * @param weight \n * @returns \n */\nexport function connectTo(graph: DirectedGraph, from: string, to: string, weight?: number): { graph: DirectedGraph, edge: Edge } {\n  throwGraphTest(graph);\n\n  const fromResult = getOrCreate(graph, from);\n  graph = fromResult.graph;\n  const toResult = getOrCreate(graph, to);\n  graph = toResult.graph;\n\n  const edge: Edge = {\n    id: to,\n    weight\n  }\n\n  if (!hasOut(graph, fromResult.vertex, toResult.vertex)) {\n    graph = updateGraphVertex(graph, {\n      ...fromResult.vertex,\n      // Add new edge to list of edges for this node\n      out: [ ...fromResult.vertex.out, edge ]\n    });\n  }\n  return { graph, edge }\n}\n\n/**\n * Connect from -> to. Same as {@link connectWithEdges}, but this version just returns the graph.\n * \n * By default unidirectional, meaning a connection is made only from->to. Use `bidi` option to set a bidirection connection, adding also to->from.\n * \n * Returns a result of `{ graph, edges }`, where `graph` is the new {@link DirectedGraph} and `edges`\n * is an array of {@link Edge Edges}. One for unidirectional, or two for bidirectional.\n * @param graph \n * @param options \n * @returns \n */\nexport function connect(graph: DirectedGraph, options: ConnectOptions): DirectedGraph {\n  const result = connectWithEdges(graph, options);\n  return result.graph;\n}\n\n/**\n * Connect from -> to. Same as {@link connect} except you get back the edges as well. \n * \n * By default unidirectional, meaning a connection is made only from->to. Use `bidi` option to set a bidirection connection, adding also to->from.\n * \n * Returns a result of `{ graph, edges }`, where `graph` is the new {@link DirectedGraph} and `edges`\n * is an array of {@link Edge Edges}. One for unidirectional, or two for bidirectional.\n * @param graph \n * @param options \n * @returns \n */\nexport function connectWithEdges(graph: DirectedGraph, options: ConnectOptions): { graph: DirectedGraph, edges: Edge[] } {\n  throwGraphTest(graph);\n\n  const { to, weight, from } = options;\n  const bidi = options.bidi ?? false;\n  const toList = Array.isArray(to) ? to : [ to ];\n\n  let edges: Edge[] = []\n  // Connect from -> to\n  for (const toSingle of toList) {\n    const result = connectTo(graph, from, toSingle, weight);\n    graph = result.graph;\n    edges.push(result.edge);\n  }\n\n  if (!bidi) return { graph, edges };\n\n  // Bidirectional connection\n  // Connect to -> from\n  for (const toSingle of toList) {\n    const result = connectTo(graph, toSingle, from, weight);\n    graph = result.graph;\n    edges.push(result.edge);\n  }\n  return { graph, edges };\n}\n\n/**\n * Returns an array of debug-representations for the given vertex.\n * @param v \n * @returns \n */\nconst debugDumpVertex = (v: Vertex): Array<string> => {\n  const r = [\n    v.id\n  ]\n  const stringForEdge = (edge: Edge) => edge.weight === undefined ? edge.id : `${ edge.id } (${ edge.weight })`\n\n  // for (const edge of v.in) {\n  //   r.push(` <- ${ stringForEdge(edge) }`);\n  // }\n  for (const edge of v.out) {\n    r.push(` -> ${ stringForEdge(edge) }`);\n  }\n  if (v.out.length === 0) r[ 0 ] += ` (terminal)`;\n\n  return r;\n}\n\n/**\n * Returns _true_ if a->b or b->a\n * @param graph \n * @param a \n * @param b \n * @returns \n */\nexport function areAdjacent(graph: DirectedGraph, a: Vertex, b: Vertex) {\n  throwGraphTest(graph);\n\n  if (hasOut(graph, a, b.id)) return true;\n  if (hasOut(graph, b, a.id)) return true;\n}\n\n/**\n * Resolves the id or vertex into a Vertex.\n * throws an error if vertex is not found\n * @param graph \n * @param idOrVertex \n * @returns \n */\nfunction resolveVertex(graph: DirectedGraph, idOrVertex: string | Vertex): Vertex {\n  throwGraphTest(graph);\n\n  if (idOrVertex === undefined) throw new Error(`Param 'idOrVertex' is undefined. Expected string or Vertex`);\n\n  const v = typeof idOrVertex === `string` ? graph.vertices.get(idOrVertex) : idOrVertex;\n  if (v === undefined) throw new Error(`Id not found ${ idOrVertex as string }`);\n  return v;\n}\n\n/**\n * Iterates over vertices from a starting vertex in an bread-first-search\n * @param graph \n * @param startIdOrVertex \n * @param targetIdOrVertex \n * @returns \n */\nexport function* bfs(graph: DirectedGraph, startIdOrVertex: string | Vertex, targetIdOrVertex?: string | Vertex) {\n  throwGraphTest(graph);\n\n  const start = resolveVertex(graph, startIdOrVertex);\n  const target = targetIdOrVertex === undefined ? undefined : resolveVertex(graph, targetIdOrVertex);\n\n  const queue = new QueueMutable<Vertex>();\n  const seen = new Set<string>();\n  queue.enqueue(start);\n  while (!queue.isEmpty) {\n    const v = queue.dequeue()!;\n    yield v;\n    if (target !== undefined && target === v) return;\n    for (const edge of adjacentVertices(graph, v)) {\n      if (!seen.has(edge.id)) {\n        seen.add(edge.id);\n        queue.enqueue(resolveVertex(graph, edge.id));\n      }\n    }\n  }\n}\n\n/**\n * Iterates over vertices from a starting vertex in an depth-first-search\n * @param graph \n * @param startIdOrVertex \n */\nexport function* dfs(graph: DirectedGraph, startIdOrVertex: string | Vertex) {\n  throwGraphTest(graph);\n\n  const source = resolveVertex(graph, startIdOrVertex);\n\n  const s = new StackMutable<Vertex>();\n  const seen = new Set<string>();\n  s.push(source);\n  while (!s.isEmpty) {\n    const v = s.pop();\n    if (v === undefined) continue;\n    if (!seen.has(v.id)) {\n      seen.add(v.id);\n      yield v;\n      for (const edge of v.out) {\n        const destination = graph.vertices.get(edge.id);\n        if (destination) {\n          s.push(destination);\n        }\n      }\n    }\n  }\n}\n\n/**\n * Compute shortest distance from the source vertex to the rest of the graph.\n * @param graph \n * @param sourceOrId \n * @returns \n */\nexport const pathDijkstra = (graph: DirectedGraph, sourceOrId: Vertex | string) => {\n  throwGraphTest(graph);\n\n  const source = typeof sourceOrId === `string` ? graph.vertices.get(sourceOrId) : sourceOrId;\n  if (source === undefined) throw new Error(`source vertex not found`);\n\n  const distances = new Map<string, number>();\n  const previous = new Map<string, Vertex | null>();\n\n  distances.set(source.id, 0);\n\n  const pq = new PriorityMutable<string>();\n\n  const vertices = [ ...graph.vertices.values() ];\n  for (const v of vertices) {\n    if (v.id !== source.id) {\n      distances.set(v.id, Number.MAX_SAFE_INTEGER);\n      // eslint-disable-next-line unicorn/no-null\n      previous.set(v.id, null);\n    }\n    pq.enqueueWithPriority(v.id, Number.MAX_SAFE_INTEGER);\n  }\n\n  while (!pq.isEmpty) {\n    const u = pq.dequeueMin();\n    if (u === undefined) throw new Error(`Bug. Queue unexpectedly empty`);\n    const vertexU = graph.vertices.get(u)!;\n    for (const neighbour of vertexU.out) {\n      //const vertexNeigbour = graph.vertices.get(neighbour.to)!;\n      const alt = distances.get(u)! + distance(graph, neighbour);\n      if (alt < distances.get(neighbour.id)!) {\n        distances.set(neighbour.id, alt);\n        previous.set(neighbour.id, vertexU);\n        pq.changePriority(neighbour.id, alt, true);\n      }\n    }\n  }\n\n  const pathTo = (id: string): Array<Edge> => {\n    const path: Array<Edge> = [];\n    while (true) {\n      if (id === source.id) break;\n      const v = previous.get(id);\n      if (v === undefined || v === null) throw new Error(`Id not present: ${ id }`);\n      path.push({ id, weight: distances.get(id) });\n      id = v.id;\n    }\n    return path;\n  }\n  return {\n    distances, previous, pathTo\n  }\n}\n\n/**\n * Clones the graph. Uses shallow clone, because it's all immutable\n * @param graph \n * @returns \n */\nexport const clone = (graph: DirectedGraph): DirectedGraph => {\n  throwGraphTest(graph);\n\n  const g: DirectedGraph = {\n    vertices: immutableMap<string, Vertex>([ ...graph.vertices.entries() ])\n  }\n  return g;\n}\n\n/**\n * Create a graph\n * ```js\n * let g = graph();\n * ```\n * \n * Can optionally provide initial connections:\n * ```js\n * let g = graph(\n *  { from: `a`, to: `b` },\n *  { from: `b`, to: `c` }\n * )\n * ```\n * @param initialConnections \n * @returns \n */\nexport const graph = (...initialConnections: Array<ConnectOptions>): DirectedGraph => {\n  let g: DirectedGraph = {\n    vertices: immutableMap()\n  }\n  for (const ic of initialConnections) {\n    g = connect(g, ic);\n  }\n  return g;\n}\n\n/**\n * Internal type for Tarjan algorithm\n */\ntype TarjanVertex = Vertex & {\n  lowlink: number\n  index: number\n  onStack: boolean\n}\n\n/**\n * Returns _true_ if the graph contains is acyclic - that is, it has no loops\n * @param graph \n */\nexport function isAcyclic(graph: DirectedGraph): boolean {\n  throwGraphTest(graph);\n\n  const cycles = getCycles(graph);\n  return cycles.length === 0;\n}\n\n/**\n * Topological sort using Kahn's algorithm.\n * Returns a new graph that is sorted\n * @param graph \n */\nexport function topologicalSort(graph: DirectedGraph): DirectedGraph {\n  throwGraphTest(graph);\n\n  const indegrees = new NumberMap(0);\n\n  // Increment indegrees for each edge leading to a vertex\n  for (const edge of edges(graph)) {\n    indegrees.add(edge.id, 1);\n  }\n\n  // Enqueue all vertices with an indegree of 0\n  const queue = new QueueMutable<Vertex>();\n  let vertexCount = 0;\n  for (const vertex of vertices(graph)) {\n    if (indegrees.get(vertex.id) === 0) {\n      queue.enqueue(vertex);\n    }\n    vertexCount++;\n  }\n\n  const topOrder: Array<Vertex> = [];\n  while (!queue.isEmpty) {\n    // Add to topological order\n    const u = queue.dequeue()!;\n    topOrder.push(u);\n\n    // Iterate through neighbours\n    for (const neighbour of u.out) {\n      const result = indegrees.subtract(neighbour.id, 1);\n      if (result === 0) {\n        queue.enqueue(graph.vertices.get(neighbour.id)!);\n      }\n    }\n  }\n\n  if (topOrder.length !== vertexCount) {\n    throw new Error(`Graph contains cycles`);\n  }\n  return graphFromVertices(topOrder);\n}\n\n/**\n * Create a graph from an iterable of vertices\n * @param vertices \n * @returns \n */\nexport function graphFromVertices(vertices: Iterable<Vertex>): DirectedGraph {\n  // eslint-disable-next-line unicorn/no-array-callback-reference, unicorn/no-array-method-this-argument\n  const keyValues = Sync.map(vertices, f => {\n    return [ f.id, f ] as [ string, Vertex ]\n  });\n  const m = immutableMap<string, Vertex>([ ...keyValues ]);\n  return {\n    vertices: m\n  }\n}\n\n/**\n * Get all the cycles ('strongly-connected-components') within the graph\n * [Read more](https://en.wikipedia.org/wiki/Strongly_connected_component)\n * @param graph \n * @returns \n */\nexport function getCycles(graph: DirectedGraph): Array<Array<Vertex>> {\n  throwGraphTest(graph);\n\n  let index = 0;\n  const stack = new StackMutable<TarjanVertex>();\n  const vertices = new Map<string, TarjanVertex>();\n  const scc: Array<Array<Vertex>> = [];\n\n  for (const v of graph.vertices.values()) {\n    vertices.set(v.id, {\n      ...v,\n      lowlink: Number.NaN,\n      index: Number.NaN,\n      onStack: false\n    });\n  }\n\n  const strongConnect = (vertex: TarjanVertex) => {\n    vertex.index = index;\n    vertex.lowlink = index;\n    index++;\n    stack.push(vertex);\n    vertex.onStack = true;\n\n    for (const edge of vertex.out) {\n      const edgeV = vertices.get(edge.id)!;\n      if (Number.isNaN(edgeV.index)) {\n        strongConnect(edgeV);\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      } else if (edgeV.onStack) {\n        vertex.lowlink = Math.min(vertex.lowlink, edgeV.lowlink);\n      }\n    }\n\n    if (vertex.lowlink === vertex.index) {\n      const stronglyConnected: Array<Vertex> = [];\n      let w: TarjanVertex | undefined;\n      while (vertex !== w) {\n        w = stack.pop()!;\n        w.onStack = false;\n        stronglyConnected.push({ id: w.id, out: w.out });\n\n      }\n      if (stronglyConnected.length > 1)\n        scc.push(stronglyConnected);\n    }\n  }\n\n  for (const v of vertices.values()) {\n    if (Number.isNaN(v.index)) {\n      strongConnect(v);\n    }\n  }\n  return scc;\n}\n\n/**\n * Returns a new graph which is transitively reduced.\n * That is, redundant edges are removed\n * @param graph \n * @returns \n */\nexport function transitiveReduction(graph: DirectedGraph) {\n  throwGraphTest(graph);\n\n  for (const u of vertices(graph)) {\n    for (const v of adjacentVertices(graph, u)) {\n      for (const v1 of dfs(graph, v)) {\n        if (v.id === v1.id) continue;\n        if (hasOut(graph, u, v1)) {\n          const g = disconnect(graph, u, v1);\n          return transitiveReduction(g);\n        }\n      }\n    }\n  }\n  return graph;\n}","import { throwNumberTest } from \"../../util/GuardNumbers.js\";\nimport { isEqualDefault, type IsEqual } from \"../../util/IsEqual.js\";\nimport { maxScore as IterablesMax, min as IterablesMin } from \"../../iterables/CompareValues.js\";\nimport type { IPriorityQueueMutable, PriorityItem } from \"./IPriorityQueueMutable.js\";\nimport { QueueMutable } from \"./QueueMutable.js\";\nimport type { QueueOpts } from \"./QueueTypes.js\";\n\n/**\n * Simple priority queue implementation.\n * Higher numbers mean higher priority.\n * \n * ```js\n * const pm = new PriorityMutable();\n * \n * // Add items with a priority (higher numeric value = higher value)\n * pm.enqueueWithPriority(`hello`, 4);\n * pm.enqueueWithPriotity(`there`, 1);\n * \n * ```\n */\nexport class PriorityMutable<V> extends QueueMutable<PriorityItem<V>> implements IPriorityQueueMutable<V> {\n  constructor(opts: QueueOpts<PriorityItem<V>> = {}) {\n    if (opts.eq === undefined) {\n      opts = {\n        ...opts,\n        eq: (a, b) => {\n          return isEqualDefault(a.item, b.item);\n        }\n      }\n    }\n    super(opts);\n  }\n\n  /**\n   * Adds an item with a given priority\n   * @param item Item\n   * @param priority Priority (higher numeric value means higher priority)\n   */\n  enqueueWithPriority(item: V, priority: number) {\n    throwNumberTest(priority, `positive`)\n    super.enqueue({ item, priority });\n  }\n\n  changePriority(item: V, priority: number, addIfMissing = false, eq?: IsEqual<V>) {\n    if (item === undefined) throw new Error(`Item cannot be undefined`);\n    let toDelete: PriorityItem<V> | undefined;\n    for (const d of this.data) {\n      if (eq) {\n        if (eq(d.item, item)) {\n          toDelete = d;\n          break;\n        }\n      } else {\n        if (this.eq(d, { item, priority: 0 })) {\n          toDelete = d;\n          break;\n        }\n      }\n    }\n    if (toDelete === undefined && !addIfMissing) throw new Error(`Item not found in priority queue. Item: ${ JSON.stringify(item) }`);\n    if (toDelete !== undefined) {\n      this.removeWhere(item => toDelete === item)\n    }\n    this.enqueueWithPriority(item, priority);\n  }\n\n  dequeueMax(): V | undefined {\n    const m = IterablesMax(this.data, v => v.priority);\n    if (m === undefined) return;\n    this.removeWhere(item => item === m);\n    return m.item;\n  }\n\n  dequeueMin(): V | undefined {\n    const m = IterablesMin(this.data, v => v.priority);\n    if (m === undefined) return;\n    this.removeWhere(item => item === m);\n    return m.item;\n  }\n\n  peekMax(): V | undefined {\n    const m = IterablesMax(this.data, v => v.priority);\n    if (m === undefined) return;\n    return m.item;\n  }\n\n  peekMin(): V | undefined {\n    const m = IterablesMin(this.data, v => v.priority);\n    if (m === undefined) return;\n    return m.item;\n  }\n}\n\n/**\n * Creates a {@link PriorityMutable} queue.\n * \n * Options:\n * * eq: Equality function\n * * capacity: limit on number of items\n * * discardPolicy: what to do if capacity is reached\n * @param opts \n * @returns \n */\nexport function priority<V>(\n  opts: QueueOpts<PriorityItem<V>> = {}\n): IPriorityQueueMutable<V> {\n  return new PriorityMutable(opts);\n}","\nexport class Table<V> {\n  rows: Array<Array<V | undefined>> = [];\n  rowLabels: Array<string> = [];\n  colLabels: Array<string> = [];\n\n  labelColumns(...labels: Array<string>) {\n    this.colLabels = labels;\n  }\n\n  labelColumn(columnNumber: number, label: string) {\n    this.colLabels[ columnNumber ] = label;\n  }\n\n  getColumnLabelIndex(label: string): number | undefined {\n    for (const [ index, l ] of this.colLabels.entries()) {\n      if (l === label) return index;\n    }\n  }\n\n  print() {\n    console.table([ ...this.rowsWithLabelsObject() ]);\n  }\n\n  *rowsWithLabelsArray() {\n    for (let index = 0; index < this.rows.length; index++) {\n      const labelledRow = this.getRowWithLabelsArray(index);\n      yield labelledRow;\n    }\n  }\n\n  /**\n   * Return a copy of table as nested array\n   * ```js\n   * const t = new Table();\n   * // add stuff\n   * // ...\n   * const m = t.asArray();\n   * for (const row of m) {\n   *  for (const colValue of row) {\n   *    // iterate over all column values for this row\n   *  }\n   * }\n   * ```\n   * \n   * Alternative: get value at row Y and column X\n   * ```js\n   * const value = m[y][x];\n   * ```\n   * @returns \n   */\n  asArray(): Array<Array<V | undefined>> {\n    const r: Array<Array<V | undefined>> = [];\n    for (const row of this.rows) {\n      if (row === undefined) r.push([]);\n      else r.push([ ...row ]);\n    }\n    return r;\n  }\n\n  /**\n   * Return the number of rows\n   */\n  get rowCount() {\n    return this.rows.length;\n  }\n\n  /**\n   * Return the maximum number of columns in any row\n   */\n  get columnCount() {\n    const lengths = this.rows.map(row => row.length);\n    return Math.max(...lengths);\n  }\n\n  *rowsWithLabelsObject() {\n    for (let index = 0; index < this.rows.length; index++) {\n      const labelledRow = this.getRowWithLabelsObject(index);\n      yield labelledRow;\n    }\n  }\n\n  labelRows(...labels: Array<string>) {\n    this.rowLabels = labels;\n  }\n\n  appendRow(...data: Array<V | undefined>) {\n    this.rows.push(data);\n  }\n\n  getRowWithLabelsArray(rowNumber: number): Array<[ label: string | undefined, value: V | undefined ]> | undefined {\n    const row = this.rows.at(rowNumber);\n    if (row === undefined) return undefined;\n    return row.map((value, index) => [ this.colLabels.at(index), value ]);\n  }\n\n  /**\n   * Return a row of objects. Keys use the column labels.\n   * \n   * ```js\n   * const row = table.getRowWithLabelsObject(10);\n   * // eg:\n   * // [{ colour: red, size: 10}, { colour: blue, size: 20 }]\n   * ```\n   * @param rowNumber \n   * @returns \n   */\n  getRowWithLabelsObject(rowNumber: number): object | undefined {\n    const row = this.rows.at(rowNumber);\n    if (row === undefined) return undefined;\n    const object = {};\n    for (let index = 0; index < this.colLabels.length; index++) {\n      const label = this.colLabels.at(index) ?? index.toString();\n      // @ts-expect-error\n      object[ label ] = row[ index ];\n    }\n    return object;\n  }\n\n  /**\n   * Gets or creates a row at `rowNumber`.\n   * @param rowNumber \n   * @returns \n   */\n  private getOrCreateRow(rowNumber: number): Array<V | undefined> {\n    let row = this.rows.at(rowNumber);\n    if (row === undefined) {\n      row = [];\n      this.rows[ rowNumber ] = row;\n    }\n    return row;\n  }\n\n  /**\n   * Gets the values at `rowNumber`\n   * @param rowNumber \n   * @returns \n   */\n  row(rowNumber: number): Array<V | undefined> | undefined {\n    return this.rows.at(rowNumber);\n  }\n\n  /**\n   * Set the value of row,column to `value`\n   * @param rowNumber \n   * @param columnNumber \n   * @param value \n   */\n  set(rowNumber: number, columnNumber: number, value: V | undefined) {\n    const row = this.getOrCreateRow(rowNumber);\n    row[ columnNumber ] = value;\n  }\n\n  get(rowNumber: number, column: number | string) {\n    const row = this.getOrCreateRow(rowNumber);\n    const index = typeof column === `number` ? column : this.getColumnLabelIndex(column);\n    if (index === undefined) throw new Error(`Column not found: ${ column }`);\n    return row[ index ];\n  }\n\n  /**\n   * For a given row number, set all the columns to `value`.\n   * `cols` gives the number of columns to set\n   * @param rowNumber \n   * @param cols \n   * @param value \n   */\n  setRow(rowNumber: number, cols: number, value: V | undefined) {\n    const row = this.getOrCreateRow(rowNumber);\n    for (let columnNumber = 0; columnNumber < cols; columnNumber++) {\n      row[ columnNumber ] = value;\n    }\n  }\n}","import * as DiGraph from \"../collections/graphs/DirectedGraph.js\";\nimport { initStream } from \"./InitStream.js\";\nimport type { Reactive } from \"./Types.js\";\nimport { isReactive } from \"./Util.js\";\ntype RxNodeBase = {\n  type: `primitive` | `rx` | `object`\n}\n\ntype RxNodeRx = RxNodeBase & {\n  type: `rx`,\n  value: Reactive<any>\n}\n\ntype RxNodePrimitive = RxNodeBase & {\n  type: `primitive`,\n  value: any\n}\n\ntype RxNode = RxNodeRx | RxNodePrimitive;\n\n// function isReactive(o: object): o is Reactive<any> {\n//   if (typeof o !== `object`) return false;\n//   if (`on` in o) {\n//     return (typeof o.on === `function`);\n//   }\n//   return false;\n// }\n\n/**\n * Build a graph of reactive dependencies for `rx`\n * @param _rx \n */\nexport function prepare<V extends Record<string, any>>(_rx: V): Reactive<V> {\n  let g = DiGraph.graph();\n  const nodes = new Map<string, RxNode>();\n  const events = initStream<V>();\n\n  const process = (o: object, path: string) => {\n    for (const [ key, value ] of Object.entries(o)) {\n      const subPath = path + `.` + key;\n      g = DiGraph.connect(g, {\n        from: path,\n        to: subPath\n      });\n      if (isReactive(value)) {\n        nodes.set(subPath, { value, type: `rx` });\n        value.on(v => {\n          console.log(`Rx.prepare value: ${ JSON.stringify(v) } path: ${ subPath }`);\n        });\n      } else {\n        const valueType = typeof value;\n        // eslint-disable-next-line unicorn/prefer-switch\n        if (valueType === `bigint` || valueType === `boolean` || valueType === `number` || valueType === `string`) {\n          nodes.set(subPath, { type: `primitive`, value });\n        } else if (valueType === `object`) {\n          process(value, subPath)\n        } else if (valueType === `function`) {\n          console.log(`Rx.process - not handling functions`);\n        }\n      }\n    }\n  }\n\n  // const produce = () => {\n  //   Object.fromEntries(entries);\n  // }\n\n  // process(rx, `_root`);\n  // console.log(DiGraph.dumpGraph(g));\n\n  // console.log(`--- Map ---`);\n\n  // for (const entries of nodes.entries()) {\n  //   console.log(entries[ 0 ]);\n  //   console.log(entries[ 1 ]);\n  //   console.log(``)\n  // }\n\n\n  const returnValue = {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    dispose: events.dispose,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    isDisposed: events.isDisposed,\n    graph: g,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    on: events.on,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    onValue: events.onValue\n  }\n  return returnValue;\n}\n\n","import type { Primitive } from '../PrimitiveTypes.js';\nimport type { Interval } from '../flow/IntervalType.js';\nimport * as Immutable from '../data/Pathed.js';\nimport type { ChunkOptions, DebounceOptions, FieldOptions, FilterPredicate, SplitOptions, SyncOptions, SwitcherOptions, TransformOpts, ThrottleOptions, OpMathOptions } from './ops/Types.js';\nimport type { TimeoutPingOptions, TimeoutValueOptions } from './sources/Types.js';\nimport type { SetHtmlOptions } from './sinks/Dom.js';\nimport type { Processors } from '../data/Process.js';\nimport type { TallyOptions } from './ops/Math.js';\nimport type { ChangeRecord } from '../data/Compare.js';\nimport type { RecursivePartial } from 'src/TsUtil.js';\n\n\nexport type CombineLatestOptions = {\n  /**\n   * If _true_, disposes all the merged sources when the merged reactive closes.\n   * Default: _true_.\n   */\n  disposeSources: boolean\n  /**\n   * How to handle when a source ends.\n   * * 'allow': continue combined stream, last value for done stream will kept\n   * * 'break': stop combined stream\n   * \n   * Default: 'break'\n   */\n  onSourceDone: `allow` | `break`\n  /**\n   * If _true_ (default), emits a value when initialised.\n   */\n  emitInitial: boolean\n}\n\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;\n\nexport const symbol = Symbol(`Rx`);\n\nexport type SignalKinds = `done` | `warn`;\nexport type Passed<V> = {\n  value: V | undefined\n  signal?: SignalKinds\n  context?: string\n}\n\nexport type PassedSignal = Passed<any> & {\n  value: undefined\n  signal: SignalKinds\n  context: string\n}\n\nexport type PassedValue<V> = Passed<V> & {\n  value: V\n}\n\nexport type UpstreamOptions<In> = {\n  lazy: Lazy\n  /**\n   * If _true_ (default), we dispose the underlying stream if the upstream closes. This happens after onStop() is called.\n   */\n  disposeIfSourceDone: boolean\n  onValue: (v: In) => void\n  /**\n   * Called just before we subscribe to source\n   * @returns \n   */\n  onStart: () => void\n  /**\n   * Called after we unsubscribe from source\n   * @returns\n   */\n  onStop: () => void\n  debugLabel: string\n  onDispose: (reason: string) => void\n}\n\nexport type UpstreamInitialOptions<In> = UpstreamOptions<In> & {\n  initialValue: In\n}\n\n//export type Processor = <TIn, TOptions>(source: ReactiveOrSource<TIn>) => (options: TOptions) => () => void;\n\n/**\n * Wrapped Reactive for object-oriented access\n */\nexport type Wrapped<TIn> = {\n  enacts: {\n    setHtmlText: (options: SetHtmlOptions) => () => void\n  }\n  source: Reactive<TIn>,\n\n  /**\n   * Annotate values with output from the `annotation` function.\n   * Returned values will be in the form `{ value:TIn, annotation:TAnnotation }`\n   * @param transformer \n   * @returns \n   */\n  annotate: <TAnnotation>(transformer: (value: TIn) => TAnnotation) => Wrapped<{ value: TIn, annotation: TAnnotation }>\n  annotateWithOp: <TOut>(op: ReactiveOp<TIn, TOut>) => Wrapped<{ value: TIn, annotation: TOut }>\n  /**\n  * Accumulate a chunk of values, emitted as an array\n  * @param options \n  * @returns \n  */\n  chunk: (options: Partial<ChunkOptions>) => Wrapped<Array<TIn>>\n\n  debounce: (options: Partial<DebounceOptions>) => Wrapped<TIn>\n\n\n  /**\n   * Pluck and emit a single field from values\n   * @param fieldName \n   * @param options \n   * @returns \n   */\n  field: <TSource, TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TSource, TFieldType>>) => Wrapped<TFieldType>\n  /**\n   * Throws away values that don't match `predicate`\n   * @param predicate \n   * @param options \n   * @returns \n   */\n  filter: (predicate: FilterPredicate<TIn>, options: Partial<InitStreamOptions>) => Wrapped<TIn>\n\n  combineLatestToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(sources: T, options: Partial<CombineLatestOptions>) => Wrapped<RxValueTypes<T>>\n  combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name: string } & Partial<CombineLatestOptions>) => Wrapped<RxValueTypeObject<T>>\n\n  min: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  max: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  average: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  sum: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  tally: (options?: Partial<TallyOptions>) => Wrapped<number>\n\n  /**\n   * Converts one source stream into two, with values being emitted by both\n   * @param options \n   * @returns \n   */\n  split: (options?: Partial<SplitOptions>) => Array<Wrapped<TIn>>\n  /**\n * Emits values when this stream and any additional streams produce a value. The resulting stream is\n * thus an array of values, each source at a given index.\n * Waits to output a value until each stream has produced a value. Thus, the pace is determined by\n * the slowest stream.\n * @returns \n */\n  syncToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(reactiveSources: T, options?: Partial<SyncOptions>) => Wrapped<[ TIn, ...RxValueTypes<T> ]>\n\n  syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options?: { name?: string } & Partial<SyncOptions>) => Wrapped<RxValueTypeObject<T>>\n\n  /**\n   * Creates new streams for each case, sending values to the stream if they match the filter predicate\n   * @param cases \n   * @param options \n   * @returns \n   */\n  switcher: <TRec extends Record<string, FilterPredicate<TIn>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions>) => Record<TLabel, Wrapped<TIn>>\n  /**\n   * Creates new streams for each case\n   * @param labels \n   * @returns \n   */\n  splitLabelled: <K extends keyof TIn>(...labels: Array<K>) => Record<K, Wrapped<TIn>>\n  /**\n   * Taps the stream, passing values to one or more 'processor' functions.\n   * This processing essentially happens in parallel, not affecting the main stream.\n   * \n   * ```js\n   * // Stream of pointermove events with {x:0,y:0} as default\n   * const move = Rx.From.event(document.body, `pointermove`, {x:0,y:0});\n   * // Wrap it for fluent access\n   * const ptr = Rx.wrap(move)\n   *  .tapProcess(\n   *    // Create a string representation\n   *    v => `${v.x},${v.y}`\n   *    // Set to DOM\n   *    v => {\n   *      document.getElementById(`coords`).innerText = v;\n   *    }\n   *   )\n   *  .onValue(value => {\n   *    // 'value' will be original PointerEvent, since .tapProcess happened in parallel,\n   *    // not affecting stream\n   *  });\n   * ```\n   * @param processors One-five processing functions\n   * @returns \n   */\n  tapProcess: <T2, T3, T4, T5, T6>(...processors: Processors<TIn, T2, T3, T4, T5, T6>) => Wrapped<TIn>\n  tapStream: (divergedStream: ReactiveWritable<TIn>) => Wrapped<TIn>\n  tapOps: <TOut>(source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<TIn, TOut>>) => Wrapped<TIn>\n  /**\n   * Transforms all values\n   * @param transformer \n   * @param options \n   * @returns \n   */\n  transform: <TOut>(transformer: (value: TIn) => TOut, options?: Partial<TransformOpts>) => Wrapped<TOut>\n  /**\n   * Only allow values through if a minimum of time has elapsed. Throws away values.\n   * Ie. converts a fast stream into a slower one.\n   * @param options \n   * @returns \n   */\n  throttle: (options: Partial<ThrottleOptions>) => Wrapped<TIn>\n  /**\n   * Emits a value if `source` does not emit a value after `interval`\n   * has elapsed. This can be useful to reset a reactive to some\n   * 'zero' state if nothing is going on.\n   * \n   * If `source` emits faster than the `interval`, it won't get triggered.\n   * \n   * Default for 'timeout': 1000s.\n   * \n   * ```js\n   * // Emit 'hello' if 'source' doesn't emit a value after 1 minute\n   * const r = Rx.timeoutValue(source, { value: 'hello', interval: { mins: 1 } });\n   * ```\n   * \n   * Can also emit results from a function or generator\n   * ```js\n   * // Emits a random number if 'source' doesn't emit a value after 500ms\n   * const r = Rx.timeoutValue(source, { fn: Math.random, interval: 500 });\n   * ```\n   * \n   * If `immediate` option is _true_ (default), the timer starts from stream initialisation.\n   * Otherwise it won't start until it observes the first value from `source`.\n   * @param options \n   */\n  timeoutValue: <TTriggerValue>(options: TimeoutValueOptions<TTriggerValue>) => Wrapped<TIn | TTriggerValue>\n  /**\n   * 'Pings' reactive (if it supports it) if a value is not received within a given interval.\n   * Behaviour can be stopped using an abort signal.\n   * @param options \n   * @returns \n   */\n  timeoutPing: (options: TimeoutPingOptions) => Wrapped<TIn>\n\n  /**\n   * Copies values from source into an array, throwing\n   * an error if expected number of items is not reached\n   * @param options \n   * @returns \n   */\n  toArrayOrThrow: (options: Partial<ToArrayOptions<TIn>>) => Promise<Array<TIn>>\n  /**\n   * Copies values from source into an array.\n   * @param options \n   * @returns \n   */\n  toArray: (options: Partial<ToArrayOptions<TIn>>) => Promise<Array<TIn | undefined>>\n  /**\n   * Listen for values\n   * @param callback \n   * @returns \n   */\n  onValue: (callback: (value: TIn) => void) => void\n}\n\nexport type ToArrayOptions<V> = {\n  /**\n   * Maximim time to wait for `limit` to be reached. 10s by default.\n   */\n  maximumWait: Interval\n  /**\n   * Number of items to read\n   */\n  limit: number\n  /**\n   * Behaviour if threshold is not reached.\n   * partial: return partial results\n   * throw: throw an error\n   * fill: fill remaining array slots with `fillValue`\n   */\n  underThreshold: `partial` | `throw` | `fill`\n  /**\n   * Value to fill empty slots with if `underThreshold = 'fill'`.\n   */\n  fillValue: V\n}\n\n/**\n * Laziness\n * * start: only begins on first subscriber. Keeps running even when there are no subscribers\n * * very: only begins on first subscriber. Stops looping if there are no subscribers\n * * never: begins calling function when initalised and doesn't stop until Reactive is disposed\n */\nexport type Lazy = `initial` | `never` | `very`\nexport type InitLazyStreamOptions = Partial<InitStreamOptions> & {\n  lazy?: Lazy\n  debugLabel?: string\n  onStart: () => void\n  onStop: () => void\n};\n\nexport type InitLazyStreamInitedOptions<T> = InitLazyStreamOptions & {\n  initialValue: T\n}\n\n\nexport type ReactiveOrSource<V> = Wrapped<V> | Reactive<V> | IterableIterator<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V> | Array<V> | (() => V)\n\nexport type BindUpdateOpts<V> = {\n  initial: (v: V, el: HTMLElement) => void,\n  binds: Record<string, DomBindValueTarget & {\n    transform?: (value: any) => string\n  }>\n}\n\n/**\n * A Reactive\n */\nexport type Reactive<V> = {\n  /**\n   * Subscribes to a reactive. Receives\n   * data as well as signals. Use `onValue` if you\n   * just care about values.\n   * \n   * Return result unsubscribes.\n   * \n   * ```js\n   * const unsub = someReactive.on(msg => {\n   *    // Do something with msg.value\n   * });\n   * \n   * unsub(); // Unsubscribe\n   * ```\n   * @param handler \n   */\n  on(handler: (value: Passed<V>) => void): Unsubscriber\n  /**\n   * Subscribes to a reactive's values.\n   * Returns a function that unsubscribes.\n   * @param handler\n   */\n  onValue(handler: (value: V) => void): Unsubscriber\n\n  /**\n   * Disposes the reactive, providing a reason for debug tracing\n   * @param reason \n   */\n  dispose(reason: string): void\n  /**\n   * Returns _true_ if Reactive is disposed\n   */\n  isDisposed(): boolean\n  /**\n   * Optional 'set' to write a value. Use {@link ReactiveWritable} if you want this non-optional\n   * @param value \n   */\n  set?(value: V): void\n}\n\n/**\n * A reactive that can be 'pinged' to produce a value.\n * \n * Use {@link isPingable} to check if a reactive is pingable.\n * \n * Pingable reactives are returned from\n * * interpolate\n * * computeWithPrevious\n * * valueToPing\n */\nexport type ReactivePingable<V> = Reactive<V> & {\n  ping(): void\n}\n\nexport type Unsubscriber = () => void;\n\nexport type ReactiveNonInitial<V> = Reactive<V> & {\n  last(): V | undefined\n}\n\n/**\n * A stream that can be written to\n */\nexport type ReactiveWritable<TIn, TOut = TIn> = Reactive<TOut> & {\n  /**\n   * Sets a value\n   * @param value Value to write\n   */\n  set(value: TIn): void\n}\n\nexport type ReactiveInitial<V> = Reactive<V> & {\n  last(): V\n}\n\nexport type ReactiveFinite = {\n  isDone(): boolean\n}\n\nexport type ReactiveArray<V> = ReactiveWritable<Array<V>> & {\n  push(value: V): void\n  deleteAt(index: number): void\n  deleteWhere(filter: (value: V) => boolean): number\n  setAt(index: number, value: V): void\n  insertAt(index: number, value: V): void\n  onArray(handler: (changes: Passed<Array<ChangeRecord<number>>>) => void): () => void\n}\nexport type ObjectFieldHandler = { value: any, fieldName: string, pattern: string };\n\nexport type ReactiveDiff<V> = Reactive<V> & ReactiveWritable<V> & {\n  /**\n   * Notifies when the value of `fieldName` is changed.\n   * \n   * Use the returned function to unsubscribe.\n   * @param fieldName \n   * @param handler \n   */\n  onField(fieldName: string, handler: (result: ObjectFieldHandler) => void): () => void\n  /**\n   * Notifies of which field(s) were changed.\n   * If you just care about the whole, changed data use the `value` event.\n   * \n   * Use the returned function to unsubscribe.\n   * @param changes \n   */\n  onDiff(changes: (changes: Array<Immutable.PathDataChange<any>>) => void): () => void\n  /**\n   * Updates the reactive with some partial key-value pairs.\n   * Keys omitted are left the same as the current value.\n   * @param changedPart \n   * @returns Returns new value\n   */\n  update(changedPart: RecursivePartial<V>): V\n  /**\n   * Updates a particular field by its path\n   * @param field \n   * @param value \n   */\n  updateField(field: string, value: any): void\n}\n\n/**\n * A reactive stream which can be read and written to\n */\nexport type ReactiveStream<V> = Reactive<V> & ReactiveWritable<V> & {\n  /**\n   * Removes all the subscribers from this stream.\n   */\n  removeAllSubscribers(): void\n  /**\n   * Dispatches a signal\n   * @param signal \n   * @param context \n   */\n  signal(signal: SignalKinds, context?: string): void\n}\n\nexport type ReactiveInitialStream<V> = ReactiveStream<V> & ReactiveInitial<V>;\n\nexport type DomBindValueTarget = {\n  /**\n   * If _true_ `innerHTML` is set (a shortcut for elField:`innerHTML`)\n   */\n  htmlContent?: boolean\n  /**\n   * If _true_, 'textContent' is set (a shortcut for elField:'textContext')\n   */\n  textContent?: boolean\n  /**\n   * If set, this DOM element field is set. Eg 'textContent'\n   */\n  elField?: string\n  /**\n   * If set, this DOM attribute is set, Eg 'width'\n   */\n  attribName?: string\n  /**\n   * If set, this CSS variable is set, Eg 'hue' (sets '--hue')\n   */\n  cssVariable?: string\n  /**\n   * If set, this CSS property is set, Eg 'background-color'\n   */\n  cssProperty?: string\n}\n\nexport type ElementBind = {\n  /**\n   * Tag name for this binding.\n   * Overrides `defaultTag`\n   */\n  tagName?: string\n  /**\n   * If _true_, sub-paths are appended to element, rather than `container`\n   */\n  nestChildren?: boolean\n  transform?: (value: any) => string\n}\nexport type ElementsOptions = {\n  container: HTMLElement | string\n  defaultTag: string,\n  binds: Record<string, DomBindValueTarget & ElementBind>\n}\n\nexport type DomBindTargetNode = {\n  query?: string\n  element?: HTMLElement\n}\n\nexport type DomBindTargetNodeResolved = {\n  element: HTMLElement\n}\n\nexport type DomBindUnresolvedSource<TSource, TDestination> = DomBindTargetNode & DomBindSourceValue<TSource, TDestination> & DomBindValueTarget;\nexport type DomBindResolvedSource<TSource, TDestination> = DomBindTargetNodeResolved & DomBindSourceValue<TSource, TDestination> & DomBindValueTarget;\n\nexport type DomBindSourceValue<TSource, TDestination> = {\n  twoway?: boolean\n  /**\n   * Field from source value to pluck and use.\n   * This will also be the value passed to the transform\n   */\n  sourceField?: keyof TSource\n  transform?: (input: TSource) => TDestination\n  transformValue?: (input: any) => TDestination\n}\n\nexport type DomBindInputOptions<TSource, TDestination> = DomBindSourceValue<TSource, TDestination> & {\n  transformFromInput: (input: TDestination) => TSource\n}\n\n// export type PipeSet<In, Out> = [\n//   Reactive<In>,\n//   ...Array<Reactive<any> & ReactiveWritable<any>>,\n//   ReactiveWritable<Out> & Reactive<any>\n// ]\nexport type PipeSet<In, Out> = [\n  Reactive<In>,\n  ...Array<Reactive<any> & ReactiveWritable<any>>\n]\n\nexport type InitStreamOptions = {\n  /**\n   * Optional label to associate with this stream. Useful for debugging.\n   */\n  debugLabel: string\n  /**\n   * Called when there is a subscriber after there were no subscribers.\n   * Useful for 'startup' types of things that we want to run only when someone is actually listening.\n   * \n   * During the lifeycle of a stream, this could be called multiple times. Eg if all subscribers are removed\n   * next time someone subscribes it will get called again.\n   * @returns \n   */\n  onFirstSubscribe: () => void\n  /**\n   * Called when there are no longer any subscribers. Useful for shutting down\n   * activities now that no-one is listening.\n   * \n   * During the lifecycle of a stream, this could be called multiple times.\n   * @returns\n   */\n  onNoSubscribers: () => void\n  /**\n   * Called whenever the stream disposes. Useful for cleaning up.\n   * @param reason \n   * @returns \n   */\n  onDispose: (reason: string) => void\n}\n\n\nexport type DomCreateOptions = {\n  tagName: string\n  parentEl: string | HTMLElement\n}\n\nexport type PipeDomBinding = {\n  /**\n   * Remove binding and optionally delete element(s) (false by default)\n   */\n  remove(deleteElements: boolean): void\n}\n\n\n/**\n * WithValue stream options\n */\nexport type WithValueOptions<V> = Partial<InitStreamOptions> & {\n  /**\n   * Initial value\n   */\n  initial: V,\n  /**\n   * Laziness\n   */\n  lazy?: Lazy\n}\n\n\n\n\nexport type ResolveOptions = {\n  /**\n   * How many times to return value or call function.\n   * If _infinite_ is set to true, this value is ignored\n   */\n  loops: number\n  /**\n   * If _true_ loops forever\n   */\n  infinite: boolean\n  /**\n   * Delay before value\n   */\n  interval: Interval\n\n  lazy: Lazy\n}\n\nexport type ReactiveOpInit<TIn, TOut, TOpts> = (options: Partial<TOpts>) => ReactiveOp<TIn, TOut>\nexport type ReactiveOp<TIn, TOut> = (source: ReactiveOrSource<TIn>) => Reactive<TOut>\n\nexport type ReactiveOpLinks<In, Out> = [\n  ReactiveOrSource<In>,\n  ...Array<ReactiveOp<any, any>>,\n  ReactiveOp<any, Out>\n]\n\nexport type RxValueTypes<T extends ReadonlyArray<ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V | undefined :\n    T[ K ] extends Wrapped<infer V> ? V | undefined :\n    T[ K ] extends Generator<infer V> ? V | undefined :\n    T[ K ] extends AsyncGenerator<infer V> ? V | undefined :\n    T[ K ] extends IterableIterator<infer V> ? V | undefined :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V | undefined :\n    T[ K ] extends Array<infer V> ? V | undefined :\n    never };\n\nexport type RxValueTypeObject<T extends Record<string, ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V :\n    T[ K ] extends Wrapped<infer V> ? V :\n    T[ K ] extends Generator<infer V> ? V :\n    T[ K ] extends AsyncGenerator<infer V> ? V :\n    T[ K ] extends IterableIterator<infer V> ? V :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V :\n    T[ K ] extends Array<infer V> ? V :\n    never };\n\nexport type RxValueTypeObjectOrUndefined<T extends Record<string, ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V | undefined :\n    T[ K ] extends Wrapped<infer V> ? V | undefined :\n    T[ K ] extends Generator<infer V> ? V | undefined :\n    T[ K ] extends AsyncGenerator<infer V> ? V | undefined :\n    T[ K ] extends IterableIterator<infer V> ? V | undefined :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V | undefined :\n    T[ K ] extends Array<infer V> ? V | undefined :\n    never };\n\nexport type RxValueTypeRx<T extends Record<string, ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? Reactive<V> :\n    T[ K ] extends Wrapped<infer V> ? Reactive<V> :\n    T[ K ] extends Generator<infer V> ? Reactive<V> :\n    T[ K ] extends AsyncGenerator<infer V> ? Reactive<V> :\n    T[ K ] extends IterableIterator<infer V> ? Reactive<V> :\n    T[ K ] extends AsyncIterableIterator<infer V> ? Reactive<V> :\n    T[ K ] extends Array<infer V> ? Reactive<V> :\n    never };\n\nexport type PrimitiveValueTypeObject<T extends Record<string, Primitive>> =\n  { [ K in keyof T ]:\n    T[ K ] extends number ? number | undefined :\n    T[ K ] extends string ? string | undefined :\n    T[ K ] extends boolean ? boolean | undefined :\n    T[ K ] extends bigint ? bigint | undefined :\n    never };\n\n\n","import { intervalToMs } from \"../flow/IntervalType.js\";\nimport type { ReactiveOrSource, ToArrayOptions } from \"./Types.js\";\nimport { resolveSource } from \"./ResolveSource.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./Util.js\";\n\n/**\n * Reads a set number of values from `source`, returning as an array. May contain\n * empty values if desired values is not reached.\n * \n * After the limit is reached (or `source` completes), `source` is unsubscribed from.\n * \n * If no limit is set, it will read until `source` completes or `maximumWait` is reached.\n * `maximumWait` is 10 seconds by default.\n * \n * Use {@link toArrayOrThrow} to throw if desired limit is not reached.\n * \n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArray()(source);\n * // Read 5 items from `source`\n * const data = await toArray({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArray({ maximumWait: 10_1000 })(source);\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport async function toArray<V>(source: ReactiveOrSource<V>, options: Partial<ToArrayOptions<V>> = {}): Promise<Array<V | undefined>> {\n  const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n  const maximumWait = intervalToMs(options.maximumWait, 10 * 1000);\n  const underThreshold = options.underThreshold ?? `partial`\n  const read: Array<V | undefined> = [];\n\n  const rx = resolveSource(source);\n\n  const promise = new Promise<Array<V | undefined>>((resolve, reject) => {\n    const done = () => {\n      clearTimeout(maxWait);\n      unsub();\n      if (read.length < limit && underThreshold === `throw`) {\n        reject(new Error(`Threshold not reached. Wanted: ${ limit } got: ${ read.length }. Maximum wait: ${ maximumWait }`));\n        return;\n      }\n      if (read.length < limit && underThreshold === `fill`) {\n        for (let index = 0; index < limit; index++) {\n          if (read[ index ] === undefined) {\n            //console.log(`Rx.toArray filling at index: ${ index }`);\n            read[ index ] = options.fillValue;\n          }\n        }\n      }\n      resolve(read);\n    }\n\n    const maxWait = setTimeout(() => {\n      done();\n    }, maximumWait);\n\n    const unsub = rx.on(message => {\n      //console.log(`Rx.toArray: ${ JSON.stringify(message) }`);\n      if (messageIsDoneSignal(message)) {\n        done();\n      } else if (messageHasValue(message)) {\n        read.push(message.value);\n        //console.log(`Rx.toArray read buffer: ${ JSON.stringify(read) }`);\n        if (read.length === limit) {\n          done();\n        }\n      }\n    });\n  });\n\n  return promise;\n}\n\n\n/**\n * By default, reads all the values from `source`, or until 5 seconds has elapsed.\n * \n * If `limit` is provided as an option, it will exit early, or throw if that number of values was not acheived.\n * \n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArrayOrThrow()(source);\n * // Read 5 items from `source`\n * const data = await toArrayOrThrow({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArrayOrThrow({ maximumWait: 10_1000 })(source);\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport async function toArrayOrThrow<V>(source: ReactiveOrSource<V>, options: Partial<ToArrayOptions<V>> = {}): Promise<Array<V>> {\n  const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n  const maximumWait = options.maximumWait ?? 5 * 1000;\n  const v = await toArray(source, { limit, maximumWait, underThreshold: `partial` });\n\n  // There was a limit, but it wasn't reached\n  if (options.limit && v.length < options.limit) throw new Error(`Threshold not reached. Wanted: ${ options.limit }, got ${ v.length }`);\n\n  // Otherwise, we may have been reading for a specified duration\n  return v as Array<V>;\n\n}","import { resolveSource } from \"./ResolveSource.js\";\nimport type { ReactiveOrSource } from \"./Types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./Util.js\";\n\n/**\n * Returns an AsyncGenerator wrapper around Reactive.\n * This allows values to be iterated over using a `for await` loop,\n * like Chains.\n *\n * ```js\n * // Reactive numerical value\n * const number = Reactive.number(10);\n * \n * const g = Reactive.toGenerator(number);\n * for await (const v of g) {\n *  console.log(v); // Prints out whenever the reactive value changes\n * }\n * // Execution doesn't continue until Reactive finishes\n * ```\n * \n * When/if `source` closes, an exception is thrown.\n * To catch this, wrap the calling `for await` in a try-catch block\n * ```js\n * try {\n *  for await (const v of g) {\n *  }\n * } catch (error) {\n * }\n * // Completed\n * ``` \n * \n * Use something like `setTimeout` to loop over the generator\n * without impeding the rest of your code flow. For example:\n * ```js\n * // Listen for every pointerup event\n * const ptr = Reactive.fromEvent(document.body, `pointerup`);\n * // Start iterating\n * setTimeout(async () => {\n *  const gen = Reactive.toGenerator(ptr);\n *  try {\n *    for await (const v of gen) {\n *      // Prints out whenever there is a click\n *      console.log(v);\n *    }\n *  } catch (e) { }\n *  console.log(`Iteration done`);\n * });\n * \n * // Execution continues here immediately\n * ```\n * @param source \n */\nexport async function* toGenerator<V>(source: ReactiveOrSource<V>): AsyncGenerator<V> {\n  const s = resolveSource(source);\n  let promiseResolve: ((value: V | PromiseLike<V>) => void) = (_) => {/** noop */ };\n  let promiseReject: ((reason: string) => void) = (_) => {/** no-op */ }\n\n  const promiseInit = () => (new Promise<V>((resolve, reject) => {\n    promiseResolve = resolve;\n    promiseReject = reject;\n  }));\n  let promise = promiseInit();\n  let keepRunning = true;\n\n  s.on(message => {\n    if (messageHasValue(message)) {\n      promiseResolve(message.value);\n      promise = promiseInit();\n    } else if (messageIsDoneSignal(message)) {\n      keepRunning = false;\n      promiseReject(`Source has completed`);\n    }\n  });\n\n  while (keepRunning) {\n    yield await promise;\n  }\n}\n","import * as Ops from \"./ops/index.js\";\nimport { resolveSource } from \"./ResolveSource.js\";\nimport { toArray, toArrayOrThrow } from \"./ToArray.js\";\nimport type { ReactiveOrSource, Wrapped, ToArrayOptions, InitStreamOptions, Reactive, RxValueTypes, CombineLatestOptions, ReactiveOp, } from \"./Types.js\";\nimport type { ChunkOptions, FieldOptions, FilterPredicate, DebounceOptions, SwitcherOptions, SplitOptions, ThrottleOptions, TransformOpts, SyncOptions, } from './ops/Types.js'\nimport type { TimeoutPingOptions, TimeoutValueOptions } from './sources/Types.js'\nimport { messageHasValue } from \"./Util.js\";\nimport { mapObjectShallow } from '../data/MapObject.js';\nimport * as Enacts from './sinks/index.js';\nimport type { Processors } from \"../data/Process.js\";\n\n/**\n * Wrap a reactive source to allow for chained\n * function calls.\n * \n * Example:\n * For every `pointerup` event on the body, chunk the events over\n * periods of 200ms, get the number of events in that period,\n * and print it out.\n * \n * eg. detecting single or double-clicks\n * ```js\n * wrap(Rx.fromEvent<{ x: number, y: number }>(document.body, `pointerup`))\n *  .chunk({ elapsed: 200 })\n *  .transform(v => v.length)\n *  .onValue(v => { console.log(v) });\n * ```\n * @param source \n * @returns \n */\nexport function wrap<TIn>(source: ReactiveOrSource<TIn>): Wrapped<TIn> {\n  return {\n    source: resolveSource(source),\n    enacts: {\n      setHtmlText: (options) => {\n        return Enacts.setHtmlText(source, options);\n      },\n    },\n    annotate: <TAnnotation>(transformer: (value: TIn) => TAnnotation): Wrapped<{ value: TIn, annotation: TAnnotation }> => {\n      const a = Ops.annotate<TIn, TAnnotation>(source, transformer);\n      return wrap(a);\n    },\n    annotateWithOp: <TOut>(op: ReactiveOp<TIn, TOut>): Wrapped<{ value: TIn, annotation: TOut }> => {\n      const a = Ops.annotateWithOp<TIn, TOut>(source, op);\n      return wrap(a);\n    },\n\n    chunk: (options: Partial<ChunkOptions>): Wrapped<Array<TIn>> => {\n      const w = wrap<Array<TIn>>(Ops.chunk(source, options));\n      return w;\n    },\n    debounce: (options: Partial<DebounceOptions> = {}) => {\n      return wrap(Ops.debounce<TIn>(source, options));\n    },\n    field: <TSource, TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TSource, TFieldType>> = {}) => {\n      // Ops.field requires TIn extends object\n      // Would be good if `wrap` returns different versions depending on TIn, so .field\n      // would not be present at all if we had Reactive<number>, for example\n      // @ts-expect-error\n      const f = Ops.field<TIn, TFieldType>(source, fieldName, options);\n      return wrap<TFieldType>(f);\n    },\n    filter: (predicate: FilterPredicate<TIn>, options: Partial<InitStreamOptions>) => {\n      return wrap(Ops.filter(source, predicate, options));\n    },\n    combineLatestToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(sources: T, options: Partial<CombineLatestOptions> = {}) => {\n      const srcs = [ source, ...sources ] as any as T;\n      return wrap(Ops.combineLatestToArray(srcs, options));\n    },\n    combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name?: string } & Partial<CombineLatestOptions>) => {\n      const name = options.name ?? `source`;\n      const o = { ...sources };\n      (o as any)[ name ] = source;\n      return wrap(Ops.combineLatestToObject(o, options));\n    },\n    min: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.min(source, options));\n    },\n    max: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.max(source, options));\n    },\n    average: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.average(source, options));\n    },\n    sum: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.sum(source, options));\n    },\n    tally: (options: Partial<Ops.TallyOptions> = {}) => {\n      return wrap(Ops.tally(source, options));\n    },\n    split: (options: Partial<SplitOptions> = {}) => {\n      const streams = Ops.split<TIn>(source, options).map(v => wrap(v));\n      return streams;\n    },\n    splitLabelled: <K extends keyof TIn>(...labels: Array<K>) => {\n      const l = Ops.splitLabelled<TIn, keyof TIn>(source, labels);\n      const m = mapObjectShallow<typeof l, Wrapped<TIn>>(l, args => wrap(args.value as Reactive<TIn>)) as Record<K, Wrapped<TIn>>;\n      return m;\n    },\n    switcher: <TRec extends Record<string, FilterPredicate<TIn>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions> = {}) => {\n      const s = Ops.switcher<TIn, TRec, TLabel>(source, cases, options);\n      const m = mapObjectShallow<typeof s, Wrapped<TIn>>(s, args => wrap(args.value as Reactive<TIn>));\n      return m as Record<TLabel, Wrapped<TIn>>;\n    },\n    syncToArray: <const T extends ReadonlyArray<ReactiveOrSource<any>>>(additionalSources: T, options: Partial<SyncOptions> = {}) => {\n      const unwrapped = [ source, ...additionalSources ].map(v => resolveSource(v));\n      const x = Ops.syncToArray(unwrapped, options) as Reactive<[ TIn, ...RxValueTypes<T> ]>;\n      return wrap(x); //synchronise<TIn>([ source, ...unwrapped ] as const));\n    },\n    syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name?: string } & Partial<SyncOptions> = {}) => {\n      const name = options.name ?? `source`;\n      const o = { ...sources };\n      (o as any)[ name ] = source;\n      return wrap(Ops.syncToObject(o, options));\n    },\n    tapProcess: <T2, T3, T4, T5, T6>(...processors: Processors<TIn, T2, T3, T4, T5, T6>) => {\n      Ops.tapProcess(source, ...processors)\n      return wrap(source);\n    },\n    tapStream: (divergedStream) => {\n      Ops.tapStream(source, divergedStream);\n      return wrap(source);\n    },\n    tapOps: <TOut>(source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<TIn, TOut>>) => {\n      Ops.tapOps(source, ...ops);\n      return wrap(source);\n    },\n    throttle: (options: Partial<ThrottleOptions> = {}) => {\n      return wrap(Ops.throttle<TIn>(source, options));\n    },\n    transform: <TOut>(transformer: (value: TIn) => TOut, options: Partial<TransformOpts> = {}) => {\n      return wrap(Ops.transform(source, transformer, options));\n    },\n    timeoutValue: <TTrigger>(options: TimeoutValueOptions<TTrigger>) => {\n      return wrap(Ops.timeoutValue<TIn, TTrigger>(source, options));\n    },\n    timeoutPing: (options: TimeoutPingOptions) => {\n      return wrap(Ops.timeoutPing(source, options));\n    },\n    toArray: (options: Partial<ToArrayOptions<TIn>>) => {\n      return toArray(source, options);\n    },\n    toArrayOrThrow: (options: Partial<ToArrayOptions<TIn>>) => {\n      return toArrayOrThrow(source, options);\n    },\n    onValue: (callback: ((value: TIn) => void)) => {\n      const s = resolveSource(source);\n      s.on(message => {\n        if (messageHasValue(message)) callback(message.value);\n      })\n    }\n  }\n}\n","import * as Immutable from \"../data/Pathed.js\";\nimport { resolveEl } from \"../dom/ResolveEl.js\";\nimport * as Rx from \"./index.js\";\nimport type { ElementsOptions, PipeDomBinding, BindUpdateOpts, DomBindResolvedSource, DomBindSourceValue, DomBindValueTarget, ElementBind } from './Types.js';\nimport { hasLast, messageHasValue, messageIsSignal } from \"./Util.js\";\nimport { getFromKeys } from \"../data/maps/MapFns.js\";\nimport { afterMatch, beforeMatch } from \"../text/Text.js\";\nimport { stringSegmentsWholeToEnd, stringSegmentsWholeToFirst } from \"../text/Segments.js\";\nimport { QueueMutable } from \"../collections/queue/QueueMutable.js\";\nimport { object } from \"./sources/Object.js\";\n\n/**\n * Reactive stream of array of elements that match `query`.\n * @param query \n * @returns \n */\nexport function fromDomQuery(query: string) {\n  const elements = [ ...document.querySelectorAll(query) ] as Array<HTMLElement>;\n\n  return object(elements);\n  /// TODO: MutationObserver to update element list\n}\n\n/**\n * Updates an element's `textContent` when the source value changes.\n * ```js\n * bindText(source, `#blah`);\n * ```\n * @param elOrQuery \n * @param source \n * @param bindOpts \n */\nexport const bindText = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, bindOpts: Partial<Rx.DomBindSourceValue<TSource, string>> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `textContent` });\n}\n\n/**\n * Updates an element's `value` (as well as the 'value' attribute) when the source value changes.s\n * @param source \n * @param elOrQuery \n * @param bindOpts \n * @returns \n */\nexport const bindValueText = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindSourceValue<TSource, string>> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `value`, attribName: `value` });\n}\n\n/**\n * Updates an element's `valueAsNumber` (as well as the 'value' attribute) when the source value changes.\n * ```js\n * // Create a reactive number, with a default value of 10\n * const r1 = Rx.From.number(10);\n * // Bind reactive to HTML input element with id 'inputRange'\n * const b1 = Rx.Dom.bindValueRange(r1,`#inputRange`);\n *\n * // Demo: Change the reactive value every second\n * // ...changing the reactive in turn updates the HTML\n * setInterval(() => {\n *  r1.set(Math.floor(Math.random()*100));\n * }, 1000);\n * ```\n * @param source \n * @param elOrQuery \n * @param bindOpts \n * @returns \n */\n// export const bindValueRange = (source: Rx.Reactive<number>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindInputOptions<number, number>> = {}) => {\n//   const el = validateElement(elOrQuery, `range`);\n//   const b = bindElement<number, number>(source, el, { ...bindOpts, elField: `valueAsNumber`, attribName: `value` });\n//   const twoway = bindOpts.twoway ?? false;\n\n//   const transformFromInput = bindOpts.transformFromInput ?? ((value) => {\n//     if (typeof value === `number`) return value;\n//     return Number.parseFloat(value);\n//   });\n//   const input = Rx.From.domValueAsNumber(el);\n//   return setupInput(b, input, source, twoway, transformFromInput);\n// }\n\n// export const bindValueColour = (source: Rx.Reactive<Colour.Colourish>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindInputOptions<Colour.Colourish, string>> = {}) => {\n//   const el = validateElement(elOrQuery, `color`);\n//   const b = bindElement<Colour.Colourish, string>(source, el, {\n//     ...bindOpts,\n//     elField: `value`,\n//     attribName: `value`,\n//     transform(input) {\n//       console.log(`transform from: ${ JSON.stringify(input) } to hex`);\n//       const c = Colour.resolve(input);\n//       return c.to(`srgb`).toString({ format: `hex`, collapse: false });\n//     },\n//   });\n\n//   const twoway = bindOpts.twoway ?? false;\n\n//   const transformFromInput = bindOpts.transformFromInput ?? ((value) => {\n//     const x = Colour.toHsl(value);\n//     console.log(`transformFromInput: ${ value } x: ${ JSON.stringify(x) }`);\n//     return x;\n//   });\n\n//   const input = Rx.From.domValue<Colour.Hsl>(el, {\n//     domToValue: transformFromInput\n//   });\n//   return setupInput(b, input, source, twoway, transformFromInput);\n// }\n\nconst setupInput = <TSource, TDestination>(b: PipeDomBinding, input: Rx.Reactive<TDestination>, source: Rx.Reactive<TSource>, twoway: boolean, transformFromInput: (value: TDestination) => TSource) => {\n  input.onValue(value => {\n    const v = transformFromInput(value);\n    if (twoway && Rx.isWritable(source)) {\n      source.set(v);\n    }\n  });\n  const dispose = () => {\n    input.dispose(`bindInput twoway dispose`);\n    b.remove(false);\n  }\n  return { ...b, dispose, input };\n}\n\nconst validateElement = (elOrQuery: string | HTMLInputElement | null, type?: string): HTMLInputElement => {\n  const el = resolveEl(elOrQuery);\n  if (el.nodeName !== `INPUT`) throw new Error(`HTML INPUT element expected. Got: ${ el.nodeName }`);\n  if (type !== undefined && el.type !== type) throw new Error(`HTML INPUT element expected with type 'range'. Got: ${ el.type }`);\n  return el;\n}\n\n\n/**\n * Updates an element's `innerHTML` when the source value changes\n * ```js\n * bindHtml(source, `#blah`);\n * ```\n * \n * Uses {@link bindElement}, with `{elField:'innerHTML'}` as the options.\n * @param elOrQuery\n * @param source \n * @param bindOpts \n * @returns \n */\nexport const bindHtml = <TSource>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, bindOpts: DomBindSourceValue<TSource, string> = {}) => {\n  return bindElement(source, elOrQuery, { ...bindOpts, elField: `innerHTML` });\n}\n\n\n/**\n * Shortcut to bind to an elements attribute\n * @param elOrQuery\n * @param source \n * @param attribute \n * @param bindOpts \n * @returns \n */\n// export const bindAttribute = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, attribute: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, attribName: attribute });\n// }\n\n/**\n * Shortcut to bind to a CSS variable\n * @param elOrQuery\n * @param source \n * @param cssVariable \n * @param bindOpts \n * @returns \n */\n// export const bindCssVariable = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, cssVariable: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, cssVariable: cssVariable });\n// }\n\n/**\n * Creates a new HTML element, calling {@link bind} on it to update when `source` emits new values.\n * \n * \n * ```js\n * // Set textContent of a SPAN with values from `source`\n * create(source, { tagName: `span`, parentEl: document.body })\n * ```\n * \n * If `parentEl` is not given in the options, the created element needs to be manually added\n * ```js\n * const b = create(source);\n * someEl.append(b.el); // Append manually\n * ```\n * \n * ```\n * // Set 'title' attribute based on values from `source`\n * create(source, { parentEl: document.body, attribName: `title` })\n * ```\n * @param source \n * @param options \n * @returns \n */\n// export const create = <V>(source: Rx.Reactive<V>, options: Partial<DomCreateOptions> & Partial<DomBindOptions<V>> = {}): PipeDomBinding => {\n//   const nodeType = options.tagName ?? `DIV`;\n\n//   const el = document.createElement(nodeType);\n//   const b = bind(el, source, options);\n\n//   if (options.parentEl) {\n//     const parentElementOrQuery = resolveEl(options.parentEl);\n//     if (parentElementOrQuery === undefined) throw new Error(`Parent element could not be resolved`);\n//     parentElementOrQuery.append(el);\n//   }\n//   return b;\n// }\n\n/**\n * Update a DOM element's field, attribute or CSS variable when `source` produces a value.\n * \n * ```js\n * // Access via DOM query. Binds to 'textContent' by default\n * bind(readableSource, `#someEl`);\n * \n * // Set innerHTML instead\n * bind(readableSource, someEl, { elField: `innerHTML` });\n * \n * // An attribute\n * bind(readableSource, someEl, { attribName: `width` });\n * \n * // A css variable ('--' optiona)\n * bind(readableSource, someEl, { cssVariable: `hue` });\n * \n * // Pluck a particular field from source data.\n * // Ie someEl.textContent = value.colour\n * bind(readableSource, someEl, { sourceField: `colour` });\n * \n * // Transform value before setting it to field\n * bind(readableSource, someEl, { \n *  field: `innerHTML`, \n *  transform: (v) => `Colour: ${v.colour}`\n * })\n * ```\n * \n * If `source` has an initial value, this is used when first bound.\n * \n * Returns {@link PipeDomBinding} to control binding:\n * ```js\n * const bind = bind(source, `#someEl`);\n * bind.remove();     // Unbind\n * bind.remove(true); // Unbind and remove HTML element\n * ```\n * \n * If several fields need to be updated based on a new value, consider using {@link bindUpdate} instead.\n * @param elOrQuery Element to update to, or query string such as '#someid'\n * @param source Source of data\n * @param binds Bindings\n */\nexport const bindElement = <TSource, TDestination>(source: Rx.Reactive<TSource>, elOrQuery: string | HTMLElement | null, ...binds: Array<DomBindSourceValue<TSource, TDestination> & Rx.DomBindValueTarget>): PipeDomBinding => {\n  if (elOrQuery === null) throw new Error(`Param 'elOrQuery' is null`);\n  if (elOrQuery === undefined) throw new Error(`Param 'elOrQuery' is undefined`);\n\n  const el = resolveEl(elOrQuery);\n  let b = [];\n  if (binds.length === 0) {\n    b.push({ elField: `textContent` });\n  } else {\n    b = [ ...binds ];\n  }\n  const bb = b.map(bind => {\n    if (`element` in bind) return bind as DomBindResolvedSource<TSource, TDestination>;\n    return { ...bind, element: el } as DomBindResolvedSource<TSource, TDestination>\n  });\n  return bind<TSource, TDestination>(source, ...bb);\n}\n\nconst resolveBindUpdater = (bind: DomBindValueTarget, element: HTMLElement): (value: any) => void => {\n  const b = resolveBindUpdaterBase(bind);\n  return (value: any) => {\n    b(value, element);\n  }\n}\n\nconst resolveBindUpdaterBase = (bind: DomBindValueTarget): (value: any, element: HTMLElement) => void => {\n  if (bind.elField !== undefined || (bind.cssVariable === undefined && bind.attribName === undefined && bind.cssProperty === undefined && bind.textContent === undefined && bind.htmlContent === undefined)) {\n    const field = bind.elField ?? `textContent`;\n    return (v: any, element: HTMLElement) => {\n      (element as any)[ field ] = v;\n    }\n  }\n  if (bind.attribName !== undefined) {\n    const attrib = bind.attribName;\n    return (v: any, element: HTMLElement) => {\n      element.setAttribute(attrib, v);\n    }\n  }\n  if (bind.textContent) {\n    return (v: any, element: HTMLElement) => {\n      element.textContent = v;\n    }\n  }\n  if (bind.htmlContent) {\n    return (v: any, element: HTMLElement) => {\n      element.innerHTML = v;\n    }\n  }\n  if (bind.cssVariable !== undefined) {\n    let css = bind.cssVariable;\n    if (!css.startsWith(`--`)) css = `--` + css;\n    return (v: any, element: HTMLElement) => {\n      element.style.setProperty(css, v);\n    }\n  }\n  if (bind.cssProperty !== undefined) {\n    return (v: any, element: HTMLElement) => {\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      (element.style as any)[ bind.cssProperty! ] = v;\n    }\n  }\n  return (_: any, _element: HTMLElement) => {\n    /** no-op */\n  }\n}\n\nconst resolveTransform = <TSource, TDestination>(bind: DomBindSourceValue<TSource, TDestination>) => {\n  if (!bind.transform && !bind.transformValue) return;\n  if (bind.transformValue) {\n    if (bind.sourceField === undefined) throw new Error(`Expects 'sourceField' to be set when 'transformValue' is set`);\n    return (value: TSource) => {\n      const fieldValue = (value as any)[ bind.sourceField ]\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      return bind.transformValue!(fieldValue);\n    }\n  } else if (bind.transform) {\n    if (bind.sourceField !== undefined) throw new Error(`If 'transform' is set, 'sourceField' is ignored`);\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return (value: TSource) => bind.transform!(value);\n  }\n}\n\n/**\n * Binds `source` to one or more element(s). One or more bindings for the same source\n * can be provided.\n * \n * ```js\n * bind(source, \n *  // Binds .name field of source values to textContent of #some-element\n *  { query: `#some-element`, sourceField: `name` },\n *  { query: `section`, }\n * );\n * ```\n * \n * Can update\n * * CSS variables\n * * CSS styles\n * * textContent / innerHTML\n * * HTML DOM attributes and object fields\n * \n * Can use a particular field on source values, or use the whole value. These can\n * pass through `transformValue` or `transform` respectively.\n * \n * Returns a function to unbind from source and optionally remove HTML element\n * ```js\n * const unbind = bind( . . . );\n * unbind();     // Unbind\n * unbind(true); // Unbind and remove HTML element(s)\n * ```\n * @param source \n * @param bindsUnresolvedElements \n * @returns \n */\nexport const bind = <TSource, TDestination>(source: Rx.Reactive<TSource>, ...bindsUnresolvedElements: Array<Rx.DomBindUnresolvedSource<TSource, TDestination>>): PipeDomBinding => {\n  const binds: Array<DomBindResolvedSource<TSource, TDestination>> = bindsUnresolvedElements.map(bind => {\n    if (bind.element && bind.element !== undefined) return bind as DomBindResolvedSource<TSource, TDestination>;\n    if (bind.query) return {\n      ...bind,\n      element: resolveEl<HTMLElement>(bind.query)\n    }\n    throw new Error(`Unable to resolve element. Missing 'element' or 'query' values on bind. ${ JSON.stringify(bind) }`);\n  });\n\n  const bindsResolved = binds.map(bind => ({\n    update: resolveBindUpdater(bind, bind.element),\n    transformer: resolveTransform(bind),\n    sourceField: bind.sourceField\n  }));\n\n  const update = (value: TSource) => {\n    for (const bind of bindsResolved) {\n      if (bind.transformer) {\n        bind.update(bind.transformer(value));\n      } else {\n        const v = (bind.sourceField) ? value[ bind.sourceField ] : value;\n\n        if (typeof v === `object`) {\n          if (bind.sourceField) {\n            bind.update(JSON.stringify(v));\n          } else {\n            bind.update(JSON.stringify(v));\n          }\n        } else bind.update(v as string);\n      }\n    }\n  }\n  const unsub = source.on(message => {\n    if (messageHasValue(message)) {\n      update(message.value);\n    } else if (messageIsSignal(message)) {\n      console.warn(message);\n    }\n  });\n\n  if (hasLast(source)) {\n    update(source.last());\n  }\n\n  return {\n    remove: (removeElements: boolean) => {\n      unsub();\n      if (removeElements) {\n        for (const bind of binds) {\n          bind.element.remove();\n        }\n      }\n    }\n  }\n}\n\n/**\n * Calls `updater` whenever `source` produces a value. Useful when several fields from a value\n * are needed to update an element.\n * ```js\n * bindUpdate(source, `#someEl`, (v, el) => {\n *  el.setAttribute(`width`, v.width);\n *  el.setAttribute(`height`, v.height);\n * });\n * ```\n * \n * Returns a {@link PipeDomBinding} to manage binding\n * ```js\n * const b = bindUpdate(...);\n * b.remove();     // Disconnect binding\n * b.remove(true); // Disconnect binding and remove element\n * b.el;           // HTML element\n * ```\n * @param elOrQuery \n * @param source \n * @param updater \n * @returns \n */\nexport const bindUpdate = <V>(source: Rx.Reactive<V>, elOrQuery: string | HTMLElement, updater: (v: V, el: HTMLElement) => void): PipeDomBinding => {\n  const el = resolveEl(elOrQuery);\n\n  const update = (value: V) => {\n    updater(value, el);\n  }\n\n  const unsub = source.on(message => {\n    if (messageHasValue(message)) {\n      console.log(message);\n      update(message.value);\n    } else {\n      console.warn(message);\n    }\n  });\n\n  if (hasLast(source)) {\n    update(source.last());\n  }\n\n  return {\n    remove: (removeElement: boolean) => {\n      unsub();\n      if (removeElement) {\n        el.remove();\n      }\n    }\n  }\n}\n\n/**\n * Updates a HTML element based on diffs on an object.\n * ```js\n * // Wrap an object\n * const o = Rx.object({ name: `Jane`, ticks: 0 });\n * const b = bindDiffUpdate(`#test`, o, (diffs, el) => {\n *  // el = reference to #test\n * // diff = Array of Changes, \n * //  eg [ { path: `ticks`, value: 797, previous: 0 } ]\n *  for (const diff of diffs) {\n *    if (diff.path === `ticks`) el.textContent = `${diff.previous} -> ${diff.value}`\n *  }\n * })\n * \n * // Eg. update field\n * o.updateField(`ticks`, Math.floor(Math.random()*1000));\n * ```\n * \n * If `initial` is provided as an option, this will be called if `source` has an initial value. Without this, the DOM won't be updated until the first data\n * update happens.\n * ```js\n * bindDiffUpdate(el, source, updater, { \n *  initial: (v, el) => {\n *    el.innerHTML = v.name;\n *  }\n * })\n * ```\n * @param elOrQuery \n * @param source \n * @param updater \n * @param opts \n * @returns \n */\nexport const bindDiffUpdate = <V>(\n  source: Rx.ReactiveDiff<V>,\n  elOrQuery: string | HTMLElement | null,\n  updater: (diffs: Array<Immutable.PathDataChange<any>>, el: HTMLElement) => void,\n  opts: Partial<BindUpdateOpts<V>> = {}\n): PipeDomBinding & { refresh: () => void } => {\n  if (elOrQuery === null) throw new Error(`Param 'elOrQuery' is null`);\n  if (elOrQuery === undefined) throw new Error(`Param 'elOrQuery' is undefined`);\n\n  const el = resolveEl(elOrQuery);\n  //const binds = opts.binds;\n  const update = (value: Array<Immutable.PathDataChange<any>>) => {\n    updater(value, el);\n  }\n\n  const unsub = source.onDiff(value => {\n    update(value);\n  });\n\n  const init = () => {\n    if (Rx.hasLast(source) && opts.initial) opts.initial(source.last(), el);\n  }\n\n  init();\n\n  return {\n    refresh: () => {\n      init();\n    },\n    remove: (removeElement: boolean) => {\n      unsub();\n      if (removeElement) {\n        el.remove();\n      }\n    }\n  }\n}\n\n/**\n * Creates a new HTML element and calls `bindUpdate` so values from `source` can be used\n * to update it.\n * \n * \n * ```js\n * // Creates a span, adding it to <body>\n * const b = createUpdate(dataSource, (value, el) => {\n *  el.width = value.width;\n *  el.height = value.height;\n * }, { \n *  tagName: `SPAN`,\n *  parentEl: document.body\n * })\n * ```\n * @param source \n * @param updater \n * @param options \n * @returns \n */\n// export const createUpdate = <V>(source: Rx.Reactive<V>, updater: (v: V, el: HTMLElement) => void, options: Partial<DomCreateOptions> = {}): PipeDomBinding => {\n//   const tag = options.tagName ?? `DIV`;\n//   const el = document.createElement(tag);\n//   if (options.parentEl) {\n//     const parent = resolveEl(options.parentEl);\n//     parent.append(el);\n//   }\n//   const b = bindUpdate(source, el, updater);\n//   return b;\n// }\n\n\n/**\n * Creates, updates & deletes elements based on pathed values from a reactive.\n * \n * This means that elements are only manipulated if its associated data changes,\n * and elements are not modified if there's no need to.\n * @param source \n * @param options \n */\nexport const elements = <T>(source: Rx.ReactiveDiff<T> | (Rx.ReactiveDiff<T> & Rx.ReactiveInitial<T>), options: Partial<ElementsOptions>) => {\n  const containerEl = options.container ? resolveEl(options.container) : document.body;\n  const defaultTag = options.defaultTag ?? `div`\n  const elByField = new Map<string, HTMLElement>();\n  const binds = new Map<string, ElementBind & {\n    update: ((value: any, el: HTMLElement) => void)\n    path: string\n  }>();\n\n  for (const [ key, value ] of Object.entries(options.binds ?? {})) {\n    const tagName = value.tagName ?? defaultTag;\n    //console.log(`key: ${ key }`);\n    binds.set(key, {\n      ...value,\n      update: resolveBindUpdaterBase(value),\n      transform: resolveTransform(value),\n      tagName,\n      path: key\n    });\n  }\n\n  const findBind = (path: string) => {\n    const bind = getFromKeys(binds, stringSegmentsWholeToEnd(path));\n    if (bind !== undefined) return bind;\n    if (!path.includes(`.`)) return binds.get(`_root`);\n  }\n\n  function* ancestorBinds(path: string) {\n    for (const p of stringSegmentsWholeToFirst(path)) {\n      //console.log(` ancestorBinds path: ${ path } segment: ${ p }`)\n\n      if (binds.has(p)) {\n        //console.log(`  bind: ${ p } found: ${ JSON.stringify(binds.get(p)) }`);\n        yield binds.get(p);\n      } else {\n        //console.log(` bind: ${ p } not found`);\n      }\n    }\n    if (binds.has(`_root`) && path.includes(`.`)) yield binds.get(`_root`);\n  }\n\n\n  const create = (path: string, value: any) => {\n    const rootedPath = getRootedPath(path);\n    console.log(`Rx.Dom.elements.create: ${ path } rooted: ${ rootedPath } value: ${ JSON.stringify(value) }`);\n\n    // Create\n    const bind = findBind(getRootedPath(path));\n    let tagName = defaultTag;\n    if (bind?.tagName) tagName = bind.tagName;\n\n    const el = document.createElement(tagName);\n    el.setAttribute(`data-path`, path);\n    update(path, el, value);\n\n    let parentForEl;\n    for (const b of ancestorBinds(rootedPath)) {\n      //console.log(`  path: ${ rootedPath } b: ${ JSON.stringify(b) }`);\n      if (b?.nestChildren) {\n        // Get root of path\n        const absoluteRoot = beforeMatch(path, `.`);\n        const findBy = b.path.replace(`_root`, absoluteRoot);\n\n        parentForEl = elByField.get(findBy);\n        if (parentForEl === undefined) {\n          //console.log(`    could not find parent. path: ${ path } b.path: ${ b.path } findBy: ${ findBy }`);\n        } else {\n          //console.log(`    found parent`);\n          break;\n        }\n      }\n    }\n    (parentForEl ?? containerEl).append(el);\n    elByField.set(path, el);\n    console.log(`Added el: ${ path }`);\n  }\n\n  const update = (path: string, el: HTMLElement, value: any) => {\n    console.log(`Rx.dom.update path: ${ path } value:`, value);\n\n    const bind = findBind(getRootedPath(path));\n    if (bind === undefined) {\n      //console.log(`Rx.dom.update   no bind for ${ path }`)\n      if (typeof value === `object`) value = JSON.stringify(value);\n      el.textContent = value;\n    } else {\n      //console.log(`Rx.dom.update   got bind! ${ path } `);\n      if (bind.transform) value = bind.transform(value);\n      bind.update(value, el);\n    }\n  }\n\n  const changes = (changes: Array<Immutable.PathDataChange<any> | Immutable.PathData<any>>) => {\n    const queue = new QueueMutable({}, changes);\n    let d = queue.dequeue();\n    const seenPaths = new Set<string>();\n    while (d !== undefined) {\n      //for (const d of changes) {\n      const path = d.path;\n      if (!(`previous` in d) || d.previous === undefined) {\n        // Create\n        console.log(`Rx.Dom.elements.changes no previous. path: ${ path }`);\n\n        create(path, d.value);\n        const subdata = [ ...Immutable.getPathsAndData(d.value, false, Number.MAX_SAFE_INTEGER, path) ];\n        console.log(subdata);\n        for (const dd of subdata) {\n          if (!seenPaths.has(dd.path)) {\n            queue.enqueue(dd);\n            seenPaths.add(dd.path);\n          }\n        }\n      } else if (d.value === undefined) {\n        // Delete\n        const el = elByField.get(path);\n        if (el === undefined) {\n          console.warn(`No element to delete? ${ path } `);\n        } else {\n          console.log(`Rx.Dom.elements.changes delete ${ path }`);\n          el.remove();\n        }\n      } else {\n        // Update\n        const el = elByField.get(path);\n        if (el === undefined) {\n          console.warn(`Rx.Dom.elements.changes No element to update ? ${ path } `);\n          create(path, d.value);\n        } else {\n          //console.log(`Rx.Dom.elements.changes Updating ${ path } `, el);\n          update(path, el, d.value);\n        }\n      }\n      d = queue.dequeue();\n    }\n  }\n\n  /**\n   * Source has changed\n   */\n  source.onDiff(value => {\n    //console.log(`Rx.Dom.elements diff ${ JSON.stringify(value) } `);\n    changes(value);\n  });\n\n  // Source has an initial value, use that\n  if (hasLast(source)) {\n    const last = source.last();\n    // Get data of value as a set of paths and data\n    // but only at first level of depth, because changes() will probe\n    // deeper itself\n    changes([ ...Immutable.getPathsAndData(last as object, false, 1) ]);\n  }\n};\n\n/**\n * Replaces the root portion of `path` with the magic keyword `_root`\n * @param path \n * @returns \n */\nconst getRootedPath = (path: string) => {\n  const after = afterMatch(path, `.`);\n  return after === path ? `_root` : `_root.` + after;\n}\n\nexport function win() {\n  const generateRect = () => ({ width: window.innerWidth, height: window.innerHeight });\n\n  const size = Rx.From.event(window, `resize`, {\n    lazy: `very`,\n    transform: () => generateRect(),\n  });\n  const pointer = Rx.From.event(window, `pointermove`, {\n    lazy: `very`,\n    transform: (args: Event | undefined) => {\n      if (args === undefined) return { x: 0, y: 0 };\n      const pe = args as PointerEvent;\n      return { x: pe.x, y: pe.y }\n    }\n  });\n  const dispose = (reason = `Reactive.win.dispose`) => {\n    size.dispose(reason);\n    pointer.dispose(reason);\n  }\n  return { dispose, size, pointer };\n}\n","export * from './Array.js';\nexport * from './ArrayObject.js';\nexport * from './Boolean.js';\nexport * from './Colour.js';\nexport * from './Count.js';\nexport * from './Derived.js';\nexport * from './Dom.js';\nexport * from './Event.js';\nexport * from './Function.js';\nexport * from './Iterator.js';\nexport * from './Merged.js';\nexport * from './Number.js';\nexport * from './Object.js';\nexport * from './ObjectProxy.js';\nexport * from './Observable.js';\nexport * from './String.js';\nexport * from './Types.js';","\nimport { continuously } from \"../../flow/Continuously.js\";\nimport { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport type { Reactive, ReactiveFinite, ReactiveInitial } from \"../Types.js\";\nimport type { ArrayOptions } from \"./Types.js\";\n\nexport const of = <V>(source: Array<V> | Iterable<V>, options: Partial<ArrayOptions> = {}) => {\n  if (Array.isArray(source)) {\n    return array(source, options);\n  } else {}\n}\n\n/**\n * Reads the contents of `array` into a Reactive, with optional time interval\n * between values. A copy of the array is used, so changes will not\n * affect the reactive.\n * \n * See also {@link arrayObject} which monitors changes to array values.\n *\n * Reads items from an array with a given interval, by default 5ms\n * \n * ```js\n * const data = [`apples`, `oranges`, `pears` ];\n * const rx = Rx.From.array(data);\n * rx.onValue(v => {\n *  // v will be each fruit in turn\n * })\n * ```\n * \n * Note that there is the possibility of missing values since there is delay between subscribing and when items start getting emitted.\n * If a new subscriber connects to the reactive, they won't get values already emitted.\n * @param sourceArray \n * @param options \n * @returns \n */\nexport const array = <V>(sourceArray: Array<V>, options: Partial<ArrayOptions> = {}): Reactive<V> & ReactiveFinite & ReactiveInitial<V> => {\n  const lazy = options.lazy ?? `initial`;\n  const signal = options.signal;\n  const whenStopped = options.whenStopped ?? `continue`;\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const array = [ ...sourceArray ];\n\n  if (lazy !== `very` && whenStopped === `reset`) throw new Error(`whenStopped:'reset' has no effect with 'lazy:${ lazy }'. Use lazy:'very' instead.`);\n\n  const intervalMs = intervalToMs(options.interval, 5);\n  let index = 0;\n  let lastValue = array[ 0 ];\n\n  const s = initLazyStream<V>({\n    ...options,\n    lazy,\n    onStart() {\n      if (debugLifecycle) console.log(`Rx.readFromArray:onStart`);\n      c.start();\n    },\n    onStop() {\n      if (debugLifecycle) console.log(`Rx.readFromArray:onStop. whenStopped: ${ whenStopped } index: ${ index }`);\n\n      c.cancel();\n      if (whenStopped === `reset`) index = 0;\n    },\n    // onFirstSubscribe() {\n    //   if (debugLifecycle) console.log(`Rx.readFromArray:onFirstSubscribe lazy: ${ lazy } runState: '${ c.runState }'`);\n    //   // Start if in lazy mode and not running\n    //   if (lazy !== `never` && c.runState === `idle`) c.start();\n    // },\n    // onNoSubscribers() {\n    //   if (debugLifecycle) console.log(`Rx.readFromArray:onNoSubscribers lazy: ${ lazy } runState: '${ c.runState }' whenStopped: '${ whenStopped }'`);\n    //   if (lazy === `very`) {\n    //     c.cancel();\n    //     if (whenStopped === `reset`) {\n    //       index = 0;\n    //     }\n    //   }\n    // }\n  });\n\n  const c = continuously(() => {\n    if (signal?.aborted) {\n      s.dispose(`Signalled (${ signal.reason })`);\n      return false; // stop looping\n    }\n    lastValue = array[ index ];\n    index++;\n\n    s.set(lastValue)\n    if (index === array.length) {\n      s.dispose(`Source array complete`);\n      return false; // stop loop\n    }\n  }, intervalMs);\n\n  if (!lazy) c.start();\n\n  return {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    dispose: s.dispose,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    isDisposed: s.isDisposed,\n    isDone() {\n      return index === array.length;\n    },\n    last() {\n      return lastValue;\n    },\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    on: s.on,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    onValue: s.onValue\n  }\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { isEqualValueDefault } from \"../../util/IsEqual.js\";\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveInitial, ReactiveNonInitial, ReactiveArray, Reactive } from \"../Types.js\";\nimport type { ArrayObjectOptions } from \"./Types.js\";\nimport { compareArrays, type ChangeRecord } from \"../../data/Compare.js\";\nimport { remove as ArraysRemove } from '../../data/arrays/Remove.js';\nimport { insertAt as ArraysInsertAt } from \"../../data/arrays/InsertAt.js\";\n/**\n * Wraps an array object.\n * \n * It returns an reactive along with some array-ish functions to manipulating it.\n * @param initialValue \n * @param options \n * @returns \n */\nexport function arrayObject<V>(initialValue: ReadonlyArray<V> = [], options: Partial<ArrayObjectOptions<V>> = {}): ReactiveArray<V> & ReactiveInitial<ReadonlyArray<V>> {\n  const eq = options.eq ?? isEqualValueDefault;\n  const setEvent = initStream<Array<V>>();\n  //const diffEvent = initStream<Array<Immutable.Change<any>>>();\n  const arrayEvent = initStream<Array<ChangeRecord<number>>>();\n  let value: ReadonlyArray<V> = initialValue;\n  let disposed = false;\n\n  const set = (replacement: Array<V> | ReadonlyArray<V>) => {\n    const diff = compareArrays<V>(value as Array<V>, replacement as Array<V>, eq);\n    //console.log(`Rx.fromArray.set diff`, diff);\n    //if (diff.length === 0) return;\n    //diffEvent.set(diff);\n    value = replacement;\n    setEvent.set([ ...replacement ]);\n  }\n\n  const setAt = (index: number, v: V) => {\n    (value as Array<V>)[ index ] = v;\n    setEvent.set([ ...value ]);\n  }\n\n  const push = (v: V) => {\n    value = [ ...value, v ];\n    setEvent.set([ ...value ]);\n    const cr: ChangeRecord<number> = [ `add`, value.length - 1, v ];\n    arrayEvent.set([ cr ]);\n  }\n\n  const deleteAt = (index: number) => {\n    const valueChanged = ArraysRemove(value, index);\n    if (valueChanged.length === value.length) return; // no change\n    const diff = compareArrays<V>(value as Array<V>, valueChanged, eq);\n    //console.log(diff.summary);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n  }\n\n  const deleteWhere = (filter: (value: V) => boolean) => {\n    const valueChanged = value.filter(v => !filter(v));\n    const count = value.length - valueChanged.length;\n    const diff = compareArrays<V>(value as Array<V>, valueChanged, eq);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n    return count;\n  }\n\n  const insertAt = (index: number, v: V) => {\n    const valueChanged = ArraysInsertAt(value, index, v);\n    const diff = compareArrays<V>(value as Array<V>, valueChanged, eq);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n  }\n\n  // const update = (toMerge: Partial<V>) => {\n  //   // eslint-disable-next-line unicorn/prefer-ternary\n  //   if (value === undefined) {\n  //     value = toMerge as V;\n  //   } else {\n  //     const diff = Immutable.compareData(toMerge, value);\n  //     // console.log(`Rx.fromObject.update value: ${ JSON.stringify(value) }`);\n  //     // console.log(`Rx.fromObject.update  diff: ${ JSON.stringify(diff) }`);\n  //     if (diff.length === 0) return; // No changes\n  //     value = {\n  //       ...value,\n  //       ...toMerge\n  //     }\n  //     diffEvent.set(diff);\n  //   }\n  //   setEvent.set(value);\n  // }\n\n  const dispose = (reason: string) => {\n    if (disposed) return;\n    //diffEvent.dispose(reason);\n    setEvent.dispose(reason);\n    disposed = true;\n  }\n\n  const r = {\n    dispose,\n    isDisposed() {\n      return disposed\n    },\n    last: () => value,\n    on: setEvent.on,\n    onArray: arrayEvent.on,\n    onValue: setEvent.onValue,\n    setAt,\n    push,\n    deleteAt,\n    deleteWhere,\n    insertAt,\n    /**\n     * Set the whole object\n     */\n    set\n  }\n  return r;\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport function boolean(initialValue: boolean): ReactiveWritable<boolean> & ReactiveInitial<boolean>;\nexport function boolean(): ReactiveWritable<boolean> & ReactiveNonInitial<boolean>;\nexport function boolean(initialValue?: boolean): ReactiveWritable<boolean> & (ReactiveNonInitial<boolean> | ReactiveInitial<boolean>) {\n  let value = initialValue;\n  const events = initStream<boolean>();\n\n  const set = (v: boolean) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set\n  }\n}","export * from './Generate.js';\nexport * from './Hsl.js';\nexport * from './Interpolate.js';\nexport * from './Math.js';\nexport * from './Oklch.js';\nexport * from './ResolveCss.js';\nexport * from './ResolveToColorJs.js';\nexport * from './Rgb.js';\nexport * from './ToString.js';\nexport type * from './Types.js';","import { throwNumberTest } from '../../util/GuardNumbers.js';\nimport { defaultRandom, type RandomSource } from '../../random/Types.js';\n/**\n * Returns a full HSL colour string (eg `hsl(20,50%,75%)`) based on a index.\n * It's useful for generating perceptually different shades as the index increments.\n *\n * ```\n * el.style.backgroundColor = goldenAgeColour(10);\n * ```\n *\n * Saturation and lightness can be specified, as numeric ranges of 0-1.\n *\n * @param saturation Saturation (0-1), defaults to 0.5\n * @param lightness Lightness (0-1), defaults to 0.75\n * @param alpha Opacity (0-1), defaults to 1.0\n * @returns HSL colour string eg `hsl(20,50%,75%)`\n */\nexport const goldenAngleColour = (\n  index: number,\n  saturation = 0.5,\n  lightness = 0.75,\n  alpha = 1\n) => {\n  throwNumberTest(index, `positive`, `index`);\n  throwNumberTest(saturation, `percentage`, `saturation`);\n  throwNumberTest(lightness, `percentage`, `lightness`);\n  throwNumberTest(alpha, `percentage`, `alpha`);\n\n  // Via Stackoverflow\n  const hue = index * 137.508; // use golden angle approximation\n  return alpha === 1 ? `hsl(${ hue },${ saturation * 100 }%,${ lightness * 100 }%)` : `hsl(${ hue },${ saturation * 100 }%,${ lightness * 100 }%,${ alpha * 100 }%)`;\n};\n\n/**\n * Returns a random hue component (0..359)\n * ```\n * // Generate hue\n * const h =randomHue(); // 0-359\n *\n * // Generate hue and assign as part of a HSL string\n * el.style.backgroundColor = `hsl(${randomHue(), 50%, 75%})`;\n * ```\n * @param rand\n * @returns\n */\nexport const randomHue = (rand: RandomSource = defaultRandom): number => {\n  const r = rand();\n  return r * 360;\n};\n","// A is m x n. B is n x p. product is m x p.\nexport default function multiplyMatrices (A, B) {\n\tlet m = A.length;\n\n\tif (!Array.isArray(A[0])) {\n\t\t// A is vector, convert to [[a, b, c, ...]]\n\t\tA = [A];\n\t}\n\n\tif (!Array.isArray(B[0])) {\n\t\t// B is vector, convert to [[a], [b], [c], ...]]\n\t\tB = B.map(x => [x]);\n\t}\n\n\tlet p = B[0].length;\n\tlet B_cols = B[0].map((_, i) => B.map(x => x[i])); // transpose B\n\tlet product = A.map(row => B_cols.map(col => {\n\t\tlet ret = 0;\n\n\t\tif (!Array.isArray(row)) {\n\t\t\tfor (let c of col) {\n\t\t\t\tret += row * c;\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tfor (let i = 0; i < row.length; i++) {\n\t\t\tret += row[i] * (col[i] || 0);\n\t\t}\n\n\t\treturn ret;\n\t}));\n\n\tif (m === 1) {\n\t\tproduct = product[0]; // Avoid [[a, b, c, ...]]\n\t}\n\n\tif (p === 1) {\n\t\treturn product.map(x => x[0]); // Avoid [[a], [b], [c], ...]]\n\t}\n\n\treturn product;\n}\n","/**\n * Various utility functions\n */\n\nexport {default as multiplyMatrices} from \"./multiply-matrices.js\";\n\n/**\n * Check if a value is a string (including a String object)\n * @param {*} str - Value to check\n * @returns {boolean}\n */\nexport function isString (str) {\n\treturn type(str) === \"string\";\n}\n\n/**\n * Determine the internal JavaScript [[Class]] of an object.\n * @param {*} o - Value to check\n * @returns {string}\n */\nexport function type (o) {\n\tlet str = Object.prototype.toString.call(o);\n\n\treturn (str.match(/^\\[object\\s+(.*?)\\]$/)[1] || \"\").toLowerCase();\n}\n\nexport function serializeNumber (n, {precision, unit }) {\n\tif (isNone(n)) {\n\t\treturn \"none\";\n\t}\n\n\treturn toPrecision(n, precision) + (unit ?? \"\");\n}\n\n/**\n * Check if a value corresponds to a none argument\n * @param {*} n - Value to check\n * @returns {boolean}\n */\nexport function isNone (n) {\n\treturn Number.isNaN(n) || (n instanceof Number && n?.none);\n}\n\n/**\n * Replace none values with 0\n */\nexport function skipNone (n) {\n\treturn isNone(n) ? 0 : n;\n}\n\n/**\n * Round a number to a certain number of significant digits\n * @param {number} n - The number to round\n * @param {number} precision - Number of significant digits\n */\nexport function toPrecision (n, precision) {\n\tif (n === 0) {\n\t\treturn 0;\n\t}\n\tlet integer = ~~n;\n\tlet digits = 0;\n\tif (integer && precision) {\n\t\tdigits = ~~Math.log10(Math.abs(integer)) + 1;\n\t}\n\tconst multiplier = 10.0 ** (precision - digits);\n\treturn Math.floor(n * multiplier + 0.5) / multiplier;\n}\n\nconst angleFactor = {\n\tdeg: 1,\n\tgrad: 0.9,\n\trad: 180 / Math.PI,\n\tturn: 360,\n};\n\n/**\n* Parse a CSS function, regardless of its name and arguments\n* @param String str String to parse\n* @return {{name, args, rawArgs}}\n*/\nexport function parseFunction (str) {\n\tif (!str) {\n\t\treturn;\n\t}\n\n\tstr = str.trim();\n\n\tconst isFunctionRegex = /^([a-z]+)\\((.+?)\\)$/i;\n\tconst isNumberRegex = /^-?[\\d.]+$/;\n\tconst unitValueRegex = /%|deg|g?rad|turn$/;\n\tconst singleArgument = /\\/?\\s*(none|[-\\w.]+(?:%|deg|g?rad|turn)?)/g;\n\tlet parts = str.match(isFunctionRegex);\n\n\tif (parts) {\n\t\t// It is a function, parse args\n\t\tlet args = [];\n\t\tparts[2].replace(singleArgument, ($0, rawArg) => {\n\t\t\tlet match = rawArg.match(unitValueRegex);\n\t\t\tlet arg = rawArg;\n\n\t\t\tif (match) {\n\t\t\t\tlet unit = match[0];\n\t\t\t\t// Drop unit from value\n\t\t\t\tlet unitlessArg = arg.slice(0, -unit.length);\n\n\t\t\t\tif (unit === \"%\") {\n\t\t\t\t\t// Convert percentages to 0-1 numbers\n\t\t\t\t\targ = new Number(unitlessArg / 100);\n\t\t\t\t\targ.type = \"<percentage>\";\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// Multiply angle by appropriate factor for its unit\n\t\t\t\t\targ = new Number(unitlessArg * angleFactor[unit]);\n\t\t\t\t\targ.type = \"<angle>\";\n\t\t\t\t\targ.unit = unit;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (isNumberRegex.test(arg)) {\n\t\t\t\t// Convert numerical args to numbers\n\t\t\t\targ = new Number(arg);\n\t\t\t\targ.type = \"<number>\";\n\t\t\t}\n\t\t\telse if (arg === \"none\") {\n\t\t\t\targ = new Number(NaN);\n\t\t\t\targ.none = true;\n\t\t\t}\n\n\t\t\tif ($0.startsWith(\"/\")) {\n\t\t\t\t// It's alpha\n\t\t\t\targ = arg instanceof Number ? arg : new Number(arg);\n\t\t\t\targ.alpha = true;\n\t\t\t}\n\n\t\t\tif (typeof arg === \"object\" && arg instanceof Number) {\n\t\t\t\targ.raw = rawArg;\n\t\t\t}\n\n\t\t\targs.push(arg);\n\t\t});\n\n\t\treturn {\n\t\t\tname: parts[1].toLowerCase(),\n\t\t\trawName: parts[1],\n\t\t\trawArgs: parts[2],\n\t\t\t// An argument could be (as of css-color-4):\n\t\t\t// a number, percentage, degrees (hue), ident (in color())\n\t\t\targs,\n\t\t};\n\t}\n}\n\nexport function last (arr) {\n\treturn arr[arr.length - 1];\n}\n\nexport function interpolate (start, end, p) {\n\tif (isNaN(start)) {\n\t\treturn end;\n\t}\n\n\tif (isNaN(end)) {\n\t\treturn start;\n\t}\n\n\treturn start + (end - start) * p;\n}\n\nexport function interpolateInv (start, end, value) {\n\treturn (value - start) / (end - start);\n}\n\nexport function mapRange (from, to, value) {\n\treturn interpolate(to[0], to[1], interpolateInv(from[0], from[1], value));\n}\n\nexport function parseCoordGrammar (coordGrammars) {\n\treturn coordGrammars.map(coordGrammar => {\n\t\treturn coordGrammar.split(\"|\").map(type => {\n\t\t\ttype = type.trim();\n\t\t\tlet range = type.match(/^(<[a-z]+>)\\[(-?[.\\d]+),\\s*(-?[.\\d]+)\\]?$/);\n\n\t\t\tif (range) {\n\t\t\t\tlet ret = new String(range[1]);\n\t\t\t\tret.range = [+range[2], +range[3]];\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\treturn type;\n\t\t});\n\t});\n}\n\n/**\n * Clamp value between the minimum and maximum\n * @param {number} min minimum value to return\n * @param {number} val the value to return if it is between min and max\n * @param {number} max maximum value to return\n * @returns number\n */\nexport function clamp (min, val, max) {\n\treturn Math.max(Math.min(max, val), min);\n}\n\n/**\n * Copy sign of one value to another.\n * @param {number} - to number to copy sign to\n * @param {number} - from number to copy sign from\n * @returns number\n */\nexport function copySign (to, from) {\n\treturn Math.sign(to) === Math.sign(from) ? to : -to;\n}\n\n/**\n * Perform pow on a signed number and copy sign to result\n * @param {number} - base the base number\n * @param {number} - exp the exponent\n * @returns number\n */\nexport function spow (base, exp) {\n\treturn copySign(Math.abs(base) ** exp, base);\n}\n\n/**\n * Perform a divide, but return zero if the numerator is zero\n * @param {number} n - the numerator\n * @param {number} d - the denominator\n * @returns number\n */\nexport function zdiv (n, d) {\n\treturn (d === 0) ? 0 : n / d;\n}\n\n/**\n * Perform a bisect on a sorted list and locate the insertion point for\n * a value in arr to maintain sorted order.\n * @param {number[]} arr - array of sorted numbers\n * @param {number} value - value to find insertion point for\n * @param {number} lo - used to specify a the low end of a subset of the list\n * @param {number} hi - used to specify a the high end of a subset of the list\n * @returns number\n */\nexport function bisectLeft (arr, value, lo = 0, hi = arr.length) {\n\twhile (lo < hi) {\n\t\tconst mid = (lo + hi) >> 1;\n\t\tif (arr[mid] < value) {\n\t\t\tlo = mid + 1;\n\t\t}\n\t\telse {\n\t\t\thi = mid;\n\t\t}\n\t}\n\treturn lo;\n}\n","/**\n * A class for adding deep extensibility to any piece of JS code\n */\nexport class Hooks {\n\tadd (name, callback, first) {\n\t\tif (typeof arguments[0] != \"string\") {\n\t\t\t// Multiple hooks\n\t\t\tfor (var name in arguments[0]) {\n\t\t\t\tthis.add(name, arguments[0][name], arguments[1]);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\t(Array.isArray(name) ? name : [name]).forEach(function (name) {\n\t\t\tthis[name] = this[name] || [];\n\n\t\t\tif (callback) {\n\t\t\t\tthis[name][first ? \"unshift\" : \"push\"](callback);\n\t\t\t}\n\t\t}, this);\n\t}\n\n\trun (name, env) {\n\t\tthis[name] = this[name] || [];\n\t\tthis[name].forEach(function (callback) {\n\t\t\tcallback.call(env && env.context ? env.context : env, env);\n\t\t});\n\t}\n}\n\n/**\n * The instance of {@link Hooks} used throughout Color.js\n */\nconst hooks = new Hooks();\n\nexport default hooks;\n","// Global defaults one may want to configure\nexport default {\n\tgamut_mapping: \"css\",\n\tprecision: 5,\n\tdeltaE: \"76\", // Default deltaE method\n\tverbose: globalThis?.process?.env?.NODE_ENV?.toLowerCase() !== \"test\",\n\twarn: function warn (msg) {\n\t\tif (this.verbose) {\n\t\t\tglobalThis?.console?.warn?.(msg);\n\t\t}\n\t},\n};\n","import hooks from \"./hooks.js\";\nimport {multiplyMatrices} from \"./util.js\";\n\nexport const WHITES = {\n\t// for compatibility, the four-digit chromaticity-derived ones everyone else uses\n\tD50: [0.3457 / 0.3585, 1.00000, (1.0 - 0.3457 - 0.3585) / 0.3585],\n\tD65: [0.3127 / 0.3290, 1.00000, (1.0 - 0.3127 - 0.3290) / 0.3290],\n};\n\nexport function getWhite (name) {\n\tif (Array.isArray(name)) {\n\t\treturn name;\n\t}\n\n\treturn WHITES[name];\n}\n\n// Adapt XYZ from white point W1 to W2\nexport default function adapt (W1, W2, XYZ, options = {}) {\n\tW1 = getWhite(W1);\n\tW2 = getWhite(W2);\n\n\tif (!W1 || !W2) {\n\t\tthrow new TypeError(`Missing white point to convert ${!W1 ? \"from\" : \"\"}${!W1 && !W2 ? \"/\" : \"\"}${!W2 ? \"to\" : \"\"}`);\n\t}\n\n\tif (W1 === W2) {\n\t\t// Same whitepoints, no conversion needed\n\t\treturn XYZ;\n\t}\n\n\tlet env = {W1, W2, XYZ, options};\n\n\thooks.run(\"chromatic-adaptation-start\", env);\n\n\tif (!env.M) {\n\t\tif (env.W1 === WHITES.D65 && env.W2 === WHITES.D50) {\n\t\t\tenv.M = [\n\t\t\t\t[ 1.0479297925449969, 0.022946870601609652, -0.05019226628920524 ],\n\t\t\t\t[ 0.02962780877005599, 0.9904344267538799, -0.017073799063418826 ],\n\t\t\t\t[ -0.009243040646204504, 0.015055191490298152, 0.7518742814281371 ],\n\t\t\t];\n\t\t}\n\t\telse if (env.W1 === WHITES.D50 && env.W2 === WHITES.D65) {\n\n\t\t\tenv.M = [\n\t\t\t\t[ 0.955473421488075, -0.02309845494876471, 0.06325924320057072 ],\n\t\t\t\t[ -0.0283697093338637, 1.0099953980813041, 0.021041441191917323 ],\n\t\t\t\t[ 0.012314014864481998, -0.020507649298898964, 1.330365926242124 ],\n\t\t\t];\n\t\t}\n\t}\n\n\thooks.run(\"chromatic-adaptation-end\", env);\n\n\tif (env.M) {\n\t\treturn multiplyMatrices(env.M, env.XYZ);\n\t}\n\telse {\n\t\tthrow new TypeError(\"Only Bradford CAT with white points D50 and D65 supported for now.\");\n\t}\n}\n","import * as util from \"./util.js\";\nimport hooks from \"./hooks.js\";\nimport ColorSpace from \"./space.js\";\nimport defaults from \"./defaults.js\";\n\nconst noneTypes = new Set([\"<number>\", \"<percentage>\", \"<angle>\"]);\n\n/**\n * Validates the coordinates of a color against a format's coord grammar and\n * maps the coordinates to the range or refRange of the coordinates.\n * @param {ColorSpace} space - Colorspace the coords are in\n * @param {object} format - the format object to validate against\n * @param {string} name - the name of the color function. e.g. \"oklab\" or \"color\"\n * @returns {object[]} - an array of type metadata for each coordinate\n */\nfunction coerceCoords (space, format, name, coords) {\n\tlet types = Object.entries(space.coords).map(([id, coordMeta], i) => {\n\t\tlet coordGrammar = format.coordGrammar[i];\n\t\tlet arg = coords[i];\n\t\tlet providedType = arg?.type;\n\n\t\t// Find grammar alternative that matches the provided type\n\t\t// Non-strict equals is intentional because we are comparing w/ string objects\n\t\tlet type;\n\t\tif (arg.none) {\n\t\t\ttype = coordGrammar.find(c => noneTypes.has(c));\n\t\t}\n\t\telse {\n\t\t\ttype = coordGrammar.find(c => c == providedType);\n\t\t}\n\n\t\t// Check that each coord conforms to its grammar\n\t\tif (!type) {\n\t\t\t// Type does not exist in the grammar, throw\n\t\t\tlet coordName = coordMeta.name || id;\n\t\t\tthrow new TypeError(`${providedType ?? arg.raw} not allowed for ${coordName} in ${name}()`);\n\t\t}\n\n\t\tlet fromRange = type.range;\n\n\t\tif (providedType === \"<percentage>\") {\n\t\t\tfromRange ||= [0, 1];\n\t\t}\n\n\t\tlet toRange = coordMeta.range || coordMeta.refRange;\n\n\t\tif (fromRange && toRange) {\n\t\t\tcoords[i] = util.mapRange(fromRange, toRange, coords[i]);\n\t\t}\n\n\t\treturn type;\n\t});\n\n\treturn types;\n}\n\n\n/**\n * Convert a CSS Color string to a color object\n * @param {string} str\n * @param {object} [options]\n * @param {object} [options.meta] - Object for additional information about the parsing\n * @returns {Color}\n */\nexport default function parse (str, {meta} = {}) {\n\tlet env = {\"str\": String(str)?.trim()};\n\thooks.run(\"parse-start\", env);\n\n\tif (env.color) {\n\t\treturn env.color;\n\t}\n\n\tenv.parsed = util.parseFunction(env.str);\n\n\tif (env.parsed) {\n\t\t// Is a functional syntax\n\t\tlet name = env.parsed.name;\n\n\t\tif (name === \"color\") {\n\t\t\t// color() function\n\t\t\tlet id = env.parsed.args.shift();\n\t\t\t// Check against both <dashed-ident> and <ident> versions\n\t\t\tlet alternateId = id.startsWith(\"--\") ? id.substring(2) : `--${id}`;\n\t\t\tlet ids = [id, alternateId];\n\t\t\tlet alpha = env.parsed.rawArgs.indexOf(\"/\") > 0 ? env.parsed.args.pop() : 1;\n\n\t\t\tfor (let space of ColorSpace.all) {\n\t\t\t\tlet colorSpec = space.getFormat(\"color\");\n\n\t\t\t\tif (colorSpec) {\n\t\t\t\t\tif (ids.includes(colorSpec.id) || colorSpec.ids?.filter((specId) => ids.includes(specId)).length) {\n\t\t\t\t\t\t// From https://drafts.csswg.org/css-color-4/#color-function\n\t\t\t\t\t\t// If more <number>s or <percentage>s are provided than parameters that the colorspace takes, the excess <number>s at the end are ignored.\n\t\t\t\t\t\t// If less <number>s or <percentage>s are provided than parameters that the colorspace takes, the missing parameters default to 0. (This is particularly convenient for multichannel printers where the additional inks are spot colors or varnishes that most colors on the page wont use.)\n\t\t\t\t\t\tconst coords = Object.keys(space.coords).map((_, i) => env.parsed.args[i] || 0);\n\n\t\t\t\t\t\tlet types;\n\n\t\t\t\t\t\tif (colorSpec.coordGrammar) {\n\t\t\t\t\t\t\ttypes = coerceCoords(space, colorSpec, \"color\", coords);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (meta) {\n\t\t\t\t\t\t\tObject.assign(meta, {formatId: \"color\", types});\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (colorSpec.id.startsWith(\"--\") && !id.startsWith(\"--\")) {\n\t\t\t\t\t\t\tdefaults.warn(`${space.name} is a non-standard space and not currently supported in the CSS spec. ` +\n\t\t\t\t\t\t\t              `Use prefixed color(${colorSpec.id}) instead of color(${id}).`);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (id.startsWith(\"--\") && !colorSpec.id.startsWith(\"--\")) {\n\t\t\t\t\t\t\tdefaults.warn(`${space.name} is a standard space and supported in the CSS spec. ` +\n\t\t\t\t\t\t\t              `Use color(${colorSpec.id}) instead of prefixed color(${id}).`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn {spaceId: space.id, coords, alpha};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Not found\n\t\t\tlet didYouMean = \"\";\n\t\t\tlet registryId = id in ColorSpace.registry ? id : alternateId;\n\t\t\tif (registryId in ColorSpace.registry) {\n\t\t\t\t// Used color space id instead of color() id, these are often different\n\t\t\t\tlet cssId = ColorSpace.registry[registryId].formats?.color?.id;\n\n\t\t\t\tif (cssId) {\n\t\t\t\t\tdidYouMean = `Did you mean color(${cssId})?`;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthrow new TypeError(`Cannot parse color(${id}). ` + (didYouMean || \"Missing a plugin?\"));\n\t\t}\n\t\telse {\n\t\t\tfor (let space of ColorSpace.all) {\n\t\t\t\t// color space specific function\n\t\t\t\tlet format = space.getFormat(name);\n\t\t\t\tif (format && format.type === \"function\") {\n\t\t\t\t\tlet alpha = 1;\n\n\t\t\t\t\tif (format.lastAlpha || util.last(env.parsed.args).alpha) {\n\t\t\t\t\t\talpha = env.parsed.args.pop();\n\t\t\t\t\t}\n\n\t\t\t\t\tlet coords = env.parsed.args;\n\n\t\t\t\t\tlet types;\n\n\t\t\t\t\tif (format.coordGrammar) {\n\t\t\t\t\t\ttypes = coerceCoords(space, format, name, coords);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (meta) {\n\t\t\t\t\t\tObject.assign(meta, {formatId: format.name, types});\n\t\t\t\t\t}\n\n\t\t\t\t\treturn {\n\t\t\t\t\t\tspaceId: space.id,\n\t\t\t\t\t\tcoords, alpha,\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\telse {\n\t\t// Custom, colorspace-specific format\n\t\tfor (let space of ColorSpace.all) {\n\t\t\tfor (let formatId in space.formats) {\n\t\t\t\tlet format = space.formats[formatId];\n\n\t\t\t\tif (format.type !== \"custom\") {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (format.test && !format.test(env.str)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tlet color = format.parse(env.str);\n\n\t\t\t\tif (color) {\n\t\t\t\t\tcolor.alpha ??= 1;\n\n\t\t\t\t\tif (meta) {\n\t\t\t\t\t\tmeta.formatId = formatId;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn color;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\n\t// If we're here, we couldn't parse\n\tthrow new TypeError(`Could not parse ${str} as a color. Missing a plugin?`);\n}\n","import ColorSpace from \"./space.js\";\nimport {isString} from \"./util.js\";\nimport parse from \"./parse.js\";\n\n/**\n * Resolves a color reference (object or string) to a plain color object\n * @param {Color | {space, coords, alpha} | string | Array<Color | {space, coords, alpha} | string> } color\n * @returns {{space, coords, alpha} | Array<{space, coords, alpha}}>\n */\nexport default function getColor (color) {\n\tif (Array.isArray(color)) {\n\t\treturn color.map(getColor);\n\t}\n\n\tif (!color) {\n\t\tthrow new TypeError(\"Empty color reference\");\n\t}\n\n\tif (isString(color)) {\n\t\tcolor = parse(color);\n\t}\n\n\t// Object fixup\n\tlet space = color.space || color.spaceId;\n\n\tif (!(space instanceof ColorSpace)) {\n\t\t// Convert string id to color space object\n\t\tcolor.space = ColorSpace.get(space);\n\t}\n\n\tif (color.alpha === undefined) {\n\t\tcolor.alpha = 1;\n\t}\n\n\treturn color;\n}\n","import {type, parseCoordGrammar, serializeNumber, mapRange} from \"./util.js\";\nimport {getWhite} from \"./adapt.js\";\nimport hooks from \"./hooks.js\";\nimport getColor from \"./getColor.js\";\n\nconst  = .000075;\n\n/**\n * Class to represent a color space\n */\nexport default class ColorSpace {\n\tconstructor (options) {\n\t\tthis.id = options.id;\n\t\tthis.name = options.name;\n\t\tthis.base = options.base ? ColorSpace.get(options.base) : null;\n\t\tthis.aliases = options.aliases;\n\n\t\tif (this.base) {\n\t\t\tthis.fromBase = options.fromBase;\n\t\t\tthis.toBase = options.toBase;\n\t\t}\n\n\t\t// Coordinate metadata\n\n\t\tlet coords = options.coords ?? this.base.coords;\n\n\t\tfor (let name in coords) {\n\t\t\tif (!(\"name\" in coords[name])) {\n\t\t\t\tcoords[name].name = name;\n\t\t\t}\n\t\t}\n\t\tthis.coords = coords;\n\n\t\t// White point\n\n\t\tlet white = options.white ?? this.base.white ?? \"D65\";\n\t\tthis.white = getWhite(white);\n\n\t\t// Sort out formats\n\n\t\tthis.formats = options.formats ?? {};\n\n\t\tfor (let name in this.formats) {\n\t\t\tlet format = this.formats[name];\n\t\t\tformat.type ||= \"function\";\n\t\t\tformat.name ||= name;\n\t\t}\n\n\t\tif (!this.formats.color?.id) {\n\t\t\tthis.formats.color = {\n\t\t\t\t...this.formats.color ?? {},\n\t\t\t\tid: options.cssId || this.id,\n\t\t\t};\n\t\t}\n\n\t\t// Gamut space\n\n\t\tif (options.gamutSpace) {\n\t\t\t// Gamut space explicitly specified\n\t\t\tthis.gamutSpace = options.gamutSpace === \"self\" ? this : ColorSpace.get(options.gamutSpace);\n\t\t}\n\t\telse {\n\t\t\t// No gamut space specified, calculate a sensible default\n\t\t\tif (this.isPolar) {\n\t\t\t\t// Do not check gamut through polar coordinates\n\t\t\t\tthis.gamutSpace = this.base;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.gamutSpace =  this;\n\t\t\t}\n\t\t}\n\n\t\t// Optimize inGamut for unbounded spaces\n\t\tif (this.gamutSpace.isUnbounded) {\n\t\t\tthis.inGamut = (coords, options) => {\n\t\t\t\treturn true;\n\t\t\t};\n\t\t}\n\n\t\t// Other stuff\n\t\tthis.referred = options.referred;\n\n\t\t// Compute ancestors and store them, since they will never change\n\t\tObject.defineProperty(this, \"path\", {\n\t\t\tvalue: getPath(this).reverse(),\n\t\t\twritable: false,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true,\n\t\t});\n\n\t\thooks.run(\"colorspace-init-end\", this);\n\t}\n\n\tinGamut (coords, {epsilon = } = {}) {\n\t\tif (!this.equals(this.gamutSpace)) {\n\t\t\tcoords = this.to(this.gamutSpace, coords);\n\t\t\treturn this.gamutSpace.inGamut(coords, {epsilon});\n\t\t}\n\n\t\tlet coordMeta = Object.values(this.coords);\n\n\t\treturn coords.every((c, i) => {\n\t\t\tlet meta = coordMeta[i];\n\n\t\t\tif (meta.type !== \"angle\" && meta.range) {\n\t\t\t\tif (Number.isNaN(c)) {\n\t\t\t\t\t// NaN is always in gamut\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\n\t\t\t\tlet [min, max] = meta.range;\n\t\t\t\treturn (min === undefined || c >= min - epsilon)\n\t\t\t\t    && (max === undefined || c <= max + epsilon);\n\t\t\t}\n\n\t\t\treturn true;\n\t\t});\n\t}\n\n\tget isUnbounded () {\n\t\treturn Object.values(this.coords).every(coord => !(\"range\" in coord));\n\t}\n\n\tget cssId () {\n\t\treturn this.formats?.color?.id || this.id;\n\t}\n\n\tget isPolar () {\n\t\tfor (let id in this.coords) {\n\t\t\tif (this.coords[id].type === \"angle\") {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\treturn false;\n\t}\n\n\tgetFormat (format) {\n\t\tif (typeof format === \"object\") {\n\t\t\tformat = processFormat(format, this);\n\t\t\treturn format;\n\t\t}\n\n\t\tlet ret;\n\t\tif (format === \"default\") {\n\t\t\t// Get first format\n\t\t\tret = Object.values(this.formats)[0];\n\t\t}\n\t\telse {\n\t\t\tret = this.formats[format];\n\t\t}\n\n\t\tif (ret) {\n\t\t\tret = processFormat(ret, this);\n\t\t\treturn ret;\n\t\t}\n\n\t\treturn null;\n\t}\n\n\t/**\n\t * Check if this color space is the same as another color space reference.\n\t * Allows proxying color space objects and comparing color spaces with ids.\n\t * @param {string | ColorSpace} space ColorSpace object or id to compare to\n\t * @returns {boolean}\n\t */\n\tequals (space) {\n\t\tif (!space) {\n\t\t\treturn false;\n\t\t}\n\n\t\treturn this === space || this.id === space || this.id === space.id;\n\t}\n\n\tto (space, coords) {\n\t\tif (arguments.length === 1) {\n\t\t\tconst color = getColor(space);\n\t\t\t[space, coords] = [color.space, color.coords];\n\t\t}\n\n\t\tspace = ColorSpace.get(space);\n\n\t\tif (this.equals(space)) {\n\t\t\t// Same space, no change needed\n\t\t\treturn coords;\n\t\t}\n\n\t\t// Convert NaN to 0, which seems to be valid in every coordinate of every color space\n\t\tcoords = coords.map(c => Number.isNaN(c) ? 0 : c);\n\n\t\t// Find connection space = lowest common ancestor in the base tree\n\t\tlet myPath = this.path;\n\t\tlet otherPath = space.path;\n\n\t\tlet connectionSpace, connectionSpaceIndex;\n\n\t\tfor (let i = 0; i < myPath.length; i++) {\n\t\t\tif (myPath[i].equals(otherPath[i])) {\n\t\t\t\tconnectionSpace = myPath[i];\n\t\t\t\tconnectionSpaceIndex = i;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!connectionSpace) {\n\t\t\t// This should never happen\n\t\t\tthrow new Error(`Cannot convert between color spaces ${this} and ${space}: no connection space was found`);\n\t\t}\n\n\t\t// Go up from current space to connection space\n\t\tfor (let i = myPath.length - 1; i > connectionSpaceIndex; i--) {\n\t\t\tcoords = myPath[i].toBase(coords);\n\t\t}\n\n\t\t// Go down from connection space to target space\n\t\tfor (let i = connectionSpaceIndex + 1; i < otherPath.length; i++) {\n\t\t\tcoords = otherPath[i].fromBase(coords);\n\t\t}\n\n\t\treturn coords;\n\t}\n\n\tfrom (space, coords) {\n\t\tif (arguments.length === 1) {\n\t\t\tconst color = getColor(space);\n\t\t\t[space, coords] = [color.space, color.coords];\n\t\t}\n\n\t\tspace = ColorSpace.get(space);\n\n\t\treturn space.to(this, coords);\n\t}\n\n\ttoString () {\n\t\treturn `${this.name} (${this.id})`;\n\t}\n\n\tgetMinCoords () {\n\t\tlet ret = [];\n\n\t\tfor (let id in this.coords) {\n\t\t\tlet meta = this.coords[id];\n\t\t\tlet range = meta.range || meta.refRange;\n\t\t\tret.push(range?.min ?? 0);\n\t\t}\n\n\t\treturn ret;\n\t}\n\n\tstatic registry = {};\n\n\t// Returns array of unique color spaces\n\tstatic get all () {\n\t\treturn [...new Set(Object.values(ColorSpace.registry))];\n\t}\n\n\tstatic register (id, space) {\n\t\tif (arguments.length === 1) {\n\t\t\tspace = arguments[0];\n\t\t\tid = space.id;\n\t\t}\n\n\t\tspace = this.get(space);\n\n\t\tif (this.registry[id] && this.registry[id] !== space) {\n\t\t\tthrow new Error(`Duplicate color space registration: '${id}'`);\n\t\t}\n\t\tthis.registry[id] = space;\n\n\t\t// Register aliases when called without an explicit ID.\n\t\tif (arguments.length === 1 && space.aliases) {\n\t\t\tfor (let alias of space.aliases) {\n\t\t\t\tthis.register(alias, space);\n\t\t\t}\n\t\t}\n\n\t\treturn space;\n\t}\n\n\t/**\n\t * Lookup ColorSpace object by name\n\t * @param {ColorSpace | string} name\n\t */\n\tstatic get (space, ...alternatives) {\n\t\tif (!space || space instanceof ColorSpace) {\n\t\t\treturn space;\n\t\t}\n\n\t\tlet argType = type(space);\n\n\t\tif (argType === \"string\") {\n\t\t\t// It's a color space id\n\t\t\tlet ret = ColorSpace.registry[space.toLowerCase()];\n\n\t\t\tif (!ret) {\n\t\t\t\tthrow new TypeError(`No color space found with id = \"${space}\"`);\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t}\n\n\t\tif (alternatives.length) {\n\t\t\treturn ColorSpace.get(...alternatives);\n\t\t}\n\n\t\tthrow new TypeError(`${space} is not a valid color space`);\n\t}\n\n\t/**\n\t * Get metadata about a coordinate of a color space\n\t *\n\t * @static\n\t * @param {Array | string} ref\n\t * @param {ColorSpace | string} [workingSpace]\n\t * @return {Object}\n\t */\n\tstatic resolveCoord (ref, workingSpace) {\n\t\tlet coordType = type(ref);\n\t\tlet space, coord;\n\n\t\tif (coordType === \"string\") {\n\t\t\tif (ref.includes(\".\")) {\n\t\t\t\t// Absolute coordinate\n\t\t\t\t[space, coord] = ref.split(\".\");\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// Relative coordinate\n\t\t\t\t[space, coord] = [, ref];\n\t\t\t}\n\t\t}\n\t\telse if (Array.isArray(ref)) {\n\t\t\t[space, coord] = ref;\n\t\t}\n\t\telse {\n\t\t\t// Object\n\t\t\tspace = ref.space;\n\t\t\tcoord = ref.coordId;\n\t\t}\n\n\t\tspace = ColorSpace.get(space);\n\n\t\tif (!space) {\n\t\t\tspace = workingSpace;\n\t\t}\n\n\t\tif (!space) {\n\t\t\tthrow new TypeError(`Cannot resolve coordinate reference ${ref}: No color space specified and relative references are not allowed here`);\n\t\t}\n\n\t\tcoordType = type(coord);\n\n\t\tif (coordType === \"number\" || coordType === \"string\" && coord >= 0) {\n\t\t\t// Resolve numerical coord\n\t\t\tlet meta = Object.entries(space.coords)[coord];\n\n\t\t\tif (meta) {\n\t\t\t\treturn {space, id: meta[0], index: coord, ...meta[1]};\n\t\t\t}\n\t\t}\n\n\t\tspace = ColorSpace.get(space);\n\n\t\tlet normalizedCoord = coord.toLowerCase();\n\n\t\tlet i = 0;\n\t\tfor (let id in space.coords) {\n\t\t\tlet meta = space.coords[id];\n\n\t\t\tif (id.toLowerCase() === normalizedCoord || meta.name?.toLowerCase() === normalizedCoord) {\n\t\t\t\treturn {space, id, index: i, ...meta};\n\t\t\t}\n\n\t\t\ti++;\n\t\t}\n\n\t\tthrow new TypeError(`No \"${coord}\" coordinate found in ${space.name}. Its coordinates are: ${Object.keys(space.coords).join(\", \")}`);\n\t}\n\n\tstatic DEFAULT_FORMAT = {\n\t\ttype: \"functions\",\n\t\tname: \"color\",\n\t};\n}\n\nfunction getPath (space) {\n\tlet ret = [space];\n\n\tfor (let s = space; s = s.base;) {\n\t\tret.push(s);\n\t}\n\n\treturn ret;\n}\n\nfunction processFormat (format, {coords} = {}) {\n\tif (format.coords && !format.coordGrammar) {\n\t\tformat.type ||= \"function\";\n\t\tformat.name ||= \"color\";\n\n\t\t// Format has not been processed\n\t\tformat.coordGrammar = parseCoordGrammar(format.coords);\n\n\t\tlet coordFormats = Object.entries(coords).map(([id, coordMeta], i) => {\n\t\t\t// Preferred format for each coord is the first one\n\t\t\tlet outputType = format.coordGrammar[i][0];\n\n\t\t\tlet fromRange = coordMeta.range || coordMeta.refRange;\n\t\t\tlet toRange = outputType.range, suffix = \"\";\n\n\t\t\t// Non-strict equals intentional since outputType could be a string object\n\t\t\tif (outputType == \"<percentage>\") {\n\t\t\t\ttoRange = [0, 100];\n\t\t\t\tsuffix = \"%\";\n\t\t\t}\n\t\t\telse if (outputType == \"<angle>\") {\n\t\t\t\tsuffix = \"deg\";\n\t\t\t}\n\n\t\t\treturn  {fromRange, toRange, suffix};\n\t\t});\n\n\t\tformat.serializeCoords = (coords, precision) => {\n\t\t\treturn coords.map((c, i) => {\n\t\t\t\tlet {fromRange, toRange, suffix} = coordFormats[i];\n\n\t\t\t\tif (fromRange && toRange) {\n\t\t\t\t\tc = mapRange(fromRange, toRange, c);\n\t\t\t\t}\n\n\t\t\t\tc = serializeNumber(c, {precision, unit: suffix});\n\n\t\t\t\treturn c;\n\t\t\t});\n\t\t};\n\t}\n\n\treturn format;\n}\n","import ColorSpace from \"../space.js\";\n\nexport default new ColorSpace({\n\tid: \"xyz-d65\",\n\tname: \"XYZ D65\",\n\tcoords: {\n\t\tx: {name: \"X\"},\n\t\ty: {name: \"Y\"},\n\t\tz: {name: \"Z\"},\n\t},\n\twhite: \"D65\",\n\tformats: {\n\t\tcolor: {\n\t\t\tids: [\"xyz-d65\", \"xyz\"],\n\t\t},\n\t},\n\taliases: [\"xyz\"],\n});\n","import ColorSpace from \"./space.js\";\nimport {multiplyMatrices} from \"./util.js\";\nimport adapt from \"./adapt.js\";\nimport XYZ_D65 from \"./spaces/xyz-d65.js\";\n\n/**\n * Convenience class for RGB color spaces\n * @extends {ColorSpace}\n */\nexport default class RGBColorSpace extends ColorSpace {\n\t/**\n\t * Creates a new RGB ColorSpace.\n\t * If coords are not specified, they will use the default RGB coords.\n\t * Instead of `fromBase()` and `toBase()` functions,\n\t * you can specify to/from XYZ matrices and have `toBase()` and `fromBase()` automatically generated.\n\t * @param {*} options - Same options as {@link ColorSpace} plus:\n\t * @param {number[][]} options.toXYZ_M - Matrix to convert to XYZ\n\t * @param {number[][]} options.fromXYZ_M - Matrix to convert from XYZ\n\t */\n\tconstructor (options) {\n\t\tif (!options.coords) {\n\t\t\toptions.coords = {\n\t\t\t\tr: {\n\t\t\t\t\trange: [0, 1],\n\t\t\t\t\tname: \"Red\",\n\t\t\t\t},\n\t\t\t\tg: {\n\t\t\t\t\trange: [0, 1],\n\t\t\t\t\tname: \"Green\",\n\t\t\t\t},\n\t\t\t\tb: {\n\t\t\t\t\trange: [0, 1],\n\t\t\t\t\tname: \"Blue\",\n\t\t\t\t},\n\t\t\t};\n\t\t}\n\n\t\tif (!options.base) {\n\t\t\toptions.base = XYZ_D65;\n\t\t}\n\n\t\tif (options.toXYZ_M && options.fromXYZ_M) {\n\t\t\toptions.toBase ??= rgb => {\n\t\t\t\tlet xyz = multiplyMatrices(options.toXYZ_M, rgb);\n\n\t\t\t\tif (this.white !== this.base.white) {\n\t\t\t\t\t// Perform chromatic adaptation\n\t\t\t\t\txyz = adapt(this.white, this.base.white, xyz);\n\t\t\t\t}\n\n\t\t\t\treturn xyz;\n\t\t\t};\n\n\t\t\toptions.fromBase ??= xyz => {\n\t\t\t\txyz = adapt(this.base.white, this.white, xyz);\n\t\t\t\treturn multiplyMatrices(options.fromXYZ_M, xyz);\n\t\t\t};\n\t\t}\n\n\t\toptions.referred ??= \"display\";\n\n\t\tsuper(options);\n\t}\n}\n","import ColorSpace from \"./space.js\";\nimport getColor from \"./getColor.js\";\n\n/**\n * Get the coordinates of a color in any color space\n * @param {Color} color\n * @param {string | ColorSpace} [space = color.space] The color space to convert to. Defaults to the color's current space\n * @returns {number[]} The color coordinates in the given color space\n */\nexport default function getAll (color, space) {\n\tcolor = getColor(color);\n\n\tif (!space || color.space.equals(space)) {\n\t\t// No conversion needed\n\t\treturn color.coords.slice();\n\t}\n\n\tspace = ColorSpace.get(space);\n\treturn space.from(color);\n}\n","import ColorSpace from \"./space.js\";\nimport getAll from \"./getAll.js\";\nimport getColor from \"./getColor.js\";\n\nexport default function get (color, prop) {\n\tcolor = getColor(color);\n\n\tlet {space, index} = ColorSpace.resolveCoord(prop, color.space);\n\tlet coords = getAll(color, space);\n\treturn coords[index];\n}\n","import ColorSpace from \"./space.js\";\nimport getColor from \"./getColor.js\";\n\nexport default function setAll (color, space, coords) {\n\tcolor = getColor(color);\n\n\tspace = ColorSpace.get(space);\n\tcolor.coords = space.to(color.space, coords);\n\treturn color;\n}\n\nsetAll.returns = \"color\";\n","import ColorSpace from \"./space.js\";\nimport getColor from \"./getColor.js\";\nimport get from \"./get.js\";\nimport getAll from \"./getAll.js\";\nimport setAll from \"./setAll.js\";\nimport {type} from \"./util.js\";\n\n// Set properties and return current instance\nexport default function set (color, prop, value) {\n\tcolor = getColor(color);\n\n\tif (arguments.length === 2 && type(arguments[1]) === \"object\") {\n\t\t// Argument is an object literal\n\t\tlet object = arguments[1];\n\t\tfor (let p in object) {\n\t\t\tset(color, p, object[p]);\n\t\t}\n\t}\n\telse {\n\t\tif (typeof value === \"function\") {\n\t\t\tvalue = value(get(color, prop));\n\t\t}\n\n\t\tlet {space, index} = ColorSpace.resolveCoord(prop, color.space);\n\t\tlet coords = getAll(color, space);\n\t\tcoords[index] = value;\n\t\tsetAll(color, space, coords);\n\t}\n\n\treturn color;\n}\n\nset.returns = \"color\";\n","import ColorSpace from \"../space.js\";\nimport adapt from \"../adapt.js\";\nimport XYZ_D65 from \"./xyz-d65.js\";\n\nexport default new ColorSpace({\n\tid: \"xyz-d50\",\n\tname: \"XYZ D50\",\n\twhite: \"D50\",\n\tbase: XYZ_D65,\n\tfromBase: coords => adapt(XYZ_D65.white, \"D50\", coords),\n\ttoBase: coords => adapt(\"D50\", XYZ_D65.white, coords),\n});\n","import ColorSpace from \"../space.js\";\nimport {WHITES} from \"../adapt.js\";\nimport xyz_d50 from \"./xyz-d50.js\";\n\n//  *   = 2^3 = 8\nconst  = 216 / 24389;  // 6^3/29^3 == (24/116)^3\nconst 3 = 24 / 116;\nconst  = 24389 / 27;   // 29^3/3^3\n\nlet white = WHITES.D50;\n\nexport default new ColorSpace({\n\tid: \"lab\",\n\tname: \"Lab\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t\ta: {\n\t\t\trefRange: [-125, 125],\n\t\t},\n\t\tb: {\n\t\t\trefRange: [-125, 125],\n\t\t},\n\t},\n\n\t// Assuming XYZ is relative to D50, convert to CIE Lab\n\t// from CIE standard, which now defines these as a rational fraction\n\twhite,\n\n\tbase: xyz_d50,\n\t// Convert D50-adapted XYX to Lab\n\t//  CIE 15.3:2004 section 8.2.1.1\n\tfromBase (XYZ) {\n\t\t// compute xyz, which is XYZ scaled relative to reference white\n\t\tlet xyz = XYZ.map((value, i) => value / white[i]);\n\n\t\t// now compute f\n\t\tlet f = xyz.map(value => value >  ? Math.cbrt(value) : ( * value + 16) / 116);\n\n\t\treturn [\n\t\t\t(116 * f[1]) - 16,   // L\n\t\t\t500 * (f[0] - f[1]), // a\n\t\t\t200 * (f[1] - f[2]),  // b\n\t\t];\n\t},\n\t// Convert Lab to D50-adapted XYZ\n\t// Same result as CIE 15.3:2004 Appendix D although the derivation is different\n\t// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\ttoBase (Lab) {\n\t\t// compute f, starting with the luminance-related term\n\t\tlet f = [];\n\t\tf[1] = (Lab[0] + 16) / 116;\n\t\tf[0] = Lab[1] / 500 + f[1];\n\t\tf[2] = f[1] - Lab[2] / 200;\n\n\t\t// compute xyz\n\t\tlet xyz = [\n\t\t\tf[0]   > 3 ? Math.pow(f[0], 3)                : (116 * f[0] - 16) / ,\n\t\t\tLab[0] > 8  ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / ,\n\t\t\tf[2]   > 3 ? Math.pow(f[2], 3)                : (116 * f[2] - 16) / ,\n\t\t];\n\n\t\t// Compute XYZ by scaling xyz by reference white\n\t\treturn xyz.map((value, i) => value * white[i]);\n\t},\n\n\tformats: {\n\t\t\"lab\": {\n\t\t\tcoords: [\"<number> | <percentage>\", \"<number> | <percentage>[-1,1]\", \"<number> | <percentage>[-1,1]\"],\n\t\t},\n\t},\n});\n","export function constrain (angle) {\n\treturn ((angle % 360) + 360) % 360;\n}\n\nexport function adjust (arc, angles) {\n\tif (arc === \"raw\") {\n\t\treturn angles;\n\t}\n\n\tlet [a1, a2] = angles.map(constrain);\n\n\tlet angleDiff = a2 - a1;\n\n\tif (arc === \"increasing\") {\n\t\tif (angleDiff < 0) {\n\t\t\ta2 += 360;\n\t\t}\n\t}\n\telse if (arc === \"decreasing\") {\n\t\tif (angleDiff > 0) {\n\t\t\ta1 += 360;\n\t\t}\n\t}\n\telse if (arc === \"longer\") {\n\t\tif (-180 < angleDiff && angleDiff < 180) {\n\t\t\tif (angleDiff > 0) {\n\t\t\t\ta1 += 360;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ta2 += 360;\n\t\t\t}\n\t\t}\n\t}\n\telse if (arc === \"shorter\") {\n\t\tif (angleDiff > 180) {\n\t\t\ta1 += 360;\n\t\t}\n\t\telse if (angleDiff < -180) {\n\t\t\ta2 += 360;\n\t\t}\n\t}\n\n\treturn [a1, a2];\n}\n","import ColorSpace from \"../space.js\";\nimport Lab from \"./lab.js\";\nimport {constrain as constrainAngle} from \"../angles.js\";\n\nexport default new ColorSpace({\n\tid: \"lch\",\n\tname: \"LCH\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t\tc: {\n\t\t\trefRange: [0, 150],\n\t\t\tname: \"Chroma\",\n\t\t},\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t},\n\n\tbase: Lab,\n\tfromBase (Lab) {\n\t\t// Convert to polar form\n\t\tlet [L, a, b] = Lab;\n\t\tlet hue;\n\t\tconst  = 0.02;\n\n\t\tif (Math.abs(a) <  && Math.abs(b) < ) {\n\t\t\thue = NaN;\n\t\t}\n\t\telse {\n\t\t\thue = Math.atan2(b, a) * 180 / Math.PI;\n\t\t}\n\n\t\treturn [\n\t\t\tL, // L is still L\n\t\t\tMath.sqrt(a ** 2 + b ** 2), // Chroma\n\t\t\tconstrainAngle(hue), // Hue, in degrees [0 to 360)\n\t\t];\n\t},\n\ttoBase (LCH) {\n\t\t// Convert from polar form\n\t\tlet [Lightness, Chroma, Hue] = LCH;\n\t\t// Clamp any negative Chroma\n\t\tif (Chroma < 0) {\n\t\t\tChroma = 0;\n\t\t}\n\t\t// Deal with NaN Hue\n\t\tif (isNaN(Hue)) {\n\t\t\tHue = 0;\n\t\t}\n\t\treturn [\n\t\t\tLightness, // L is still L\n\t\t\tChroma * Math.cos(Hue * Math.PI / 180), // a\n\t\t\tChroma * Math.sin(Hue * Math.PI / 180),  // b\n\t\t];\n\t},\n\n\tformats: {\n\t\t\"lch\": {\n\t\t\tcoords: [\"<number> | <percentage>\", \"<number> | <percentage>\", \"<number> | <angle>\"],\n\t\t},\n\t},\n});\n","import defaults from \"../defaults.js\";\nimport lab from \"../spaces/lab.js\";\nimport lch from \"../spaces/lch.js\";\nimport getColor from \"../getColor.js\";\n\n// deltaE2000 is a statistically significant improvement\n// and is recommended by the CIE and Idealliance\n// especially for color differences less than 10 deltaE76\n// but is wicked complicated\n// and many implementations have small errors!\n// DeltaE2000 is also discontinuous; in case this\n// matters to you, use deltaECMC instead.\n\nconst Gfactor = 25 ** 7;\nconst  = Math.PI;\nconst r2d = 180 / ;\nconst d2r =  / 180;\n\nfunction pow7 (x) {\n\t// Faster than x ** 7 or Math.pow(x, 7)\n\n\tconst x2 = x * x;\n\tconst x7 = x2 * x2 * x2 * x;\n\n\treturn x7;\n}\n\nexport default function (color, sample, {kL = 1, kC = 1, kH = 1} = {}) {\n\t[color, sample] = getColor([color, sample]);\n\n\t// Given this color as the reference\n\t// and the function parameter as the sample,\n\t// calculate deltaE 2000.\n\n\t// This implementation assumes the parametric\n\t// weighting factors kL, kC and kH\n\t// for the influence of viewing conditions\n\t// are all 1, as sadly seems typical.\n\t// kL should be increased for lightness texture or noise\n\t// and kC increased for chroma noise\n\n\tlet [L1, a1, b1] = lab.from(color);\n\tlet C1 = lch.from(lab, [L1, a1, b1])[1];\n\tlet [L2, a2, b2] = lab.from(sample);\n\tlet C2 = lch.from(lab, [L2, a2, b2])[1];\n\n\t// Check for negative Chroma,\n\t// which might happen through\n\t// direct user input of LCH values\n\n\tif (C1 < 0) {\n\t\tC1 = 0;\n\t}\n\tif (C2 < 0) {\n\t\tC2 = 0;\n\t}\n\n\tlet Cbar = (C1 + C2) / 2; // mean Chroma\n\n\t// calculate a-axis asymmetry factor from mean Chroma\n\t// this turns JND ellipses for near-neutral colors back into circles\n\tlet C7 = pow7(Cbar);\n\n\tlet G = 0.5 * (1 - Math.sqrt(C7 / (C7 + Gfactor)));\n\n\t// scale a axes by asymmetry factor\n\t// this by the way is why there is no Lab2000 colorspace\n\tlet adash1 = (1 + G) * a1;\n\tlet adash2 = (1 + G) * a2;\n\n\t// calculate new Chroma from scaled a and original b axes\n\tlet Cdash1 = Math.sqrt(adash1 ** 2 + b1 ** 2);\n\tlet Cdash2 = Math.sqrt(adash2 ** 2 + b2 ** 2);\n\n\t// calculate new hues, with zero hue for true neutrals\n\t// and in degrees, not radians\n\n\tlet h1 = (adash1 === 0 && b1 === 0) ? 0 : Math.atan2(b1, adash1);\n\tlet h2 = (adash2 === 0 && b2 === 0) ? 0 : Math.atan2(b2, adash2);\n\n\tif (h1 < 0) {\n\t\th1 += 2 * ;\n\t}\n\tif (h2 < 0) {\n\t\th2 += 2 * ;\n\t}\n\n\th1 *= r2d;\n\th2 *= r2d;\n\n\t// Lightness and Chroma differences; sign matters\n\tlet L = L2 - L1;\n\tlet C = Cdash2 - Cdash1;\n\n\t// Hue difference, getting the sign correct\n\tlet hdiff = h2 - h1;\n\tlet hsum = h1 + h2;\n\tlet habs = Math.abs(hdiff);\n\tlet h;\n\n\tif (Cdash1 * Cdash2 === 0) {\n\t\th = 0;\n\t}\n\telse if (habs <= 180) {\n\t\th = hdiff;\n\t}\n\telse if (hdiff > 180) {\n\t\th = hdiff - 360;\n\t}\n\telse if (hdiff < -180) {\n\t\th = hdiff + 360;\n\t}\n\telse {\n\t\tdefaults.warn(\"the unthinkable has happened\");\n\t}\n\n\t// weighted Hue difference, more for larger Chroma\n\tlet H = 2 * Math.sqrt(Cdash2 * Cdash1) * Math.sin(h * d2r / 2);\n\n\t// calculate mean Lightness and Chroma\n\tlet Ldash = (L1 + L2) / 2;\n\tlet Cdash = (Cdash1 + Cdash2) / 2;\n\tlet Cdash7 = pow7(Cdash);\n\n\t// Compensate for non-linearity in the blue region of Lab.\n\t// Four possibilities for hue weighting factor,\n\t// depending on the angles, to get the correct sign\n\tlet hdash;\n\tif (Cdash1 * Cdash2 === 0) {\n\t\thdash = hsum;   // which should be zero\n\t}\n\telse if (habs <= 180) {\n\t\thdash = hsum / 2;\n\t}\n\telse if (hsum < 360) {\n\t\thdash = (hsum + 360) / 2;\n\t}\n\telse {\n\t\thdash = (hsum - 360) / 2;\n\t}\n\n\t// positional corrections to the lack of uniformity of CIELAB\n\t// These are all trying to make JND ellipsoids more like spheres\n\n\t// SL Lightness crispening factor\n\t// a background with L=50 is assumed\n\tlet lsq = (Ldash - 50) ** 2;\n\tlet SL = 1 + ((0.015 * lsq) / Math.sqrt(20 + lsq));\n\n\t// SC Chroma factor, similar to those in CMC and deltaE 94 formulae\n\tlet SC = 1 + 0.045 * Cdash;\n\n\t// Cross term T for blue non-linearity\n\tlet T = 1;\n\tT -= (0.17 * Math.cos((     hdash - 30)  * d2r));\n\tT += (0.24 * Math.cos(  2 * hdash        * d2r));\n\tT += (0.32 * Math.cos(((3 * hdash) + 6)  * d2r));\n\tT -= (0.20 * Math.cos(((4 * hdash) - 63) * d2r));\n\n\t// SH Hue factor depends on Chroma,\n\t// as well as adjusted hue angle like deltaE94.\n\tlet SH = 1 + 0.015 * Cdash * T;\n\n\t// RT Hue rotation term compensates for rotation of JND ellipses\n\t// and Munsell constant hue lines\n\t// in the medium-high Chroma blue region\n\t// (Hue 225 to 315)\n\tlet  = 30 * Math.exp(-1 * (((hdash - 275) / 25) ** 2));\n\tlet RC = 2 * Math.sqrt(Cdash7 / (Cdash7 + Gfactor));\n\tlet RT = -1 * Math.sin(2 *  * d2r) * RC;\n\n\t// Finally calculate the deltaE, term by term as root sume of squares\n\tlet dE = (L / (kL * SL)) ** 2;\n\tdE += (C / (kC * SC)) ** 2;\n\tdE += (H / (kH * SH)) ** 2;\n\tdE += RT * (C / (kC * SC)) * (H / (kH * SH));\n\treturn Math.sqrt(dE);\n\t// Yay!!!\n}\n","import ColorSpace from \"../space.js\";\nimport {multiplyMatrices} from \"../util.js\";\nimport XYZ_D65 from \"./xyz-d65.js\";\n\n// Recalculated for consistent reference white\n// see https://github.com/w3c/csswg-drafts/issues/6642#issuecomment-943521484\nconst XYZtoLMS_M = [\n\t[ 0.8190224379967030, 0.3619062600528904, -0.1288737815209879 ],\n\t[ 0.0329836539323885, 0.9292868615863434,  0.0361446663506424 ],\n\t[ 0.0481771893596242, 0.2642395317527308,  0.6335478284694309 ],\n];\n// inverse of XYZtoLMS_M\nconst LMStoXYZ_M = [\n\t[  1.2268798758459243, -0.5578149944602171,  0.2813910456659647 ],\n\t[ -0.0405757452148008,  1.1122868032803170, -0.0717110580655164 ],\n\t[ -0.0763729366746601, -0.4214933324022432,  1.5869240198367816 ],\n];\nconst LMStoLab_M = [\n\t[ 0.2104542683093140,  0.7936177747023054, -0.0040720430116193 ],\n\t[ 1.9779985324311684, -2.4285922420485799,  0.4505937096174110 ],\n\t[ 0.0259040424655478,  0.7827717124575296, -0.8086757549230774 ],\n];\n// LMStoIab_M inverted\nconst LabtoLMS_M = [\n\t[ 1.0000000000000000,  0.3963377773761749,  0.2158037573099136 ],\n\t[ 1.0000000000000000, -0.1055613458156586, -0.0638541728258133 ],\n\t[ 1.0000000000000000, -0.0894841775298119, -1.2914855480194092 ],\n];\n\nexport default new ColorSpace({\n\tid: \"oklab\",\n\tname: \"Oklab\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 1],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t\ta: {\n\t\t\trefRange: [-0.4, 0.4],\n\t\t},\n\t\tb: {\n\t\t\trefRange: [-0.4, 0.4],\n\t\t},\n\t},\n\n\t// Note that XYZ is relative to D65\n\twhite: \"D65\",\n\tbase: XYZ_D65,\n\tfromBase (XYZ) {\n\t\t// move to LMS cone domain\n\t\tlet LMS = multiplyMatrices(XYZtoLMS_M, XYZ);\n\n\t\t// non-linearity\n\t\tlet LMSg = LMS.map(val => Math.cbrt(val));\n\n\t\treturn multiplyMatrices(LMStoLab_M, LMSg);\n\n\t},\n\ttoBase (OKLab) {\n\t\t// move to LMS cone domain\n\t\tlet LMSg = multiplyMatrices(LabtoLMS_M, OKLab);\n\n\t\t// restore linearity\n\t\tlet LMS = LMSg.map(val => val ** 3);\n\n\t\treturn multiplyMatrices(LMStoXYZ_M, LMS);\n\t},\n\n\tformats: {\n\t\t\"oklab\": {\n\t\t\tcoords: [\"<percentage> | <number>\", \"<number> | <percentage>[-1,1]\", \"<number> | <percentage>[-1,1]\"],\n\t\t},\n\t},\n});\n","// More accurate color-difference formulae\n// than the simple 1976 Euclidean distance in CIE Lab\n\nimport oklab from \"../spaces/oklab.js\";\nimport getColor from \"../getColor.js\";\n\nexport default function (color, sample) {\n\t[color, sample] = getColor([color, sample]);\n\n\t// Given this color as the reference\n\t// and a sample,\n\t// calculate deltaEOK, term by term as root sum of squares\n\tlet [L1, a1, b1] = oklab.from(color);\n\tlet [L2, a2, b2] = oklab.from(sample);\n\tlet L = L1 - L2;\n\tlet a = a1 - a2;\n\tlet b = b1 - b2;\n\treturn Math.sqrt(L ** 2 + a ** 2 + b ** 2);\n}\n","import ColorSpace from \"./space.js\";\nimport getColor from \"./getColor.js\";\n\nconst  = .000075;\n\n/**\n * Check if a color is in gamut of either its own or another color space\n * @return {Boolean} Is the color in gamut?\n */\nexport default function inGamut (color, space, {epsilon = } = {}) {\n\tcolor = getColor(color);\n\n\tif (!space) {\n\t\tspace = color.space;\n\t}\n\n\tspace = ColorSpace.get(space);\n\tlet coords = color.coords;\n\n\tif (space !== color.space) {\n\t\tcoords = space.from(color);\n\t}\n\n\treturn space.inGamut(coords, {epsilon});\n}\n","export default function clone (color) {\n\treturn {\n\t\tspace: color.space,\n\t\tcoords: color.coords.slice(),\n\t\talpha: color.alpha,\n\t};\n}\n","import ColorSpace from \"./space.js\";\n\n/**\n * Euclidean distance of colors in an arbitrary color space\n */\nexport default function distance (color1, color2, space = \"lab\") {\n\tspace = ColorSpace.get(space);\n\n\t// Assume getColor() is called on color in space.from()\n\tlet coords1 = space.from(color1);\n\tlet coords2 = space.from(color2);\n\n\treturn Math.sqrt(coords1.reduce((acc, c1, i) => {\n\t\tlet c2 = coords2[i];\n\t\tif (isNaN(c1) || isNaN(c2)) {\n\t\t\treturn acc;\n\t\t}\n\n\t\treturn acc + (c2 - c1) ** 2;\n\t}, 0));\n}\n","import distance from \"../distance.js\";\nimport getColor from \"../getColor.js\";\n\nexport default function deltaE76 (color, sample) {\n\t// Assume getColor() is called in the distance function\n\treturn distance(color, sample, \"lab\");\n}\n","import lab from \"../spaces/lab.js\";\nimport lch from \"../spaces/lch.js\";\nimport getColor from \"../getColor.js\";\n\n// More accurate color-difference formulae\n// than the simple 1976 Euclidean distance in Lab\n\n// CMC by the Color Measurement Committee of the\n// Bradford Society of Dyeists and Colorsts, 1994.\n// Uses LCH rather than Lab,\n// with different weights for L, C and H differences\n// A nice increase in accuracy for modest increase in complexity\nconst  = Math.PI;\nconst d2r =  / 180;\n\nexport default function (color, sample, {l = 2, c = 1} = {}) {\n\t[color, sample] = getColor([color, sample]);\n\n\t// Given this color as the reference\n\t// and a sample,\n\t// calculate deltaE CMC.\n\n\t// This implementation assumes the parametric\n\t// weighting factors l:c are 2:1\n\t// which is typical for non-textile uses.\n\n\tlet [L1, a1, b1] = lab.from(color);\n\tlet [, C1, H1] = lch.from(lab, [L1, a1, b1]);\n\tlet [L2, a2, b2] = lab.from(sample);\n\tlet C2 = lch.from(lab, [L2, a2, b2])[1];\n\n\t// let [L1, a1, b1] = color.getAll(lab);\n\t// let C1 = color.get(\"lch.c\");\n\t// let H1 = color.get(\"lch.h\");\n\t// let [L2, a2, b2] = sample.getAll(lab);\n\t// let C2 = sample.get(\"lch.c\");\n\n\t// Check for negative Chroma,\n\t// which might happen through\n\t// direct user input of LCH values\n\n\tif (C1 < 0) {\n\t\tC1 = 0;\n\t}\n\tif (C2 < 0) {\n\t\tC2 = 0;\n\t}\n\n\t// we don't need H2 as H is calculated from a, b and C\n\n\t// Lightness and Chroma differences\n\t// These are (color - sample), unlike deltaE2000\n\tlet L = L1 - L2;\n\tlet C = C1 - C2;\n\n\tlet a = a1 - a2;\n\tlet b = b1 - b2;\n\n\t// weighted Hue difference, less for larger Chroma difference\n\n\tlet H2 = (a ** 2) + (b ** 2) - (C ** 2);\n\t// due to roundoff error it is possible that, for zero a and b,\n\t// C > a + b is 0, resulting in attempting\n\t// to take the square root of a negative number\n\n\t// trying instead the equation from Industrial Color Physics\n\t// By Georg A. Klein\n\n\t// let H = ((a1 * b2) - (a2 * b1)) / Math.sqrt(0.5 * ((C2 * C1) + (a2 * a1) + (b2 * b1)));\n\t// console.log({H});\n\t// This gives the same result to 12 decimal places\n\t// except it sometimes NaNs when trying to root a negative number\n\n\t// let H = Math.sqrt(H2); we never actually use the root, it gets squared again!!\n\n\t// positional corrections to the lack of uniformity of CIELAB\n\t// These are all trying to make JND ellipsoids more like spheres\n\n\t// SL Lightness crispening factor, depends entirely on L1 not L2\n\tlet SL = 0.511;\t// linear portion of the Y to L transfer function\n\tif (L1 >= 16) {\t// cubic portion\n\t\tSL = (0.040975 * L1) / (1 + 0.01765 * L1);\n\t}\n\n\t// SC Chroma factor\n\tlet SC = ((0.0638 * C1) / (1 + 0.0131 * C1)) + 0.638;\n\n\t// Cross term T for blue non-linearity\n\tlet T;\n\tif (Number.isNaN(H1)) {\n\t\tH1 = 0;\n\t}\n\n\tif (H1 >= 164 && H1 <= 345) {\n\t\tT = 0.56 + Math.abs(0.2 * Math.cos((H1 + 168) * d2r));\n\t}\n\telse {\n\t\tT = 0.36 + Math.abs(0.4 * Math.cos((H1 + 35) * d2r));\n\t}\n\t// console.log({T});\n\n\t// SH Hue factor also depends on C1,\n\tlet C4 = Math.pow(C1, 4);\n\tlet F = Math.sqrt(C4 / (C4 + 1900));\n\tlet SH = SC * ((F * T) + 1 - F);\n\n\t// Finally calculate the deltaE, term by term as root sume of squares\n\tlet dE = (L / (l * SL)) ** 2;\n\tdE += (C / (c * SC)) ** 2;\n\tdE += (H2 / (SH ** 2));\n\t// dE += (H / SH)  ** 2;\n\treturn Math.sqrt(dE);\n\t// Yay!!!\n}\n","import ColorSpace from \"../space.js\";\nimport XYZ_D65 from \"./xyz-d65.js\";\n\nconst Yw = 203;\t// absolute luminance of media white\n\nexport default new ColorSpace({\n// Absolute CIE XYZ, with a D65 whitepoint,\n// as used in most HDR colorspaces as a starting point.\n// SDR spaces are converted per BT.2048\n// so that diffuse, media white is 203 cd/m\n\tid: \"xyz-abs-d65\",\n\tcssId: \"--xyz-abs-d65\",\n\tname: \"Absolute XYZ D65\",\n\tcoords: {\n\t\tx: {\n\t\t\trefRange: [0, 9504.7],\n\t\t\tname: \"Xa\",\n\t\t},\n\t\ty: {\n\t\t\trefRange: [0, 10000],\n\t\t\tname: \"Ya\",\n\t\t},\n\t\tz: {\n\t\t\trefRange: [0, 10888.3],\n\t\t\tname: \"Za\",\n\t\t},\n\t},\n\n\tbase: XYZ_D65,\n\tfromBase (XYZ) {\n\t\t// Make XYZ absolute, not relative to media white\n\t\t// Maximum luminance in PQ is 10,000 cd/m\n\t\t// Relative XYZ has Y=1 for media white\n\t\treturn XYZ.map (v => Math.max(v * Yw, 0));\n\t},\n\ttoBase (AbsXYZ) {\n\t\t// Convert to media-white relative XYZ\n\t\treturn AbsXYZ.map(v => Math.max(v / Yw, 0));\n\t},\n});\n","import ColorSpace from \"../space.js\";\nimport {multiplyMatrices} from \"../util.js\";\nimport XYZ_Abs_D65 from \"./xyz-abs-d65.js\";\n\nconst b = 1.15;\nconst g = 0.66;\nconst n = 2610 / (2 ** 14);\nconst ninv = (2 ** 14) / 2610;\nconst c1 = 3424 / (2 ** 12);\nconst c2 = 2413 / (2 ** 7);\nconst c3 = 2392 / (2 ** 7);\nconst p = 1.7 * 2523 / (2 ** 5);\nconst pinv = (2 ** 5) / (1.7 * 2523);\nconst d = -0.56;\nconst d0 = 1.6295499532821566E-11;\n\nconst XYZtoCone_M = [\n\t[  0.41478972, 0.579999,  0.0146480 ],\n\t[ -0.2015100,  1.120649,  0.0531008 ],\n\t[ -0.0166008,  0.264800,  0.6684799 ],\n];\n// XYZtoCone_M inverted\nconst ConetoXYZ_M = [\n\t[  1.9242264357876067,  -1.0047923125953657,  0.037651404030618   ],\n\t[  0.35031676209499907,  0.7264811939316552, -0.06538442294808501 ],\n\t[ -0.09098281098284752, -0.3127282905230739,  1.5227665613052603  ],\n];\nconst ConetoIab_M = [\n\t[  0.5,       0.5,       0        ],\n\t[  3.524000, -4.066708,  0.542708 ],\n\t[  0.199076,  1.096799, -1.295875 ],\n];\n// ConetoIab_M inverted\nconst IabtoCone_M = [\n\t[ 1,                   0.1386050432715393,   0.05804731615611886 ],\n\t[ 0.9999999999999999, -0.1386050432715393,  -0.05804731615611886 ],\n\t[ 0.9999999999999998, -0.09601924202631895, -0.8118918960560388  ],\n];\n\nexport default new ColorSpace({\n\tid: \"jzazbz\",\n\tname: \"Jzazbz\",\n\tcoords: {\n\t\tjz: {\n\t\t\trefRange: [0, 1],\n\t\t\tname: \"Jz\",\n\t\t},\n\t\taz: {\n\t\t\trefRange: [-0.5, 0.5],\n\t\t},\n\t\tbz: {\n\t\t\trefRange: [-0.5, 0.5],\n\t\t},\n\t},\n\n\tbase: XYZ_Abs_D65,\n\tfromBase (XYZ) {\n\t\t// First make XYZ absolute, not relative to media white\n\t\t// Maximum luminance in PQ is 10,000 cd/m\n\t\t// Relative XYZ has Y=1 for media white\n\t\t// BT.2048 says media white Y=203 at PQ 58\n\n\t\tlet [ Xa, Ya, Za ] = XYZ;\n\n\t\t// modify X and Y\n\t\tlet Xm = (b * Xa) - ((b - 1) * Za);\n\t\tlet Ym = (g * Ya) - ((g - 1) * Xa);\n\n\t\t// move to LMS cone domain\n\t\tlet LMS = multiplyMatrices(XYZtoCone_M, [ Xm, Ym, Za ]);\n\n\t\t// PQ-encode LMS\n\t\tlet PQLMS = LMS.map (function (val) {\n\t\t\tlet num = c1 + (c2 * ((val / 10000) ** n));\n\t\t\tlet denom = 1 + (c3 * ((val / 10000) ** n));\n\n\t\t\treturn (num / denom)  ** p;\n\t\t});\n\n\t\t// almost there, calculate Iz az bz\n\t\tlet [ Iz, az, bz] = multiplyMatrices(ConetoIab_M, PQLMS);\n\t\t// console.log({Iz, az, bz});\n\n\t\tlet Jz = ((1 + d) * Iz) / (1 + (d * Iz)) - d0;\n\t\treturn [Jz, az, bz];\n\t},\n\ttoBase (Jzazbz) {\n\t\tlet [Jz, az, bz] = Jzazbz;\n\t\tlet Iz = (Jz + d0) / (1 + d - d * (Jz + d0));\n\n\t\t// bring into LMS cone domain\n\t\tlet PQLMS = multiplyMatrices(IabtoCone_M, [ Iz, az, bz ]);\n\n\t\t// convert from PQ-coded to linear-light\n\t\tlet LMS = PQLMS.map(function (val) {\n\t\t\tlet num = (c1 - (val ** pinv));\n\t\t\tlet denom = (c3 * (val ** pinv)) - c2;\n\t\t\tlet x = 10000 * ((num / denom) ** ninv);\n\n\t\t\treturn (x); \t// luminance relative to diffuse white, [0, 70 or so].\n\t\t});\n\n\t\t// modified abs XYZ\n\t\tlet [ Xm, Ym, Za ] = multiplyMatrices(ConetoXYZ_M, LMS);\n\n\t\t// restore standard D50 relative XYZ, relative to media white\n\t\tlet Xa = (Xm + ((b - 1) * Za)) / b;\n\t\tlet Ya = (Ym + ((g - 1) * Xa)) / g;\n\t\treturn [ Xa, Ya, Za ];\n\t},\n\n\tformats: {\n\t\t// https://drafts.csswg.org/css-color-hdr/#Jzazbz\n\t\t\"color\": {\n\t\t\tcoords: [\"<number> | <percentage>\", \"<number> | <percentage>[-1,1]\", \"<number> | <percentage>[-1,1]\"],\n\t\t},\n\t},\n});\n","import ColorSpace from \"../space.js\";\nimport Jzazbz from \"./jzazbz.js\";\nimport {constrain as constrainAngle} from \"../angles.js\";\n\nexport default new ColorSpace({\n\tid: \"jzczhz\",\n\tname: \"JzCzHz\",\n\tcoords: {\n\t\tjz: {\n\t\t\trefRange: [0, 1],\n\t\t\tname: \"Jz\",\n\t\t},\n\t\tcz: {\n\t\t\trefRange: [0, 1],\n\t\t\tname: \"Chroma\",\n\t\t},\n\t\thz: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t},\n\n\tbase: Jzazbz,\n\tfromBase (jzazbz) {\n\t\t// Convert to polar form\n\t\tlet [Jz, az, bz] = jzazbz;\n\t\tlet hue;\n\t\tconst  = 0.0002; // chromatic components much smaller than a,b\n\n\t\tif (Math.abs(az) <  && Math.abs(bz) < ) {\n\t\t\thue = NaN;\n\t\t}\n\t\telse {\n\t\t\thue = Math.atan2(bz, az) * 180 / Math.PI;\n\t\t}\n\n\t\treturn [\n\t\t\tJz, // Jz is still Jz\n\t\t\tMath.sqrt(az ** 2 + bz ** 2), // Chroma\n\t\t\tconstrainAngle(hue), // Hue, in degrees [0 to 360)\n\t\t];\n\t},\n\ttoBase (jzczhz) {\n\t\t// Convert from polar form\n\t\t// debugger;\n\t\treturn [\n\t\t\tjzczhz[0], // Jz is still Jz\n\t\t\tjzczhz[1] * Math.cos(jzczhz[2] * Math.PI / 180), // az\n\t\t\tjzczhz[1] * Math.sin(jzczhz[2] * Math.PI / 180),  // bz\n\t\t];\n\t},\n});\n","import jzczhz from \"../spaces/jzczhz.js\";\nimport getColor from \"../getColor.js\";\n\n// More accurate color-difference formulae\n// than the simple 1976 Euclidean distance in Lab\n\n// Uses JzCzHz, which has improved perceptual uniformity\n// and thus a simple Euclidean root-sum of L C H\n// gives good results.\n\nexport default function (color, sample) {\n\t[color, sample] = getColor([color, sample]);\n\n\t// Given this color as the reference\n\t// and a sample,\n\t// calculate deltaE in JzCzHz.\n\tlet [Jz1, Cz1, Hz1] = jzczhz.from(color);\n\tlet [Jz2, Cz2, Hz2] = jzczhz.from(sample);\n\n\t// Lightness and Chroma differences\n\t// sign does not matter as they are squared.\n\tlet J = Jz1 - Jz2;\n\tlet C = Cz1 - Cz2;\n\n\t// length of chord for H\n\tif ((Number.isNaN(Hz1)) && (Number.isNaN(Hz2))) {\n\t\t// both undefined hues\n\t\tHz1 = 0;\n\t\tHz2 = 0;\n\t}\n\telse if (Number.isNaN(Hz1)) {\n\t\t// one undefined, set to the defined hue\n\t\tHz1 = Hz2;\n\t}\n\telse if (Number.isNaN(Hz2)) {\n\t\tHz2 = Hz1;\n\t}\n\n\tlet h = Hz1 - Hz2;\n\tlet H = 2 * Math.sqrt(Cz1 * Cz2) * Math.sin((h / 2) * (Math.PI / 180));\n\n\treturn Math.sqrt(J ** 2 + C ** 2 + H ** 2);\n}\n","import ColorSpace from \"../space.js\";\nimport {multiplyMatrices} from \"../util.js\";\nimport XYZ_Abs_D65 from \"./xyz-abs-d65.js\";\n\nconst c1 = 3424 / 4096;\nconst c2 = 2413 / 128;\nconst c3 = 2392 / 128;\nconst m1 = 2610 / 16384;\nconst m2 = 2523 / 32;\nconst im1 = 16384 / 2610;\nconst im2 = 32 / 2523;\n\n// The matrix below includes the 4% crosstalk components\n// and is from the Dolby \"What is ICtCp\" paper\"\nconst XYZtoLMS_M = [\n\t[  0.3592832590121217,  0.6976051147779502, -0.0358915932320290 ],\n\t[ -0.1920808463704993,  1.1004767970374321,  0.0753748658519118 ],\n\t[  0.0070797844607479,  0.0748396662186362,  0.8433265453898765 ],\n];\n// linear-light Rec.2020 to LMS, again with crosstalk\n// rational terms from Jan Frhlich,\n// Encoding High Dynamic Range andWide Color Gamut Imagery, p.97\n// and ITU-R BT.2124-0 p.2\n/*\nconst Rec2020toLMS_M = [\n\t[ 1688 / 4096,  2146 / 4096,   262 / 4096 ],\n\t[  683 / 4096,  2951 / 4096,   462 / 4096 ],\n\t[   99 / 4096,   309 / 4096,  3688 / 4096 ]\n];\n*/\n// this includes the Ebner LMS coefficients,\n// the rotation, and the scaling to [-0.5,0.5] range\n// rational terms from Frhlich p.97\n// and ITU-R BT.2124-0 pp.2-3\nconst LMStoIPT_M = [\n\t[  2048 / 4096,   2048 / 4096,       0      ],\n\t[  6610 / 4096, -13613 / 4096,  7003 / 4096 ],\n\t[ 17933 / 4096, -17390 / 4096,  -543 / 4096 ],\n];\n\n// inverted matrices, calculated from the above\nconst IPTtoLMS_M = [\n\t[ 0.9999999999999998,  0.0086090370379328,  0.1110296250030260 ],\n\t[ 0.9999999999999998, -0.0086090370379328, -0.1110296250030259 ],\n\t[ 0.9999999999999998,  0.5600313357106791, -0.3206271749873188 ],\n];\n/*\nconst LMStoRec2020_M = [\n\t[ 3.4375568932814012112,   -2.5072112125095058195,   0.069654319228104608382],\n\t[-0.79142868665644156125,   1.9838372198740089874,  -0.19240853321756742626 ],\n\t[-0.025646662911506476363, -0.099240248643945566751, 1.1248869115554520431  ]\n];\n*/\nconst LMStoXYZ_M = [\n\t[  2.0701522183894223, -1.3263473389671563,  0.2066510476294053 ],\n\t[  0.3647385209748072,  0.6805660249472273, -0.0453045459220347 ],\n\t[ -0.0497472075358123, -0.0492609666966131,  1.1880659249923042 ],\n];\n\n// Only the PQ form of ICtCp is implemented here. There is also an HLG form.\n// from Dolby, \"WHAT IS ICTCP?\"\n// https://professional.dolby.com/siteassets/pdfs/ictcp_dolbywhitepaper_v071.pdf\n// and\n// Dolby, \"Perceptual Color Volume\n// Measuring the Distinguishable Colors of HDR and WCG Displays\"\n// https://professional.dolby.com/siteassets/pdfs/dolby-vision-measuring-perceptual-color-volume-v7.1.pdf\nexport default new ColorSpace({\n\tid: \"ictcp\",\n\tname: \"ICTCP\",\n\t// From BT.2100-2 page 7:\n\t// During production, signal values are expected to exceed the\n\t// range E = [0.0 : 1.0]. This provides processing headroom and avoids\n\t// signal degradation during cascaded processing. Such values of E,\n\t// below 0.0 or exceeding 1.0, should not be clipped during production\n\t// and exchange.\n\t// Values below 0.0 should not be clipped in reference displays (even\n\t// though they represent negative light) to allow the black level of\n\t// the signal (LB) to be properly set using test signals known as PLUGE\n\tcoords: {\n\t\ti: {\n\t\t\trefRange: [0, 1],\t// Constant luminance,\n\t\t\tname: \"I\",\n\t\t},\n\t\tct: {\n\t\t\trefRange: [-0.5, 0.5],\t// Full BT.2020 gamut in range [-0.5, 0.5]\n\t\t\tname: \"CT\",\n\t\t},\n\t\tcp: {\n\t\t\trefRange: [-0.5, 0.5],\n\t\t\tname: \"CP\",\n\t\t},\n\t},\n\n\tbase: XYZ_Abs_D65,\n\tfromBase (XYZ) {\n\t\t// move to LMS cone domain\n\t\tlet LMS = multiplyMatrices(XYZtoLMS_M, XYZ);\n\n\t\treturn LMStoICtCp(LMS);\n\t},\n\ttoBase (ICtCp) {\n\t\tlet LMS = ICtCptoLMS(ICtCp);\n\n\t\treturn multiplyMatrices(LMStoXYZ_M, LMS);\n\t},\n});\n\nfunction LMStoICtCp (LMS) {\n\t// apply the PQ EOTF\n\t// we can't ever be dividing by zero because of the \"1 +\" in the denominator\n\tlet PQLMS = LMS.map (function (val) {\n\t\tlet num = c1 + (c2 * ((val / 10000) ** m1));\n\t\tlet denom = 1 + (c3 * ((val / 10000) ** m1));\n\n\t\treturn (num / denom)  ** m2;\n\t});\n\n\t// LMS to IPT, with rotation for Y'C'bC'r compatibility\n\treturn multiplyMatrices(LMStoIPT_M, PQLMS);\n}\n\nfunction ICtCptoLMS (ICtCp) {\n\tlet PQLMS = multiplyMatrices(IPTtoLMS_M, ICtCp);\n\n\t// From BT.2124-0 Annex 2 Conversion 3\n\tlet LMS = PQLMS.map (function (val) {\n\t\tlet num  = Math.max((val ** im2) - c1, 0);\n\t\tlet denom = (c2 - (c3 * (val ** im2)));\n\t\treturn 10000 * ((num / denom) ** im1);\n\t});\n\n\treturn LMS;\n}\n","import ictcp from \"../spaces/ictcp.js\";\nimport getColor from \"../getColor.js\";\n\n// Delta E in ICtCp space,\n// which the ITU calls Delta E ITP, which is shorter\n// formulae from ITU Rec. ITU-R BT.2124-0\n\nexport default function (color, sample) {\n\t[color, sample] = getColor([color, sample]);\n\n\t// Given this color as the reference\n\t// and a sample,\n\t// calculate deltaE in ICtCp\n\t// which is simply the Euclidean distance\n\n\tlet [ I1, T1, P1 ] = ictcp.from(color);\n\tlet [ I2, T2, P2 ] = ictcp.from(sample);\n\n\t// the 0.25 factor is to undo the encoding scaling in Ct\n\t// the 720 is so that 1 deltaE = 1 JND\n\t// per  ITU-R BT.2124-0 p.3\n\n\treturn 720 * Math.sqrt((I1 - I2) ** 2 + (0.25 * (T1 - T2) ** 2) + (P1 - P2) ** 2);\n}\n","import ColorSpace from \"../space.js\";\nimport {multiplyMatrices, interpolate, copySign, spow, zdiv, bisectLeft} from \"../util.js\";\nimport {constrain} from \"../angles.js\";\nimport xyz_d65 from \"./xyz-d65.js\";\nimport {WHITES} from \"../adapt.js\";\n\nconst white = WHITES.D65;\nconst adaptedCoef = 0.42;\nconst adaptedCoefInv = 1 / adaptedCoef;\nconst tau = 2 * Math.PI;\n\nconst cat16 = [\n\t[  0.401288,  0.650173, -0.051461 ],\n\t[ -0.250268,  1.204414,  0.045854 ],\n\t[ -0.002079,  0.048952,  0.953127 ],\n];\n\nconst cat16Inv = [\n\t[1.8620678550872327, -1.0112546305316843, 0.14918677544445175],\n\t[0.38752654323613717, 0.6214474419314753, -0.008973985167612518],\n\t[-0.015841498849333856, -0.03412293802851557, 1.0499644368778496],\n];\n\nconst m1 = [\n\t[460.0, 451.0, 288.0],\n\t[460.0, -891.0, -261.0],\n\t[460.0, -220.0, -6300.0],\n];\n\nconst surroundMap = {\n\tdark: [0.8, 0.525, 0.8],\n\tdim: [0.9, 0.59, 0.9],\n\taverage: [1, 0.69, 1],\n};\n\nconst hueQuadMap = {\n\t// Red, Yellow, Green, Blue, Red\n\th: [20.14, 90.00, 164.25, 237.53, 380.14],\n\te: [0.8, 0.7, 1.0, 1.2, 0.8],\n\tH: [0.0, 100.0, 200.0, 300.0, 400.0],\n};\n\nconst rad2deg = 180 / Math.PI;\nconst deg2rad = Math.PI / 180;\n\nexport function adapt (coords, fl) {\n\tconst temp = coords.map(c => {\n\t\tconst x = spow(fl * Math.abs(c) * 0.01, adaptedCoef);\n\t\treturn 400 * copySign(x, c) / (x + 27.13);\n\t});\n\treturn temp;\n}\n\nexport function unadapt (adapted, fl) {\n\tconst constant = 100 / fl * (27.13 ** adaptedCoefInv);\n\treturn adapted.map(c => {\n\t\tconst cabs = Math.abs(c);\n\t\treturn copySign(constant * spow(cabs / (400 - cabs), adaptedCoefInv), c);\n\t});\n}\n\nexport function hueQuadrature (h) {\n\tlet hp = constrain(h);\n\tif (hp <= hueQuadMap.h[0]) {\n\t\thp += 360;\n\t}\n\n\tconst i = bisectLeft(hueQuadMap.h, hp) - 1;\n\tconst [hi, hii] = hueQuadMap.h.slice(i, i + 2);\n\tconst [ei, eii] = hueQuadMap.e.slice(i, i + 2);\n\tconst Hi = hueQuadMap.H[i];\n\n\tconst t = (hp - hi) / ei;\n\treturn Hi + (100 * t) / (t + (hii - hp) / eii);\n}\n\nexport function invHueQuadrature (H) {\n\tlet Hp = ((H % 400 + 400) % 400);\n\tconst i = Math.floor(0.01 * Hp);\n\tHp = Hp % 100;\n\tconst [hi, hii] = hueQuadMap.h.slice(i, i + 2);\n\tconst [ei, eii] = hueQuadMap.e.slice(i, i + 2);\n\n\treturn constrain(\n\t\t(Hp * (eii * hi - ei * hii) - 100 * hi * eii) /\n\t\t(Hp * (eii - ei) - 100 * eii),\n\t);\n}\n\nexport function environment (\n\trefWhite,\n\tadaptingLuminance,\n\tbackgroundLuminance,\n\tsurround,\n\tdiscounting,\n) {\n\n\tconst env = {};\n\n\tenv.discounting = discounting;\n\tenv.refWhite = refWhite;\n\tenv.surround = surround;\n\tconst xyzW = refWhite.map(c => {\n\t\treturn c * 100;\n\t});\n\n\t// The average luminance of the environment in `cd/m^2cd/m` (a.k.a. nits)\n\tenv.la = adaptingLuminance;\n\t// The relative luminance of the nearby background\n\tenv.yb = backgroundLuminance;\n\t// Absolute luminance of the reference white.\n\tconst yw = xyzW[1];\n\n\t// Cone response for reference white\n\tconst rgbW = multiplyMatrices(cat16, xyzW);\n\n\t// Surround: dark, dim, and average\n\tsurround = surroundMap[env.surround];\n\tconst f = surround[0];\n\tenv.c = surround[1];\n\tenv.nc = surround[2];\n\n\tconst k = 1 / (5 * env.la + 1);\n\tconst k4 = k ** 4;\n\n\t// Factor of luminance level adaptation\n\tenv.fl = (k4 * env.la + 0.1 * (1 - k4) * (1 - k4) * Math.cbrt(5 * env.la));\n\tenv.flRoot = env.fl ** 0.25;\n\n\tenv.n = env.yb / yw;\n\tenv.z = 1.48 + Math.sqrt(env.n);\n\tenv.nbb = 0.725 * (env.n ** -0.2);\n\tenv.ncb = env.nbb;\n\n\t// Degree of adaptation calculating if not discounting\n\t// illuminant (assumed eye is fully adapted)\n\tconst d = (discounting) ?\n\t\t1 :\n\t\tMath.max(\n\t\t\tMath.min(f * (1 - 1 / 3.6 * Math.exp((-env.la - 42) / 92)), 1),\n\t\t\t0,\n\t\t);\n\tenv.dRgb = rgbW.map(c => {\n\t\treturn interpolate(1, yw / c, d);\n\t});\n\tenv.dRgbInv = env.dRgb.map(c => {\n\t\treturn 1 / c;\n\t});\n\n\t// Achromatic response\n\tconst rgbCW = rgbW.map((c, i) => {\n\t\treturn c * env.dRgb[i];\n\t});\n\tconst rgbAW = adapt(rgbCW, env.fl);\n\tenv.aW = env.nbb * (2 * rgbAW[0] + rgbAW[1] + 0.05 * rgbAW[2]);\n\n\t// console.log(env);\n\n\treturn env;\n}\n\n// Pre-calculate everything we can with the viewing conditions\nconst viewingConditions = environment(\n\twhite,\n\t64 / Math.PI * 0.2, 20,\n\t\"average\",\n\tfalse,\n);\n\nexport function fromCam16 (cam16, env) {\n\n\t// These check ensure one, and only one attribute for a\n\t// given category is provided.\n\tif (!((cam16.J !== undefined) ^ (cam16.Q !== undefined))) {\n\t\tthrow new Error(\"Conversion requires one and only one: 'J' or 'Q'\");\n\t}\n\n\tif (!((cam16.C !== undefined) ^ (cam16.M !== undefined) ^ (cam16.s !== undefined))) {\n\t\tthrow new Error(\"Conversion requires one and only one: 'C', 'M' or 's'\");\n\t}\n\n\t// Hue is absolutely required\n\tif (!((cam16.h !== undefined) ^ (cam16.H !== undefined))) {\n\t\tthrow new Error(\"Conversion requires one and only one: 'h' or 'H'\");\n\t}\n\n\t// Black\n\tif (cam16.J === 0.0 || cam16.Q === 0.0) {\n\t\treturn [0.0, 0.0, 0.0];\n\t}\n\n\t// Break hue into Cartesian components\n\tlet hRad = 0.0;\n\tif (cam16.h !== undefined) {\n\t\thRad = constrain(cam16.h) * deg2rad;\n\t}\n\telse {\n\t\thRad = invHueQuadrature(cam16.H) * deg2rad;\n\t}\n\n\tconst cosh = Math.cos(hRad);\n\tconst sinh = Math.sin(hRad);\n\n\t// Calculate `Jroot` from one of the lightness derived coordinates.\n\tlet Jroot = 0.0;\n\tif (cam16.J !== undefined) {\n\t\tJroot = spow(cam16.J, 1 / 2) * 0.1;\n\t}\n\telse if (cam16.Q !== undefined) {\n\t\tJroot = 0.25 * env.c * cam16.Q / ((env.aW + 4) * env.flRoot);\n\t}\n\n\t// Calculate the `t` value from one of the chroma derived coordinates\n\tlet alpha = 0.0;\n\tif (cam16.C !== undefined) {\n\t\talpha = cam16.C / Jroot;\n\t}\n\telse if (cam16.M !== undefined) {\n\t\talpha = (cam16.M / env.flRoot) / Jroot;\n\t}\n\telse if (cam16.s !== undefined) {\n\t\talpha = 0.0004 * (cam16.s ** 2) * (env.aW + 4) / env.c;\n\t}\n\tconst t = spow(\n\t\talpha * Math.pow(1.64 - Math.pow(0.29, env.n), -0.73),\n\t\t10 / 9,\n\t);\n\n\t// Eccentricity\n\tconst et = 0.25 * (Math.cos(hRad + 2) + 3.8);\n\n\t// Achromatic response\n\tconst A = env.aW * spow(Jroot, 2 / env.c / env.z);\n\n\t// Calculate red-green and yellow-blue components\n\tconst p1 = 5e4 / 13 * env.nc * env.ncb * et;\n\tconst p2 = A / env.nbb;\n\tconst r = (\n\t\t23 * (p2 + 0.305) *\n\t\tzdiv(t, 23 * p1 + t * (11 * cosh + 108 * sinh))\n\t);\n\tconst a = r * cosh;\n\tconst b = r * sinh;\n\n\t// Calculate back from cone response to XYZ\n\tconst rgb_c = unadapt(\n\t\tmultiplyMatrices(m1, [p2, a, b]).map(c => {\n\t\t\treturn c * 1 / 1403;\n\t\t}),\n\t\tenv.fl,\n\t);\n\treturn multiplyMatrices(\n\t\tcat16Inv,\n\t\trgb_c.map((c, i) => {\n\t\t\treturn c * env.dRgbInv[i];\n\t\t}),\n\t).map(c => {\n\t\treturn c / 100;\n\t});\n}\n\n\nexport function toCam16 (xyzd65, env) {\n\t// Cone response\n\tconst xyz100 = xyzd65.map(c => {\n\t\treturn c * 100;\n\t});\n\tconst rgbA = adapt(\n\t\tmultiplyMatrices(cat16, xyz100).map((c, i) => {\n\t\t\treturn c * env.dRgb[i];\n\t\t}),\n\t\tenv.fl,\n\t);\n\n\t// Calculate hue from red-green and yellow-blue components\n\tconst a = rgbA[0] + (-12 * rgbA[1] + rgbA[2]) / 11;\n\tconst b = (rgbA[0] + rgbA[1] - 2 * rgbA[2]) / 9;\n\tconst hRad = ((Math.atan2(b, a) % tau) + tau) % tau;\n\n\t// Eccentricity\n\tconst et = 0.25 * (Math.cos(hRad + 2) + 3.8);\n\n\tconst t = (\n\t\t5e4 / 13 * env.nc * env.ncb *\n\t\tzdiv(\n\t\t\tet * Math.sqrt(a ** 2 + b ** 2),\n\t\t\trgbA[0] + rgbA[1] + 1.05 * rgbA[2] + 0.305,\n\t\t)\n\t);\n\tconst alpha = spow(t, 0.9) * Math.pow(1.64 - Math.pow(0.29, env.n), 0.73);\n\n\t// Achromatic response\n\tconst A = env.nbb * (2 * rgbA[0] + rgbA[1] + 0.05 * rgbA[2]);\n\n\tconst Jroot = spow(A / env.aW, 0.5 * env.c * env.z);\n\n\t// Lightness\n\tconst J = 100 * spow(Jroot, 2);\n\n\t// Brightness\n\tconst Q = (4 / env.c * Jroot * (env.aW + 4) * env.flRoot);\n\n\t// Chroma\n\tconst C = alpha * Jroot;\n\n\t// Colorfulness\n\tconst M = C * env.flRoot;\n\n\t// Hue\n\tconst h = constrain(hRad * rad2deg);\n\n\t// Hue quadrature\n\tconst H = hueQuadrature(h);\n\n\t// Saturation\n\tconst s = 50 * spow(env.c * alpha / (env.aW + 4), 1 / 2);\n\n\t// console.log({J: J, C: C, h: h, s: s, Q: Q, M: M, H: H});\n\n\treturn {J: J, C: C, h: h, s: s, Q: Q, M: M, H: H};\n}\n\n\n// Provided as a way to directly evaluate the CAM16 model\n// https://observablehq.com/@jrus/cam16: reference implementation\n// https://arxiv.org/pdf/1802.06067.pdf: Nico Schlmer\n// https://onlinelibrary.wiley.com/doi/pdf/10.1002/col.22324: hue quadrature\n// https://www.researchgate.net/publication/318152296_Comprehensive_color_solutions_CAM16_CAT16_and_CAM16-UCS\n// Results compared against: https://github.com/colour-science/colour\nexport default new ColorSpace({\n\tid: \"cam16-jmh\",\n\tcssId: \"--cam16-jmh\",\n\tname: \"CAM16-JMh\",\n\tcoords: {\n\t\tj: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"J\",\n\t\t},\n\t\tm: {\n\t\t\trefRange: [0, 105.0],\n\t\t\tname: \"Colorfulness\",\n\t\t},\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t},\n\n\tbase: xyz_d65,\n\n\tfromBase (xyz) {\n\t\tconst cam16 = toCam16(xyz, viewingConditions);\n\t\treturn [cam16.J, cam16.M, cam16.h];\n\t},\n\ttoBase (cam16) {\n\t\treturn fromCam16(\n\t\t\t{J: cam16[0], M: cam16[1], h: cam16[2]},\n\t\t\tviewingConditions,\n\t\t);\n\t},\n});\n","import ColorSpace from \"../space.js\";\nimport {constrain} from \"../angles.js\";\nimport xyz_d65 from \"./xyz-d65.js\";\nimport {fromCam16, toCam16, environment} from \"./cam16.js\";\nimport {WHITES} from \"../adapt.js\";\n\nconst white = WHITES.D65;\nconst  = 216 / 24389;  // 6^3/29^3 == (24/116)^3\nconst  = 24389 / 27;   // 29^3/3^3\n\nfunction toLstar (y) {\n\t// Convert XYZ Y to L*\n\n\tconst fy = (y > ) ? Math.cbrt(y) : ( * y + 16) / 116;\n\treturn (116.0 * fy) - 16.0;\n}\n\nfunction fromLstar (lstar) {\n\t// Convert L* back to XYZ Y\n\n\treturn (lstar > 8) ?  Math.pow((lstar + 16) / 116, 3) : lstar / ;\n}\n\nfunction fromHct (coords, env) {\n\t// Use Newton's method to try and converge as quick as possible or\n\t// converge as close as we can. While the requested precision is achieved\n\t// most of the time, it may not always be achievable. Especially past the\n\t// visible spectrum, the algorithm will likely struggle to get the same\n\t// precision. If, for whatever reason, we cannot achieve the accuracy we\n\t// seek in the allotted iterations, just return the closest we were able to\n\t// get.\n\n\tlet [h, c, t] = coords;\n\tlet xyz = [];\n\tlet j = 0;\n\n\t// Shortcut out for black\n\tif (t === 0) {\n\t\treturn [0.0, 0.0, 0.0];\n\t}\n\n\t// Calculate the Y we need to target\n\tlet y = fromLstar(t);\n\n\t// A better initial guess yields better results. Polynomials come from\n\t// curve fitting the T vs J response.\n\tif (t > 0) {\n\t\tj = 0.00379058511492914 * t ** 2 + 0.608983189401032 * t + 0.9155088574762233;\n\t}\n\telse {\n\t\tj = 9.514440756550361e-06 * t ** 2 + 0.08693057439788597 * t - 21.928975842194614;\n\t}\n\n\t// Threshold of how close is close enough, and max number of attempts.\n\t// More precision and more attempts means more time spent iterating. Higher\n\t// required precision gives more accuracy but also increases the chance of\n\t// not hitting the goal. 2e-12 allows us to convert round trip with\n\t// reasonable accuracy of six decimal places or more.\n\tconst threshold = 2e-12;\n\tconst max_attempts = 15;\n\n\tlet attempt = 0;\n\tlet last = Infinity;\n\tlet best = j;\n\n\t// Try to find a J such that the returned y matches the returned y of the L*\n\twhile (attempt <= max_attempts) {\n\t\txyz = fromCam16({J: j, C: c, h: h}, env);\n\n\t\t// If we are within range, return XYZ\n\t\t// If we are closer than last time, save the values\n\t\tconst delta = Math.abs(xyz[1] - y);\n\t\tif (delta < last) {\n\t\t\tif (delta <= threshold) {\n\t\t\t\treturn xyz;\n\t\t\t}\n\t\t\tbest = j;\n\t\t\tlast = delta;\n\t\t}\n\n\t\t// f(j_root) = (j ** (1 / 2)) * 0.1\n\t\t// f(j) = ((f(j_root) * 100) ** 2) / j - 1 = 0\n\t\t// f(j_root) = Y = y / 100\n\t\t// f(j) = (y ** 2) / j - 1\n\t\t// f'(j) = (2 * y) / j\n\t\tj = j - (xyz[1] - y) * j / (2 * xyz[1]);\n\n\t\tattempt += 1;\n\t}\n\n\t// We could not acquire the precision we desired,\n\t// return our closest attempt.\n\treturn fromCam16({J: j, C: c, h: h}, env);\n}\n\nfunction toHct (xyz, env) {\n\t// Calculate HCT by taking the L* of CIE LCh D65 and CAM16 chroma and hue.\n\n\tconst t = toLstar(xyz[1]);\n\tif (t === 0.0) {\n\t\treturn [0.0, 0.0, 0.0];\n\t}\n\tconst cam16 = toCam16(xyz, viewingConditions);\n\treturn [constrain(cam16.h), cam16.C, t];\n}\n\n// Pre-calculate everything we can with the viewing conditions\nexport const viewingConditions = environment(\n\twhite, 200 / Math.PI * fromLstar(50.0),\n\tfromLstar(50.0) * 100,\n\t\"average\",\n\tfalse,\n);\n\n// https://material.io/blog/science-of-color-design\n// This is not a port of the material-color-utilities,\n// but instead implements the full color space as described,\n// combining CAM16 JCh and Lab D65. This does not clamp conversion\n// to HCT to specific chroma bands and provides support for wider\n// gamuts than Google currently supports and does so at a greater\n// precision (> 8 bits back to sRGB).\n// This implementation comes from https://github.com/facelessuser/coloraide\n// which is licensed under MIT.\nexport default new ColorSpace({\n\tid: \"hct\",\n\tname: \"HCT\",\n\tcoords: {\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t\tc: {\n\t\t\trefRange: [0, 145],\n\t\t\tname: \"Colorfulness\",\n\t\t},\n\t\tt: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"Tone\",\n\t\t},\n\t},\n\n\tbase: xyz_d65,\n\n\tfromBase (xyz) {\n\t\treturn toHct(xyz, viewingConditions);\n\t},\n\ttoBase (hct) {\n\t\treturn fromHct(hct, viewingConditions);\n\t},\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"--hct\",\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage> | <number>\", \"<percentage> | <number>\"],\n\t\t},\n\t},\n});\n","import hct from \"../spaces/hct.js\";\nimport {viewingConditions} from \"../spaces/hct.js\";\nimport getColor from \"../getColor.js\";\n\nconst rad2deg = 180 / Math.PI;\nconst deg2rad = Math.PI / 180;\nconst ucsCoeff = [1.00, 0.007, 0.0228];\n\n/**\n* Convert HCT chroma and hue (CAM16 JMh colorfulness and hue) using UCS logic for a and b.\n* @param {number[]} coords - HCT coordinates.\n* @return {number[]}\n*/\nfunction convertUcsAb (coords) {\n\t// We want the distance between the actual color.\n\t// If chroma is negative, it will throw off our calculations.\n\t// Normally, converting back to the base and forward will correct it.\n\t// If we have a negative chroma after this, then we have a color that\n\t// cannot resolve to positive chroma.\n\tif (coords[1] < 0) {\n\t\tcoords = hct.fromBase(hct.toBase(coords));\n\t}\n\n\t// Only in extreme cases (usually outside the visible spectrum)\n\t// can the input value for log become negative.\n\t// Avoid domain error by forcing a zero result via \"max\" if necessary.\n\tconst M = Math.log(Math.max(1 + ucsCoeff[2] * coords[1] * viewingConditions.flRoot, 1.0)) / ucsCoeff[2];\n\tconst hrad = coords[0] * deg2rad;\n\tconst a = M * Math.cos(hrad);\n\tconst b = M * Math.sin(hrad);\n\n\treturn [coords[2], a, b];\n}\n\n\n/**\n* Color distance using HCT.\n* @param {Color} color - Color to compare.\n* @param {Color} sample - Color to compare.\n* @return {number[]}\n*/\nexport default function (color, sample) {\n\t[color, sample] = getColor([color, sample]);\n\n\tlet [ t1, a1, b1 ] = convertUcsAb(hct.from(color));\n\tlet [ t2, a2, b2 ] = convertUcsAb(hct.from(sample));\n\n\t// Use simple euclidean distance with a and b using UCS conversion\n\t// and LCh lightness (HCT tone).\n\treturn Math.sqrt((t1 - t2) ** 2 + (a1 - a2) ** 2 + (b1 - b2) ** 2);\n}\n","import deltaE76 from \"./deltaE76.js\";\nimport deltaECMC from \"./deltaECMC.js\";\nimport deltaE2000 from \"./deltaE2000.js\";\nimport deltaEJz from \"./deltaEJz.js\";\nimport deltaEITP from \"./deltaEITP.js\";\nimport deltaEOK from \"./deltaEOK.js\";\nimport deltaEHCT from \"./deltaEHCT.js\";\n\nexport {\n\tdeltaE76,\n\tdeltaECMC,\n\tdeltaE2000,\n\tdeltaEJz,\n\tdeltaEITP,\n\tdeltaEOK,\n\tdeltaEHCT,\n};\n\nexport default {\n\tdeltaE76,\n\tdeltaECMC,\n\tdeltaE2000,\n\tdeltaEJz,\n\tdeltaEITP,\n\tdeltaEOK,\n\tdeltaEHCT,\n};\n","import * as util from \"./util.js\";\nimport ColorSpace from \"./space.js\";\nimport defaults from \"./defaults.js\";\nimport deltaE2000 from \"./deltaE/deltaE2000.js\";\nimport deltaEOK from \"./deltaE/deltaEOK.js\";\nimport inGamut from \"./inGamut.js\";\nimport to from \"./to.js\";\nimport get from \"./get.js\";\nimport oklab from \"./spaces/oklab.js\";\nimport set from \"./set.js\";\nimport clone from \"./clone.js\";\nimport getColor from \"./getColor.js\";\nimport deltaEMethods from \"./deltaE/index.js\";\nimport {WHITES} from \"./adapt.js\";\n\n/**\n * Calculate the epsilon to 2 degrees smaller than the specified JND.\n * @param {Number} jnd - The target \"just noticeable difference\".\n * @returns {Number}\n */\nfunction calcEpsilon (jnd) {\n\t// Calculate the epsilon to 2 degrees smaller than the specified JND.\n\n\tconst order = (!jnd) ? 0 : Math.floor(Math.log10(Math.abs(jnd)));\n\t// Limit to an arbitrary value to ensure value is never too small and causes infinite loops.\n\treturn Math.max(parseFloat(`1e${order - 2}`), 1e-6);\n}\n\nconst GMAPPRESET = {\n\t\"hct\": {\n\t\tmethod: \"hct.c\",\n\t\tjnd: 2,\n\t\tdeltaEMethod: \"hct\",\n\t\tblackWhiteClamp: {},\n\t},\n\t\"hct-tonal\": {\n\t\tmethod: \"hct.c\",\n\t\tjnd: 0,\n\t\tdeltaEMethod: \"hct\",\n\t\tblackWhiteClamp: { channel: \"hct.t\", min: 0, max: 100 },\n\t},\n};\n\n/**\n * Force coordinates to be in gamut of a certain color space.\n * Mutates the color it is passed.\n * @param {Object|string} options object or spaceId string\n * @param {string} options.method - How to force into gamut.\n *        If \"clip\", coordinates are just clipped to their reference range.\n *        If \"css\", coordinates are reduced according to the CSS 4 Gamut Mapping Algorithm.\n *        If in the form [colorSpaceId].[coordName], that coordinate is reduced\n *        until the color is in gamut. Please note that this may produce nonsensical\n *        results for certain coordinates (e.g. hue) or infinite loops if reducing the coordinate never brings the color in gamut.\n * @param {ColorSpace|string} options.space - The space whose gamut we want to map to\n * @param {string} options.deltaEMethod - The delta E method to use while performing gamut mapping.\n *        If no method is specified, delta E 2000 is used.\n * @param {Number} options.jnd - The \"just noticeable difference\" to target.\n * @param {Object} options.blackWhiteClamp - Used to configure SDR black and clamping.\n *        \"channel\" indicates the \"space.channel\" to use for determining when to clamp.\n *        \"min\" indicates the lower limit for black clamping and \"max\" indicates the upper\n *        limit for white clamping.\n */\n\nexport default function toGamut (\n\tcolor,\n\t{\n\t\tmethod = defaults.gamut_mapping,\n\t\tspace = undefined,\n\t\tdeltaEMethod = \"\",\n\t\tjnd = 2,\n\t\tblackWhiteClamp = {},\n\t} = {},\n) {\n\tcolor = getColor(color);\n\n\tif (util.isString(arguments[1])) {\n\t\tspace = arguments[1];\n\t}\n\telse if (!space) {\n\t\tspace = color.space;\n\t}\n\n\tspace = ColorSpace.get(space);\n\n\t// 3 spaces:\n\t// color.space: current color space\n\t// space: space whose gamut we are mapping to\n\t// mapSpace: space with the coord we're reducing\n\n\tif (inGamut(color, space, { epsilon: 0 })) {\n\t\treturn color;\n\t}\n\n\tlet spaceColor;\n\tif (method === \"css\") {\n\t\tspaceColor = toGamutCSS(color, { space });\n\t}\n\telse {\n\t\tif (method !== \"clip\" && !inGamut(color, space)) {\n\n\t\t\tif (Object.prototype.hasOwnProperty.call(GMAPPRESET, method)) {\n\t\t\t\t({method, jnd, deltaEMethod, blackWhiteClamp} = GMAPPRESET[method]);\n\t\t\t}\n\n\t\t\t// Get the correct delta E method\n\t\t\tlet de = deltaE2000;\n\t\t\tif (deltaEMethod !== \"\") {\n\t\t\t\tfor (let m in deltaEMethods) {\n\t\t\t\t\tif (\"deltae\" + deltaEMethod.toLowerCase() === m.toLowerCase()) {\n\t\t\t\t\t\tde = deltaEMethods[m];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlet clipped = toGamut(to(color, space), { method: \"clip\", space });\n\t\t\tif (de(color, clipped) > jnd) {\n\n\t\t\t\t// Clamp to SDR white and black if required\n\t\t\t\tif (Object.keys(blackWhiteClamp).length === 3) {\n\t\t\t\t\tlet channelMeta = ColorSpace.resolveCoord(blackWhiteClamp.channel);\n\t\t\t\t\tlet channel = get(to(color, channelMeta.space), channelMeta.id);\n\t\t\t\t\tif (util.isNone(channel)) {\n\t\t\t\t\t\tchannel = 0;\n\t\t\t\t\t}\n\t\t\t\t\tif (channel >= blackWhiteClamp.max) {\n\t\t\t\t\t\treturn to({ space: \"xyz-d65\", coords: WHITES[\"D65\"] }, color.space);\n\t\t\t\t\t}\n\t\t\t\t\telse if (channel <= blackWhiteClamp.min) {\n\t\t\t\t\t\treturn to({ space: \"xyz-d65\", coords: [0, 0, 0] }, color.space);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// Reduce a coordinate of a certain color space until the color is in gamut\n\t\t\t\tlet coordMeta = ColorSpace.resolveCoord(method);\n\t\t\t\tlet mapSpace = coordMeta.space;\n\t\t\t\tlet coordId = coordMeta.id;\n\n\t\t\t\tlet mappedColor = to(color, mapSpace);\n\t\t\t\t// If we were already in the mapped color space, we need to resolve undefined channels\n\t\t\t\tmappedColor.coords.forEach((c, i) => {\n\t\t\t\t\tif (util.isNone(c)) {\n\t\t\t\t\t\tmappedColor.coords[i] = 0;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tlet bounds = coordMeta.range || coordMeta.refRange;\n\t\t\t\tlet min = bounds[0];\n\t\t\t\tlet  = calcEpsilon(jnd);\n\t\t\t\tlet low = min;\n\t\t\t\tlet high = get(mappedColor, coordId);\n\n\t\t\t\twhile (high - low > ) {\n\t\t\t\t\tlet clipped = clone(mappedColor);\n\t\t\t\t\tclipped = toGamut(clipped, { space, method: \"clip\" });\n\t\t\t\t\tlet deltaE = de(mappedColor, clipped);\n\n\t\t\t\t\tif (deltaE - jnd < ) {\n\t\t\t\t\t\tlow = get(mappedColor, coordId);\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\thigh = get(mappedColor, coordId);\n\t\t\t\t\t}\n\n\t\t\t\t\tset(mappedColor, coordId, (low + high) / 2);\n\t\t\t\t}\n\n\t\t\t\tspaceColor = to(mappedColor, space);\n\t\t\t}\n\t\t\telse {\n\t\t\t\tspaceColor = clipped;\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tspaceColor = to(color, space);\n\t\t}\n\n\t\tif (method === \"clip\" // Dumb coord clipping\n\t\t\t// finish off smarter gamut mapping with clip to get rid of , see #17\n\t\t\t|| !inGamut(spaceColor, space, { epsilon: 0 })\n\t\t) {\n\t\t\tlet bounds = Object.values(space.coords).map(c => c.range || []);\n\n\t\t\tspaceColor.coords = spaceColor.coords.map((c, i) => {\n\t\t\t\tlet [min, max] = bounds[i];\n\n\t\t\t\tif (min !== undefined) {\n\t\t\t\t\tc = Math.max(min, c);\n\t\t\t\t}\n\n\t\t\t\tif (max !== undefined) {\n\t\t\t\t\tc = Math.min(c, max);\n\t\t\t\t}\n\n\t\t\t\treturn c;\n\t\t\t});\n\t\t}\n\t}\n\n\tif (space !== color.space) {\n\t\tspaceColor = to(spaceColor, color.space);\n\t}\n\n\tcolor.coords = spaceColor.coords;\n\treturn color;\n}\n\ntoGamut.returns = \"color\";\n\n// The reference colors to be used if lightness is out of the range 0-1 in the\n// `Oklch` space. These are created in the `Oklab` space, as it is used by the\n// DeltaEOK calculation, so it is guaranteed to be imported.\nconst COLORS = {\n\tWHITE: { space: oklab, coords: [1, 0, 0] },\n\tBLACK: { space: oklab, coords: [0, 0, 0] },\n};\n\n/**\n * Given a color `origin`, returns a new color that is in gamut using\n * the CSS Gamut Mapping Algorithm. If `space` is specified, it will be in gamut\n * in `space`, and returned in `space`. Otherwise, it will be in gamut and\n * returned in the color space of `origin`.\n * @param {Object} origin\n * @param {Object} options\n * @param {ColorSpace|string} options.space\n * @returns {Color}\n */\nexport function toGamutCSS (origin, {space} = {}) {\n\tconst JND = 0.02;\n\tconst  = 0.0001;\n\n\torigin = getColor(origin);\n\n\tif (!space) {\n\t\tspace = origin.space;\n\t}\n\n\tspace = ColorSpace.get(space);\n\tconst oklchSpace = ColorSpace.get(\"oklch\");\n\n\tif (space.isUnbounded) {\n\t\treturn to(origin, space);\n\t}\n\n\tconst origin_OKLCH = to(origin, oklchSpace);\n\tlet L = origin_OKLCH.coords[0];\n\n\t// return media white or black, if lightness is out of range\n\tif (L >= 1) {\n\t\tconst white = to(COLORS.WHITE, space);\n\t\twhite.alpha = origin.alpha;\n\t\treturn to(white, space);\n\t}\n\tif (L <= 0) {\n\t\tconst black = to(COLORS.BLACK, space);\n\t\tblack.alpha = origin.alpha;\n\t\treturn to(black, space);\n\t}\n\n\tif (inGamut(origin_OKLCH, space, {epsilon: 0})) {\n\t\treturn to(origin_OKLCH, space);\n\t}\n\n\tfunction clip (_color) {\n\t\tconst destColor = to(_color, space);\n\t\tconst spaceCoords = Object.values(space.coords);\n\t\tdestColor.coords = destColor.coords.map((coord, index) => {\n\t\t\tif (\"range\" in spaceCoords[index]) {\n\t\t\t\tconst [min, max] =  spaceCoords[index].range;\n\t\t\t\treturn util.clamp(min, coord, max);\n\t\t\t}\n\t\t\treturn coord;\n\t\t});\n\t\treturn destColor;\n\t}\n\tlet min = 0;\n\tlet max = origin_OKLCH.coords[1];\n\tlet min_inGamut = true;\n\tlet current = clone(origin_OKLCH);\n\tlet clipped = clip(current);\n\n\tlet E = deltaEOK(clipped, current);\n\tif (E < JND) {\n\t\treturn clipped;\n\t}\n\n\twhile ((max - min) > ) {\n\t\tconst chroma = (min + max) / 2;\n\t\tcurrent.coords[1] = chroma;\n\t\tif (min_inGamut && inGamut(current, space, {epsilon: 0})) {\n\t\t\tmin = chroma;\n\t\t}\n\t\telse {\n\t\t\tclipped = clip(current);\n\t\t\tE = deltaEOK(clipped, current);\n\t\t\tif (E < JND) {\n\t\t\t\tif ((JND - E < )) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tmin_inGamut = false;\n\t\t\t\t\tmin = chroma;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse {\n\t\t\t\tmax = chroma;\n\t\t\t}\n\t\t}\n\t}\n\treturn clipped;\n}\n","import getColor from \"./getColor.js\";\nimport ColorSpace from \"./space.js\";\nimport toGamut from \"./toGamut.js\";\n\n/**\n * Convert to color space and return a new color\n * @param {Object|string} space - Color space object or id\n * @param {Object} options\n * @param {boolean} options.inGamut - Whether to force resulting color in gamut\n * @returns {Color}\n */\nexport default function to (color, space, {inGamut} = {}) {\n\tcolor = getColor(color);\n\tspace = ColorSpace.get(space);\n\n\tlet coords = space.from(color);\n\tlet ret = {space, coords, alpha: color.alpha};\n\n\tif (inGamut) {\n\t\tret = toGamut(ret, inGamut === true ? undefined : inGamut);\n\t}\n\n\treturn ret;\n}\n\nto.returns = \"color\";\n","import * as util from \"./util.js\";\nimport ColorSpace from \"./space.js\";\nimport defaults from \"./defaults.js\";\nimport getColor from \"./getColor.js\";\nimport checkInGamut from \"./inGamut.js\";\nimport toGamut from \"./toGamut.js\";\nimport clone from \"./clone.js\";\n\n/**\n * Generic toString() method, outputs a color(spaceId ...coords) function, a functional syntax, or custom formats defined by the color space\n * @param {Object} options\n * @param {number} options.precision - Significant digits\n * @param {boolean} options.inGamut - Adjust coordinates to fit in gamut first? [default: false]\n */\nexport default function serialize (color, {\n\tprecision = defaults.precision,\n\tformat = \"default\",\n\tinGamut = true,\n\t...customOptions\n} = {}) {\n\tlet ret;\n\n\tcolor = getColor(color);\n\n\tlet formatId = format;\n\tformat = color.space.getFormat(format)\n\t       ?? color.space.getFormat(\"default\")\n\t       ?? ColorSpace.DEFAULT_FORMAT;\n\n\t// The assignment to coords and inGamut needs to stay in the order they are now\n\t// The order of the assignment was changed as a workaround for a bug in Next.js\n\t// See this issue for details: https://github.com/color-js/color.js/issues/260\n\n\tlet coords = color.coords.slice(); // clone so we can manipulate it\n\n\tinGamut ||= format.toGamut;\n\n\tif (inGamut && !checkInGamut(color)) {\n\t\t// FIXME what happens if the color contains NaNs?\n\t\tcoords = toGamut(clone(color), inGamut === true ? undefined : inGamut).coords;\n\t}\n\n\tif (format.type === \"custom\") {\n\t\tcustomOptions.precision = precision;\n\n\t\tif (format.serialize) {\n\t\t\tret = format.serialize(coords, color.alpha, customOptions);\n\t\t}\n\t\telse {\n\t\t\tthrow new TypeError(`format ${formatId} can only be used to parse colors, not for serialization`);\n\t\t}\n\t}\n\telse {\n\t\t// Functional syntax\n\t\tlet name = format.name || \"color\";\n\n\t\tif (format.serializeCoords) {\n\t\t\tcoords = format.serializeCoords(coords, precision);\n\t\t}\n\t\telse {\n\t\t\tif (precision !== null) {\n\t\t\t\tcoords = coords.map(c => {\n\t\t\t\t\treturn util.serializeNumber(c, {precision});\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tlet args = [...coords];\n\n\t\tif (name === \"color\") {\n\t\t\t// If output is a color() function, add colorspace id as first argument\n\t\t\tlet cssId = format.id || format.ids?.[0] || color.space.id;\n\t\t\targs.unshift(cssId);\n\t\t}\n\n\t\tlet alpha = color.alpha;\n\t\tif (precision !== null) {\n\t\t\talpha = util.serializeNumber(alpha, {precision});\n\t\t}\n\n\t\tlet strAlpha = color.alpha >= 1 || format.noAlpha ? \"\" : `${format.commas ? \",\" : \" /\"} ${alpha}`;\n\t\tret = `${name}(${args.join(format.commas ? \", \" : \" \")}${strAlpha})`;\n\t}\n\n\treturn ret;\n}\n","import RGBColorSpace from \"../rgbspace.js\";\n\n// convert an array of linear-light rec2020 values to CIE XYZ\n// using  D65 (no chromatic adaptation)\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n// 0 is actually calculated as  4.994106574466076e-17\nconst toXYZ_M = [\n\t[ 0.6369580483012914, 0.14461690358620832,  0.1688809751641721  ],\n\t[ 0.2627002120112671, 0.6779980715188708,   0.05930171646986196 ],\n\t[ 0.000000000000000,  0.028072693049087428, 1.060985057710791   ],\n];\n\n// from ITU-R BT.2124-0 Annex 2 p.3\nconst fromXYZ_M = [\n\t[  1.716651187971268,  -0.355670783776392, -0.253366281373660  ],\n\t[ -0.666684351832489,   1.616481236634939,  0.0157685458139111 ],\n\t[  0.017639857445311,  -0.042770613257809,  0.942103121235474  ],\n];\n\nexport default new RGBColorSpace({\n\tid: \"rec2020-linear\",\n\tcssId: \"--rec2020-linear\",\n\tname: \"Linear REC.2020\",\n\twhite: \"D65\",\n\ttoXYZ_M,\n\tfromXYZ_M,\n});\n","import RGBColorSpace from \"../rgbspace.js\";\nimport REC2020Linear from \"./rec2020-linear.js\";\n// import sRGB from \"./srgb.js\";\n\nconst  = 1.09929682680944;\nconst  = 0.018053968510807;\n\nexport default new RGBColorSpace({\n\tid: \"rec2020\",\n\tname: \"REC.2020\",\n\tbase: REC2020Linear,\n\t// Non-linear transfer function from Rec. ITU-R BT.2020-2 table 4\n\ttoBase (RGB) {\n\t\treturn RGB.map(function (val) {\n\t\t\tif (val <  * 4.5) {\n\t\t\t\treturn val / 4.5;\n\t\t\t}\n\n\t\t\treturn Math.pow((val +  - 1) / , 1 / 0.45);\n\t\t});\n\t},\n\tfromBase (RGB) {\n\t\treturn RGB.map(function (val) {\n\t\t\tif (val >= ) {\n\t\t\t\treturn  * Math.pow(val, 0.45) - ( - 1);\n\t\t\t}\n\n\t\t\treturn 4.5 * val;\n\t\t});\n\t},\n});\n","import RGBColorSpace from \"../rgbspace.js\";\n\nconst toXYZ_M = [\n\t[0.4865709486482162, 0.26566769316909306, 0.1982172852343625],\n\t[0.2289745640697488, 0.6917385218365064,  0.079286914093745],\n\t[0.0000000000000000, 0.04511338185890264, 1.043944368900976],\n];\n\nconst fromXYZ_M = [\n\t[ 2.493496911941425,   -0.9313836179191239, -0.40271078445071684],\n\t[-0.8294889695615747,   1.7626640603183463,  0.023624685841943577],\n\t[ 0.03584583024378447, -0.07617238926804182, 0.9568845240076872],\n];\n\nexport default new RGBColorSpace({\n\tid: \"p3-linear\",\n\tcssId: \"--display-p3-linear\",\n\tname: \"Linear P3\",\n\twhite: \"D65\",\n\ttoXYZ_M,\n\tfromXYZ_M,\n});\n","import RGBColorSpace from \"../rgbspace.js\";\n\n// This is the linear-light version of sRGB\n// as used for example in SVG filters\n// or in Canvas\n\n// This matrix was calculated directly from the RGB and white chromaticities\n// when rounded to 8 decimal places, it agrees completely with the official matrix\n// see https://github.com/w3c/csswg-drafts/issues/5922\nconst toXYZ_M = [\n\t[ 0.41239079926595934, 0.357584339383878,   0.1804807884018343  ],\n\t[ 0.21263900587151027, 0.715168678767756,   0.07219231536073371 ],\n\t[ 0.01933081871559182, 0.11919477979462598, 0.9505321522496607  ],\n];\n\n// This matrix is the inverse of the above;\n// again it agrees with the official definition when rounded to 8 decimal places\nexport const fromXYZ_M = [\n\t[  3.2409699419045226,  -1.537383177570094,   -0.4986107602930034  ],\n\t[ -0.9692436362808796,   1.8759675015077202,   0.04155505740717559 ],\n\t[  0.05563007969699366, -0.20397695888897652,  1.0569715142428786  ],\n];\n\nexport default new RGBColorSpace({\n\tid: \"srgb-linear\",\n\tname: \"Linear sRGB\",\n\twhite: \"D65\",\n\ttoXYZ_M,\n\tfromXYZ_M,\n});\n","/* List of CSS color keywords\n * Note that this does not include currentColor, transparent,\n * or system colors\n */\n\n// To produce: Visit https://www.w3.org/TR/css-color-4/#named-colors\n// and run in the console:\n// copy($$(\"tr\", $(\".named-color-table tbody\")).map(tr => `\"${tr.cells[2].textContent.trim()}\": [${tr.cells[4].textContent.trim().split(/\\s+/).map(c => c === \"0\"? \"0\" : c === \"255\"? \"1\" : c + \" / 255\").join(\", \")}]`).join(\",\\n\"))\nexport default {\n\t\"aliceblue\": [240 / 255, 248 / 255, 1],\n\t\"antiquewhite\": [250 / 255, 235 / 255, 215 / 255],\n\t\"aqua\": [0, 1, 1],\n\t\"aquamarine\": [127 / 255, 1, 212 / 255],\n\t\"azure\": [240 / 255, 1, 1],\n\t\"beige\": [245 / 255, 245 / 255, 220 / 255],\n\t\"bisque\": [1, 228 / 255, 196 / 255],\n\t\"black\": [0, 0, 0],\n\t\"blanchedalmond\": [1, 235 / 255, 205 / 255],\n\t\"blue\": [0, 0, 1],\n\t\"blueviolet\": [138 / 255, 43 / 255, 226 / 255],\n\t\"brown\": [165 / 255, 42 / 255, 42 / 255],\n\t\"burlywood\": [222 / 255, 184 / 255, 135 / 255],\n\t\"cadetblue\": [95 / 255, 158 / 255, 160 / 255],\n\t\"chartreuse\": [127 / 255, 1, 0],\n\t\"chocolate\": [210 / 255, 105 / 255, 30 / 255],\n\t\"coral\": [1, 127 / 255, 80 / 255],\n\t\"cornflowerblue\": [100 / 255, 149 / 255, 237 / 255],\n\t\"cornsilk\": [1, 248 / 255, 220 / 255],\n\t\"crimson\": [220 / 255, 20 / 255, 60 / 255],\n\t\"cyan\": [0, 1, 1],\n\t\"darkblue\": [0, 0, 139 / 255],\n\t\"darkcyan\": [0, 139 / 255, 139 / 255],\n\t\"darkgoldenrod\": [184 / 255, 134 / 255, 11 / 255],\n\t\"darkgray\": [169 / 255, 169 / 255, 169 / 255],\n\t\"darkgreen\": [0, 100 / 255, 0],\n\t\"darkgrey\": [169 / 255, 169 / 255, 169 / 255],\n\t\"darkkhaki\": [189 / 255, 183 / 255, 107 / 255],\n\t\"darkmagenta\": [139 / 255, 0, 139 / 255],\n\t\"darkolivegreen\": [85 / 255, 107 / 255, 47 / 255],\n\t\"darkorange\": [1, 140 / 255, 0],\n\t\"darkorchid\": [153 / 255, 50 / 255, 204 / 255],\n\t\"darkred\": [139 / 255, 0, 0],\n\t\"darksalmon\": [233 / 255, 150 / 255, 122 / 255],\n\t\"darkseagreen\": [143 / 255, 188 / 255, 143 / 255],\n\t\"darkslateblue\": [72 / 255, 61 / 255, 139 / 255],\n\t\"darkslategray\": [47 / 255, 79 / 255, 79 / 255],\n\t\"darkslategrey\": [47 / 255, 79 / 255, 79 / 255],\n\t\"darkturquoise\": [0, 206 / 255, 209 / 255],\n\t\"darkviolet\": [148 / 255, 0, 211 / 255],\n\t\"deeppink\": [1, 20 / 255, 147 / 255],\n\t\"deepskyblue\": [0, 191 / 255, 1],\n\t\"dimgray\": [105 / 255, 105 / 255, 105 / 255],\n\t\"dimgrey\": [105 / 255, 105 / 255, 105 / 255],\n\t\"dodgerblue\": [30 / 255, 144 / 255, 1],\n\t\"firebrick\": [178 / 255, 34 / 255, 34 / 255],\n\t\"floralwhite\": [1, 250 / 255, 240 / 255],\n\t\"forestgreen\": [34 / 255, 139 / 255, 34 / 255],\n\t\"fuchsia\": [1, 0, 1],\n\t\"gainsboro\": [220 / 255, 220 / 255, 220 / 255],\n\t\"ghostwhite\": [248 / 255, 248 / 255, 1],\n\t\"gold\": [1, 215 / 255, 0],\n\t\"goldenrod\": [218 / 255, 165 / 255, 32 / 255],\n\t\"gray\": [128 / 255, 128 / 255, 128 / 255],\n\t\"green\": [0, 128 / 255, 0],\n\t\"greenyellow\": [173 / 255, 1, 47 / 255],\n\t\"grey\": [128 / 255, 128 / 255, 128 / 255],\n\t\"honeydew\": [240 / 255, 1, 240 / 255],\n\t\"hotpink\": [1, 105 / 255, 180 / 255],\n\t\"indianred\": [205 / 255, 92 / 255, 92 / 255],\n\t\"indigo\": [75 / 255, 0, 130 / 255],\n\t\"ivory\": [1, 1, 240 / 255],\n\t\"khaki\": [240 / 255, 230 / 255, 140 / 255],\n\t\"lavender\": [230 / 255, 230 / 255, 250 / 255],\n\t\"lavenderblush\": [1, 240 / 255, 245 / 255],\n\t\"lawngreen\": [124 / 255, 252 / 255, 0],\n\t\"lemonchiffon\": [1, 250 / 255, 205 / 255],\n\t\"lightblue\": [173 / 255, 216 / 255, 230 / 255],\n\t\"lightcoral\": [240 / 255, 128 / 255, 128 / 255],\n\t\"lightcyan\": [224 / 255, 1, 1],\n\t\"lightgoldenrodyellow\": [250 / 255, 250 / 255, 210 / 255],\n\t\"lightgray\": [211 / 255, 211 / 255, 211 / 255],\n\t\"lightgreen\": [144 / 255, 238 / 255, 144 / 255],\n\t\"lightgrey\": [211 / 255, 211 / 255, 211 / 255],\n\t\"lightpink\": [1, 182 / 255, 193 / 255],\n\t\"lightsalmon\": [1, 160 / 255, 122 / 255],\n\t\"lightseagreen\": [32 / 255, 178 / 255, 170 / 255],\n\t\"lightskyblue\": [135 / 255, 206 / 255, 250 / 255],\n\t\"lightslategray\": [119 / 255, 136 / 255, 153 / 255],\n\t\"lightslategrey\": [119 / 255, 136 / 255, 153 / 255],\n\t\"lightsteelblue\": [176 / 255, 196 / 255, 222 / 255],\n\t\"lightyellow\": [1, 1, 224 / 255],\n\t\"lime\": [0, 1, 0],\n\t\"limegreen\": [50 / 255, 205 / 255, 50 / 255],\n\t\"linen\": [250 / 255, 240 / 255, 230 / 255],\n\t\"magenta\": [1, 0, 1],\n\t\"maroon\": [128 / 255, 0, 0],\n\t\"mediumaquamarine\": [102 / 255, 205 / 255, 170 / 255],\n\t\"mediumblue\": [0, 0, 205 / 255],\n\t\"mediumorchid\": [186 / 255, 85 / 255, 211 / 255],\n\t\"mediumpurple\": [147 / 255, 112 / 255, 219 / 255],\n\t\"mediumseagreen\": [60 / 255, 179 / 255, 113 / 255],\n\t\"mediumslateblue\": [123 / 255, 104 / 255, 238 / 255],\n\t\"mediumspringgreen\": [0, 250 / 255, 154 / 255],\n\t\"mediumturquoise\": [72 / 255, 209 / 255, 204 / 255],\n\t\"mediumvioletred\": [199 / 255, 21 / 255, 133 / 255],\n\t\"midnightblue\": [25 / 255, 25 / 255, 112 / 255],\n\t\"mintcream\": [245 / 255, 1, 250 / 255],\n\t\"mistyrose\": [1, 228 / 255, 225 / 255],\n\t\"moccasin\": [1, 228 / 255, 181 / 255],\n\t\"navajowhite\": [1, 222 / 255, 173 / 255],\n\t\"navy\": [0, 0, 128 / 255],\n\t\"oldlace\": [253 / 255, 245 / 255, 230 / 255],\n\t\"olive\": [128 / 255, 128 / 255, 0],\n\t\"olivedrab\": [107 / 255, 142 / 255, 35 / 255],\n\t\"orange\": [1, 165 / 255, 0],\n\t\"orangered\": [1, 69 / 255, 0],\n\t\"orchid\": [218 / 255, 112 / 255, 214 / 255],\n\t\"palegoldenrod\": [238 / 255, 232 / 255, 170 / 255],\n\t\"palegreen\": [152 / 255, 251 / 255, 152 / 255],\n\t\"paleturquoise\": [175 / 255, 238 / 255, 238 / 255],\n\t\"palevioletred\": [219 / 255, 112 / 255, 147 / 255],\n\t\"papayawhip\": [1, 239 / 255, 213 / 255],\n\t\"peachpuff\": [1, 218 / 255, 185 / 255],\n\t\"peru\": [205 / 255, 133 / 255, 63 / 255],\n\t\"pink\": [1, 192 / 255, 203 / 255],\n\t\"plum\": [221 / 255, 160 / 255, 221 / 255],\n\t\"powderblue\": [176 / 255, 224 / 255, 230 / 255],\n\t\"purple\": [128 / 255, 0, 128 / 255],\n\t\"rebeccapurple\": [102 / 255, 51 / 255, 153 / 255],\n\t\"red\": [1, 0, 0],\n\t\"rosybrown\": [188 / 255, 143 / 255, 143 / 255],\n\t\"royalblue\": [65 / 255, 105 / 255, 225 / 255],\n\t\"saddlebrown\": [139 / 255, 69 / 255, 19 / 255],\n\t\"salmon\": [250 / 255, 128 / 255, 114 / 255],\n\t\"sandybrown\": [244 / 255, 164 / 255, 96 / 255],\n\t\"seagreen\": [46 / 255, 139 / 255, 87 / 255],\n\t\"seashell\": [1, 245 / 255, 238 / 255],\n\t\"sienna\": [160 / 255, 82 / 255, 45 / 255],\n\t\"silver\": [192 / 255, 192 / 255, 192 / 255],\n\t\"skyblue\": [135 / 255, 206 / 255, 235 / 255],\n\t\"slateblue\": [106 / 255, 90 / 255, 205 / 255],\n\t\"slategray\": [112 / 255, 128 / 255, 144 / 255],\n\t\"slategrey\": [112 / 255, 128 / 255, 144 / 255],\n\t\"snow\": [1, 250 / 255, 250 / 255],\n\t\"springgreen\": [0, 1, 127 / 255],\n\t\"steelblue\": [70 / 255, 130 / 255, 180 / 255],\n\t\"tan\": [210 / 255, 180 / 255, 140 / 255],\n\t\"teal\": [0, 128 / 255, 128 / 255],\n\t\"thistle\": [216 / 255, 191 / 255, 216 / 255],\n\t\"tomato\": [1, 99 / 255, 71 / 255],\n\t\"turquoise\": [64 / 255, 224 / 255, 208 / 255],\n\t\"violet\": [238 / 255, 130 / 255, 238 / 255],\n\t\"wheat\": [245 / 255, 222 / 255, 179 / 255],\n\t\"white\": [1, 1, 1],\n\t\"whitesmoke\": [245 / 255, 245 / 255, 245 / 255],\n\t\"yellow\": [1, 1, 0],\n\t\"yellowgreen\": [154 / 255, 205 / 255, 50 / 255],\n};\n","import RGBColorSpace from \"../rgbspace.js\";\nimport sRGBLinear from \"./srgb-linear.js\";\nimport KEYWORDS from \"../keywords.js\";\n\nlet coordGrammar = Array(3).fill(\"<percentage> | <number>[0, 255]\");\nlet coordGrammarNumber = Array(3).fill(\"<number>[0, 255]\");\n\nexport default new RGBColorSpace({\n\tid: \"srgb\",\n\tname: \"sRGB\",\n\tbase: sRGBLinear,\n\tfromBase: rgb => {\n\t\t// convert an array of linear-light sRGB values in the range 0.0-1.0\n\t\t// to gamma corrected form\n\t\t// https://en.wikipedia.org/wiki/SRGB\n\t\treturn rgb.map(val => {\n\t\t\tlet sign = val < 0 ? -1 : 1;\n\t\t\tlet abs = val * sign;\n\n\t\t\tif (abs > 0.0031308) {\n\t\t\t\treturn sign * (1.055 * (abs ** (1 / 2.4)) - 0.055);\n\t\t\t}\n\n\t\t\treturn 12.92 * val;\n\t\t});\n\t},\n\ttoBase: rgb => {\n\t\t// convert an array of sRGB values in the range 0.0 - 1.0\n\t\t// to linear light (un-companded) form.\n\t\t// https://en.wikipedia.org/wiki/SRGB\n\t\treturn rgb.map(val => {\n\t\t\tlet sign = val < 0 ? -1 : 1;\n\t\t\tlet abs = val * sign;\n\n\t\t\tif (abs <= 0.04045) {\n\t\t\t\treturn val / 12.92;\n\t\t\t}\n\n\t\t\treturn sign * (((abs + 0.055) / 1.055) ** 2.4);\n\t\t});\n\t},\n\tformats: {\n\t\t\"rgb\": {\n\t\t\tcoords: coordGrammar,\n\t\t},\n\t\t\"rgb_number\": {\n\t\t\tname: \"rgb\",\n\t\t\tcommas: true,\n\t\t\tcoords: coordGrammarNumber,\n\t\t\tnoAlpha: true,\n\t\t},\n\t\t\"color\": { /* use defaults */ },\n\t\t\"rgba\": {\n\t\t\tcoords: coordGrammar,\n\t\t\tcommas: true,\n\t\t\tlastAlpha: true,\n\t\t},\n\t\t\"rgba_number\": {\n\t\t\tname: \"rgba\",\n\t\t\tcommas: true,\n\t\t\tcoords: coordGrammarNumber,\n\t\t},\n\t\t\"hex\": {\n\t\t\ttype: \"custom\",\n\t\t\ttoGamut: true,\n\t\t\ttest: str => /^#([a-f0-9]{3,4}){1,2}$/i.test(str),\n\t\t\tparse (str) {\n\t\t\t\tif (str.length <= 5) {\n\t\t\t\t\t// #rgb or #rgba, duplicate digits\n\t\t\t\t\tstr = str.replace(/[a-f0-9]/gi, \"$&$&\");\n\t\t\t\t}\n\n\t\t\t\tlet rgba = [];\n\t\t\t\tstr.replace(/[a-f0-9]{2}/gi, component => {\n\t\t\t\t\trgba.push(parseInt(component, 16) / 255);\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\tspaceId: \"srgb\",\n\t\t\t\t\tcoords: rgba.slice(0, 3),\n\t\t\t\t\talpha: rgba.slice(3)[0],\n\t\t\t\t};\n\t\t\t},\n\t\t\tserialize: (coords, alpha, {\n\t\t\t\tcollapse = true, // collapse to 3-4 digit hex when possible?\n\t\t\t} = {}) => {\n\t\t\t\tif (alpha < 1) {\n\t\t\t\t\tcoords.push(alpha);\n\t\t\t\t}\n\n\t\t\t\tcoords = coords.map(c => Math.round(c * 255));\n\n\t\t\t\tlet collapsible = collapse && coords.every(c => c % 17 === 0);\n\n\t\t\t\tlet hex = coords.map(c => {\n\t\t\t\t\tif (collapsible) {\n\t\t\t\t\t\treturn (c / 17).toString(16);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn c.toString(16).padStart(2, \"0\");\n\t\t\t\t}).join(\"\");\n\n\t\t\t\treturn \"#\" + hex;\n\t\t\t},\n\t\t},\n\t\t\"keyword\": {\n\t\t\ttype: \"custom\",\n\t\t\ttest: str => /^[a-z]+$/i.test(str),\n\t\t\tparse (str) {\n\t\t\t\tstr = str.toLowerCase();\n\t\t\t\tlet ret = {spaceId: \"srgb\", coords: null, alpha: 1};\n\n\t\t\t\tif (str === \"transparent\") {\n\t\t\t\t\tret.coords = KEYWORDS.black;\n\t\t\t\t\tret.alpha = 0;\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret.coords = KEYWORDS[str];\n\t\t\t\t}\n\n\t\t\t\tif (ret.coords) {\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t},\n});\n","import RGBColorSpace from \"../rgbspace.js\";\nimport P3Linear from \"./p3-linear.js\";\nimport sRGB from \"./srgb.js\";\n\nexport default new RGBColorSpace({\n\tid: \"p3\",\n\tcssId: \"display-p3\",\n\tname: \"P3\",\n\tbase: P3Linear,\n\t// Gamma encoding/decoding is the same as sRGB\n\tfromBase: sRGB.fromBase,\n\ttoBase: sRGB.toBase,\n});\n","import { isNone, skipNone } from \"./util.js\";\nimport defaults from \"./defaults.js\";\nimport to from \"./to.js\";\nimport serialize from \"./serialize.js\";\nimport clone from \"./clone.js\";\nimport REC2020 from \"./spaces/rec2020.js\";\nimport P3 from \"./spaces/p3.js\";\nimport Lab from \"./spaces/lab.js\";\nimport sRGB from \"./spaces/srgb.js\";\n\n// Default space for CSS output. Code in Color.js makes this wider if there's a DOM available\ndefaults.display_space = sRGB;\n\nlet supportsNone;\n\nif (typeof CSS !== \"undefined\" && CSS.supports) {\n\t// Find widest supported color space for CSS\n\tfor (let space of [Lab, REC2020, P3]) {\n\t\tlet coords = space.getMinCoords();\n\t\tlet color = {space, coords, alpha: 1};\n\t\tlet str = serialize(color);\n\n\t\tif (CSS.supports(\"color\", str)) {\n\t\t\tdefaults.display_space = space;\n\t\t\tbreak;\n\t\t}\n\t}\n}\n\n/**\n * Returns a serialization of the color that can actually be displayed in the browser.\n * If the default serialization can be displayed, it is returned.\n * Otherwise, the color is converted to Lab, REC2020, or P3, whichever is the widest supported.\n * In Node.js, this is basically equivalent to `serialize()` but returns a `String` object instead.\n *\n * @export\n * @param {{space, coords} | Color | string} color\n * @param {*} [options={}] Options to be passed to serialize()\n * @param {ColorSpace | string} [options.space = defaults.display_space] Color space to use for serialization if default is not supported\n * @returns {String} String object containing the serialized color with a color property containing the converted color (or the original, if no conversion was necessary)\n */\nexport default function display (color, {space = defaults.display_space, ...options} = {}) {\n\tlet ret = serialize(color, options);\n\n\tif (typeof CSS === \"undefined\" || CSS.supports(\"color\", ret) || !defaults.display_space) {\n\t\tret = new String(ret);\n\t\tret.color = color;\n\t}\n\telse {\n\t\t// If we're here, what we were about to output is not supported\n\t\tlet fallbackColor = color;\n\n\t\t// First, check if the culprit is none values\n\t\tlet hasNone = color.coords.some(isNone) || isNone(color.alpha);\n\n\t\tif (hasNone) {\n\t\t\t// Does the browser support none values?\n\t\t\tif (!(supportsNone ??= CSS.supports(\"color\", \"hsl(none 50% 50%)\"))) {\n\t\t\t\t// Nope, try again without none\n\t\t\t\tfallbackColor = clone(color);\n\t\t\t\tfallbackColor.coords = fallbackColor.coords.map(skipNone);\n\t\t\t\tfallbackColor.alpha = skipNone(fallbackColor.alpha);\n\n\t\t\t\tret = serialize(fallbackColor, options);\n\n\t\t\t\tif (CSS.supports(\"color\", ret)) {\n\t\t\t\t\t// We're done, now it's supported\n\t\t\t\t\tret = new String(ret);\n\t\t\t\t\tret.color = fallbackColor;\n\t\t\t\t\treturn ret;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// If we're here, the color function is not supported\n\t\t// Fall back to fallback space\n\t\tfallbackColor = to(fallbackColor, space);\n\t\tret = new String(serialize(fallbackColor, options));\n\t\tret.color = fallbackColor;\n\t}\n\n\treturn ret;\n}\n","import getColor from \"./getColor.js\";\n\nexport default function equals (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\treturn color1.space === color2.space\n\t       && color1.alpha === color2.alpha\n\t       && color1.coords.every((c, i) => c === color2.coords[i]);\n}\n","/**\n * Relative luminance\n */\nimport get from \"./get.js\";\nimport set from \"./set.js\";\nimport xyz_d65 from \"./spaces/xyz-d65.js\";\n\nexport function getLuminance (color) {\n\t// Assume getColor() is called on color in get()\n\treturn get(color, [xyz_d65, \"y\"]);\n}\n\nexport function setLuminance (color, value) {\n\t// Assume getColor() is called on color in set()\n\tset(color, [xyz_d65, \"y\"], value);\n}\n\nexport function register (Color) {\n\tObject.defineProperty(Color.prototype, \"luminance\", {\n\t\tget () {\n\t\t\treturn getLuminance(this);\n\t\t},\n\t\tset (value) {\n\t\t\tsetLuminance(this, value);\n\t\t},\n\t});\n}\n","// WCAG 2.0 contrast https://www.w3.org/TR/WCAG20-TECHS/G18.html\n// Simple contrast, with fixed 5% viewing flare contribution\n// Symmetric, does not matter which is foreground and which is background\n\nimport getColor from \"../getColor.js\";\nimport {getLuminance} from \"../luminance.js\";\n\nexport default function contrastWCAG21 (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\tlet Y1 = Math.max(getLuminance(color1), 0);\n\tlet Y2 = Math.max(getLuminance(color2), 0);\n\n\tif (Y2 > Y1) {\n\t\t[Y1, Y2] = [Y2, Y1];\n\t}\n\n\treturn (Y1 + .05) / (Y2 + .05);\n}\n","// APCA 0.0.98G\n// https://github.com/Myndex/apca-w3\n// see also https://github.com/w3c/silver/issues/643\n\nimport getColor from \"../getColor.js\";\nimport to from \"../to.js\";\n\n// exponents\nconst normBG = 0.56;\nconst normTXT = 0.57;\nconst revTXT = 0.62;\nconst revBG = 0.65;\n\n// clamps\nconst blkThrs = 0.022;\nconst blkClmp = 1.414;\nconst loClip = 0.1;\nconst deltaYmin = 0.0005;\n\n// scalers\n// see https://github.com/w3c/silver/issues/645\nconst scaleBoW = 1.14;\nconst loBoWoffset = 0.027;\nconst scaleWoB = 1.14;\nconst loWoBoffset = 0.027;\n\nfunction fclamp (Y) {\n\tif (Y >= blkThrs) {\n\t\treturn Y;\n\t}\n\treturn Y + (blkThrs - Y) ** blkClmp;\n}\n\nfunction linearize (val) {\n\tlet sign = val < 0 ? -1 : 1;\n\tlet abs = Math.abs(val);\n\treturn sign * Math.pow(abs, 2.4);\n}\n\n// Not symmetric, requires a foreground (text) color, and a background color\nexport default function contrastAPCA (background, foreground) {\n\tforeground = getColor(foreground);\n\tbackground = getColor(background);\n\n\tlet S;\n\tlet C;\n\tlet Sapc;\n\n\t// Myndex as-published, assumes sRGB inputs\n\tlet R, G, B;\n\n\tforeground = to(foreground, \"srgb\");\n\t// Should these be clamped to in-gamut values?\n\n\t// Calculates \"screen luminance\" with non-standard simple gamma EOTF\n\t// weights should be from CSS Color 4, not the ones here which are via Myndex and copied from Lindbloom\n\t[R, G, B] = foreground.coords;\n\tlet lumTxt = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.0721750;\n\n\tbackground = to(background, \"srgb\");\n\t[R, G, B] = background.coords;\n\tlet lumBg = linearize(R) * 0.2126729 + linearize(G) * 0.7151522 + linearize(B) * 0.0721750;\n\n\t// toe clamping of very dark values to account for flare\n\tlet Ytxt = fclamp(lumTxt);\n\tlet Ybg = fclamp(lumBg);\n\n\t// are we \"Black on White\" (dark on light), or light on dark?\n\tlet BoW = Ybg > Ytxt;\n\n\t// why is this a delta, when Y is not perceptually uniform?\n\t// Answer: it is a noise gate, see\n\t// https://github.com/LeaVerou/color.js/issues/208\n\tif (Math.abs(Ybg - Ytxt) < deltaYmin) {\n\t\tC = 0;\n\t}\n\telse {\n\t\tif (BoW) {\n\t\t\t// dark text on light background\n\t\t\tS = Ybg ** normBG - Ytxt ** normTXT;\n\t\t\tC = S * scaleBoW;\n\t\t}\n\t\telse {\n\t\t\t// light text on dark background\n\t\t\tS = Ybg ** revBG - Ytxt ** revTXT;\n\t\t\tC = S * scaleWoB;\n\t\t}\n\t}\n\tif (Math.abs(C) < loClip) {\n\t\tSapc = 0;\n\t}\n\telse if (C > 0) {\n\t\t// not clear whether Woffset is loBoWoffset or loWoBoffset\n\t\t// but they have the same value\n\t\tSapc = C - loBoWoffset;\n\t}\n\telse {\n\t\tSapc = C + loBoWoffset;\n\t}\n\n\treturn Sapc * 100;\n}\n","// Michelson  luminance contrast\n// the relation between the spread and the sum of the two luminances\n// Symmetric, does not matter which is foreground and which is background\n// No black level compensation for flare.\n\nimport getColor from \"../getColor.js\";\nimport {getLuminance} from \"../luminance.js\";\n\nexport default function contrastMichelson (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\tlet Y1 = Math.max(getLuminance(color1), 0);\n\tlet Y2 = Math.max(getLuminance(color2), 0);\n\n\tif (Y2 > Y1) {\n\t\t[Y1, Y2] = [Y2, Y1];\n\t}\n\n\tlet denom = (Y1 + Y2);\n\treturn denom === 0 ? 0 : (Y1 - Y2) / denom;\n}\n","// Weber luminance contrast\n// The difference between the two luminances divided by the lower luminance\n// Symmetric, does not matter which is foreground and which is background\n// No black level compensation for flare.\n\nimport getColor from \"../getColor.js\";\nimport {getLuminance} from \"../luminance.js\";\n\n// the darkest sRGB color above black is #000001 and this produces\n// a plain Weber contrast of ~45647.\n// So, setting the divide-by-zero result at 50000 is a reasonable\n// max clamp for the plain Weber\nconst max = 50000;\n\nexport default function contrastWeber (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\tlet Y1 = Math.max(getLuminance(color1), 0);\n\tlet Y2 = Math.max(getLuminance(color2), 0);\n\n\tif (Y2 > Y1) {\n\t\t[Y1, Y2] = [Y2, Y1];\n\t}\n\n\treturn Y2 === 0 ? max : (Y1 - Y2) / Y2;\n}\n","// CIE Lightness difference, as used by Google Material Design\n// Google HCT Tone is the same as CIE Lightness\n// https://material.io/blog/science-of-color-design\n\nimport getColor from \"../getColor.js\";\nimport get from \"../get.js\";\nimport lab from \"../spaces/lab.js\";\n\nexport default function contrastLstar (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\tlet L1 = get(color1, [lab, \"l\"]);\n\tlet L2 = get(color2, [lab, \"l\"]);\n\n\treturn Math.abs(L1 - L2);\n}\n","import ColorSpace from \"../space.js\";\nimport {WHITES} from \"../adapt.js\";\nimport xyz_d65 from \"./xyz-d65.js\";\n\n//  *   = 2^3 = 8\nconst  = 216 / 24389;  // 6^3/29^3 == (24/116)^3\nconst 3 = 24 / 116;\nconst  = 24389 / 27;   // 29^3/3^3\n\nlet white = WHITES.D65;\n\nexport default new ColorSpace({\n\tid: \"lab-d65\",\n\tname: \"Lab D65\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t\ta: {\n\t\t\trefRange: [-125, 125],\n\t\t},\n\t\tb: {\n\t\t\trefRange: [-125, 125],\n\t\t},\n\t},\n\n\t// Assuming XYZ is relative to D65, convert to CIE Lab\n\t// from CIE standard, which now defines these as a rational fraction\n\twhite,\n\n\tbase: xyz_d65,\n\t// Convert D65-adapted XYZ to Lab\n\t//  CIE 15.3:2004 section 8.2.1.1\n\tfromBase (XYZ) {\n\t\t// compute xyz, which is XYZ scaled relative to reference white\n\t\tlet xyz = XYZ.map((value, i) => value / white[i]);\n\n\t\t// now compute f\n\t\tlet f = xyz.map(value => value >  ? Math.cbrt(value) : ( * value + 16) / 116);\n\n\t\treturn [\n\t\t\t(116 * f[1]) - 16,   // L\n\t\t\t500 * (f[0] - f[1]), // a\n\t\t\t200 * (f[1] - f[2]),  // b\n\t\t];\n\t},\n\t// Convert Lab to D65-adapted XYZ\n\t// Same result as CIE 15.3:2004 Appendix D although the derivation is different\n\t// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n\ttoBase (Lab) {\n\t\t// compute f, starting with the luminance-related term\n\t\tlet f = [];\n\t\tf[1] = (Lab[0] + 16) / 116;\n\t\tf[0] = Lab[1] / 500 + f[1];\n\t\tf[2] = f[1] - Lab[2] / 200;\n\n\t\t// compute xyz\n\t\tlet xyz = [\n\t\t\tf[0]   > 3 ? Math.pow(f[0], 3)                : (116 * f[0] - 16) / ,\n\t\t\tLab[0] > 8  ? Math.pow((Lab[0] + 16) / 116, 3) : Lab[0] / ,\n\t\t\tf[2]   > 3 ? Math.pow(f[2], 3)                : (116 * f[2] - 16) / ,\n\t\t];\n\n\t\t// Compute XYZ by scaling xyz by reference white\n\t\treturn xyz.map((value, i) => value * white[i]);\n\t},\n\n\tformats: {\n\t\t\"lab-d65\": {\n\t\t\tcoords: [\"<number> | <percentage>\", \"<number> | <percentage>[-1,1]\", \"<number> | <percentage>[-1,1]\"],\n\t\t},\n\t},\n});\n","// Delta Phi Star perceptual lightness contrast\n// See https://github.com/Myndex/deltaphistar\n// The (difference between two Lstars each raised to phi) raised to (1/phi)\n// Symmetric, does not matter which is foreground and which is background\n\n\nimport getColor from \"../getColor.js\";\nimport get from \"../get.js\";\nimport lab_d65 from \"../spaces/lab-d65.js\";\n\nconst phi = Math.pow(5, 0.5) * 0.5 + 0.5; // Math.phi can be used if Math.js\n\nexport default function contrastDeltaPhi (color1, color2) {\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\tlet Lstr1 = get(color1, [lab_d65, \"l\"]);\n\tlet Lstr2 = get(color2, [lab_d65, \"l\"]);\n\n\tlet deltaPhiStar = Math.abs(Math.pow(Lstr1, phi) - Math.pow(Lstr2, phi));\n\n\tlet contrast = Math.pow(deltaPhiStar, (1 / phi)) * Math.SQRT2 - 40;\n\n\treturn (contrast < 7.5) ? 0.0 : contrast ;\n}\n","import getColor from \"./getColor.js\";\n// import defaults from \"./defaults.js\";\nimport {isString} from \"./util.js\";\nimport * as contrastAlgorithms from \"./contrast/index.js\";\n\nexport default function contrast (background, foreground, o = {}) {\n\tif (isString(o)) {\n\t\to = {algorithm: o};\n\t}\n\n\tlet {algorithm, ...rest} = o;\n\n\tif (!algorithm) {\n\t\tlet algorithms = Object.keys(contrastAlgorithms).map(a => a.replace(/^contrast/, \"\")).join(\", \");\n\t\tthrow new TypeError(`contrast() function needs a contrast algorithm. Please specify one of: ${algorithms}`);\n\t}\n\n\tbackground = getColor(background);\n\tforeground = getColor(foreground);\n\n\tfor (let a in contrastAlgorithms) {\n\t\tif (\"contrast\" + algorithm.toLowerCase() === a.toLowerCase()) {\n\t\t\treturn contrastAlgorithms[a](background, foreground, rest);\n\t\t}\n\t}\n\n\tthrow new TypeError(`Unknown contrast algorithm: ${algorithm}`);\n}\n","import xyz_d65 from \"./spaces/xyz-d65.js\";\nimport getAll from \"./getAll.js\";\n\n// Chromaticity coordinates\nexport function uv (color) {\n\t// Assumes getAll() calls getColor() on color\n\tlet [X, Y, Z] = getAll(color, xyz_d65);\n\tlet denom = X + 15 * Y + 3 * Z;\n\treturn [4 * X / denom, 9 * Y / denom];\n}\n\nexport function xy (color) {\n\t// Assumes getAll() calls getColor() on color\n\tlet [X, Y, Z] = getAll(color, xyz_d65);\n\tlet  sum = X + Y + Z;\n\treturn [X / sum, Y / sum];\n}\n\nexport function register (Color) {\n\t// no setters, as lightness information is lost\n\t// when converting color to chromaticity\n\tObject.defineProperty(Color.prototype, \"uv\", {\n\t\tget () {\n\t\t\treturn uv(this);\n\t\t},\n\t});\n\n\tObject.defineProperty(Color.prototype, \"xy\", {\n\t\tget () {\n\t\t\treturn xy(this);\n\t\t},\n\t});\n}\n","import defaults from \"./defaults.js\";\nimport {isString} from \"./util.js\";\nimport deltaEMethods from \"./deltaE/index.js\";\n\nexport default function deltaE (c1, c2, o = {}) {\n\tif (isString(o)) {\n\t\to = {method: o};\n\t}\n\n\tlet {method = defaults.deltaE, ...rest} = o;\n\n\tfor (let m in deltaEMethods) {\n\t\tif (\"deltae\" + method.toLowerCase() === m.toLowerCase()) {\n\t\t\treturn deltaEMethods[m](c1, c2, rest);\n\t\t}\n\t}\n\n\tthrow new TypeError(`Unknown deltaE method: ${method}`);\n}\n","import ColorSpace from \"./space.js\";\nimport set from \"./set.js\";\n\nexport function lighten (color, amount = .25) {\n\tlet space = ColorSpace.get(\"oklch\", \"lch\");\n\tlet lightness = [space, \"l\"];\n\treturn set(color, lightness, l => l * (1 + amount));\n}\n\nexport function darken (color, amount = .25) {\n\tlet space = ColorSpace.get(\"oklch\", \"lch\");\n\tlet lightness = [space, \"l\"];\n\treturn set(color, lightness, l => l * (1 - amount));\n}\n","/**\n * Functions related to color interpolation\n */\nimport ColorSpace from \"./space.js\";\nimport {type, interpolate} from \"./util.js\";\nimport getColor from \"./getColor.js\";\nimport clone from \"./clone.js\";\nimport to from \"./to.js\";\nimport toGamut from \"./toGamut.js\";\nimport get from \"./get.js\";\nimport set from \"./set.js\";\nimport defaults from \"./defaults.js\";\nimport * as angles from \"./angles.js\";\nimport deltaE from \"./deltaE.js\";\n\n/**\n * Return an intermediate color between two colors\n * Signatures: mix(c1, c2, p, options)\n *             mix(c1, c2, options)\n *             mix(color)\n * @param {Color | string} c1 The first color\n * @param {Color | string} [c2] The second color\n * @param {number} [p=.5] A 0-1 percentage where 0 is c1 and 1 is c2\n * @param {Object} [o={}]\n * @return {Color}\n */\nexport function mix (c1, c2, p = .5, o = {}) {\n\t[c1, c2] = [getColor(c1), getColor(c2)];\n\n\tif (type(p) === \"object\") {\n\t\t[p, o] = [.5, p];\n\t}\n\n\tlet r = range(c1, c2, o);\n\treturn r(p);\n}\n\n/**\n *\n * @param {Color | string | Function} c1 The first color or a range\n * @param {Color | string} [c2] The second color if c1 is not a range\n * @param {Object} [options={}]\n * @return {Color[]}\n */\nexport function steps (c1, c2, options = {}) {\n\tlet colorRange;\n\n\tif (isRange(c1)) {\n\t\t// Tweaking existing range\n\t\t[colorRange, options] = [c1, c2];\n\t\t[c1, c2] = colorRange.rangeArgs.colors;\n\t}\n\n\tlet {\n\t\tmaxDeltaE, deltaEMethod,\n\t\tsteps = 2, maxSteps = 1000,\n\t\t...rangeOptions\n\t} = options;\n\n\tif (!colorRange) {\n\t\t[c1, c2] = [getColor(c1), getColor(c2)];\n\t\tcolorRange = range(c1, c2, rangeOptions);\n\t}\n\n\tlet totalDelta = deltaE(c1, c2);\n\tlet actualSteps = maxDeltaE > 0 ? Math.max(steps, Math.ceil(totalDelta / maxDeltaE) + 1) : steps;\n\tlet ret = [];\n\n\tif (maxSteps !== undefined) {\n\t\tactualSteps = Math.min(actualSteps, maxSteps);\n\t}\n\n\tif (actualSteps === 1) {\n\t\tret = [{p: .5, color: colorRange(.5)}];\n\t}\n\telse {\n\t\tlet step = 1 / (actualSteps - 1);\n\t\tret = Array.from({length: actualSteps}, (_, i) => {\n\t\t\tlet p = i * step;\n\t\t\treturn {p, color: colorRange(p)};\n\t\t});\n\t}\n\n\tif (maxDeltaE > 0) {\n\t\t// Iterate over all stops and find max deltaE\n\t\tlet maxDelta = ret.reduce((acc, cur, i) => {\n\t\t\tif (i === 0) {\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tlet  = deltaE(cur.color, ret[i - 1].color, deltaEMethod);\n\t\t\treturn Math.max(acc, );\n\t\t}, 0);\n\n\t\twhile (maxDelta > maxDeltaE) {\n\t\t\t// Insert intermediate stops and measure maxDelta again\n\t\t\t// We need to do this for all pairs, otherwise the midpoint shifts\n\t\t\tmaxDelta = 0;\n\n\t\t\tfor (let i = 1; (i < ret.length) && (ret.length < maxSteps); i++) {\n\t\t\t\tlet prev = ret[i - 1];\n\t\t\t\tlet cur = ret[i];\n\n\t\t\t\tlet p = (cur.p + prev.p) / 2;\n\t\t\t\tlet color = colorRange(p);\n\t\t\t\tmaxDelta = Math.max(maxDelta, deltaE(color, prev.color), deltaE(color, cur.color));\n\t\t\t\tret.splice(i, 0, {p, color: colorRange(p)});\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n\n\tret = ret.map(a => a.color);\n\n\treturn ret;\n}\n\n/**\n * Interpolate to color2 and return a function that takes a 0-1 percentage\n * @param {Color | string | Function} color1 The first color or an existing range\n * @param {Color | string} [color2] If color1 is a color, this is the second color\n * @param {Object} [options={}]\n * @returns {Function} A function that takes a 0-1 percentage and returns a color\n */\nexport function range (color1, color2, options = {}) {\n\tif (isRange(color1)) {\n\t\t// Tweaking existing range\n\t\tlet [r, options] = [color1, color2];\n\n\t\treturn range(...r.rangeArgs.colors, {...r.rangeArgs.options, ...options});\n\t}\n\n\tlet {space, outputSpace, progression, premultiplied} = options;\n\n\tcolor1 = getColor(color1);\n\tcolor2 = getColor(color2);\n\n\t// Make sure we're working on copies of these colors\n\tcolor1 = clone(color1);\n\tcolor2 = clone(color2);\n\n\tlet rangeArgs = {colors: [color1, color2], options};\n\n\tif (space) {\n\t\tspace = ColorSpace.get(space);\n\t}\n\telse {\n\t\tspace = ColorSpace.registry[defaults.interpolationSpace] || color1.space;\n\t}\n\n\toutputSpace = outputSpace ? ColorSpace.get(outputSpace) : space;\n\n\tcolor1 = to(color1, space);\n\tcolor2 = to(color2, space);\n\n\t// Gamut map to avoid areas of flat color\n\tcolor1 = toGamut(color1);\n\tcolor2 = toGamut(color2);\n\n\t// Handle hue interpolation\n\t// See https://github.com/w3c/csswg-drafts/issues/4735#issuecomment-635741840\n\tif (space.coords.h && space.coords.h.type === \"angle\") {\n\t\tlet arc = options.hue = options.hue || \"shorter\";\n\n\t\tlet hue = [space, \"h\"];\n\t\tlet [1, 2] = [get(color1, hue), get(color2, hue)];\n\t\t// Undefined hues must be evaluated before hue fix-up to properly\n\t\t// calculate hue arcs between undefined and defined hues.\n\t\t// See https://github.com/w3c/csswg-drafts/issues/9436#issuecomment-1746957545\n\t\tif (isNaN(1) && !isNaN(2)) {\n\t\t\t1 = 2;\n\t\t}\n\t\telse if (isNaN(2) && !isNaN(1)) {\n\t\t\t2 = 1;\n\t\t}\n\t\t[1, 2] = angles.adjust(arc, [1, 2]);\n\t\tset(color1, hue, 1);\n\t\tset(color2, hue, 2);\n\t}\n\n\tif (premultiplied) {\n\t\t// not coping with polar spaces yet\n\t\tcolor1.coords = color1.coords.map(c => c * color1.alpha);\n\t\tcolor2.coords = color2.coords.map(c => c * color2.alpha);\n\t}\n\n\treturn Object.assign(p => {\n\t\tp = progression ? progression(p) : p;\n\t\tlet coords = color1.coords.map((start, i) => {\n\t\t\tlet end = color2.coords[i];\n\t\t\treturn interpolate(start, end, p);\n\t\t});\n\n\t\tlet alpha = interpolate(color1.alpha, color2.alpha, p);\n\t\tlet ret = {space, coords, alpha};\n\n\t\tif (premultiplied) {\n\t\t\t// undo premultiplication\n\t\t\tret.coords = ret.coords.map(c => c / alpha);\n\t\t}\n\n\t\tif (outputSpace !== space) {\n\t\t\tret = to(ret, outputSpace);\n\t\t}\n\n\t\treturn ret;\n\t}, {\n\t\trangeArgs,\n\t});\n}\n\nexport function isRange (val) {\n\treturn type(val) === \"function\" && !!val.rangeArgs;\n}\n\ndefaults.interpolationSpace = \"lab\";\n\nexport function register (Color) {\n\tColor.defineFunction(\"mix\", mix, {returns: \"color\"});\n\tColor.defineFunction(\"range\", range, {returns: \"function<color>\"});\n\tColor.defineFunction(\"steps\", steps, {returns: \"array<color>\"});\n}\n","import ColorSpace from \"../space.js\";\nimport sRGB from \"./srgb.js\";\n\nexport default new ColorSpace({\n\tid: \"hsl\",\n\tname: \"HSL\",\n\tcoords: {\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t\ts: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Saturation\",\n\t\t},\n\t\tl: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t},\n\n\tbase: sRGB,\n\n\t// Adapted from https://drafts.csswg.org/css-color-4/better-rgbToHsl.js\n\tfromBase: rgb => {\n\t\tlet max = Math.max(...rgb);\n\t\tlet min = Math.min(...rgb);\n\t\tlet [r, g, b] = rgb;\n\t\tlet [h, s, l] = [NaN, 0, (min + max) / 2];\n\t\tlet d = max - min;\n\n\t\tif (d !== 0) {\n\t\t\ts = (l === 0 || l === 1) ? 0 : (max - l) / Math.min(l, 1 - l);\n\n\t\t\tswitch (max) {\n\t\t\t\tcase r: h = (g - b) / d + (g < b ? 6 : 0); break;\n\t\t\t\tcase g: h = (b - r) / d + 2; break;\n\t\t\t\tcase b: h = (r - g) / d + 4;\n\t\t\t}\n\n\t\t\th = h * 60;\n\t\t}\n\n\t\t// Very out of gamut colors can produce negative saturation\n\t\t// If so, just rotate the hue by 180 and use a positive saturation\n\t\t// see https://github.com/w3c/csswg-drafts/issues/9222\n\t\tif (s < 0) {\n\t\t\th += 180;\n\t\t\ts = Math.abs(s);\n\t\t}\n\n\t\tif (h >= 360) {\n\t\t\th -= 360;\n\t\t}\n\n\t\treturn [h, s * 100, l * 100];\n\t},\n\n\t// Adapted from https://en.wikipedia.org/wiki/HSL_and_HSV#HSL_to_RGB_alternative\n\ttoBase: hsl => {\n\t\tlet [h, s, l] = hsl;\n\t\th = h % 360;\n\n\t\tif (h < 0) {\n\t\t\th += 360;\n\t\t}\n\n\t\ts /= 100;\n\t\tl /= 100;\n\n\t\tfunction f (n) {\n\t\t\tlet k = (n + h / 30) % 12;\n\t\t\tlet a = s * Math.min(l, 1 - l);\n\t\t\treturn l - a * Math.max(-1, Math.min(k - 3, 9 - k, 1));\n\t\t}\n\n\t\treturn [f(0), f(8), f(4)];\n\t},\n\n\tformats: {\n\t\t\"hsl\": {\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage>\", \"<percentage>\"],\n\t\t},\n\t\t\"hsla\": {\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage>\", \"<percentage>\"],\n\t\t\tcommas: true,\n\t\t\tlastAlpha: true,\n\t\t},\n\t},\n});\n","import ColorSpace from \"../space.js\";\nimport HSL from \"./hsl.js\";\n\n// The Hue, Whiteness Blackness (HWB) colorspace\n// See https://drafts.csswg.org/css-color-4/#the-hwb-notation\n// Note that, like HSL, calculations are done directly on\n// gamma-corrected sRGB values rather than linearising them first.\n\nexport default new ColorSpace({\n\tid: \"hsv\",\n\tname: \"HSV\",\n\tcoords: {\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t\ts: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Saturation\",\n\t\t},\n\t\tv: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Value\",\n\t\t},\n\t},\n\n\tbase: HSL,\n\t// https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion\n\tfromBase (hsl) {\n\t\tlet [h, s, l] = hsl;\n\t\ts /= 100;\n\t\tl /= 100;\n\n\t\tlet v = l + s * Math.min(l, 1 - l);\n\n\t\treturn [\n\t\t\th, // h is the same\n\t\t\tv === 0 ? 0 : 200 * (1 - l / v), // s\n\t\t\t100 * v,\n\t\t];\n\t},\n\t// https://en.wikipedia.org/wiki/HSL_and_HSV#Interconversion\n\ttoBase (hsv) {\n\t\tlet [h, s, v] = hsv;\n\n\t\ts /= 100;\n\t\tv /= 100;\n\n\t\tlet l = v * (1 - s / 2);\n\n\t\treturn [\n\t\t\th, // h is the same\n\t\t\t(l === 0 || l === 1) ? 0 : ((v - l) / Math.min(l, 1 - l)) * 100,\n\t\t\tl * 100,\n\t\t];\n\t},\n\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"--hsv\",\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage> | <number>\", \"<percentage> | <number>\"],\n\t\t},\n\t},\n});\n","import ColorSpace from \"../space.js\";\nimport HSV from \"./hsv.js\";\n\n// The Hue, Whiteness Blackness (HWB) colorspace\n// See https://drafts.csswg.org/css-color-4/#the-hwb-notation\n// Note that, like HSL, calculations are done directly on\n// gamma-corrected sRGB values rather than linearising them first.\n\nexport default new ColorSpace({\n\tid: \"hwb\",\n\tname: \"HWB\",\n\tcoords: {\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t\tw: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Whiteness\",\n\t\t},\n\t\tb: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Blackness\",\n\t\t},\n\t},\n\n\tbase: HSV,\n\tfromBase (hsv) {\n\t\tlet [h, s, v] = hsv;\n\n\t\treturn [h, v * (100 - s) / 100, 100 - v];\n\t},\n\ttoBase (hwb) {\n\t\tlet [h, w, b] = hwb;\n\n\t\t// Now convert percentages to [0..1]\n\t\tw /= 100;\n\t\tb /= 100;\n\n\t\t// Achromatic check (white plus black >= 1)\n\t\tlet sum = w + b;\n\t\tif (sum >= 1) {\n\t\t\tlet gray = w / sum;\n\t\t\treturn [h, 0, gray * 100];\n\t\t}\n\n\t\tlet v = (1 - b);\n\t\tlet s = (v === 0) ? 0 : 1 - w / v;\n\t\treturn [h, s * 100, v * 100];\n\t},\n\n\tformats: {\n\t\t\"hwb\": {\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage> | <number>\", \"<percentage> | <number>\"],\n\t\t},\n\t},\n});\n","import RGBColorSpace from \"../rgbspace.js\";\n\n// convert an array of linear-light a98-rgb values to CIE XYZ\n// http://www.brucelindbloom.com/index.html?Eqn_RGB_XYZ_Matrix.html\n// has greater numerical precision than section 4.3.5.3 of\n// https://www.adobe.com/digitalimag/pdfs/AdobeRGB1998.pdf\n// but the values below were calculated from first principles\n// from the chromaticity coordinates of R G B W\nconst toXYZ_M = [\n\t[ 0.5766690429101305,   0.1855582379065463,   0.1882286462349947  ],\n\t[ 0.29734497525053605,  0.6273635662554661,   0.07529145849399788 ],\n\t[ 0.02703136138641234,  0.07068885253582723,  0.9913375368376388  ],\n];\n\nconst fromXYZ_M = [\n\t[  2.0415879038107465,    -0.5650069742788596,   -0.34473135077832956 ],\n\t[ -0.9692436362808795,     1.8759675015077202,    0.04155505740717557 ],\n\t[  0.013444280632031142,  -0.11836239223101838,   1.0151749943912054  ],\n];\n\nexport default new RGBColorSpace({\n\tid: \"a98rgb-linear\",\n\tcssId: \"--a98-rgb-linear\",\n\tname: \"Linear Adobe 98 RGB compatible\",\n\twhite: \"D65\",\n\ttoXYZ_M,\n\tfromXYZ_M,\n});\n","import RGBColorSpace from \"../rgbspace.js\";\nimport A98Linear from \"./a98rgb-linear.js\";\n\nexport default new RGBColorSpace({\n\tid: \"a98rgb\",\n\tcssId: \"a98-rgb\",\n\tname: \"Adobe 98 RGB compatible\",\n\tbase: A98Linear,\n\ttoBase: RGB => RGB.map(val => Math.pow(Math.abs(val), 563 / 256) * Math.sign(val)),\n\tfromBase: RGB => RGB.map(val => Math.pow(Math.abs(val), 256 / 563) * Math.sign(val)),\n});\n","import RGBColorSpace from \"../rgbspace.js\";\nimport XYZ_D50 from \"./xyz-d50.js\";\n\n// convert an array of  prophoto-rgb values to CIE XYZ\n// using  D50 (so no chromatic adaptation needed afterwards)\n// matrix cannot be expressed in rational form, but is calculated to 64 bit accuracy\n// see https://github.com/w3c/csswg-drafts/issues/7675\nconst toXYZ_M = [\n\t[ 0.79776664490064230,  0.13518129740053308,  0.03134773412839220 ],\n\t[ 0.28807482881940130,  0.71183523424187300,  0.00008993693872564 ],\n\t[ 0.00000000000000000,  0.00000000000000000,  0.82510460251046020 ],\n];\n\nconst fromXYZ_M = [\n\t[  1.34578688164715830, -0.25557208737979464, -0.05110186497554526 ],\n\t[ -0.54463070512490190,  1.50824774284514680,  0.02052744743642139 ],\n\t[  0.00000000000000000,  0.00000000000000000,  1.21196754563894520 ],\n];\n\nexport default new RGBColorSpace({\n\tid: \"prophoto-linear\",\n\tcssId: \"--prophoto-rgb-linear\",\n\tname: \"Linear ProPhoto\",\n\twhite: \"D50\",\n\tbase: XYZ_D50,\n\ttoXYZ_M,\n\tfromXYZ_M,\n});\n","import RGBColorSpace from \"../rgbspace.js\";\nimport ProPhotoLinear from \"./prophoto-linear.js\";\n\nconst Et = 1 / 512;\nconst Et2 = 16 / 512;\n\nexport default new RGBColorSpace({\n\tid: \"prophoto\",\n\tcssId: \"prophoto-rgb\",\n\tname: \"ProPhoto\",\n\tbase: ProPhotoLinear,\n\ttoBase (RGB) {\n\t\t// Transfer curve is gamma 1.8 with a small linear portion\n\t\treturn RGB.map(v => v < Et2 ? v / 16 : v ** 1.8);\n\t},\n\tfromBase (RGB) {\n\t\treturn RGB.map(v => v >= Et ? v ** (1 / 1.8) : 16 * v);\n\t},\n});\n","import ColorSpace from \"../space.js\";\nimport OKLab from \"./oklab.js\";\nimport {constrain as constrainAngle} from \"../angles.js\";\n\nexport default new ColorSpace({\n\tid: \"oklch\",\n\tname: \"Oklch\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 1],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t\tc: {\n\t\t\trefRange: [0, 0.4],\n\t\t\tname: \"Chroma\",\n\t\t},\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t},\n\twhite: \"D65\",\n\n\tbase: OKLab,\n\tfromBase (oklab) {\n\t\t// Convert to polar form\n\t\tlet [L, a, b] = oklab;\n\t\tlet h;\n\t\tconst  = 0.0002; // chromatic components much smaller than a,b\n\n\t\tif (Math.abs(a) <  && Math.abs(b) < ) {\n\t\t\th = NaN;\n\t\t}\n\t\telse {\n\t\t\th = Math.atan2(b, a) * 180 / Math.PI;\n\t\t}\n\n\t\treturn [\n\t\t\tL, // OKLab L is still L\n\t\t\tMath.sqrt(a ** 2 + b ** 2), // Chroma\n\t\t\tconstrainAngle(h), // Hue, in degrees [0 to 360)\n\t\t];\n\t},\n\t// Convert from polar form\n\ttoBase (oklch) {\n\t\tlet [L, C, h] = oklch;\n\t\tlet a, b;\n\n\t\t// check for NaN hue\n\t\tif (isNaN(h)) {\n\t\t\ta = 0;\n\t\t\tb = 0;\n\t\t}\n\t\telse {\n\t\t\ta = C * Math.cos(h * Math.PI / 180);\n\t\t\tb = C * Math.sin(h * Math.PI / 180);\n\t\t}\n\n\t\treturn [ L, a, b ];\n\t},\n\n\tformats: {\n\t\t\"oklch\": {\n\t\t\tcoords: [\"<percentage> | <number>\", \"<number> | <percentage>[0,1]\", \"<number> | <angle>\"],\n\t\t},\n\t},\n});\n","import ColorSpace from \"../space.js\";\nimport {WHITES} from \"../adapt.js\";\nimport xyz_d65 from \"./xyz-d65.js\";\nimport {uv} from \"../chromaticity.js\";\nimport {isNone, skipNone} from \"../util.js\";\n\nlet white = WHITES.D65;\n\nconst  = 216 / 24389;  // 6^3/29^3 == (24/116)^3\nconst  = 24389 / 27;   // 29^3/3^3\nconst [U_PRIME_WHITE, V_PRIME_WHITE] = uv({space: xyz_d65, coords: white});\n\nexport default new ColorSpace({\n\tid: \"luv\",\n\tname: \"Luv\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t\t// Reference ranges from https://facelessuser.github.io/coloraide/colors/luv/\n\t\tu: {\n\t\t\trefRange: [-215, 215],\n\t\t},\n\t\tv: {\n\t\t\trefRange: [-215, 215],\n\t\t},\n\t},\n\n\twhite: white,\n\tbase: xyz_d65,\n\n\t// Convert D65-adapted XYZ to Luv\n\t// https://en.wikipedia.org/wiki/CIELUV#The_forward_transformation\n\tfromBase (XYZ) {\n\t\tlet xyz = [skipNone(XYZ[0]), skipNone(XYZ[1]), skipNone(XYZ[2])];\n\t\tlet y = xyz[1];\n\n\t\tlet [up, vp] = uv({space: xyz_d65, coords: xyz});\n\n\t\t// Protect against XYZ of [0, 0, 0]\n\t\tif (!Number.isFinite(up) || !Number.isFinite(vp)) {\n\t\t\treturn [0, 0, 0];\n\t\t}\n\n\t\tlet L = y <=  ?  * y : 116 * Math.cbrt(y) - 16;\n\t\treturn [\n\t\t\tL,\n\t\t\t13 * L * (up - U_PRIME_WHITE),\n\t\t\t13 * L * (vp - V_PRIME_WHITE),\n\t\t ];\n\t},\n\n\t// Convert Luv to D65-adapted XYZ\n\t// https://en.wikipedia.org/wiki/CIELUV#The_reverse_transformation\n\ttoBase (Luv) {\n\t\tlet [L, u, v] = Luv;\n\n\t\t// Protect against division by zero and NaN Lightness\n\t\tif (L === 0 || isNone(L)) {\n\t\t\treturn [0, 0, 0];\n\t\t}\n\n\t\tu = skipNone(u);\n\t\tv = skipNone(v);\n\n\t\tlet up = (u / (13 * L)) + U_PRIME_WHITE;\n\t\tlet vp = (v / (13 * L)) + V_PRIME_WHITE;\n\n\t\tlet y = L <= 8 ? L /  : Math.pow((L + 16) / 116, 3);\n\n\t\treturn [\n\t\t\ty * ((9 * up) / (4 * vp)),\n\t\t\ty,\n\t\t\ty * ((12 - 3 * up - 20 * vp) / (4 * vp)),\n\t\t];\n\t},\n\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"--luv\",\n\t\t\tcoords: [\"<number> | <percentage>\", \"<number> | <percentage>[-1,1]\", \"<number> | <percentage>[-1,1]\"],\n\t\t},\n\t},\n});\n","import ColorSpace from \"../space.js\";\nimport Luv from \"./luv.js\";\nimport {constrain as constrainAngle} from \"../angles.js\";\n\nexport default new ColorSpace({\n\tid: \"lchuv\",\n\tname: \"LChuv\",\n\tcoords: {\n\t\tl: {\n\t\t\trefRange: [0, 100],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t\tc: {\n\t\t\trefRange: [0, 220],\n\t\t\tname: \"Chroma\",\n\t\t},\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t},\n\n\tbase: Luv,\n\tfromBase (Luv) {\n\t\t// Convert to polar form\n\t\tlet [L, u, v] = Luv;\n\t\tlet hue;\n\t\tconst  = 0.02;\n\n\t\tif (Math.abs(u) <  && Math.abs(v) < ) {\n\t\t\thue = NaN;\n\t\t}\n\t\telse {\n\t\t\thue = Math.atan2(v, u) * 180 / Math.PI;\n\t\t}\n\n\t\treturn [\n\t\t\tL, // L is still L\n\t\t\tMath.sqrt(u ** 2 + v ** 2), // Chroma\n\t\t\tconstrainAngle(hue), // Hue, in degrees [0 to 360)\n\t\t];\n\t},\n\ttoBase (LCH) {\n\t\t// Convert from polar form\n\t\tlet [Lightness, Chroma, Hue] = LCH;\n\t\t// Clamp any negative Chroma\n\t\tif (Chroma < 0) {\n\t\t\tChroma = 0;\n\t\t}\n\t\t// Deal with NaN Hue\n\t\tif (isNaN(Hue)) {\n\t\t\tHue = 0;\n\t\t}\n\t\treturn [\n\t\t\tLightness, // L is still L\n\t\t\tChroma * Math.cos(Hue * Math.PI / 180), // u\n\t\t\tChroma * Math.sin(Hue * Math.PI / 180),  // v\n\t\t];\n\t},\n\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"--lchuv\",\n\t\t\tcoords: [\"<number> | <percentage>\", \"<number> | <percentage>\", \"<number> | <angle>\"],\n\t\t},\n\t},\n});\n","/*\nAdapted from: https://github.com/hsluv/hsluv-javascript/blob/14b49e6cf9a9137916096b8487a5372626b57ba4/src/hsluv.ts\n\nCopyright (c) 2012-2022 Alexei Boronine\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nimport ColorSpace from \"../space.js\";\nimport LCHuv from \"./lchuv.js\";\nimport sRGB from \"./srgb.js\";\nimport {fromXYZ_M} from \"./srgb-linear.js\";\nimport {skipNone} from \"../util.js\";\n\nconst  = 216 / 24389;  // 6^3/29^3 == (24/116)^3\nconst  = 24389 / 27;   // 29^3/3^3\n\nconst m_r0 = fromXYZ_M[0][0];\nconst m_r1 = fromXYZ_M[0][1];\nconst m_r2 = fromXYZ_M[0][2];\nconst m_g0 = fromXYZ_M[1][0];\nconst m_g1 = fromXYZ_M[1][1];\nconst m_g2 = fromXYZ_M[1][2];\nconst m_b0 = fromXYZ_M[2][0];\nconst m_b1 = fromXYZ_M[2][1];\nconst m_b2 = fromXYZ_M[2][2];\n\nfunction distanceFromOriginAngle (slope, intercept, angle) {\n\tconst d = intercept / (Math.sin(angle) - slope * Math.cos(angle));\n\treturn d < 0 ? Infinity : d;\n}\n\nexport function calculateBoundingLines (l) {\n\tconst sub1 = Math.pow(l + 16, 3) / 1560896;\n\tconst sub2 = sub1 >  ? sub1 : l / ;\n\tconst s1r = sub2 * (284517 * m_r0 - 94839 * m_r2);\n\tconst s2r = sub2 * (838422 * m_r2 + 769860 * m_r1 + 731718 * m_r0);\n\tconst s3r = sub2 * (632260 * m_r2 - 126452 * m_r1);\n\tconst s1g = sub2 * (284517 * m_g0 - 94839 * m_g2);\n\tconst s2g = sub2 * (838422 * m_g2 + 769860 * m_g1 + 731718 * m_g0);\n\tconst s3g = sub2 * (632260 * m_g2 - 126452 * m_g1);\n\tconst s1b = sub2 * (284517 * m_b0 - 94839 * m_b2);\n\tconst s2b = sub2 * (838422 * m_b2 + 769860 * m_b1 + 731718 * m_b0);\n\tconst s3b = sub2 * (632260 * m_b2 - 126452 * m_b1);\n\n\treturn {\n\t\tr0s: s1r / s3r,\n\t\tr0i: s2r * l / s3r,\n\t\tr1s: s1r / (s3r + 126452),\n\t\tr1i: (s2r - 769860) * l / (s3r + 126452),\n\t\tg0s: s1g / s3g,\n\t\tg0i: s2g * l / s3g,\n\t\tg1s: s1g / (s3g + 126452),\n\t\tg1i: (s2g - 769860) * l / (s3g + 126452),\n\t\tb0s: s1b / s3b,\n\t\tb0i: s2b * l / s3b,\n\t\tb1s: s1b / (s3b + 126452),\n\t\tb1i: (s2b - 769860) * l / (s3b + 126452),\n\t};\n}\n\nfunction calcMaxChromaHsluv (lines, h) {\n\tconst hueRad = h / 360 * Math.PI * 2;\n\tconst r0 = distanceFromOriginAngle(lines.r0s, lines.r0i, hueRad);\n\tconst r1 = distanceFromOriginAngle(lines.r1s, lines.r1i, hueRad);\n\tconst g0 = distanceFromOriginAngle(lines.g0s, lines.g0i, hueRad);\n\tconst g1 = distanceFromOriginAngle(lines.g1s, lines.g1i, hueRad);\n\tconst b0 = distanceFromOriginAngle(lines.b0s, lines.b0i, hueRad);\n\tconst b1 = distanceFromOriginAngle(lines.b1s, lines.b1i, hueRad);\n\n\treturn Math.min(r0, r1, g0, g1, b0, b1);\n}\n\nexport default new ColorSpace({\n\tid: \"hsluv\",\n\tname: \"HSLuv\",\n\tcoords: {\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t\ts: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Saturation\",\n\t\t},\n\t\tl: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t},\n\n\tbase: LCHuv,\n\tgamutSpace: sRGB,\n\n\t// Convert LCHuv to HSLuv\n\tfromBase (lch) {\n\t\tlet [l, c, h] = [skipNone(lch[0]), skipNone(lch[1]), skipNone(lch[2])];\n\t\tlet s;\n\n\t\tif (l > 99.9999999) {\n\t\t\ts = 0;\n\t\t\tl = 100;\n\t\t}\n\t\telse if (l < 0.00000001) {\n\t\t\ts = 0;\n\t\t\tl = 0;\n\t\t}\n\t\telse {\n\t\t\tlet lines = calculateBoundingLines(l);\n\t\t\tlet max = calcMaxChromaHsluv(lines, h);\n\t\t\ts = c / max * 100;\n\t\t}\n\n\t\treturn [h, s, l];\n\t},\n\n\t// Convert HSLuv to LCHuv\n\ttoBase (hsl) {\n\t\tlet [h, s, l] = [skipNone(hsl[0]), skipNone(hsl[1]), skipNone(hsl[2])];\n\t\tlet c;\n\n\t\tif (l > 99.9999999) {\n\t\t\tl = 100;\n\t\t\tc = 0;\n\t\t}\n\t\telse if (l < 0.00000001) {\n\t\t\tl = 0;\n\t\t\tc = 0;\n\t\t}\n\t\telse {\n\t\t\tlet lines = calculateBoundingLines(l);\n\t\t\tlet max = calcMaxChromaHsluv(lines, h);\n\t\t\tc = max / 100 * s;\n\t\t}\n\n\t\treturn [l, c, h];\n\t},\n\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"--hsluv\",\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage> | <number>\", \"<percentage> | <number>\"],\n\t\t},\n\t},\n});\n","/*\nAdapted from: https://github.com/hsluv/hsluv-javascript/blob/14b49e6cf9a9137916096b8487a5372626b57ba4/src/hsluv.ts\n\nCopyright (c) 2012-2022 Alexei Boronine\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n*/\n\nimport ColorSpace from \"../space.js\";\nimport LCHuv from \"./lchuv.js\";\nimport {fromXYZ_M} from \"./srgb-linear.js\";\nimport {skipNone} from \"../util.js\";\nimport {calculateBoundingLines} from \"./hsluv.js\";\n\nconst  = 216 / 24389;  // 6^3/29^3 == (24/116)^3\nconst  = 24389 / 27;   // 29^3/3^3\n\nconst m_r0 = fromXYZ_M[0][0];\nconst m_r1 = fromXYZ_M[0][1];\nconst m_r2 = fromXYZ_M[0][2];\nconst m_g0 = fromXYZ_M[1][0];\nconst m_g1 = fromXYZ_M[1][1];\nconst m_g2 = fromXYZ_M[1][2];\nconst m_b0 = fromXYZ_M[2][0];\nconst m_b1 = fromXYZ_M[2][1];\nconst m_b2 = fromXYZ_M[2][2];\n\nfunction distanceFromOrigin (slope, intercept) {\n\treturn Math.abs(intercept) / Math.sqrt(Math.pow(slope, 2) + 1);\n}\n\nfunction calcMaxChromaHpluv (lines) {\n\tlet r0 = distanceFromOrigin(lines.r0s, lines.r0i);\n\tlet r1 = distanceFromOrigin(lines.r1s, lines.r1i);\n\tlet g0 = distanceFromOrigin(lines.g0s, lines.g0i);\n\tlet g1 = distanceFromOrigin(lines.g1s, lines.g1i);\n\tlet b0 = distanceFromOrigin(lines.b0s, lines.b0i);\n\tlet b1 = distanceFromOrigin(lines.b1s, lines.b1i);\n\n\treturn Math.min(r0, r1, g0, g1, b0, b1);\n}\n\nexport default new ColorSpace({\n\tid: \"hpluv\",\n\tname: \"HPLuv\",\n\tcoords: {\n\t\th: {\n\t\t\trefRange: [0, 360],\n\t\t\ttype: \"angle\",\n\t\t\tname: \"Hue\",\n\t\t},\n\t\ts: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Saturation\",\n\t\t},\n\t\tl: {\n\t\t\trange: [0, 100],\n\t\t\tname: \"Lightness\",\n\t\t},\n\t},\n\n\tbase: LCHuv,\n\tgamutSpace: \"self\",\n\n\t// Convert LCHuv to HPLuv\n\tfromBase (lch) {\n\t\tlet [l, c, h] = [skipNone(lch[0]), skipNone(lch[1]), skipNone(lch[2])];\n\t\tlet s;\n\n\t\tif (l > 99.9999999) {\n\t\t\ts = 0;\n\t\t\tl = 100;\n\t\t}\n\t\telse if (l < 0.00000001) {\n\t\t\ts = 0;\n\t\t\tl = 0;\n\t\t}\n\t\telse {\n\t\t\tlet lines = calculateBoundingLines(l);\n\t\t\tlet max = calcMaxChromaHpluv(lines);\n\t\t\ts = c / max * 100;\n\t\t}\n\t\treturn [h, s, l];\n\t},\n\n\t// Convert HPLuv to LCHuv\n\ttoBase (hsl) {\n\t\tlet [h, s, l] = [skipNone(hsl[0]), skipNone(hsl[1]), skipNone(hsl[2])];\n\t\tlet c;\n\n\t\tif (l > 99.9999999) {\n\t\t\tl = 100;\n\t\t\tc = 0;\n\t\t}\n\t\telse if (l < 0.00000001) {\n\t\t\tl = 0;\n\t\t\tc = 0;\n\t\t}\n\t\telse {\n\t\t\tlet lines = calculateBoundingLines(l);\n\t\t\tlet max = calcMaxChromaHpluv(lines, h);\n\t\t\tc = max / 100 * s;\n\t\t}\n\n\t\treturn [l, c, h];\n\t},\n\n\tformats: {\n\t\tcolor: {\n\t\t\tid: \"--hpluv\",\n\t\t\tcoords: [\"<number> | <angle>\", \"<percentage> | <number>\", \"<percentage> | <number>\"],\n\t\t},\n\t},\n});\n","import RGBColorSpace from \"../rgbspace.js\";\nimport REC2020Linear from \"./rec2020-linear.js\";\n\nconst Yw = 203;\t// absolute luminance of media white, cd/m\nconst n = 2610 / (2 ** 14);\nconst ninv = (2 ** 14) / 2610;\nconst m = 2523 / (2 ** 5);\nconst minv = (2 ** 5) / 2523;\nconst c1 = 3424 / (2 ** 12);\nconst c2 = 2413 / (2 ** 7);\nconst c3 = 2392 / (2 ** 7);\n\nexport default new RGBColorSpace({\n\tid: \"rec2100pq\",\n\tcssId: \"rec2100-pq\",\n\tname: \"REC.2100-PQ\",\n\tbase: REC2020Linear,\n\ttoBase (RGB) {\n\t\t// given PQ encoded component in range [0, 1]\n\t\t// return media-white relative linear-light\n\t\treturn RGB.map(function (val) {\n\t\t\tlet x = ((Math.max(((val ** minv) - c1), 0) / (c2 - (c3 * (val ** minv)))) ** ninv);\n\t\t\treturn (x * 10000 / Yw); \t// luminance relative to diffuse white, [0, 70 or so].\n\t\t});\n\t},\n\tfromBase (RGB) {\n\t\t// given media-white relative linear-light\n\t\t// returnPQ encoded component in range [0, 1]\n\t\treturn RGB.map(function (val) {\n\t\t\tlet x = Math.max(val * Yw / 10000, 0); \t// absolute luminance of peak white is 10,000 cd/m.\n\t\t\tlet num = (c1 + (c2 * (x ** n)));\n\t\t\tlet denom = (1 + (c3 * (x ** n)));\n\n\t\t\treturn ((num / denom)  ** m);\n\t\t});\n\t},\n});\n","import RGBColorSpace from \"../rgbspace.js\";\nimport REC2020Linear from \"./rec2020-linear.js\";\n\n// FIXME see https://github.com/LeaVerou/color.js/issues/190\n\nconst a = 0.17883277;\nconst b = 0.28466892; // 1 - (4 * a)\nconst c = 0.55991073; // 0.5 - a * Math.log(4 *a)\n\nconst scale = 3.7743;\t// Place 18% grey at HLG 0.38, so media white at 0.75\n\nexport default new RGBColorSpace({\n\tid: \"rec2100hlg\",\n\tcssId: \"rec2100-hlg\",\n\tname: \"REC.2100-HLG\",\n\treferred: \"scene\",\n\n\tbase: REC2020Linear,\n\ttoBase (RGB) {\n\t\t// given HLG encoded component in range [0, 1]\n\t\t// return media-white relative linear-light\n\t\treturn RGB.map(function (val) {\n\t\t\t// first the HLG EOTF\n\t\t\t// ITU-R BT.2390-10 p.30 section\n\t\t\t// 6.3 The hybrid log-gamma electro-optical transfer function (EOTF)\n\t\t\t// Then scale by 3 so media white is 1.0\n\t\t\tif (val <= 0.5) {\n\t\t\t\treturn (val ** 2) / 3 * scale;\n\t\t\t}\n\t\t\treturn ((Math.exp((val - c) / a) + b) / 12) * scale;\n\t\t});\n\t},\n\tfromBase (RGB) {\n\t\t// given media-white relative linear-light\n\t\t// where diffuse white is 1.0,\n\t\t// return HLG encoded component in range [0, 1]\n\t\treturn RGB.map(function (val) {\n\t\t\t// first scale to put linear-light media white at 1/3\n\t\t\tval /= scale;\n\t\t\t// now the HLG OETF\n\t\t\t// ITU-R BT.2390-10 p.23\n\t\t\t// 6.1 The hybrid log-gamma opto-electronic transfer function (OETF)\n\t\t\tif (val <= 1 / 12) {\n\t\t\t\treturn Math.sqrt(3 * val);\n\t\t\t}\n\t\t\treturn a * Math.log(12 * val - b) + c;\n\t\t});\n\t},\n});\n","import hooks from \"./hooks.js\";\nimport {multiplyMatrices} from \"./util.js\";\nimport {WHITES} from \"./adapt.js\";\n\nexport const CATs = {};\n\nhooks.add(\"chromatic-adaptation-start\", env => {\n\tif (env.options.method) {\n\t\tenv.M = adapt(env.W1, env.W2, env.options.method);\n\t}\n});\n\nhooks.add(\"chromatic-adaptation-end\", env => {\n\tif (!env.M) {\n\t\tenv.M = adapt(env.W1, env.W2, env.options.method);\n\t}\n});\n\nexport function defineCAT ({id, toCone_M, fromCone_M}) {\n\t// Use id, toCone_M, fromCone_M like variables\n\tCATs[id] = arguments[0];\n}\n\nexport function adapt (W1, W2, id = \"Bradford\") {\n\t// adapt from a source whitepoint or illuminant W1\n\t// to a destination whitepoint or illuminant W2,\n\t// using the given chromatic adaptation transform (CAT)\n\t// debugger;\n\tlet method = CATs[id];\n\n\tlet [s, s, s] = multiplyMatrices(method.toCone_M, W1);\n\tlet [d, d, d] = multiplyMatrices(method.toCone_M, W2);\n\n\t// all practical illuminants have non-zero XYZ so no division by zero can occur below\n\tlet scale = [\n\t\t[d / s,  0,        0      ],\n\t\t[0,        d / s,  0      ],\n\t\t[0,        0,        d / s],\n\t];\n\t// console.log({scale});\n\n\tlet scaled_cone_M = multiplyMatrices(scale, method.toCone_M);\n\tlet adapt_M\t= multiplyMatrices(method.fromCone_M, scaled_cone_M);\n\t// console.log({scaled_cone_M, adapt_M});\n\treturn adapt_M;\n}\n\ndefineCAT({\n\tid: \"von Kries\",\n\ttoCone_M: [\n\t\t[  0.4002400,  0.7076000, -0.0808100 ],\n\t\t[ -0.2263000,  1.1653200,  0.0457000 ],\n\t\t[  0.0000000,  0.0000000,  0.9182200 ],\n\t],\n\tfromCone_M: [\n\t\t[ 1.8599363874558397, -1.1293816185800916,   0.21989740959619328     ],\n\t\t[ 0.3611914362417676,  0.6388124632850422,  -0.000006370596838649899 ],\n\t\t[ 0,                   0,                    1.0890636230968613      ],\n\t],\n});\n\ndefineCAT({\n\tid: \"Bradford\",\n\t// Convert an array of XYZ values in the range 0.0 - 1.0\n\t// to cone fundamentals\n\ttoCone_M: [\n\t\t[  0.8951000,  0.2664000, -0.1614000 ],\n\t\t[ -0.7502000,  1.7135000,  0.0367000 ],\n\t\t[  0.0389000, -0.0685000,  1.0296000 ],\n\t],\n\t// and back\n\tfromCone_M: [\n\t\t[  0.9869929054667121, -0.14705425642099013, 0.15996265166373122  ],\n\t\t[  0.4323052697233945,  0.5183602715367774,  0.049291228212855594 ],\n\t\t[ -0.00852866457517732, 0.04004282165408486, 0.96848669578755     ],\n\t],\n});\n\ndefineCAT({\n\tid: \"CAT02\",\n\t// with complete chromatic adaptation to W2, so D = 1.0\n\ttoCone_M: [\n\t\t[  0.7328000,  0.4296000, -0.1624000 ],\n\t\t[ -0.7036000,  1.6975000,  0.0061000 ],\n\t\t[  0.0030000,  0.0136000,  0.9834000 ],\n\t],\n\tfromCone_M: [\n\t\t[  1.0961238208355142,   -0.27886900021828726, 0.18274517938277307 ],\n\t\t[  0.4543690419753592,    0.4735331543074117,  0.07209780371722911 ],\n\t\t[ -0.009627608738429355, -0.00569803121611342, 1.0153256399545427  ],\n\t],\n});\n\ndefineCAT({\n\tid: \"CAT16\",\n\ttoCone_M: [\n\t\t[  0.401288,  0.650173, -0.051461 ],\n\t\t[ -0.250268,  1.204414,  0.045854 ],\n\t\t[ -0.002079,  0.048952,  0.953127 ],\n\t],\n\t// the extra precision is needed to avoid roundtripping errors\n\tfromCone_M: [\n\t\t[  1.862067855087233,   -1.0112546305316845,  0.14918677544445172  ],\n\t\t[  0.3875265432361372,   0.6214474419314753, -0.008973985167612521 ],\n\t\t[ -0.01584149884933386, -0.03412293802851557, 1.0499644368778496   ],\n\t],\n});\n\nObject.assign(WHITES, {\n\t// whitepoint values from ASTM E308-01 with 10nm spacing, 1931 2 degree observer\n\t// all normalized to Y (luminance) = 1.00000\n\t// Illuminant A is a tungsten electric light, giving a very warm, orange light.\n\tA:   [1.09850, 1.00000, 0.35585],\n\n\t// Illuminant C was an early approximation to daylight: illuminant A with a blue filter.\n\tC:   [0.98074, 1.000000, 1.18232],\n\n\t// The daylight series of illuminants simulate natural daylight.\n\t// The color temperature (in degrees Kelvin/100) ranges from\n\t// cool, overcast daylight (D50) to bright, direct sunlight (D65).\n\tD55: [0.95682, 1.00000, 0.92149],\n\tD75: [0.94972, 1.00000, 1.22638],\n\n\t// Equal-energy illuminant, used in two-stage CAT16\n\tE:   [1.00000, 1.00000, 1.00000],\n\n\t// The F series of illuminants represent fluorescent lights\n\tF2:  [0.99186, 1.00000, 0.67393],\n\tF7:  [0.95041, 1.00000, 1.08747],\n\tF11: [1.00962, 1.00000, 0.64350],\n});\n","import RGBColorSpace from \"../rgbspace.js\";\nimport {WHITES} from \"../adapt.js\";\nimport \"../CATs.js\"; // because of the funky whitepoint\n\n// The ACES whitepoint\n// see TB-2018-001 Derivation of the ACES White Point CIE Chromaticity Coordinates\n// also https://github.com/ampas/aces-dev/blob/master/documents/python/TB-2018-001/aces_wp.py\n// Similar to D60\nWHITES.ACES = [0.32168 / 0.33767, 1.00000, (1.00000 - 0.32168 - 0.33767) / 0.33767];\n\n// convert an array of linear-light ACEScc values to CIE XYZ\nconst toXYZ_M = [\n\t[  0.6624541811085053,   0.13400420645643313,  0.1561876870049078  ],\n\t[  0.27222871678091454,  0.6740817658111484,   0.05368951740793705 ],\n\t[ -0.005574649490394108, 0.004060733528982826, 1.0103391003129971  ],\n];\nconst fromXYZ_M = [\n\t[  1.6410233796943257,   -0.32480329418479,    -0.23642469523761225  ],\n\t[ -0.6636628587229829,    1.6153315916573379,   0.016756347685530137 ],\n\t[  0.011721894328375376, -0.008284441996237409, 0.9883948585390215   ],\n];\n\nexport default new RGBColorSpace({\n\tid: \"acescg\",\n\tcssId: \"--acescg\",\n\tname: \"ACEScg\",\n\n\t// ACEScg  A scene-referred, linear-light encoding of ACES Data\n\t// https://docs.acescentral.com/specifications/acescg/\n\t// uses the AP1 primaries, see section 4.3.1 Color primaries\n\tcoords: {\n\t\tr: {\n\t\t\trange: [0, 65504],\n\t\t\tname: \"Red\",\n\t\t},\n\t\tg: {\n\t\t\trange: [0, 65504],\n\t\t\tname: \"Green\",\n\t\t},\n\t\tb: {\n\t\t\trange: [0, 65504],\n\t\t\tname: \"Blue\",\n\t\t},\n\t},\n\n\treferred: \"scene\",\n\n\twhite: WHITES.ACES,\n\n\ttoXYZ_M,\n\tfromXYZ_M,\n});\n\n// export default Color;\n","import RGBColorSpace from \"../rgbspace.js\";\nimport \"../CATs.js\"; // because of the funky whitepoint\nimport ACEScg from \"./acescg.js\";\n\nconst  = 2 ** -16;\n\n// the smallest value which, in the 32bit IEEE 754 float encoding,\n// decodes as a non-negative value\nconst ACES_min_nonzero = -0.35828683;\n\n// brightest encoded value, decodes to 65504\nconst ACES_cc_max = (Math.log2(65504) + 9.72) / 17.52; // 1.468\n\nexport default new RGBColorSpace({\n\tid: \"acescc\",\n\tcssId: \"--acescc\",\n\tname: \"ACEScc\",\n\t// see S-2014-003 ACEScc  A Logarithmic Encoding of ACES Data\n\t// https://docs.acescentral.com/specifications/acescc/\n\t// uses the AP1 primaries, see section 4.3.1 Color primaries\n\n\t// Appendix A: \"Very small ACES scene referred values below 7 1/4 stops\n\t// below 18% middle gray are encoded as negative ACEScc values.\n\t// These values should be preserved per the encoding in Section 4.4\n\t// so that all positive ACES values are maintained.\"\n\tcoords: {\n\t\tr: {\n\t\t\trange: [ACES_min_nonzero, ACES_cc_max],\n\t\t\tname: \"Red\",\n\t\t},\n\t\tg: {\n\t\t\trange: [ACES_min_nonzero, ACES_cc_max],\n\t\t\tname: \"Green\",\n\t\t},\n\t\tb: {\n\t\t\trange: [ACES_min_nonzero, ACES_cc_max],\n\t\t\tname: \"Blue\",\n\t\t},\n\t},\n\treferred: \"scene\",\n\n\tbase: ACEScg,\n\t// from section 4.4.2 Decoding Function\n\ttoBase (RGB) {\n\t\tconst low = (9.72 - 15) / 17.52; // -0.3014\n\n\t\treturn RGB.map(function (val) {\n\t\t\tif (val <= low) {\n\t\t\t\treturn (2 ** ((val * 17.52) - 9.72) - ) * 2; // very low values, below -0.3014\n\t\t\t}\n\t\t\telse if (val < ACES_cc_max) {\n\t\t\t\treturn 2 ** ((val * 17.52) - 9.72);\n\t\t\t}\n\t\t\telse { // val >= ACES_cc_max\n\t\t\t\treturn 65504;\n\t\t\t}\n\t\t});\n\t},\n\n\t// Non-linear encoding function from S-2014-003, section 4.4.1 Encoding Function\n\tfromBase (RGB) {\n\t\treturn RGB.map(function (val) {\n\t\t\tif (val <= 0) {\n\t\t\t\treturn (Math.log2() + 9.72) / 17.52; // -0.3584\n\t\t\t}\n\t\t\telse if (val < ) {\n\t\t\t\treturn  (Math.log2( + val * 0.5) + 9.72) / 17.52;\n\t\t\t}\n\t\t\telse { // val >= \n\t\t\t\treturn  (Math.log2(val) + 9.72) / 17.52;\n\t\t\t}\n\t\t});\n\t},\n\t// encoded media white (rgb 1,1,1) => linear  [ 222.861, 222.861, 222.861 ]\n\t// encoded media black (rgb 0,0,0) => linear [ 0.0011857, 0.0011857, 0.0011857]\n});\n","import * as util from \"./util.js\";\nimport hooks from \"./hooks.js\";\nimport defaults from \"./defaults.js\";\nimport ColorSpace from \"./space.js\";\nimport {WHITES} from \"./adapt.js\";\nimport {\n\tgetColor,\n\tparse,\n\tto,\n\tserialize,\n\tinGamut,\n\ttoGamut,\n\tdistance,\n\tequals,\n\tget,\n\tgetAll,\n\tset,\n\tsetAll,\n\tdisplay,\n} from \"./index-fn.js\";\n\n\nimport \"./spaces/xyz-d50.js\";\nimport \"./spaces/srgb.js\";\n\n/**\n * Class that represents a color\n */\nexport default class Color {\n\t/**\n\t * Creates an instance of Color.\n\t * Signatures:\n\t * - `new Color(stringToParse)`\n\t * - `new Color(otherColor)`\n\t * - `new Color({space, coords, alpha})`\n\t * - `new Color(space, coords, alpha)`\n\t * - `new Color(spaceId, coords, alpha)`\n\t */\n\tconstructor (...args) {\n\t\tlet color;\n\n\t\tif (args.length === 1) {\n\t\t\tcolor = getColor(args[0]);\n\t\t}\n\n\t\tlet space, coords, alpha;\n\n\t\tif (color) {\n\t\t\tspace = color.space || color.spaceId;\n\t\t\tcoords = color.coords;\n\t\t\talpha = color.alpha;\n\t\t}\n\t\telse {\n\t\t\t// default signature new Color(ColorSpace, array [, alpha])\n\t\t\t[space, coords, alpha] = args;\n\t\t}\n\n\t\tObject.defineProperty(this, \"space\", {\n\t\t\tvalue: ColorSpace.get(space),\n\t\t\twritable: false,\n\t\t\tenumerable: true,\n\t\t\tconfigurable: true, // see note in https://262.ecma-international.org/8.0/#sec-proxy-object-internal-methods-and-internal-slots-get-p-receiver\n\t\t});\n\n\t\tthis.coords = coords ? coords.slice() : [0, 0, 0];\n\n\t\t// Clamp alpha to [0, 1]\n\t\tthis.alpha = alpha > 1 || alpha === undefined ? 1 : (alpha < 0 ? 0 : alpha);\n\n\t\t// Convert \"NaN\" to NaN\n\t\tfor (let i = 0; i < this.coords.length; i++) {\n\t\t\tif (this.coords[i] === \"NaN\") {\n\t\t\t\tthis.coords[i] = NaN;\n\t\t\t}\n\t\t}\n\n\t\t// Define getters and setters for each coordinate\n\t\tfor (let id in this.space.coords) {\n\t\t\tObject.defineProperty(this, id, {\n\t\t\t\tget: () => this.get(id),\n\t\t\t\tset: value => this.set(id, value),\n\t\t\t});\n\t\t}\n\t}\n\n\tget spaceId () {\n\t\treturn this.space.id;\n\t}\n\n\tclone () {\n\t\treturn new Color(this.space, this.coords, this.alpha);\n\t}\n\n\ttoJSON () {\n\t\treturn {\n\t\t\tspaceId: this.spaceId,\n\t\t\tcoords: this.coords,\n\t\t\talpha: this.alpha,\n\t\t};\n\t}\n\n\tdisplay (...args) {\n\t\tlet ret = display(this, ...args);\n\n\t\t// Convert color object to Color instance\n\t\tret.color = new Color(ret.color);\n\n\t\treturn ret;\n\t}\n\n\t/**\n\t * Get a color from the argument passed\n\t * Basically gets us the same result as new Color(color) but doesn't clone an existing color object\n\t */\n\tstatic get (color, ...args) {\n\t\tif (color instanceof Color) {\n\t\t\treturn color;\n\t\t}\n\n\t\treturn new Color(color, ...args);\n\t}\n\n\tstatic defineFunction (name, code, o = code) {\n\t\tlet {instance = true, returns} = o;\n\n\t\tlet func = function (...args) {\n\t\t\tlet ret = code(...args);\n\n\t\t\tif (returns === \"color\") {\n\t\t\t\tret = Color.get(ret);\n\t\t\t}\n\t\t\telse if (returns === \"function<color>\") {\n\t\t\t\tlet f = ret;\n\t\t\t\tret = function (...args) {\n\t\t\t\t\tlet ret = f(...args);\n\t\t\t\t\treturn Color.get(ret);\n\t\t\t\t};\n\t\t\t\t// Copy any function metadata\n\t\t\t\tObject.assign(ret, f);\n\t\t\t}\n\t\t\telse if (returns === \"array<color>\") {\n\t\t\t\tret = ret.map(c => Color.get(c));\n\t\t\t}\n\n\t\t\treturn ret;\n\t\t};\n\n\t\tif (!(name in Color)) {\n\t\t\tColor[name] = func;\n\t\t}\n\n\t\tif (instance) {\n\t\t\tColor.prototype[name] = function (...args) {\n\t\t\t\treturn func(this, ...args);\n\t\t\t};\n\t\t}\n\t}\n\n\tstatic defineFunctions (o) {\n\t\tfor (let name in o) {\n\t\t\tColor.defineFunction(name, o[name], o[name]);\n\t\t}\n\t}\n\n\tstatic extend (exports) {\n\t\tif (exports.register) {\n\t\t\texports.register(Color);\n\t\t}\n\t\telse {\n\t\t\t// No register method, just add the module's functions\n\t\t\tfor (let name in exports) {\n\t\t\t\tColor.defineFunction(name, exports[name]);\n\t\t\t}\n\t\t}\n\t}\n}\n\nColor.defineFunctions({\n\tget,\n\tgetAll,\n\tset,\n\tsetAll,\n\tto,\n\tequals,\n\tinGamut,\n\ttoGamut,\n\tdistance,\n\ttoString: serialize,\n});\n\nObject.assign(Color, {\n\tutil,\n\thooks,\n\tWHITES,\n\tSpace: ColorSpace,\n\tspaces: ColorSpace.registry,\n\tparse,\n\n\t// Global defaults one may want to configure\n\tdefaults,\n});\n","import ColorSpace from \"../space.js\";\nimport * as spaces from \"./index-fn.js\";\n\nexport * as spaces from \"./index-fn.js\";\n\nfor (let key of Object.keys(spaces)) {\n\tColorSpace.register(spaces[key]);\n}\n","/**\n * This plugin defines getters and setters for color[spaceId]\n * e.g. color.lch on *any* color gives us the lch coords\n */\nimport ColorSpace from \"./space.js\";\nimport Color from \"./color.js\";\nimport hooks from \"./hooks.js\";\n\n// Add space accessors to existing color spaces\nfor (let id in ColorSpace.registry) {\n\taddSpaceAccessors(id, ColorSpace.registry[id]);\n}\n\n// Add space accessors to color spaces not yet created\nhooks.add(\"colorspace-init-end\", space => {\n\taddSpaceAccessors(space.id, space);\n\tspace.aliases?.forEach(alias => {\n\t\taddSpaceAccessors(alias, space);\n\t});\n});\n\nfunction addSpaceAccessors (id, space) {\n\tlet propId = id.replace(/-/g, \"_\");\n\n\tObject.defineProperty(Color.prototype, propId, {\n\t\t// Convert coords to coords in another colorspace and return them\n\t\t// Source colorspace: this.spaceId\n\t\t// Target colorspace: id\n\t\tget () {\n\t\t\tlet ret = this.getAll(id);\n\n\t\t\tif (typeof Proxy === \"undefined\") {\n\t\t\t\t// If proxies are not supported, just return a static array\n\t\t\t\treturn ret;\n\t\t\t}\n\n\t\t\t// Enable color.spaceId.coordName syntax\n\t\t\treturn new Proxy(ret, {\n\t\t\t\thas: (obj, property) => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tColorSpace.resolveCoord([space, property]);\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\tcatch (e) {}\n\n\t\t\t\t\treturn Reflect.has(obj, property);\n\t\t\t\t},\n\t\t\t\tget: (obj, property, receiver) => {\n\t\t\t\t\tif (property && typeof property !== \"symbol\" && !(property in obj)) {\n\t\t\t\t\t\tlet {index} = ColorSpace.resolveCoord([space, property]);\n\n\t\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\t\treturn obj[index];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Reflect.get(obj, property, receiver);\n\t\t\t\t},\n\t\t\t\tset: (obj, property, value, receiver) => {\n\t\t\t\t\tif (property && typeof property !== \"symbol\" && !(property in obj) || property >= 0) {\n\t\t\t\t\t\tlet {index} = ColorSpace.resolveCoord([space, property]);\n\n\t\t\t\t\t\tif (index >= 0) {\n\t\t\t\t\t\t\tobj[index] = value;\n\n\t\t\t\t\t\t\t// Update color.coords\n\t\t\t\t\t\t\tthis.setAll(id, obj);\n\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn Reflect.set(obj, property, value, receiver);\n\t\t\t\t},\n\t\t\t});\n\t\t},\n\t\t// Convert coords in another colorspace to internal coords and set them\n\t\t// Target colorspace: this.spaceId\n\t\t// Source colorspace: id\n\t\tset (coords) {\n\t\t\tthis.setAll(id, coords);\n\t\t},\n\t\tconfigurable: true,\n\t\tenumerable: true,\n\t});\n}\n","// Import all modules of Color.js\nimport Color from \"./color.js\";\n\n// Import all color spaces\nimport \"./spaces/index.js\";\n\n// Import all DeltaE methods\nimport deltaE from \"./deltaE.js\";\nimport deltaEMethods from \"./deltaE/index.js\";\n\nColor.extend(deltaEMethods);\nColor.extend({deltaE});\nObject.assign(Color, {deltaEMethods});\n\n// Import optional modules\nimport * as variations from \"./variations.js\";\nColor.extend(variations);\n\nimport contrast from \"./contrast.js\";\nColor.extend({contrast});\n\nimport * as chromaticity from \"./chromaticity.js\";\nColor.extend(chromaticity);\n\nimport * as luminance from \"./luminance.js\";\nColor.extend(luminance);\n\nimport * as interpolation from \"./interpolation.js\";\nColor.extend(interpolation);\n\nimport * as contrastMethods from \"./contrast/index.js\";\nColor.extend(contrastMethods);\n\nimport \"./CATs.js\";\nimport \"./space-accessors.js\";\n\n// Re-export everything\nexport default Color;\n","import type { ColorConstructor } from \"colorjs.io\";\nimport type { Colourish, OkLch } from \"./Types.js\";\nimport { throwNumberTest } from '../../util/GuardNumbers.js';\nexport const oklchToColorJs = (lch: OkLch): ColorConstructor => {\n  throwNumberTest(lch.l, `percentage`, `lch.l`);\n  throwNumberTest(lch.c, `percentage`, `lch.c`);\n  throwNumberTest(lch.h, `percentage`, `lch.h`);\n  throwNumberTest(lch.opacity, `percentage`, `lch.opacity`);\n  return {\n    alpha: lch.opacity,\n    coords: [ lch.l, lch.c * 0.4, lch.h * 360 ],\n    spaceId: `oklch`\n  }\n}\n\n// const oklchToColorJs = (oklch: OkLch) => {\n//   throwNumberTest(oklch.l, `percentage`, `oklch.l`);\n//   throwNumberTest(oklch.c, `percentage`, `oklch.c`);\n//   throwNumberTest(oklch.h, `percentage`, `oklch.h`);\n//   throwNumberTest(oklch.opacity, `percentage`, `oklch.opacity`);\n//   const coords: [ number, number, number ] = [\n//     oklch.l,\n//     oklch.c * 0.4,\n//     oklch.h * 360\n//   ]\n//   return new ColorJs.default(`oklch`, coords, oklch.opacity);\n// }\n\nexport const isOklch = (p: Colourish): p is OkLch => {\n  if (p === undefined || p === null) return false;\n  if (typeof p !== `object`) return false;\n\n  // Check if Colourjs\n  //if ((p as ColorJs.ColorObject).spaceId !== undefined) return false;\n  //if ((p as ColorJs.ColorObject).coords !== undefined) return false;\n  if (p.space !== `oklch`) return false;\n  if (p.l === undefined) return false;\n  if (p.c === undefined) return false;\n  if (p.h === undefined) return false;\n  return true;\n}","export const resolveCss = (colour: string, fallback?: string): string => {\n  if (typeof colour === `string`) {\n    if (colour.startsWith(`--`)) {\n      // Resolve CSS variable\n      const value = getComputedStyle(document.body).getPropertyValue(colour);\n      if (!value || value.length === 0) {\n        if (!fallback) throw new Error(`Variable not found: ${ colour }`);\n        return fallback;\n      }\n      return colour;\n    }\n  }\n  return colour;\n}\n\n/**\n * Gets a CSS variable.\n * ```\n * // Fetch --accent variable, or use `yellow` if not found.\n * getCssVariable(`accent`, `yellow`);\n * ```\n * @param name Name of variable. Leading '--' is unnecessary\n * @param fallbackColour Fallback colour if not found\n * @param root  Element to search variable from\n * @returns Colour or fallback.\n */\nexport const getCssVariable = (\n  name: string,\n  fallbackColour = `black`,\n  root?: HTMLElement\n): string => {\n  if (root === undefined) root = document.body;\n  if (name.startsWith(`--`)) name = name.slice(2);\n  const fromCss = getComputedStyle(root).getPropertyValue(`--${ name }`).trim();\n  if (fromCss === undefined || fromCss.length === 0) return fallbackColour;\n  return fromCss;\n};","import { clamp } from \"../../numbers/Clamp.js\";\nimport type { Colourish, Rgb, Rgb8Bit, RgbRelative } from \"./Types.js\";\nimport { hslToRelative, isHsl } from \"./Hsl.js\";\nimport Color, { type ColorConstructor } from 'colorjs.io';\nimport { isOklch } from \"./Oklch.js\";\nimport { resolveCss } from \"./ResolveCss.js\";\nimport type { Result } from \"../../util/Results.js\";\n/**\n * Converts to relative Rgb value.\n * All parameters are 0..255 scale\n * @param r \n * @param g \n * @param b \n * @param opacity \n * @returns \n */\nconst relativeFromAbsolute = (r: number, g: number, b: number, opacity = 255): RgbRelative => {\n  r = clamp(r / 255);\n  g = clamp(g / 255);\n  b = clamp(b / 255);\n  opacity = clamp(opacity / 255);\n  return {\n    r, g, b, opacity, unit: `relative`, space: `srgb`\n  }\n}\n\nconst rgbToRelative = (rgb: Rgb): RgbRelative => {\n  if (rgb.unit === `relative`) return rgb;\n  return relativeFromAbsolute(rgb.r, rgb.g, rgb.b, rgb.opacity);\n}\n\n// const rgbToColorJs = (rgb: Rgb): ColorJs.ColorObject => {\n//   let { r, g, b, opacity } = rgb;\n\n//   if (rgb.unit === `8bit`) {\n//     r /= 255;\n//     g /= 255;\n//     b /= 255;\n//     if (opacity !== undefined) opacity /= 255;\n//   }\n\n//   const coords: [ number, number, number ] = [\n//     r,\n//     g,\n//     b\n//   ];\n//   return opacity === undefined ?\n//     new ColorJs.default(`srgb`, coords) :\n//     new ColorJs.default(`srgb`, coords, opacity);\n// }\n\nexport const isRgb = (p: Colourish): p is Rgb => {\n  if (p === undefined || p === null) return false;\n  if (typeof p !== `object`) return false;\n\n  // Check if Colourjs\n  //if ((p as ColorJs.ColorObject).spaceId !== undefined) return false;\n  //if ((p as ColorJs.ColorObject).coords !== undefined) return false;\n\n  const space = p.space;\n  if (space !== `srgb` && space !== undefined) return false;\n  const pp = p as Rgb;\n  if (pp.r === undefined) return false;\n  if (pp.g === undefined) return false;\n  if (pp.b === undefined) return false;\n  return true;\n};\n\nexport const rgbToColorJs = (rgb: Rgb): ColorConstructor => {\n  const rel = rgbToRelative(rgb);\n  return {\n    alpha: rel.opacity,\n    coords: [ rgb.r, rgb.g, rgb.b ],\n    spaceId: `sRGB`\n  }\n}\n\n/**\n * Parses colour to `{ r, g, b }` where each field is on 0..1 scale.\n * `opacity` field is added if opacity is not 1.\n * [Named colours](https://html-color-codes.info/color-names/)\n * @param colour\n * @returns\n */\nexport const toRgb = (colour: Colourish): RgbRelative => {\n  if (typeof colour === `string` && colour === `transparent`) return { r: 1, g: 1, b: 1, opacity: 0, space: `srgb`, unit: `relative` };\n  if (isRgb(colour)) {\n    return rgbToRelative(colour);\n  } else if (isHsl(colour)) {\n    const hslRel = hslToRelative(colour);\n    const c = new Color(`hsl`, [ hslRel.h, hslRel.s, hslRel.l ], hslRel.opacity ?? 1);\n    const rgb = c.srgb; // relative 0..1\n    return { r: rgb[ 0 ], g: rgb[ 1 ], b: rgb[ 2 ], opacity: c.alpha, unit: `relative`, space: `srgb` }\n  } else if (isOklch(colour)) {\n    const c = new Color(`oklch`, [ colour.l, colour.c, colour.h ], colour.opacity ?? 1);\n    const rgb = c.srgb; // relative 0..1\n    return { r: rgb[ 0 ], g: rgb[ 1 ], b: rgb[ 2 ], opacity: c.alpha, unit: `relative`, space: `srgb` }\n  } else {\n    const c = new Color(resolveCss(colour));\n    const rgb = c.srgb; // relative 0..1\n    return { r: rgb[ 0 ], g: rgb[ 1 ], b: rgb[ 2 ], opacity: c.alpha, unit: `relative`, space: `srgb` }\n  }\n};\n\n// export const toRgb = (colour: Colourish): Rgb => {\n//   const c = resolve(colour);\n//   const rgb = c.srgb;\n//   return c.alpha < 1 ?\n//     { r: rgb.r, g: rgb.g, b: rgb.b, opacity: c.alpha, space: `srgb`, unit: `relative` } :\n//     { r: rgb.r, g: rgb.g, b: rgb.b, opacity: 1, space: `srgb`, unit: `relative` };\n// };\n\n/**\n * Converts a relative RGB value to RGB & opacity values on 0.255 scale.\n * By default values are clamped so they don't exceed scale.\n * @param rgb \n * @param clamped \n * @returns \n */\nexport const toRgb8bit = (rgb: Rgb, clamped = true): Rgb8Bit => {\n  if (rgb.unit === `8bit`) return rgb;\n  let r = rgb.r * 255;\n  let g = rgb.g * 255;\n  let b = rgb.b * 255;\n  let opacity = (rgb.opacity ?? 1) * 255;\n  if (clamped) {\n    r = clamp(r, 0, 255);\n    g = clamp(g, 0, 255);\n    b = clamp(b, 0, 255);\n    opacity = clamp(opacity, 0, 255);\n  }\n  return { r, g, b, opacity, unit: `8bit`, space: `srgb` }\n}\n\nexport const toRgbRelative = (rgb: Rgb, clamped = true): RgbRelative => {\n  if (rgb.unit === `relative`) return rgb;\n  if (rgb.unit === `8bit`) {\n    let r = rgb.r / 255;\n    let g = rgb.g / 255;\n    let b = rgb.b / 255;\n    let opacity = (rgb.opacity ?? 255) / 255;\n    if (clamped) {\n      r = clamp(r);\n      g = clamp(g);\n      b = clamp(b);\n      opacity = clamp(opacity);\n    }\n    return {\n      r, g, b, opacity, unit: `relative`, space: `srgb`\n    }\n  } else {\n    throw new Error(`Unknown unit. Expected '8bit'`);\n  }\n}\n\n/**\n * Ensures `rgb` uses 0..255 scale for r,g & b values.\n * If `rgb` is already in 8-bit scale (ie it has unit:'8bit')\n * it is returned.\n * @param rgb\n * @returns\n */\n// export const toRgb8bit = (rgb: Rgb): Rgb8Bit => {\n//   const result = parseRgbObject(rgb);\n//   throwResult(result);\n\n//   if (rgb.unit === `8bit`) return rgb as Rgb8Bit;\n\n//   const { r, g, b, opacity } = rgb;\n\n//   const t: Rgb8Bit = {\n//     r: r * 255,\n//     g: g * 255,\n//     b: b * 255,\n//     unit: `8bit`,\n//     space: rgb.space\n//   }\n//   if (opacity !== undefined) return { ...t, opacity: opacity * 255 };\n//   return t;\n// }\n\n/**\n * Tries to parse an object in forms:\n * `{r,g,b}`, `{red,green,blue}`.\n * Uses 'opacity', 'space' and 'unit' fields where available.\n * \n * If 'units' is not specified, it tries to guess if it's relative (0..1) or\n * 8-bit (0..255).\n * \n * Normalises to an Rgb structure if it can, or returns an error.\n * @param p \n * @returns \n */\nexport const parseRgbObject = (p: any): Result<Rgb> => {\n  if (p === undefined || p === null) return { success: false, error: `Undefined/null` }\n  if (typeof p !== `object`) return { success: false, error: `Not an object` };\n\n  const space = p.space ?? `srgb`;\n  let { r, g, b, opacity } = p;\n  if (r !== undefined || g !== undefined || b !== undefined) {\n    // Short field names\n  } else {\n    // Check for long field names\n    const { red, green, blue } = p;\n    if (red !== undefined || green !== undefined || blue !== undefined) {\n      r = red;\n      g = green;\n      b = blue;\n    } else return { success: false, error: `Does not contain r,g,b or red,green,blue` }\n  }\n\n  let unit = p.unit;\n  if (unit === `relative`) {\n    if (r > 1 || r < 0) return { success: false, error: `Relative units, but 'r' exceeds 0..1` };\n    if (g > 1 || g < 0) return { success: false, error: `Relative units, but 'g' exceeds 0..1` };\n    if (b > 1 || b < 0) return { success: false, error: `Relative units, but 'b' exceeds 0..1` };\n    if (opacity > 1 || opacity < 0) return { success: false, error: `Relative units, but opacity exceeds 0..1` };\n  } else if (unit === `8bit`) {\n    if (r > 255 || r < 0) return { success: false, error: `8bit units, but r exceeds 0..255` };\n    if (g > 255 || g < 0) return { success: false, error: `8bit units, but g exceeds 0..255` };\n    if (b > 255 || b < 0) return { success: false, error: `8bit units, but b exceeds 0..255` };\n    if (opacity > 255 || opacity < 0) return { success: false, error: `8bit units, but opacity exceeds 0..255` };\n  } else if (!unit) {\n    if (r > 1 || g > 1 || b > 1) {\n      if (r <= 255 && g <= 255 && b <= 255) {\n        unit = `8bit`;\n      } else return { success: false, error: `Unknown units, outside 0..255 range` };\n    } else if (r <= 1 && g <= 1 && b <= 1) {\n      if (r >= 0 && g >= 0 && b >= 0) {\n        unit = `relative`;\n      } else return { success: false, error: `Unknown units, outside of 0..1 range` };\n    } else return { success: false, error: `Unknown units for r,g,b,opacity values` };\n  }\n  if (opacity === undefined) {\n    opacity = unit === `8bit` ? 255 : 1;\n  }\n\n  const c = {\n    r, g, b, opacity, unit, space\n  }\n  return { success: true, value: c };\n};","import { numberInclusiveRangeTest, throwNumberTest } from '../../util/GuardNumbers.js';\nimport Color from 'colorjs.io';\nimport type { Colourish, Hsl, HslAbsolute, HslRelative } from './Types.js';\nimport { clamp } from '../../numbers/Clamp.js';\nimport { isRgb, toRgbRelative } from './Rgb.js';\nimport { isOklch } from './Oklch.js';\nimport { resolveCss } from './ResolveCss.js';\nimport type { ColorConstructor } from 'colorjs.io';\nimport { throwFromResult } from '../../util/GuardThrowFromResult.js';\n\nexport const hslToColorJs = (hsl: Hsl): ColorConstructor => {\n  const rel = hslToRelative(hsl);\n  return {\n    alpha: rel.opacity,\n    coords: [ rel.h, rel.s, rel.l ],\n    spaceId: `hsl`\n  }\n}\n\nexport const isHsl = (p: Colourish): p is Hsl => {\n  if (p === undefined || p === null) return false;\n  if (typeof p !== `object`) return false;\n\n  // Check if Colourjs\n  //if ((p as ColorJs.ColorObject).spaceId !== undefined) return false;\n  //if ((p as ColorJs.ColorObject).coords !== undefined) return false;\n\n  //const space = p.space;\n  //if (space !== `hsl` && space !== undefined) return false;\n  const pp = p as Hsl;\n  if (pp.h === undefined) return false;\n  if (pp.s === undefined) return false;\n  if (pp.l === undefined) return false;\n\n  if (pp.unit === `relative`) {\n    throwNumberTest(pp.h, `percentage`, `h`);\n    throwNumberTest(pp.s, `percentage`, `s`);\n    throwNumberTest(pp.l, `percentage`, `l`);\n    throwNumberTest(pp.opacity, `percentage`, `opacity`);\n  }\n  return true;\n};\n\nexport const hslToString = (hsl: Hsl): string => {\n  const { h, s, l, opacity } = hslToAbsolute(hsl, true);\n  return `hsl(${ h }deg ${ s }% ${ l }% / ${ opacity }%)`;\n}\n\n/**\n * Returns hue in 0..360, saturation, lightness and opacity in 0..100 scale\n * @param hsl \n * @param safe \n * @returns \n */\nexport const hslToAbsolute = (hsl: Hsl, safe: boolean): HslAbsolute => {\n  if (hsl.unit === `absolute`) return hsl;\n\n  const h = hsl.h === null ? (safe ? 0 : null) : hsl.h;\n  const opacity = hsl.opacity === undefined ? 1 : hsl.opacity;\n  throwNumberTest(h, `percentage`, `hsl.h`);\n  throwNumberTest(hsl.s, `percentage`, `hsl.s`);\n  throwNumberTest(hsl.l, `percentage`, `hsl.l`);\n  throwNumberTest(opacity, `percentage`, `hsl.opacity`);\n\n  return {\n    h: h! * 360,\n    s: hsl.s * 100,\n    l: hsl.l * 100,\n    opacity: opacity * 100,\n    unit: `absolute`,\n    space: `hsl`\n  }\n\n  //return new Color(`hsl`, coords, opacity);\n}\n\n// const hslToColorJs = (hsl: Hsl, safe: boolean) => {\n//   const h = hsl.h === null ? (safe ? 0 : null) : hsl.h;\n//   const opacity = hsl.opacity === undefined ? 1 : hsl.opacity;\n//   throwNumberTest(h, `percentage`, `hsl.h`);\n//   throwNumberTest(hsl.s, `percentage`, `hsl.s`);\n//   throwNumberTest(hsl.l, `percentage`, `hsl.l`);\n//   throwNumberTest(opacity, `percentage`, `hsl.opacity`);\n\n//   const coords: [ number, number, number ] = [\n//     h! * 360,\n//     hsl.s * 100,\n//     hsl.l * 100\n//   ];\n//   return new Color(`hsl`, coords, opacity);\n// }\n\n/**\n * Returns a Colorjs 'Color' object based on relative hue, saturation, lightness\n * and opacity.\n * @param h Hue (0..1)\n * @param s Saturation (0..1) Default: 1\n * @param l Lightness (0..1) Default: 0.5\n * @param opacity Opacity (0..1) Default: 1\n * @returns \n */\n// export const fromHsl = (h: number, s = 1, l = 0.5, opacity = 1): ColorJs.ColorObject => {\n//   throwNumberTest(h, `percentage`, `h`);\n//   throwNumberTest(s, `percentage`, `s`);\n//   throwNumberTest(l, `percentage`, `l`);\n\n//   return resolve({ h, s, l, opacity, space: `hsl` });\n// }\n\nexport const hslFromRelativeValues = (h: number = 1, s: number = 1, l: number = 0.5, opacity = 1): HslRelative => {\n  return {\n    h, s, l, opacity, unit: `relative`, space: `hsl`\n  }\n}\n\nexport const hslFromAbsoluteValues = (h: number, s: number, l: number, opacity = 100, safe = false): HslRelative => {\n  const hTest = numberInclusiveRangeTest(h, 0, 360, `h`);\n  if (!hTest[ 0 ]) {\n    if (safe) h = 0;\n    else throwFromResult(hTest);\n  }\n  throwFromResult(numberInclusiveRangeTest(s, 0, 100, `s`));\n  throwFromResult(numberInclusiveRangeTest(l, 0, 100, `l`));\n  throwFromResult(numberInclusiveRangeTest(opacity, 0, 100, `opacity`));\n\n  if (s > 100) throw new Error(`Param 's' expected 0..100`);\n  if (l > 100) throw new Error(`Param 'l' expected 0..100`);\n  h = clamp(h / 360);\n  s = s / 100;\n  l = l / 100;\n  return {\n    h, s, l, opacity, unit: `relative`, space: `hsl`\n  };\n}\n\nexport const hslToRelative = (hsl: Hsl, safe = true): HslRelative => {\n  if (hsl.unit === `relative`) return hsl;\n  return hslFromAbsoluteValues(hsl.h, hsl.s, hsl.l, hsl.opacity, safe);\n  // let h = hsl.h / 360;\n  // let s = hsl.s / 100;\n  // let l = hsl.l / 100;\n  // let opacity = hsl.opacity / 100;\n\n  // if (safe) {\n  //   h = clamp(h);\n  //   s = clamp(s);\n  //   l = clamp(l);\n  //   opacity = clamp(opacity);\n  // }\n  // return {\n  //   h, s, l, opacity,\n  //   unit: `relative`, space: `hsl`\n  // }\n}\n\n/**\n * Parses colour to `{ h, s, l }`, each field being on 0..1 scale.\n * \n * Note that some colours will return NaN for h,s or l. This is because they have\n * indeterminate hue. For example white, black and transparent. By default hue of 0 is used\n * in these cases.\n * @param colour\n * @returns\n */\nexport const toHsl = (colour: Colourish, safe = true): HslRelative => {\n  if (typeof colour === `string` && colour === `transparent`) return { h: 0, s: 0, l: 0, opacity: 0, space: `hsl`, unit: `relative` };\n  if (!colour && !safe) throw new Error(`Param 'colour' is undefined`);\n  if (isHsl(colour)) {\n    return hslToRelative(colour);\n  } else if (isRgb(colour)) {\n    const rgb = toRgbRelative(colour);\n    const c = new Color(`sRGB`, [ rgb.r, rgb.g, rgb.b ], rgb.opacity ?? 1);\n    //const hsl = c.hsl; // absolute\n    //return hslFromAbsoluteValues(hsl[ 0 ], hsl[ 1 ], hsl[ 2 ], c.alpha, safe);\n    const [ h, s, l ] = c.hsl.map(v => parseFloat(v as any));\n    return hslFromAbsoluteValues(h, s, l, parseFloat(c.alpha as any), safe);\n\n  } else if (isOklch(colour)) {\n    const c = new Color(`oklch`, [ colour.l, colour.c, colour.h ], colour.opacity ?? 1);\n    //const hsl = c.hsl; // absolute\n    //return hslFromAbsoluteValues(hsl[ 0 ], hsl[ 1 ], hsl[ 2 ], c.alpha, safe);\n    const [ h, s, l ] = c.hsl.map(v => parseFloat(v as any));\n    return hslFromAbsoluteValues(h, s, l, parseFloat(c.alpha as any), safe);\n\n  } else {\n    const c = new Color(resolveCss(colour));\n    // absolute values\n    const [ h, s, l ] = c.hsl.map(v => parseFloat(v as any));\n    return hslFromAbsoluteValues(h, s, l, parseFloat(c.alpha as any), safe);\n  }\n};\n","import type { ColorConstructor } from \"colorjs.io\";\nimport { hslToColorJs, isHsl } from \"./Hsl.js\";\nimport type { Colourish } from \"./Types.js\";\nimport { isRgb, rgbToColorJs } from \"./Rgb.js\";\nimport { isOklch, oklchToColorJs } from \"./Oklch.js\";\nimport Color from \"colorjs.io\";\nimport { resolveCss } from \"./ResolveCss.js\";\n\nexport const structuredToColorJsConstructor = (colour: Colourish): ColorConstructor => {\n\n  if (isHsl(colour)) {\n    return hslToColorJs(colour);\n  }\n  if (isRgb(colour)) {\n    return rgbToColorJs(colour);\n  }\n  if (isOklch(colour)) {\n    return oklchToColorJs(colour);\n  }\n  const c = new Color(resolveCss(colour));\n  return {\n    alpha: c.alpha,\n    coords: c.coords,\n    spaceId: c.spaceId\n  }\n}\n\nexport const structuredToColorJs = (colour: Colourish): Color => {\n  const cc = structuredToColorJsConstructor(colour);\n  return new Color(cc.spaceId, cc.coords, cc.alpha);\n}","import Color from \"colorjs.io\";\nimport { structuredToColorJs, structuredToColorJsConstructor } from \"./ResolveToColorJs.js\";\nimport type { Colourish } from \"./Types.js\";\n\n/**\n * Returns a colour in hex format `#000000`. \n * ```js\n * canvas.fillStyle = Colour.toHex(`blue`);\n * canvas.fillStyle = Colour.toHex({ h:0.5, s:0.1, l:1 });\n * canvas.fillStyle = Colour.toHex({ r: 1, g: 0.3, b: 0 });\n * ```\n * \n * Input colour can be a human-friendly colour name (\"blue\"), a HSL\n * colour (eg. \"hsl(0, 50%, 50%)\")\", an object {h,s,l} or {r,g,b}.\n * '#' is included in the return string.\n * \n * Transparent colour is returned as #00000000\n * @param colour\n * @returns Hex format, including #\n */\nexport const toHex = (colour: Colourish): string => {\n  if (typeof colour === `string` && colour === `transparent`) return `#00000000`;\n  const cc = structuredToColorJsConstructor(colour);\n\n  const c = new Color(cc.spaceId, cc.coords, cc.alpha)\n  return c.to(`srgb`).toString({ format: `hex`, collapse: false });\n};\n\n/**\n * Returns a colour in the best-possible CSS colour form.\n * The return value can be used setting colours in the canvas or DOM manipulations.\n * @param colour \n */\nexport const toString = (colour: Colourish): string => {\n  const c = structuredToColorJs(colour);\n  return c.display();\n}\n\n/**\n * Returns a CSS-ready string\n * representation.\n * ```js\n * element.style.backgroundColor = resolveToString(`red`);\n * ```\n * \n * Tries each parameter in turn, returning the value\n * for the first that resolves. This can be useful for\n * having fallback values.\n * \n * ```js\n * // Try a CSS variable, a object property or finally fallback to red.\n * element.style.backgroundColor = toStringFirst('--some-var', opts.background, `red`);\n * ```\n * @param colours Array of colours to resolve\n * @returns \n */\nexport const toStringFirst = (...colours: Array<Colourish | undefined>): string => {\n  for (const colour of colours) {\n    if (colour === undefined) continue;\n    if (colour === null) continue;\n    try {\n      const c = structuredToColorJs(colour);\n      return c.display();\n    } catch (_error) {\n      return colour.toString();\n      //if (typeof colour === `string`) return colour\n      //throw Error(`${ getErrorMessage(error) } Value: '${ colour }' (${ typeof colour })`);\n    }\n  }\n  return `rebeccapurple`;\n}","import { clamp } from \"../../numbers/Clamp.js\";\nimport type { ColourInterpolationOpts, Colourish } from \"./Types.js\";\nimport { pairwise } from '../../data/arrays/Pairwise.js';\nimport { scale as scaleNumber } from '../../numbers/Scale.js';\nimport { structuredToColorJsConstructor } from \"./ResolveToColorJs.js\";\nimport { toString as colourToString } from \"./ToString.js\";\nimport Color from \"colorjs.io\";\n/**\n * Returns a function to interpolate between colours\n * ```js\n * import { Colour } from 'https://unpkg.com/ixfx/dist/visual.js'\n * const i = interpolator([`orange`, `yellow`, `red`]);\n * \n * // Get a random colour on the above spectrum\n * i(Math.random());\n * ```\n * \n * Results will vary depending on the colour space used, play with the options.\n * When using a hue-based colour space, the `hue` option sets the logic for how hue values wrap.\n * \n * ```js\n * interpolator([`orange`, `yellow`, `red`], { space: `hsl`, hue: `longer })\n * ```\n * @param colours Colours to interpolate between\n * @param opts Options for interpolation\n * @returns \n */\nexport const interpolator = (colours: Array<Colourish>, opts: Partial<ColourInterpolationOpts> = {}) => {\n  const space = opts.space ?? `lch`;\n  const hue = opts.hue ?? `shorter`;\n  const pieces = interpolatorInit(colours);\n\n  //const ranges = pieces.map(piece => (piece[ 0 ] as any).range(piece[ 1 ], { space, hue })) as Array<Range>;\n  const ranges = pieces.map(piece => piece[ 0 ].range(piece[ 1 ], { space, hue }));\n\n  return (amt: number) => {\n    amt = clamp(amt);\n\n    // Scale to 0..1 to 0...ranges.length\n    const s = scaleNumber(amt, 0, 1, 0, ranges.length);\n    const index = Math.floor(s);\n    const amtAdjusted = s - index;\n    return ranges[ index ](amtAdjusted);\n  }\n}\n\nconst interpolatorInit = (colours: Array<Colourish>) => {\n  if (!Array.isArray(colours)) throw new Error(`Param 'colours' is not an array as expected. Got: ${ typeof colours }`);\n  if (colours.length < 2) throw new Error(`Param 'colours' should be at least two in length. Got: ${ colours.length }`);\n  const c = colours.map(colour => {\n    const c = structuredToColorJsConstructor(colour)\n    return new Color(c.spaceId, c.coords, c.alpha);\n  });\n  return [ ...pairwise(c) ];\n}\n\n/**\n * Returns a CSS `linear-gradient` with stops corresponding to the given list of `colours`.\n * ```js\n * element.style.background = Colour.cssLinearGradient(['red','green','blue']);\n * ```\n * @param colours \n * @returns \n */\nexport const cssLinearGradient = (colours: Array<Colourish>) => {\n  const c = colours.map(c => colourToString(c));\n  return `linear-gradient(to right, ${ c.join(`, `) })`;\n}\n\n/**\n * Produces a stepped scale of colours.\n * \n * Return result is an array of Color.js 'Colour' objects.\n * ```js\n * import { Colour } from 'ixfx/visual'\n * const steps = Colour.scale(['red','green'], 10);\n * for (const step of steps) {\n *  // Get a 'hsla(...)' string representation of colour\n *  // This can be used with the canvas, setting DOM properties etc.\n *  const css = Colour.toString(step);\n * }\n * ```\n * \n * {@link cssLinearGradient} can produce a smooth gradient in CSS on the basis\n * of the stepped colours.\n * @param colours \n * @param numberOfSteps \n * @param opts \n * @returns \n */\nexport const scale = (colours: Array<Colourish>, numberOfSteps: number, opts: Partial<ColourInterpolationOpts> = {}) => {\n  const space = opts.space ?? `lch`;\n  const hue = opts.hue ?? `shorter`;\n  const pieces = interpolatorInit(colours);\n  const stepsPerPair = Math.floor(numberOfSteps / pieces.length);\n\n\n  const steps = pieces.map(piece => (piece[ 0 ] as any).steps(piece[ 1 ],\n    { space, hue, steps: stepsPerPair, outputSpace: `srgb` }\n  )) as Array<Color>;\n\n  return steps.flat();\n}","import { clamp } from '../../numbers/Clamp.js';\nimport { throwNumberTest } from '../../util/GuardNumbers.js';\nimport { structuredToColorJs } from './ResolveToColorJs.js';\nimport type { Colourish } from './Types.js';\n/**\n * Returns a variation of colour with its opacity multiplied by `amt`.\n * Value will be clamped to 0..1\n *\n * ```js\n * // Return a colour string for blue that is 50% opaque\n * multiplyOpacity(`blue`, 0.5);\n * // eg: `rgba(0,0,255,0.5)`\n *\n * // Returns a colour string that is 50% more opaque\n * multiplyOpacity(`hsla(200,100%,50%,50%`, 0.5);\n * // eg: `hsla(200,100%,50%,25%)`\n * ```\n *\n * [Named colours](https://html-color-codes.info/color-names/)\n * @param colour A valid CSS colour\n * @param amt Amount to multiply opacity by\n * @returns String representation of colour\n */\nexport const multiplyOpacity = (colour: Colourish, amt: number): string => {\n  throwNumberTest(amt, `percentage`, `amt`);\n\n  const c = structuredToColorJs(colour);\n  const alpha = clamp((c.alpha ?? 0) * amt);\n  c.alpha = alpha;\n  return c.toString();\n};\n\nexport const multiplySaturation = (colour: Colourish, amt: number): string => {\n  throwNumberTest(amt, `percentage`, `amt`);\n  const c = structuredToColorJs(colour);\n  c.s = (c.s ?? 0) * amt;\n  return c.toString();\n};","//import * as ColorJs from \"colorjs.io\";\n\nimport * as Colour from '../../visual/colour/index.js';\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport type ReactiveColour = ReactiveWritable<Colour.Colourish> & {\n  setHsl: (hsl: Colour.Hsl) => void;\n}\n\nexport function colour(initialValue: Colour.Colourish): ReactiveColour & ReactiveInitial<Colour.Colourish>;\nexport function colour(): ReactiveColour & ReactiveNonInitial<Colour.Colourish>;\nexport function colour(initialValue?: Colour.Colourish): ReactiveColour & (ReactiveNonInitial<Colour.Colourish> | ReactiveInitial<Colour.Colourish>) {\n  let value = initialValue;\n  const events = initStream<Colour.Colourish>();\n\n  const set = (v: Colour.Colourish) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set,\n    setHsl: (hsl: Colour.Hsl) => {\n      set(hsl);\n    }\n  }\n}\n","import { intervalToMs } from \"../../flow/IntervalType.js\";\nimport { continuously } from \"../../flow/Continuously.js\";\nimport type { CountOptions } from \"./Types.js\";\nimport { initLazyStream } from \"../InitStream.js\";\n\n/**\n * Produces an incrementing value. By default starts at 0 and counts\n * forever, incrementing every second.\n * \n * ```js\n * const r = Rx.From.count();\n * r.onValue(c => {\n *  // 0, 1, 2, 3 ... every second\n * });\n * ```\n * \n * The `limit` is exclusive\n * ```js\n * const r = Rx.From.count({limit:5});\n * // Yields 0,1,2,3,4\n * ```\n * \n * If limit is less than start, it will count down instead.\n * ```js\n * const r = Rx.count({start:5, limit: 0});\n * // Yie:ds 5,4,3,2,1\n * ```\n * \n * ```js\n * // Count 10, 12, 14 ... every 500ms\n * const r = Rx.From.count({ start: 10, amount: 2, interval: 500 });\n * ```\n * \n * In addition to setting `limit` (which is exclusive), you can stop with an abort signal\n * ```js\n * const ac = new AbortController();\n * const r = Rx.From.count({signal:ac.signal});\n * ...\n * ac.abort(`stop`);\n * ```\n * @param options \n */\nexport function count(options: Partial<CountOptions> = {}) {\n\n  const lazy = options.lazy ?? `initial`;\n  const interval = intervalToMs(options.interval, 1000);\n  const amount = options.amount ?? 1;\n  const offset = options.offset ?? 0;\n\n  let produced = 0;\n  let value = offset;\n\n  const done = (reason: string) => {\n    events.dispose(reason);\n  }\n\n  const timer = continuously(() => {\n    if (options.signal?.aborted) {\n      done(`Aborted (${ options.signal.reason })`);\n      return false;\n    }\n    events.set(value);\n    value += 1;\n    produced++;\n    if (produced >= amount) {\n      done(`Limit reached`);\n      return false;\n    }\n  }, interval);\n\n  const events = initLazyStream<number>({\n    onStart() {\n      timer.start();\n    },\n    onStop() {\n      timer.cancel();\n    },\n    onDispose() {\n      timer.cancel();\n    },\n    lazy\n  });\n  return events;\n}\n","import { isEqualValueDefault } from \"../../util/IsEqual.js\";\nimport { cache } from \"../Cache.js\";\nimport { initUpstream } from \"../InitStream.js\";\nimport { type CombineLatestToObject, combineLatestToObject } from \"../ops/CombineLatestToObject.js\";\nimport type { ReactiveNonInitial, ReactiveOrSource, RxValueTypeObject } from \"../Types.js\";\nimport type { DerivedOptions } from \"./Types.js\";\n\nexport function derived<TResult, const T extends Record<string, ReactiveOrSource<any>>>(fn: (combined: RxValueTypeObject<T>) => TResult | undefined, reactiveSources: T, options: Partial<DerivedOptions<TResult, CombineLatestToObject<T>>> = {}): ReactiveNonInitial<TResult> {\n  const ignoreIdentical = options.ignoreIdentical ?? true;\n  const eq = options.eq ?? isEqualValueDefault<TResult>;\n\n  const sources = combineLatestToObject(reactiveSources);\n\n  const handle = (v: RxValueTypeObject<T>) => {\n    const last = output.last();\n    const vv = fn(v);\n    if (vv !== undefined) {\n      if (ignoreIdentical && last !== undefined) {\n        if (eq(vv, last)) return vv;\n      }\n      output.set(vv);\n    }\n\n    return vv;\n  }\n\n  // When the combined stream emits a value, output it\n  const s = initUpstream<RxValueTypeObject<T>, TResult>(sources, {\n    ...options,\n    onValue(v) {\n      handle(v);\n    },\n  });\n  const output = cache(s, fn(sources.last()));\n  return output;\n}\n\n","import type { Passed, Reactive, ReactiveInitial } from \"../Types.js\";\nimport { field } from \"../ops/Field.js\";\nimport { object } from \"./Object.js\";\nimport type { FieldOptions } from \"../ops/Types.js\";\nimport type { EventOptions, EventTriggerOptions } from \"./Types.js\";\nimport { initLazyStream } from \"../InitStream.js\";\nimport { Elapsed } from \"../../flow/index.js\";\n/**\n * Fired when `eventName` fires on `target`. \n * \n * Rather than whole event args being emitted on the stream,\n * it plucks a field from the event args, or if that's missing, from the target.\n * \n * ```js\n * // Emits the the value of a field named 'x'\n * // on the change event args\n * eventField(el, `pointermove`, `x`);\n * ```\n * @param targetOrQuery Event target, HTML element or HTML query (eg '#someId') \n * @param eventName Name of event, eg. 'pointermove'\n * @param fieldName Name of field, eg 'x'\n * @param initialValue Initial data\n * @param options Options for source\n */\nexport function eventField<TFieldValue = string>(targetOrQuery: EventTarget | string | null, eventName: string, fieldName: string, initialValue: TFieldValue, options: Partial<EventOptions & FieldOptions<any, TFieldValue>> = {}) {\n\n  const initial: Record<string, any> = {};\n  initial[ fieldName ] = initialValue;\n\n  const rxField = field<any, TFieldValue>(\n    event(targetOrQuery, eventName, initial, options),\n    fieldName,\n    options\n  );\n  return rxField;\n}\n\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options: EventOptions<V>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options?: Optional<EventOptions<V>, `transform`>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n\n/**\n * Subscribes to an event, emitting data\n * \n * @example Print x,y position of mouse as it moves\n * ```js\n * const r = Rx.From.event(document, `pointermove`);\n * r.onValue(event => {\n *  const { x, y } = event;\n * });\n * ```\n * \n * If `options.lazy` is _true_ (default: _false_), event will only be subscribed to when the stream\n * itself has a subscriber.\n * \n * `options.debugFiring` and `options.debugLifecycle` can be turned on to troubleshoot behaviour\n * of the stream if necessary.\n * @param targetOrQuery Event emitter, HTML element or string. If a string, it will be queryed as a selector.\n * @param name Event name\n * @param options Options\n * @returns \n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport function event<TEventArgs extends Record<string, any>>(targetOrQuery: EventTarget | null | string, name: string, initialValue: TEventArgs | undefined, options: Partial<EventOptions> = {}): ReactiveInitial<TEventArgs> & Reactive<TEventArgs> {\n  let target: EventTarget | null;\n  if (typeof targetOrQuery === `string`) {\n    target = document.querySelector(targetOrQuery);\n    if (target === null) throw new Error(`Target query did not resolve to an element. Query: '${ targetOrQuery }'`)\n  } else {\n    target = targetOrQuery;\n  }\n\n  if (target === null) throw new Error(`Param 'targetOrQuery' is null`);\n\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const debugFiring = options.debugFiring ?? false;\n  const lazy = options.lazy ?? false;\n  if (initialValue === undefined) initialValue = {} as TEventArgs;\n  const rxObject = object<TEventArgs>(initialValue, { deepEntries: true });\n  let eventAdded = false;\n  let disposed = false;\n\n  const callback = (args: any) => {\n    if (debugFiring) console.log(`Reactive.event '${ name }' firing '${ JSON.stringify(args) }`)\n    rxObject.set(args as TEventArgs);\n  }\n\n  const remove = () => {\n    if (!eventAdded) return;\n    eventAdded = false;\n    target.removeEventListener(name, callback);\n    if (debugLifecycle) {\n      console.log(`Rx.From.event remove '${ name }'`);\n    }\n  }\n\n  const add = () => {\n    if (eventAdded) return;\n    eventAdded = true;\n    target.addEventListener(name, callback);\n    if (debugLifecycle) {\n      console.log(`Rx.From.event add '${ name }'`);\n    }\n  }\n\n  if (!lazy) add();\n\n  return {\n    last: () => {\n      if (lazy) add();\n      return rxObject.last();\n    },\n    dispose: (reason: string) => {\n      if (disposed) return;\n      disposed = true;\n      remove();\n      rxObject.dispose(reason);\n    },\n    isDisposed() {\n      return disposed;\n    },\n    on: (handler: (v: Passed<TEventArgs>) => void) => {\n      if (lazy) add();\n      return rxObject.on(handler);\n    },\n    onValue: (handler: (v: TEventArgs) => void) => {\n      if (lazy) add();\n      return rxObject.onValue(handler);\n    }\n  }\n}\n\nexport type TriggerData = {\n  sinceLast: number\n  total: number\n}\n\n/**\n * Emits a value whenever event happens.\n * Data emitted is `{ sinceLast, total }`, where 'sinceLast'\n * is milliseconds since last event and 'total' is total number of \n * times event has been fired.\n * @param targetOrQuery \n * @param name \n * @param options \n * @returns \n */\nexport function eventTrigger(targetOrQuery: EventTarget | null | string, name: string, options: Partial<EventTriggerOptions> = {}): Reactive<TriggerData> {\n  let target: EventTarget | null;\n  if (typeof targetOrQuery === `string`) {\n    target = document.querySelector(targetOrQuery);\n    if (target === null) throw new Error(`Target query did not resolve to an element. Query: '${ targetOrQuery }'`)\n  } else {\n    target = targetOrQuery;\n  }\n\n  if (target === null) throw new Error(`Param 'targetOrQuery' is null`);\n\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const debugFiring = options.debugFiring ?? false;\n  const fireInitial = options.fireInitial ?? false;\n\n  let count = 0;\n  const elapsed = Elapsed.interval();\n\n  const stream = initLazyStream<TriggerData>({\n    lazy: options.lazy ?? `very`,\n    onStart() {\n      target.addEventListener(name, callback);\n      if (debugLifecycle) {\n        console.log(`Rx.From.eventTrigger add '${ name }'`);\n      }\n      if (fireInitial && count === 0) {\n        if (debugLifecycle || debugFiring) console.log(`Rx.From.eventTrigger: firing initial`);\n        callback();\n      }\n    },\n    onStop() {\n      target.removeEventListener(name, callback);\n      if (debugLifecycle) {\n        console.log(`Rx.From.eventTrigger remove '${ name }'`);\n      }\n    },\n  });\n\n  const callback = (_args?: any) => {\n    if (debugFiring) console.log(`Rx.From.eventTrigger '${ name }' triggered'`)\n    stream.set({\n      sinceLast: elapsed(),\n      total: ++count\n    });\n  }\n\n  return stream;\n}","import * as Colour from '../../visual/colour/index.js';\nimport type { ReactiveInitial, ReactiveWritable, Reactive } from \"../Types.js\";\nimport { eventTrigger } from \"./Event.js\";\nimport type { DomFormOptions, DomNumberInputValueOptions, DomValueOptions } from \"./Types.js\";\nimport { resolveEl } from '../../dom/ResolveEl.js';\nimport { transform } from '../ops/Transform.js';\nimport { hasLast } from '../Util.js';\n\n/**\n * Reactive getting/setting of values to a HTML INPUT element.\n * \n * Options:\n * - relative: if _true_, values are 0..1 (default: false)\n * - inverted: if _true_, values are 1..0 (default: false)\n * \n * If element is missing a 'type' attribute, this will be set to 'range'.\n * @param targetOrQuery \n * @param options \n * @returns \n */\nexport function domNumberInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomNumberInputValueOptions> = {}): ReactiveInitial<number> & ReactiveWritable<number> {\n  const input = domInputValue(targetOrQuery, options);\n  const el = input.el;\n  const relative = options.relative ?? false;\n  const inverted = options.inverted ?? false;\n\n  const rx = transform(input, v => {\n    return Number.parseFloat(v);\n  });\n\n  if (relative) {\n    //el.setAttribute(`max`, inverted ? \"0\" : \"1\");\n    el.max = inverted ? \"0\" : \"1\";\n    //el.setAttribute(`min`, inverted ? \"1\" : \"0\");\n    el.min = inverted ? \"1\" : \"0\";\n    if (!el.hasAttribute(`step`)) {\n      //el.setAttribute(`step`, \"0.1\");\n      el.step = \"0.1\";\n    }\n  }\n  if (el.getAttribute(`type`) === null) {\n    el.type = `range`;\n  }\n\n  const set = (value: number) => {\n    input.set(value.toString());\n  }\n\n  return {\n    ...rx,\n    last() {\n      //console.log(`domNumberInputValue last: ${ input.last() }`);\n      return Number.parseFloat(input.last())\n    },\n    set\n  };\n}\n\nexport function domHslInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomValueOptions> = {}): ReactiveInitial<Colour.Hsl> & Reactive<Colour.Hsl> & ReactiveWritable<Colour.Hsl> {\n\n  const input = domInputValue(targetOrQuery, {\n    ...options,\n    upstreamFilter(value) {\n      return (typeof value === `object`) ? Colour.toHex(value) : value;\n    },\n  });\n  const rx = transform(input, v => {\n    return Colour.toHsl(v, true);\n  });\n  return {\n    ...rx,\n    last() {\n      return Colour.toHsl(input.last(), true)\n    },\n    set(value) {\n      input.set(Colour.toHex(value));\n    },\n  };\n}\n\n/**\n * A stream of values when the a HTMLInputElement changes. Eg a <input type=\"range\">\n * ```js\n * const r = Rx.From.domInputValue(`#myEl`);\n * r.onValue(value => {\n *  // value will be string\n * });\n * ```\n * \n * Options:\n * * emitInitialValue: If _true_ emits the HTML value of element (default: false)\n * * attributeName: If set, this is the HTML attribute value is set to when writing to stream (default: 'value')\n * * fieldName: If set, this is the DOM object field set when writing to stream (default: 'value')\n * * when: 'changed'|'changing' when values are emitted. (default: 'changed')\n * * fallbackValue:  Fallback value to use if field/attribute cannot be read (default: '')\n * @param targetOrQuery \n * @param options \n * @returns \n */\nexport function domInputValue(targetOrQuery: HTMLInputElement | string, options: Partial<DomValueOptions> = {}): { el: HTMLInputElement } & ReactiveInitial<string> & ReactiveWritable<string> {\n  const target: HTMLInputElement | null = (typeof targetOrQuery === `string` ? document.querySelector(targetOrQuery) : targetOrQuery);\n  if (target === null && typeof targetOrQuery === `string`) throw new Error(`Element query could not be resolved '${ targetOrQuery }'`);\n  if (target === null) throw new Error(`targetOrQuery is null`)\n\n  const el = resolveEl(targetOrQuery);\n  const when = options.when ?? `changed`;\n  const eventName = when === `changed` ? `change` : `input`;\n  const emitInitialValue = options.emitInitialValue ?? false;\n  const fallbackValue = options.fallbackValue ?? ``;\n  const upstreamSource = options.upstreamSource;\n  let upstreamSourceUnsub = () => {}\n\n  let attribName = options.attributeName;\n  let fieldName = options.fieldName;\n\n  if (fieldName === undefined && attribName === undefined) {\n    attribName = fieldName = `value`;\n  }\n\n  const readValue = () => {\n    let value: string | null | undefined;\n    if (attribName) {\n      value = el.getAttribute(attribName);\n      //console.log(`  attrib: ${ attribName } value: ${ value }`);\n    }\n    if (fieldName) {\n      value = (el as any)[ fieldName ]\n    }\n    if (value === undefined || value === null) value = fallbackValue;\n    //console.log(`domInputValue readValue: ${ value }. attrib: ${ attribName } field: ${ fieldName }`);\n    return value;\n  }\n\n  const setValue = (value: string) => {\n    if (attribName) {\n      el.setAttribute(attribName, value);\n    }\n    if (fieldName) {\n      (el as any)[ fieldName ] = value;\n    }\n  }\n\n  const setUpstream = (v: any) => {\n    v = options.upstreamFilter ? options.upstreamFilter(v) : v;\n    setValue(v);\n  }\n  if (upstreamSource) {\n    upstreamSourceUnsub = upstreamSource.onValue(setUpstream);\n    if (hasLast(upstreamSource)) {\n      setUpstream(upstreamSource.last());\n    }\n  }\n\n  // Input element change event stream\n  const rxEvents = eventTrigger(el, eventName, {\n    fireInitial: emitInitialValue,\n    debugFiring: options.debugFiring ?? false,\n    debugLifecycle: options.debugLifecycle ?? false,\n  });\n\n  // Transform to get values\n  const rxValues = transform(rxEvents, _trigger => readValue());\n\n  return {\n    ...rxValues,\n    el,\n    last() {\n      return readValue()\n    },\n    set(value) {\n      setValue(value);\n    },\n    dispose(reason) {\n      upstreamSourceUnsub();\n      rxValues.dispose(reason);\n      rxEvents.dispose(reason);\n    },\n  }\n}\n\n/**\n * Listens for data changes from elements within a HTML form element.\n * Input elements must have a 'name' attribute.\n * \n * Simple usage:\n * ```js\n * const rx = Rx.From.domForm(`#my-form`);\n * rx.onValue(value => {\n *  // Object containing values from form\n * });\n * \n * rx.last(); // Read current values of form\n * ```\n * \n * UI can be updated\n * ```js\n * // Set using an object of key-value pairs\n * rx.set({\n *  size: 'large'\n * });\n * \n * // Or set a single name-value pair\n * rx.setNamedValue(`size`, `large`);\n * ```\n * \n * If an 'upstream' reactive is provided, this is used to set initial values of the UI, overriding\n * whatever may be in the HTML. Upstream changes modify UI elements, but UI changes do not modify the upstream\n * source.\n * \n * ```js\n * // Create a reactive object\n * const obj = Rx.From.object({\n *  when: `2024-10-03`,\n *  size: 12,\n *  checked: true\n * });\n * \n * // Use this as initial values for a HTML form\n * // (assuming appropriate INPUT/SELECT elements exist)\n * const rx = Rx.From.domForm(`form`, { \n *  upstreamSource: obj\n * });\n * \n * // Listen for changes in the UI\n * rx.onValue(value => {\n *  \n * });\n * ```\n * @param formElOrQuery \n * @param options \n * @returns \n */\nexport function domForm<T extends Record<string, any>>(formElOrQuery: HTMLFormElement | string, options: Partial<DomFormOptions<T>> = {}): {\n  setNamedValue: (name: string, value: any) => void,\n  el: HTMLFormElement\n} & ReactiveInitial<T> & ReactiveWritable<T> {\n  const formEl = resolveEl<HTMLFormElement>(formElOrQuery);\n  const when = options.when ?? `changed`;\n  const eventName = when === `changed` ? `change` : `input`;\n\n  const emitInitialValue = options.emitInitialValue ?? false;\n  const upstreamSource = options.upstreamSource;\n\n  const typeHints = new Map<string, string>();\n\n  let upstreamSourceUnsub = () => {}\n\n  const readValue = () => {\n    const fd = new FormData(formEl);\n    const entries = [];\n    for (const [ k, v ] of fd.entries()) {\n      const vString = v.toString();\n\n      // Get type hint for key\n      let typeHint = typeHints.get(k);\n      if (!typeHint) {\n        // If not found, use the kind of input element as a hint\n        const el = getFormElement(k, vString);\n        if (el) {\n          if (el.type === `range` || el.type === `number`) {\n            typeHint = `number`;\n          } else if (el.type === `color`) {\n            typeHint = `colour`;\n          } else if (el.type === `checkbox` && (v === `true` || v === `on`)) {\n            typeHint = `boolean`;\n          } else {\n            typeHint = `string`;\n          }\n          typeHints.set(k, typeHint);\n        }\n      }\n\n      if (typeHint === `number`) {\n        entries.push([ k, Number.parseFloat(vString) ]);\n      } else if (typeHint === `boolean`) {\n        const vBool = (vString === `true`) ? true : false;\n        entries.push([ k, vBool ]);\n      } else if (typeHint === `colour`) {\n        const vRgb = Colour.toString(vString);\n        entries.push([ k, Colour.toRgb(vRgb) ]);\n      } else {\n        entries.push([ k, v.toString() ]);\n      }\n    }\n\n    // Checkboxes that aren't checked don't give a value, so find those\n    for (const el of formEl.querySelectorAll<HTMLInputElement>(`input[type=\"checkbox\"]`)) {\n      if (!el.checked && el.value === `true`) {\n        entries.push([ el.name, false ]);\n      }\n    }\n    const asObject = Object.fromEntries(entries);\n    //console.log(`readValue`, asObj);\n    return asObject;\n  }\n\n  const getFormElement = (name: string, value: string): HTMLSelectElement | HTMLInputElement | undefined => {\n    const el = formEl.querySelector(`[name=\"${ name }\"]`) as HTMLInputElement | null;\n    if (!el) {\n      console.warn(`Form does not contain an element with name=\"${ name }\"`);\n      return;\n    }\n    if (el.type === `radio`) {\n      // Get right radio option\n      const radioEl = formEl.querySelector(`[name=\"${ name }\"][value=\"${ value }\"]`) as HTMLInputElement | null;\n      if (!radioEl) {\n        console.warn(`Form does not contain radio option for name=${ name } value=${ value }`);\n        return;\n      }\n      return radioEl;\n    }\n    return el;\n  }\n  const setNamedValue = (name: string, value: any) => {\n    const el = getFormElement(name, value);\n    if (!el) return;\n\n    //let typeHint = typeHints.get(name);\n    // if (typeHint) {\n    //   console.log(`${ name } hint: ${ typeHint } input type: ${ el.type }`);\n    // } else {\n    //   console.warn(`Rx.Sources.Dom.domForm no type hint for: ${ name }`);\n    // }\n    if (el.nodeName === `INPUT` || el.nodeName === `SELECT`) {\n      if (el.type === `color`) {\n        if (typeof value === `object`) {\n          // Try to parse colour if value is an object\n          //const c = Colour.resolve(value, true);\n          value = Colour.toHex(value);\n        }\n      } else if (el.type === `checkbox`) {\n        if (typeof value === `boolean`) {\n          el.checked = value;\n          return;\n        } else {\n          console.warn(`Rx.Sources.domForm: Trying to set non boolean type to a checkbox. Name: ${ name } Value: ${ value } (${ typeof value })`);\n        }\n      } else if (el.type === `radio`) {\n        el.checked = true;\n        return;\n      }\n      el.value = value;\n    }\n  }\n\n  const setFromUpstream = (value: T) => {\n    //console.log(`setUpstream`, value);\n    for (const [ name, v ] of Object.entries(value)) {\n      let hint = typeHints.get(name);\n      if (!hint) {\n        hint = typeof v;\n        if (hint === `object`) {\n          const rgb = Colour.parseRgbObject(v);\n          if (rgb.success) {\n            hint = `colour`;\n          }\n        }\n        typeHints.set(name, hint);\n      }\n      const valueFiltered = options.upstreamFilter ? options.upstreamFilter(name, v) : v;\n      setNamedValue(name, valueFiltered);\n    }\n  }\n\n  if (upstreamSource) {\n    upstreamSourceUnsub = upstreamSource.onValue(setFromUpstream);\n    if (hasLast(upstreamSource)) {\n      setFromUpstream(upstreamSource.last());\n    }\n  }\n\n  // Input element change event stream\n  const rxEvents = eventTrigger(formEl, eventName, {\n    fireInitial: emitInitialValue,\n    debugFiring: options.debugFiring ?? false,\n    debugLifecycle: options.debugLifecycle ?? false,\n  });\n\n  // Transform to get values\n  const rxValues = transform(rxEvents, _trigger => readValue());\n\n  return {\n    ...rxValues,\n    el: formEl,\n    last() {\n      return readValue()\n    },\n    set: setFromUpstream,\n    setNamedValue,\n    dispose(reason) {\n      upstreamSourceUnsub();\n      rxValues.dispose(reason);\n      rxEvents.dispose(reason);\n    },\n  }\n}","import { initLazyStream } from \"../InitStream.js\";\nimport type { InitLazyStreamOptions, Reactive, Unsubscriber } from \"../Types.js\";\n\n/**\n * Returns a stream that merges the output of a list of homogenous streams.\n * Use {@link mergedWithOptions} to specify additional options.\n * @param sources \n * @returns \n */\nexport function merged<T>(...sources: Reactive<T>[]): Reactive<T> {\n  return mergedWithOptions(sources);\n}\n\n/**\n * Returns a stream that merges the output of a list of homogenous streams.\n * \n * @param sources \n * @param options \n * @returns \n */\nexport function mergedWithOptions<T>(sources: Reactive<T>[], options: Partial<InitLazyStreamOptions> = {}): Reactive<T> {\n  let unsubs: Unsubscriber[] = [];\n  const stream = initLazyStream<T>({\n    ...options,\n    onStart() {\n      for (const s of sources) {\n        unsubs.push(s.onValue(v => {\n          stream.set(v);\n        }));\n      }\n    },\n    onStop() {\n      for (const un of unsubs) {\n        un();\n      }\n      unsubs = [];\n    },\n  });\n  return stream;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport function number(initialValue: number): ReactiveWritable<number> & ReactiveInitial<number>;\nexport function number(): ReactiveWritable<number> & ReactiveNonInitial<number>;\nexport function number(initialValue?: number): ReactiveWritable<number> & (ReactiveNonInitial<number> | ReactiveInitial<number>) {\n  let value = initialValue;\n  const events = initStream<number>();\n\n  const set = (v: number) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set\n  }\n}\n","import { object } from \"./Object.js\";\nimport { symbol, type ReactiveArray, type ReactiveDiff, type ReactiveInitial } from \"../Types.js\";\nimport { array } from \"./Array.js\";\nimport { arrayObject } from \"./ArrayObject.js\";\n\nexport type ReactiveProxied<V> = V & {\n  [ symbol ]: ReactiveDiff<V> & ReactiveInitial<V>\n}\n/**\n * Creates a proxy of `target` object (or array), so that regular property setting will be intercepted and output\n * on a {@link Reactive} object as well.\n * \n * ```js\n * const { proxy, rx } = Rx.From.objectProxy({ colour: `red`, x: 10, y: 20 });\n * \n * rx.onValue(v => {\n *  // Get notified when proxy is changed\n * });\n * \n * // Get and set properties as usual\n * console.log(proxy.x);\n * proxy.x = 20; // Triggers Reactive\n * ```\n * \n * Keep in mind that changing `target` directly won't affect the proxied object or Reactive. Thus,\n * only update the proxied object after calling `fromProxy`.\n * \n * The benefit of `objectProxy` instead of {@link Rx.From.object} is because the proxied object can be passed to other code that doesn't need\n * to know anything about Reactive objects.\n * \n * You can assign the return values to more meaningful names using\n * JS syntax.\n * ```js\n * const { proxy:colour, rx:colourRx } = Rx.From.objectProxy({ colour: `red` });\n * ```\n * \n * If `target` is an array, it's not possible to change the shape of the array by adding or removing\n * elements, only by updating existing ones. This follows the same behaviour of objects. Alternatively, use {@link arrayProxy}.\n * \n * See also:\n * * {@link objectProxySymbol}: Instead of {proxy,rx} return result, puts the `rx` under a symbol on the proxy.\n * * {@link arrayProxy}: Proxy an array, allowing inserts and deletes.\n * @param target \n * @returns \n */\nexport const objectProxy = <V extends object>(target: V): { proxy: V, rx: ReactiveDiff<V> & ReactiveInitial<V> } => {\n\n  const rx = object(target);\n\n  const proxy = new Proxy(target, {\n    set(target, p, newValue, _receiver) {\n\n      const isArray = Array.isArray(target);\n      //console.log(`Rx.Sources.object set. Target: ${ JSON.stringify(target) } (${ typeof target } array: ${ Array.isArray(target) }) p: ${ JSON.stringify(p) } (${ typeof p }) newValue: ${ JSON.stringify(newValue) } recv: ${ _receiver }`);\n\n      // Ignore length if target is array\n      if (isArray && p === `length`) return true;\n\n      if (typeof p === `string`) {\n        rx.updateField(p, newValue);\n      }\n\n      // If target is array and field looks like an array index...\n      if (isArray && typeof p === `string`) {\n        const pAsNumber = Number.parseInt(p);\n        if (!Number.isNaN(pAsNumber)) {\n          target[ pAsNumber ] = newValue;\n          return true;\n        }\n      }\n      (target as any)[ p ] = newValue;\n      return true;\n    }\n  });\n  return { proxy, rx }\n}\n\nexport const arrayProxy = <V, T extends Array<V>>(target: T): { proxy: T, rx: ReactiveArray<V> & ReactiveInitial<ReadonlyArray<V>> } => {\n  const rx = arrayObject(target);\n  const proxy = new Proxy(target, {\n    set(target, p, newValue, _receiver) {\n\n      //console.log(`Rx.Sources.arrayProxy set. Target: ${ JSON.stringify(target) } (${ typeof target } array: ${ Array.isArray(target) }) p: ${ JSON.stringify(p) } (${ typeof p }) newValue: ${ JSON.stringify(newValue) } recv: ${ _receiver }`);\n\n      // Ignore length if target is array\n      if (p === `length`) return true;\n      if (typeof p !== `string`) throw new Error(`Expected numeric index, got type: ${ typeof p } value: ${ JSON.stringify(p) }`);\n      const pAsNumber = Number.parseInt(p);\n      if (!Number.isNaN(pAsNumber)) {\n        rx.setAt(pAsNumber, newValue);\n        target[ pAsNumber ] = newValue;\n\n        return true;\n      } else {\n        throw new Error(`Expected numeric index, got: '${ p }'`);\n      }\n    }\n  });\n  return { proxy, rx }\n}\n\n/**\n * Same as {@link proxy}, but the return value is the proxied object along with \n * the Reactive wrapped as symbol property.\n * \n * ```js\n * const person = Rx.fromProxySymbol({name: `marie` });\n * person.name = `blah`;\n * person[Rx.symbol].on(msg => {\n *  // Value changed...\n * });\n * ```\n * \n * This means of access can be useful as the return result\n * is a bit neater, being a single object instead of two. \n * @param target \n * @returns \n */\nexport const objectProxySymbol = <V extends object>(target: V): ReactiveProxied<V> => {\n  const { proxy, rx } = objectProxy(target);\n\n  const p = proxy as ReactiveProxied<V>;\n  p[ symbol ] = rx;\n  return p;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport type { Reactive, ReactiveWritable } from \"../Types.js\";\nimport { messageHasValue } from \"../Util.js\";\nimport { manual } from \"../index.js\";\n\n/**\n * Creates a RxJs style observable\n * ```js\n * const o = observable(stream => {\n *  // Code to run for initialisation when we go from idle to at least one subscriber\n *  // Won't run again for additional subscribers, but WILL run again if we lose\n *  // all subscribers and then get one\n * \n *  // To send a value:\n *  stream.set(someValue);\n * \n *   // Optional: return function to call when all subscribers are removed\n *   return () => {\n *     // Code to run when all subscribers are removed\n *   }\n * });\n * ```\n * \n * For example:\n * ```js\n * const xy = observable<(stream => {\n *  // Send x,y coords from PointerEvent\n *  const send = (event) => {\n *    stream.set({ x: event.x, y: event.y });\n *  }\n *  window.addEventListener(`pointermove`, send);\n *  return () => {\n *    // Unsubscribe\n *    window.removeEventListener(`pointermove`, send);\n *  }\n * });\n * \n * xy.onValue(value => {\n *  console.log(value);\n * });\n * ```\n * @param init \n * @returns \n */\nexport function observable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined): Reactive<V> {\n  const ow = observableWritable(init);\n  return {\n    dispose: ow.dispose,\n    isDisposed: ow.isDisposed,\n    on: ow.on,\n    onValue: ow.onValue\n  }\n}\n\n/**\n * As {@link observable}, but returns a Reactive that allows writing\n * @param init \n * @returns \n */\nexport function observableWritable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined): ReactiveWritable<V> & Reactive<V> {\n  let onCleanup: (() => void) | undefined = () => {/** no-op */ };\n  const ow = manual<V>({\n    onFirstSubscribe() {\n      onCleanup = init(ow);\n    },\n    onNoSubscribers() {\n      if (onCleanup) onCleanup();\n    },\n  });\n\n  return {\n    ...ow,\n    onValue: (callback: (value: V) => void) => {\n      return ow.on(message => {\n        if (messageHasValue(message)) {\n          callback(message.value);\n        }\n      });\n    }\n  };\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../InitStream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../Types.js\";\n\nexport function string(initialValue: string): ReactiveWritable<string> & ReactiveInitial<string>;\nexport function string(): ReactiveWritable<string> & ReactiveNonInitial<string>;\nexport function string(initialValue?: string): ReactiveWritable<string> & (ReactiveNonInitial<string> | ReactiveInitial<string>) {\n  let value = initialValue;\n  const events = initStream<string>();\n\n  const set = (v: string) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set\n  }\n}"],"mappings":"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","names":["average","filter","interpolate","max","min","rank","sum","tally","to","toArray","wrap","manual","run","filter","find","fromIterable","map","min","some","toArray","zip","array","fromIterable","count","filter","find","iterator","map","a","b","max","min","some","toArray","toString","zip","iterator","c","isEmpty","elements","set","t","field","event","compareData","a","b","field","compareData","a","b","split","c","object","set","compareData","field","value","d","event","d","field","elapsed","last","elapsed","filter","min","max","a","b","create","ticks","time","t","p","c","pow","c1","c3","c2","clamp","dotProduct","interpolate","isNaN","quantiseEvery","reduce","rotate","round","toArray","toString","wrap","p","isNaN","a","b","c","average","count","distance","smoothingFactor","a","min","p","a","b","sum","p","clamp","a","min","max","a","b","p","p","b","a","c","a","guard","isNaN","a","p","a","b","a","b","d","guard","isPositioned","guardPositioned","isEmpty","isPlaceholder","isEqual","a","b","line","b","c","d","a","isEqual","centroid","a","b","a","b","guard","isPositioned","guard","distanceFromExterior","guardPositioned","a","distanceFromExterior","a","distanceFromExterior","a","b","c","toArray","p","dotProduct","a","p","toArray","p","guard","line","getPointParameter","b","a","sum","a","b","getPointParameter","line","guard","a","b","getPointParameter","d","d2","line","distance","interpolate","a","b","max","min","length","a","b","length","a","b","c","d","pipeline","a","b","distance","every","d","quantiseEvery","reduce","p","a","b","count","p","clampMagnitude","divide","dotProduct","guard","invert","multiply","normalise","p","guard","cloneFromFields","piPi","a","b","d","last","t","cloneFromFields","field","object","object","m","r","a","b","pi","p","average","max","min","sum","max","min","sum","t","average","tally","p","toString","object","a","piPi","piPi","d","c","invert","p","guard","a","b","a","b","c","distance","p","d","guard","normalise","c","clampMagnitude","max","min","dotProduct","a","b","guard","multiply","divide","toCartesian","toString","toCartesian","a","b","toString","line","a","rotate","p","round","toString","p","a","b","wrap","abs","cos","sin","sqrt","pow","pi","t","d","p","t2","a","b","c","m","sum","n","bbox","intersections","min","max","line","reduce","m1","m2","v1","q","a2","phi","d2","c1","c2","a","b","c","bbox","d","abs","min","max","cos","sin","acos","sqrt","pi","point","d","t","p","abs","last","c","steps","pi","sqrt","m","n","acos","p2","ls","le","segments","tlen","alen","line","min","max","c1","c2","intersections","cos","sin","cubic","a","cubic2","b","t","quadratic","a","max","interpolate","relative","create","time","ticks","map","interpolate","a","b","a","b","interpolate","t","interpolate","max","p","min","average","sum","tally","rank","annotate","event","t","t","event","elapsed","repeat","distance","get","a","b","priority","d","item","m","object","graph","get","vertices","line","distance","g","from","to","t","weight","edges","a","b","m","g","process","toArray","resolve","resolve","wrap","a","filter","min","max","average","sum","tally","m","source","toArray","elements","b","bind","field","p","create","changes","d","last","array","c","set","filter","count","insertAt","set","interpolator","scale","toString","m","p","c","n","interpolate","from","to","coordGrammar","type","range","clamp","min","max","d","name","adapt","util.mapRange","util.parseFunction","util.last","","white","coords","options","epsilon","XYZ_D65","get","object","3","","xyz_d50","Lab","a","b","constrainAngle","","d2r","XYZtoLMS_M","LMStoXYZ_M","OKLab","oklab","clone","distance","c1","c2","Yw","ninv","c3","Jzazbz","jzczhz","m1","tau","deg2rad","t","viewingConditions","cam16","last","hct","util.isString","util.isNone","clipped","deltaE","util.clamp","inGamut","checkInGamut","util.serializeNumber","toXYZ_M","fromXYZ_M","abs","equals","register","Color","contrast","contrastAlgorithms","sum","steps","angles.adjust","g","hwb","oklch","Luv","lch","scale","func","args","ret","lch","p","colour","g","b","p","colour","c","p","colour","c","colour","c","colour","c","toString","interpolator","c","colour","toString","scale","steps","colour","c","set","last","remove","count","elapsed","relative","set","toString","set","target","p","set","filter","interpolate","min","max","sum","average","tally","rank","p","resolve","to","a","b","transform"]}