{"version":3,"file":"queue-mutable-DVfjDZNz.js","names":["opts: QueueOpts<V>","queue: ReadonlyArray<V>","toAdd: ReadonlyArray<V>","opts: QueueOpts<V>","data: readonly V[]","index: number","result: readonly V[]","attemptedToAdd: readonly V[]","removed: readonly V[]","finalData: readonly V[]","predicate: (item: V) => boolean","options: QueueOpts<V>"],"sources":["../../packages/collections/src/queue/queue-fns.ts","../../packages/collections/src/queue/queue-mutable.ts"],"sourcesContent":["import type { QueueOpts } from './queue-types.js';\n\nexport const debug = (opts: QueueOpts<any>, message: string): void => {\n  opts.debug ? console.log(`queue:${ message }`) : undefined;\n};\n\nexport const trimQueue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>,\n  toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  const potentialLength = queue.length + toAdd.length;\n  const capacity = opts.capacity ?? potentialLength;\n  const toRemove = potentialLength - capacity;\n  const policy = opts.discardPolicy ?? `additions`;\n  // debug(\n  //   opts,\n  //   `queueLen: ${queue.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy} toAdd.length: ${toAdd.length} capacity: ${capacity}`\n  // );\n  // debug(opts, `to add: ${JSON.stringify(toAdd)}`);\n\n  switch (policy) {\n    // Only add what we can from toAdd\n    case `additions`: {\n      // debug(\n      //   opts,\n      //   `trimQueue:DiscardAdditions: queueLen: ${queue.length} slice: ${\n      //     potentialLength - capacity\n      //   } toAddLen: ${toAdd.length} nowFull: ${queue.length === opts.capacity}`\n      // );\n      if (queue.length === 0) return toAdd.slice(0, toAdd.length - toRemove);\n      // eslint-disable-next-line unicorn/prefer-ternary\n      if (queue.length === opts.capacity) {\n        return queue; // Completely full\n      } else {\n        // Only add some from the new array (from the front)\n        return [ ...queue, ...toAdd.slice(0, toRemove - 1) ];\n      }\n    }\n    // Remove from rear of queue (last index) before adding new things\n    case `newer`: {\n      if (toRemove >= queue.length) {\n        // New items will completely flush out old\n        //debug(opts, `slice start: ${toAdd.length - capacity}`);\n        if (queue.length === 0) {\n          // Special case when queue starts off empty\n          // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n          return [ ...toAdd.slice(0, capacity - 1), toAdd.at(-1)! ];\n        }\n        return toAdd.slice(\n          Math.max(0, toAdd.length - capacity),\n          Math.min(toAdd.length, capacity) + 1\n        );\n        //debug(opts, `Final value: ${JSON.stringify(tmp)}`);\n        //return tmp;\n      } else {\n        // Keep some of the old\n        // const toAddFinal = toAdd.slice(\n        //   0,\n        //   Math.min(toAdd.length, capacity - toRemove + 1)\n        // );\n        // Cap 5, queue 5, toAdd: 10.\n        const countToAdd = Math.max(1, toAdd.length - queue.length);\n        const toAddFinal = toAdd.slice(toAdd.length - countToAdd, toAdd.length);\n        const toKeep = queue.slice(0, Math.min(queue.length, capacity - 1)); //toRemove);\n        // debug(\n        //   opts,\n        //   `trimQueue: countToAdd: ${countToAdd} qLen: ${\n        //     queue.length\n        //   } capacity: ${capacity} toRemove: ${toRemove} keeping: ${JSON.stringify(\n        //     toKeep\n        //   )} from orig: ${JSON.stringify(queue)} toAddFinal: ${JSON.stringify(\n        //     toAddFinal\n        //   )}`\n        // );\n        const t = [ ...toKeep, ...toAddFinal ];\n        //debug(opts, `final: ${JSON.stringify(t)}`);\n        return t;\n      }\n    }\n    // Remove from the front of the queue (0 index). ie. older items are discarded\n    case `older`: {\n      // If queue is A, B and toAdd is C, D this yields A, B, C, D\n      return [ ...queue, ...toAdd ].slice(toRemove);\n    }\n    default: {\n      // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n      throw new Error(`Unknown overflow policy ${ policy }`);\n    }\n  }\n};\n\n/**\n * Adds to the back of the queue (last array index)\n * Last item of `toAdd` will potentially be the new end of the queue (depending on capacity limit and overflow policy)\n * @typeParam V - Type of values\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @param {...V[]} toAdd\n * @returns {V[]}\n */\nexport const enqueue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>,\n  ...toAdd: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (opts === undefined) throw new Error(`opts parameter undefined`);\n\n  const potentialLength = queue.length + toAdd.length;\n  const overSize = opts.capacity && potentialLength > opts.capacity;\n\n  const toReturn = overSize\n    ? trimQueue(opts, queue, toAdd)\n    : [ ...queue, ...toAdd ];\n  if (opts.capacity && toReturn.length !== opts.capacity && overSize) {\n    throw new Error(\n      `Bug! Expected return to be at capacity. Return len: ${ toReturn.length\n      } capacity: ${ opts.capacity } opts: ${ JSON.stringify(opts) }`\n    );\n  }\n  if (!opts.capacity && toReturn.length !== potentialLength) {\n    throw new Error(\n      `Bug! Return length not expected. Return len: ${ toReturn.length\n      } expected: ${ potentialLength } opts: ${ JSON.stringify(opts) }`\n    );\n  }\n  return toReturn;\n};\n\n// Remove from front of queue (0 index)\nexport const dequeue = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): ReadonlyArray<V> => {\n  if (queue.length === 0) throw new Error(`Queue is empty`);\n  return queue.slice(1);\n};\n\n/**\n * Returns front of queue (oldest item), or undefined if queue is empty\n *\n * @typeParam V - Type of values stored\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @returns {(V | undefined)}\n */\nexport const peek = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): V | undefined => queue[ 0 ];\n\nexport const isEmpty = <V>(opts: QueueOpts<V>, queue: ReadonlyArray<V>): boolean =>\n  queue.length === 0;\n\nexport const isFull = <V>(\n  opts: QueueOpts<V>,\n  queue: ReadonlyArray<V>\n): boolean => {\n  if (opts.capacity) {\n    return queue.length >= opts.capacity;\n  }\n  return false;\n};\n","import { type IQueueMutable, type IQueueMutableWithEvents, type QueueMutableEvents } from './iqueue-mutable.js';\nimport { enqueue, peek, dequeue, isEmpty, isFull } from './queue-fns.js';\nimport { type QueueOpts } from './queue-types.js';\nimport { isEqualDefault, type IsEqual } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events'; //'../../Events.js';\n\n/**\n * Mutable queue that fires events when manipulated.\n * \n * Queues are useful if you want to treat 'older' or 'newer'\n * items differently. _Enqueing_ adds items at the back of the queue, while\n * _dequeing_ removes items from the front (ie. the oldest).\n *\n * ```js\n * const q = Queues.mutable();       // Create\n * q.enqueue(`a`, `b`);     // Add two strings\n * const front = q.dequeue();  // `a` is at the front of queue (oldest)\n * ```\n *\n * @example Cap size to 5 items, throwing away newest items already in queue.\n * ```js\n * const q = Queues.mutable({capacity: 5, discardPolicy: `newer`});\n * ```\n *\n * Events can be used to monitor data flows.\n * * 'enqueue': fires when item(s) are added\n * * 'dequeue': fires when an item is dequeued from front\n * * 'removed': fires when an item is dequeued, queue is cleared or .removeWhere is used to trim queue\n * \n * Each of the event handlers return the state of the queue as the 'finalData'\n * field.\n * \n * ```js\n * q.addEventListener(`enqueue`, e => {\n *  // e.added, e.finalData\n * });\n * q.addEventListener(`removed`, e => {\n *  // e.removed, e.finalData\n * });\n * q.addEventListener(`dequeue`, e=> {\n *  // e.removed, e.finalData\n * })\n * ```\n * @typeParam V - Data type of items\n */\nexport class QueueMutable<V> extends SimpleEventEmitter<QueueMutableEvents<V>> implements IQueueMutable<V> {\n  readonly options: QueueOpts<V>;\n  data: readonly V[];\n  eq: IsEqual<V>;\n\n  constructor(opts: QueueOpts<V> = {}, data: readonly V[] = []) {\n    super();\n    if (opts === undefined) throw new Error(`opts parameter undefined`);\n    this.options = opts;\n    this.data = data;\n    this.eq = opts.eq ?? isEqualDefault;\n  }\n\n  clear() {\n    const copy = [ ...this.data ];\n    this.data = [];\n    this.fireEvent(`removed`, { finalData: this.data, removed: copy });\n    this.onClear();\n  }\n\n  /**\n   * Called when all data is cleared\n   */\n  protected onClear() { /** no-op */\n  }\n\n  at(index: number): V {\n    if (index >= this.data.length) throw new Error(`Index outside bounds of queue`);\n    const v = this.data.at(index);\n    if (v === undefined) throw new Error(`Index appears to be outside range of queue`);\n    return v;\n  }\n\n  enqueue(...toAdd: readonly V[]): number {\n    this.data = enqueue(this.options, this.data, ...toAdd);\n    const length = this.data.length;\n    this.onEnqueue(this.data, toAdd);\n    return length;\n  }\n\n  protected onEnqueue(result: readonly V[], attemptedToAdd: readonly V[]) {\n    this.fireEvent(`enqueue`, { added: attemptedToAdd, finalData: result });\n  }\n\n  dequeue(): V | undefined {\n    const v = peek(this.options, this.data);\n    if (v === undefined) return;\n    /* eslint-disable-next-line functional/immutable-data */\n    this.data = dequeue(this.options, this.data);\n    this.fireEvent(`dequeue`, { removed: v, finalData: this.data });\n    this.onRemoved([ v ], this.data);\n    return v;\n  }\n\n  protected onRemoved(removed: readonly V[], finalData: readonly V[]) {\n    this.fireEvent(`removed`, { removed, finalData });\n  }\n\n  /**\n   * Removes values that match `predicate`.\n   * @param predicate \n   * @returns Returns number of items removed.\n   */\n  removeWhere(predicate: (item: V) => boolean): number {\n    const countPre = this.data.length;\n    const toRemove = this.data.filter(v => predicate(v));\n    if (toRemove.length === 0) return 0;\n    this.data = this.data.filter((element) => !predicate(element));\n    this.onRemoved(toRemove, this.data);\n    return countPre - this.data.length;\n  }\n\n  /**\n * Return a copy of the array\n * @returns \n */\n  toArray(): V[] {\n    return [ ...this.data ];\n  }\n\n  get isEmpty(): boolean {\n    return isEmpty(this.options, this.data);\n  }\n\n  get isFull(): boolean {\n    return isFull(this.options, this.data);\n  }\n\n  get length(): number {\n    return this.data.length;\n  }\n\n  get peek(): V | undefined {\n    return peek(this.options, this.data);\n  }\n}\n\n/**\n * Creates a new QueueMutable\n * @param options \n * @param startingItems \n * @returns \n */\nexport function mutable<V>(\n  options: QueueOpts<V> = {},\n  ...startingItems: readonly V[]\n): IQueueMutableWithEvents<V> {\n  return new QueueMutable({ ...options }, [ ...startingItems ]);\n}\n\n"],"mappings":"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"}