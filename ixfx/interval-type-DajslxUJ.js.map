{"version":3,"file":"interval-type-DajslxUJ.js","names":[],"sources":["../../core/dist/src/records/circular.js","../../core/dist/src/to-string.js","../../core/dist/src/is-equal.js","../../core/dist/src/iterable-compare-values-shallow.js","../../core/dist/src/util/round.js","../../core/dist/src/interval-type.js"],"sourcesContent":["export const removeCircularReferences = (value, replaceWith = null, seen = new WeakSet(), path = ``) => {\n    if (value === null)\n        return value;\n    if (typeof value !== `object`)\n        throw new TypeError(`Param 'value' must be an object. Got type: ${typeof value}`);\n    seen.add(value);\n    const entries = Object.entries(value);\n    for (const entry of entries) {\n        if (entry[1] === null)\n            continue;\n        if (typeof entry[1] !== `object`)\n            continue;\n        if (seen.has(entry[1])) {\n            //value[ entry[0] ] = replaceWith;\n            entry[1] = replaceWith;\n            continue;\n        }\n        entry[1] = removeCircularReferences(entry[1], replaceWith, seen, `${entry[0]}.`);\n    }\n    return Object.fromEntries(entries);\n};\n","// Via Vuejs\nimport { removeCircularReferences } from \"./records/circular.js\";\n// eslint-disable-next-line @typescript-eslint/unbound-method\nconst objectToString = Object.prototype.toString;\nconst toTypeString = (value) => objectToString.call(value);\n/**\n * Returns _true_ if `value` is a Map type\n * @param value\n * @returns\n */\nexport const isMap = (value) => toTypeString(value) === `[object Map]`;\n/**\n * Returns _true_ if `value` is a Set type\n * @param value\n * @returns\n */\nexport const isSet = (value) => toTypeString(value) === `[object Set]`;\n/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = (itemToMakeStringFor) => typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);\n/**\n * Converts a value to string form.\n * For simple objects, .toString() is used, other JSON.stringify is used.\n * It is meant for creating debugging output or 'hash' versions of objects, and does\n * not necessarily maintain full fidelity of the input\n * @param value\n * @returns\n */\nexport const defaultToString = (value) => {\n    //ECMA specification: http://www.ecma-international.org/ecma-262/6.0/#sec-tostring\n    if (value === null)\n        return `null`;\n    if (typeof value === `boolean` || typeof value === `number`) {\n        return value.toString();\n    }\n    if (typeof value === `string`)\n        return value;\n    if (typeof value === `symbol`)\n        throw new TypeError(`Symbol cannot be converted to string`);\n    try {\n        const s = JSON.stringify(value);\n        return s;\n    }\n    catch (error) {\n        // Circular maybe\n        if (typeof value === `object`) {\n            return JSON.stringify(removeCircularReferences(value, `(circular)`));\n        }\n        else {\n            throw error;\n        }\n    }\n};\n","import { toStringDefault } from \"./to-string.js\";\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n *\n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor\n * @returns\n */\nexport const toStringOrdered = (itemToMakeStringFor) => {\n    if (typeof itemToMakeStringFor === `string`)\n        return itemToMakeStringFor;\n    const allKeys = new Set();\n    JSON.stringify(itemToMakeStringFor, (key, value) => (allKeys.add(key), value));\n    return JSON.stringify(itemToMakeStringFor, [...allKeys].sort());\n};\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = (a, b) => a === b;\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n *\n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n *\n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n *\n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = (a, b) => {\n    // ✔ UNIT TESTED\n    if (a === b)\n        return true; // Object references are the same, or string values are the same\n    return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n *\n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n *\n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n *\n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a\n * @param b\n * @param fieldComparer\n * @returns\n */\nexport const isEqualValuePartial = (a, b, fieldComparer) => {\n    if (typeof a !== `object`)\n        throw new Error(`Param 'a' expected to be object`);\n    if (typeof b !== `object`)\n        throw new Error(`Param 'b' expected to be object`);\n    if (Object.is(a, b))\n        return true;\n    const comparer = fieldComparer ?? isEqualValuePartial;\n    for (const entryB of Object.entries(b)) {\n        const valueOnAKeyFromB = a[entryB[0]];\n        const valueB = entryB[1];\n        if (typeof valueOnAKeyFromB === `object` && typeof valueB === `object`) {\n            if (!comparer(valueOnAKeyFromB, valueB)) {\n                return false;\n            }\n        }\n        else {\n            if (valueOnAKeyFromB !== valueB) {\n                return false;\n            }\n        }\n    }\n    return true;\n};\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n *\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n *\n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n * @typeParam T - Type of objects being compared\n */\nexport const isEqualValueIgnoreOrder = (a, b) => {\n    // ✔ UNIT TESTED\n    if (a === b)\n        return true; // Object references are the same, or string values are the same\n    return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n};\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value\n * @returns\n */\nexport const isEmptyEntries = (value) => [...Object.entries(value)].length === 0;\n/**\n * Returns _true_ if `a` and `b` are equal based on their JSON representations.\n * `path` is ignored.\n * @param a\n * @param b\n * @param path\n * @returns\n */\nexport const isEqualContextString = (a, b, _path) => {\n    return JSON.stringify(a) === JSON.stringify(b);\n};\n","import { isEqualDefault } from \"./is-equal.js\";\n/**\n * Compares the values of two iterables, returning a list\n * of items they have in common and those unique in `a` or `b`.\n * Ignores ordering of values, and is NOT recursive.\n *\n * ```js\n * const a = ['apples', 'oranges', 'pears' ]\n * const b = ['pears', 'kiwis', 'bananas' ];\n *\n * const r = compareValuesShallow(a, b);\n * r.shared;  // [ 'pears' ]\n * r.a;       // [ 'apples', 'oranges' ]\n * r.b;       // [ 'kiwis', 'bananas' ]\n * ```\n *\n * By default uses === semantics for comparison.\n * @param a\n * @param b\n * @param eq\n * @returns\n */\nexport const compareIterableValuesShallow = (a, b, eq = (isEqualDefault)) => {\n    const shared = [];\n    const aUnique = [];\n    const bUnique = [];\n    for (const elementOfA of a) {\n        let seenInB = false;\n        // Does B contain this thing from A?\n        for (const elementOfB of b) {\n            if (eq(elementOfA, elementOfB)) {\n                seenInB = true;\n                break;\n            }\n        }\n        if (seenInB) {\n            // Common in A & B\n            shared.push(elementOfA);\n        }\n        else {\n            // No, it's only found in A\n            aUnique.push(elementOfA);\n        }\n    }\n    for (const elementOfB of b) {\n        let seenInA = false;\n        // Does A contain this thing from B?\n        for (const elementOfA of a) {\n            if (eq(elementOfB, elementOfA)) {\n                seenInA = true;\n            }\n        }\n        if (!seenInA) {\n            // No, something unique to B\n            bUnique.push(elementOfB);\n        }\n    }\n    // Are the two iterables the same?\n    const isSame = aUnique.length === 0 && bUnique.length === 0;\n    return {\n        shared,\n        isSame,\n        a: aUnique,\n        b: bUnique\n    };\n};\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Rounds a number.\n *\n * If one parameter is given, it's the decimal places,\n * and a rounding function is returned:\n * ```js\n * const r = round(2);\n * r(10.12355); // 10.12\n * ```\n *\n * If two parameters are given, the first is decimal places,\n * the second the value to round.\n * ```js\n * round(2, 10.12355); // 10.12\n * ```\n * @param decimalPlaces\n * @returns\n */\nexport function round(a, b, roundUp) {\n    resultThrow(integerTest(a, `positive`, `decimalPlaces`));\n    const up = (typeof b === `boolean`) ? b : (roundUp ?? false);\n    let rounder;\n    if (a === 0) {\n        rounder = Math.round;\n    }\n    else {\n        const p = Math.pow(10, a);\n        if (up) {\n            rounder = (v) => Math.ceil(v * p) / p;\n        }\n        else {\n            rounder = (v) => Math.floor(v * p) / p;\n        }\n    }\n    if (typeof b === `number`)\n        return rounder(b);\n    return rounder;\n}\n","import { numberTest } from '@ixfx/guards';\nimport { round } from './util/round.js';\n// export function intervalToMs(interval: Interval | undefined): number | undefined;\n// export function intervalToMs(\n//   interval: Interval | undefined,\n//   defaultNumber: number\n// ): number;\n/**\n * Return the millisecond value of an Interval.\n *\n * ```js\n * intervalToMs(100); // 100\n * intervalToMs({ millis: 100 }); // 100\n * ```\n *\n * Use `defaultNumber` to return a default in the case of\n * _undefined_ or invalid input.\n *\n * ```js\n * intervalToMs(undefined);      // throws error\n * intervalToMs(undefined, 100); // 100\n * ```\n *\n * If no default is provided, an exception is thrown.\n * @param interval Interval\n * @param defaultNumber Default value if `interval` is _undefined_ or invalid\n * @returns Milliseconds\n */\nexport function intervalToMs(interval, defaultNumber) {\n    if (isInterval(interval)) {\n        // Number given, must be millis?\n        if (typeof interval === `number`)\n            return interval;\n        let ms = interval.millis ?? 0;\n        ms += (interval.hours ?? 0) * 60 * 60 * 1000;\n        ms += (interval.mins ?? 0) * 60 * 1000;\n        ms += (interval.secs ?? 0) * 1000;\n        return ms;\n    }\n    else {\n        if (typeof defaultNumber !== `undefined`)\n            return defaultNumber;\n        throw new Error(`Not a valid interval: ${JSON.stringify(interval)}`);\n    }\n}\n/**\n * Returns _true_ if `interval` matches the {@link Interval} type.\n * @param interval\n * @returns _True_ if `interval` is an {@link Interval}.\n */\nexport function isInterval(interval) {\n    if (typeof interval === `undefined`)\n        return false;\n    if (interval === null)\n        return false;\n    if (typeof interval === `number`) {\n        if (Number.isNaN(interval))\n            return false;\n        if (!Number.isFinite(interval))\n            return false;\n        return true;\n    }\n    if (typeof interval !== `object`)\n        return false;\n    const hasMillis = `millis` in interval;\n    const hasSecs = `secs` in interval;\n    const hasMins = `mins` in interval;\n    const hasHours = `hours` in interval;\n    if (hasMillis && !numberTest(interval.millis).success)\n        return false;\n    if (hasSecs && !numberTest(interval.secs).success)\n        return false;\n    if (hasMins && !numberTest(interval.mins).success)\n        return false;\n    if (hasHours && !numberTest(interval.hours).success)\n        return false;\n    if (hasMillis || hasSecs || hasHours || hasMins)\n        return true;\n    return false;\n}\n/**\n * Returns a human-readable representation\n * of some elapsed milliseconds\n *\n * @example\n * ```js\n * elapsedToHumanString(10);      // `10ms`\n * elapsedToHumanString(2000);    // `2s`\n * elapsedToHumanString(65*1000); // `1mins`\n * ```\n * @param millisOrFunction Milliseconds as a number, {@link Interval} or function that resolve to a number\n * @param rounding Rounding (default: 2)\n * @returns\n */\nexport const elapsedToHumanString = (millisOrFunction, rounding = 2) => {\n    let interval = 0;\n    if (typeof millisOrFunction === `function`) {\n        const intervalResult = millisOrFunction();\n        return elapsedToHumanString(intervalResult);\n    }\n    else if (typeof millisOrFunction === `number`) {\n        interval = millisOrFunction;\n    }\n    else if (typeof millisOrFunction === `object`) {\n        interval = intervalToMs(interval);\n    }\n    let ms = intervalToMs(interval);\n    if (typeof ms === `undefined`)\n        return `(undefined)`;\n    if (ms < 1000)\n        return `${round(rounding, ms)}ms`;\n    ms /= 1000;\n    if (ms < 120)\n        return `${ms.toFixed(1)}secs`;\n    ms /= 60;\n    if (ms < 60)\n        return `${ms.toFixed(2)}mins`;\n    ms /= 60;\n    return `${ms.toFixed(2)}hrs`;\n};\n"],"mappings":"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"}