{"version":3,"file":"arrays.js","names":["options: readonly T[] | T[]","indexOrValue: number | typeof opts[ number ]","array: V[]","index: number","array: readonly V[]","size: number","output: V[][]","itemToMakeStringFor: V","a: T","b: T","haystack: ArrayLike<V>","needles: ArrayLike<V>","data: Iterable<V>","array: V[] | readonly V[]","data: readonly V[] | V[]","length: number","expand: `undefined` | `repeat` | `first` | `last`","arrayA: V[]","arrayB: V[]","array: readonly V[] | V[]","equality?: IsEqual<V>","data: readonly V[]","filter: (a: V) => boolean","a: V[]","b: V[]","array: readonly V[] | V[]","predicate: (\n    value: V,\n    index: number,\n    array: readonly V[] | V[]\n  ) => boolean","startIndex?: number","endIndex?: number","array: ReadonlyArray<any> | Array<any>","groupBy: ((value: TValue) => TGroup)","data: TValue[]","groupBy","array: Iterable<V>","grouper: (item: V) => K","arrays:\n    | V[][]\n    | V[]\n    | readonly V[]\n    | readonly (readonly V[])[]","t: V[]","contains","v: V","data: readonly V[] | V[]","index: number","returnValue: V[]","arrayA: readonly V[] | V[]","arrayB: readonly V[] | V[]","equality: IsEqual<V>","keyFunction: (value: V) => string","reconcile: MergeReconcile<V>","values: T[]","array: readonly V[]","reducer: (accumulator: X, a: V, b: V) => X","initial: X","dataToShuffle: readonly V[]","rand: () => number","array: ArrayLike<V>","data: readonly V[] | V[]","index: number","array: ArrayLike<V>","amount: number","r: V[]","data: readonly V[] | V[]","propertyName: K","comparer?: (a: any, b: any) => number","data: readonly V[] | V[]","predicate: (v: V, accumulator?: A) => boolean | (readonly [ stop: boolean, acc: A ])","initial?: A","data: readonly V[] | V[]","sourceArray: readonly V[] | V[]","toRemove: V | V[]","comparer: IsEqual<V>","returnArray: V[]","returnValue: any[]"],"sources":["../packages/arrays/src/cycle.ts","../packages/arrays/src/at-wrap.ts","../packages/arrays/src/chunks.ts","../packages/arrays/src/util/to-string.ts","../packages/arrays/src/util/is-equal.ts","../packages/arrays/src/contains.ts","../packages/arrays/src/ensure-length.ts","../packages/arrays/src/equality.ts","../packages/arrays/src/filter.ts","../packages/arrays/src/flatten.ts","../packages/arrays/src/frequency.ts","../packages/arrays/src/group-by.ts","../packages/arrays/src/unique.ts","../packages/arrays/src/insert-at.ts","../packages/arrays/src/interleave.ts","../packages/arrays/src/intersection.ts","../packages/arrays/src/merge-by-key.ts","../packages/arrays/src/pairwise.ts","../packages/arrays/src/random.ts","../packages/arrays/src/remove.ts","../packages/arrays/src/sample.ts","../packages/arrays/src/sort.ts","../packages/arrays/src/until.ts","../packages/arrays/src/without.ts","../packages/arrays/src/zip.ts"],"sourcesContent":["\n/**\n * Returns a function that cycles through the contents of an array. By default starts at index 0.\n * \n * ```js\n * const c = arrayCycle([`apples`, `oranges`, `pears`]);\n * c.current; // `apples`\n * c.next();  // `oranges`\n * c.next();  // `pears`\n * c.next();  // `apples`\n * c.prev();  // `pears`\n * ```\n * \n * You can select an item by index or value:\n * ```\n * c.select(1); // `oranges`\n * c.select(`pears`); // `pears`\n * ```\n * \n * Other features:\n * ```js\n * c.current;   // Current value\n * c.toArray(); // Copy of array being cycled over\n * ```\n * \n * Additional info:\n * * Selecting by value uses === semantics.\n * * Works with a copy of input array\n * @param options Array to cycle over \n * @returns \n */\nexport const cycle = <T>(options: readonly T[] | T[]) => {\n  const opts = [ ...options ];\n  let index = 0;\n  const next = () => {\n    index++;\n    if (index === opts.length) index = 0;\n    return value();\n  }\n\n  // eslint-disable-next-line unicorn/prevent-abbreviations\n  const prev = () => {\n    index--;\n    if (index === -1) index = opts.length - 1;\n    return value();\n  }\n\n  const value = (): typeof opts[ number ] => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    return opts.at(index)!;\n  }\n\n  const select = (indexOrValue: number | typeof opts[ number ]) => {\n    if (typeof indexOrValue === `number`) {\n      index = indexOrValue;\n    } else {\n      const found = opts.indexOf(indexOrValue);\n      if (found === -1) throw new Error(`Could not find value`);\n      index = found;\n    }\n  }\n\n  const toArray = () => [ ...opts ];\n  return { toArray, next, prev, get current() { return value() }, select }\n}","import { numberTest, resultThrow } from \"@ixfx/guards\"\n\n/**\n * Similar to Javascript's in-built Array.at function, but allows offsets\n * to wrap.\n * \n * @remarks\n * ```js\n * const test = [1,2,3,4,5,6];\n * atWrap(0);   // 1\n * atWrap(-1);  // 6\n * atWrap(-6);  // 1\n * ```\n * \n * These values would return _undefined_ using Array.at since its beyond\n * the length of the array\n * ```js\n * atWrap(6);   // 1\n * atWrap(-7);  // 6\n * ```\n * @param array Array\n * @param index Index\n * @returns \n */\nexport const atWrap = <V>(array: V[], index: number) => {\n  resultThrow(numberTest(index, ``, `index`));\n  if (!Array.isArray(array)) throw new Error(`Param 'array' is not an array`);\n\n  index = index % array.length;\n  return array.at(index) as V;\n}","\n/**\n * Return `array` broken up into chunks of `size` values\n *\n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields: [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param array\n * @param size\n * @returns\n */\n\nexport function chunks<V>(\n  array: readonly V[],\n  size: number\n) {\n  // https://surma.github.io/underdash/\n  const output: V[][] = [];\n  for (let index = 0; index < array.length; index += size) {\n    output.push(array.slice(index, index + size));\n  }\n  return output;\n}","/**\n * A default converter to string that uses JSON.stringify if its an object, or the thing itself if it's a string\n */\nexport const toStringDefault = <V>(itemToMakeStringFor: V): string =>\n  typeof itemToMakeStringFor === `string`\n    ? itemToMakeStringFor\n    : JSON.stringify(itemToMakeStringFor);","import { toStringDefault } from \"./to-string.js\";\n\n/**\n * Function that returns true if `a` and `b` are considered equal\n */\nexport type IsEqual<T> = (a: T, b: T) => boolean;\n\n/**\n * If input is a string, it is returned.\n * Otherwise, it returns the result of JSON.stringify() with fields ordered.\n * \n * This allows for more consistent comparisons when object field orders are different but values the same.\n * @param itemToMakeStringFor \n * @returns \n */\n// export const toStringOrdered = (itemToMakeStringFor: unknown) => {\n//   if (typeof itemToMakeStringFor === `string`) return itemToMakeStringFor;\n//   const allKeys = new Set<string>();\n   \n//   JSON.stringify(itemToMakeStringFor, (key: string, value: unknown) => (allKeys.add(key), value));\n//   return JSON.stringify(itemToMakeStringFor, [ ...allKeys ].sort());\n// }\n\n\n/**\n * Default comparer function is equiv to checking `a === b`.\n * Use {@link isEqualValueDefault} to compare by value, via comparing JSON string representation.\n */\nexport const isEqualDefault = <T>(a: T, b: T): boolean => a === b;\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal.\n * Use {@link isEqualDefault} to compare using === semantics\n * Uses `toStringDefault` to generate a string representation (via `JSON.stringify`).\n * \n * Returns _false_ if the ordering of fields is different, even though values are identical:\n * ```js\n * isEqualValueDefault({ a: 10, b: 20}, { b: 20, a: 10 }); // false\n * ```\n * \n * Use {@link isEqualValueIgnoreOrder} to ignore order (with an overhead of additional processing).\n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * ```\n * \n * Use {@link isEqualValuePartial} to partially match `b` against `a`.\n * @returns True if the contents of `a` and `b` are equal\n */\nexport const isEqualValueDefault = <T>(a: T, b: T): boolean => {\n  // ✔ UNIT TESTED\n  if (a === b) return true; // Object references are the same, or string values are the same\n  return toStringDefault(a) === toStringDefault(b); // String representations are the same\n};\n\n/**\n * Returns _true_ if `a` contains the values of `b`. `a` may contain other values, but we\n * only check against what is in `b`. `a` and `b` must both be simple objects.\n * \n * ```js\n * const obj = {\n *  name: `Elle`,\n *  size: 100,\n *  colour: {\n *    red: 0.5,\n *    green: 0.1,\n *    blue: 0.2\n *  }\n * }\n * \n * isEqualValuePartial(obj, { name: `Elle` }); // true\n * isEqualValuePartial(obj, { name: { colour: red: { 0.5, green: 0.1  }} }); // true\n * \n * isEqualValuePartial(obj, { name: `Ellen` });     // false\n * isEqualValuePartial(obj, { lastname: `Elle` });  // false\n * ```\n * @param a \n * @param b \n * @param fieldComparer \n * @returns \n */\nexport const isEqualValuePartial = (a: Record<string,unknown>, b: Record<string,unknown>, fieldComparer?: IsEqual<unknown>): boolean => {\n  if (typeof a !== `object`) throw new Error(`Param 'a' expected to be object`);\n  if (typeof b !== `object`) throw new Error(`Param 'b' expected to be object`);\n\n  if (Object.is(a, b)) return true;\n  const comparer = fieldComparer ?? isEqualValuePartial;\n  for (const entryB of Object.entries(b)) {\n    const valueOnAKeyFromB = a[ entryB[ 0 ] ];\n    const valueB = entryB[ 1 ];\n    if (typeof valueOnAKeyFromB === `object` && typeof valueB === `object`) {\n      if (!comparer(valueOnAKeyFromB as Record<string,unknown>, valueB as Record<string,unknown>)) {\n        return false;\n      }\n    } else {\n      if (valueOnAKeyFromB !== valueB) {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\n\n/**\n * Comparer returns true if string representation of `a` and `b` are equal, regardless of field ordering.\n * Uses `toStringOrdered` to generate a string representation (via JSON.stringify`).\n * \n * ```js\n * isEqualValueIgnoreOrder({ a: 10, b: 20}, { b: 20, a: 10 }); // true\n * isEqualValue({ a: 10, b: 20}, { b: 20, a: 10 }); // false, fields are different order\n * ```\n * \n * There is an overhead to ordering fields. Use {@link isEqualValueDefault} if it's not possible that field ordering will change.\n * @returns True if the contents of `a` and `b` are equal\n * @typeParam T - Type of objects being compared\n */\n// export const isEqualValueIgnoreOrder = <T>(a: T, b: T): boolean => {\n//   // ✔ UNIT TESTED\n//   if (a === b) return true; // Object references are the same, or string values are the same\n//   return toStringOrdered(a) === toStringOrdered(b); // String representations are the same\n// };\n\n/**\n * Returns _true_ if Object.entries() is empty for `value`\n * @param value \n * @returns \n */\nexport const isEmptyEntries = (value: object) => [ ...Object.entries(value) ].length === 0;\n\n/**\n * Return _true_ if `a` and `b` ought to be considered equal\n * at a given path\n */\nexport type IsEqualContext<V> = (a: V, b: V | undefined, path: string) => boolean\n\n/**\n * Returns _true_ if `a` and `b are equal based on their JSON representations.\n * `path` is ignored.\n * @param a \n * @param b \n * @param path \n * @returns \n */\nexport const isEqualContextString: IsEqualContext<unknown> = (a: unknown, b: unknown, _path: string): boolean => {\n  return JSON.stringify(a) === JSON.stringify(b);\n}","import { isEqualDefault } from \"./util/is-equal.js\";\nimport { toStringDefault } from \"./util/to-string.js\";\n\n\n/**\n * Returns _true_ if all value in `needles` is contained in `haystack`.\n * \n * ```js\n * const a = ['apples','oranges','pears','mandarins'];\n * const b = ['pears', 'apples'];\n * contains(a, b); // True\n *\n * const c = ['pears', 'bananas'];\n * contains(a, b); // False ('bananas' does not exist in a)\n * ```\n * \n * If `needles` is empty, `contains` will return true.\n * @param haystack Array to search\n * @param needles Things to look for\n * @param eq\n */\nexport const contains = <V>(\n  haystack: ArrayLike<V>,\n  needles: ArrayLike<V>,\n  eq = isEqualDefault<V>\n) => {\n  if (!Array.isArray(haystack)) {\n    throw new TypeError(`Expects haystack parameter to be an array`);\n  }\n  if (!Array.isArray(needles)) {\n    throw new TypeError(`Expects needles parameter to be an array. Got: ${ typeof needles }`);\n  }\n\n  for (const needle of needles) {\n    let found = false;\n    for (const element of haystack) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      if (eq(needle, element)) {\n        found = true;\n        break;\n      }\n    }\n    if (!found) {\n      return false;\n    }\n  }\n  return true;\n};\n\n/**\n * Returns _true_ if array contains duplicate values.\n *\n * ```js\n * containsDuplicateValues(['a','b','a']); // True\n * containsDuplicateValues([\n *  { name: 'Apple' },\n *  { name: 'Apple' }\n * ]); // True\n * ```\n * \n * Uses JSON.toString() by default to compare values.\n * \n * See also:\n * * {@link containsDuplicateInstances}: Compare based on reference, rather than value\n * * {@link unique}: Get unique set of values in an array\n * * {@link isContentsTheSame}: Returns _true_ if every item in array is the same\n * @param data Array to examine\n * @param keyFunction Function to generate key string for object, uses JSON.stringify by default.\n * @returns\n */\nexport const containsDuplicateValues = <V>(\n  data: Iterable<V>,\n  keyFunction = toStringDefault<V>\n): boolean => {\n  if (typeof data !== `object`) throw new Error(`Param 'data' is expected to be an Iterable. Got type: ${ typeof data }`);\n  const set = new Set<string>();\n  for (const v of data) {\n    const string_ = keyFunction(v);\n    if (set.has(string_)) return true;\n    set.add(string_);\n  }\n  return false;\n};\n\n/**\n * Returns _true_ if array contains duplicate instances based on `===` equality checking\n * Use {@link containsDuplicateValues} if you'd rather compare by value.\n * @param array \n * @returns \n */\nexport const containsDuplicateInstances = <V>(array: V[] | readonly V[]): boolean => {\n  if (!Array.isArray(array)) throw new Error(`Parameter needs to be an array`);\n  for (let index = 0; index < array.length; index++) {\n    for (let x = 0; x < array.length; x++) {\n      if (index === x) continue;\n      if (array[ index ] === array[ x ]) return true;\n    }\n  }\n  return false;\n}","\nexport function ensureLength<V>(\n  data: readonly V[] | V[],\n  length: number,\n  expand: `repeat` | `first` | `last`\n): (V)[];\n\nexport function ensureLength<V>(\n  data: readonly V[] | V[],\n  length: number,\n  expand?: `undefined`\n): (V | undefined)[];\n\n/**\n * Returns a copy of an array with specified length - padded or truncated as needed.\n *\n * If the input array is too short, it will be expanded based on the `expand` strategy:\n *  - 'undefined': fill with _undefined_ (default)\n *  - 'repeat': repeat array elements, starting from position 0\n *  - 'first': repeat with first element from `data`\n *  - 'last': repeat with last element from `data`\n *\n * Truncate:\n * ```js\n * ensureLength([1,2,3], 2); // [1,2]\n * ```\n * \n * Padded:\n * ```js\n * ensureLength([1,2,3], 5, `undefined`); // [1,2,3,undefined,undefined]\n * ensureLength([1,2,3], 5, `repeat`);    // [1,2,3,1,2]\n * ensureLength([1,2,3], 5, `first`);     // [1,2,3,1,1]\n * ensureLength([1,2,3], 5, `last`);      // [1,2,3,3,3]\n * ```\n * @param data Input array to expand\n * @param length Desired length\n * @param expand Expand strategy\n * @typeParam V Type of array\n */\nexport function ensureLength<V>(\n  data: readonly V[] | V[],\n  length: number,\n  expand: `undefined` | `repeat` | `first` | `last` = `undefined`\n): (V | undefined)[] {\n  if (data === undefined) throw new Error(`Data undefined`);\n  if (!Array.isArray(data)) throw new Error(`data is not an array`);\n  if (data.length === length) return [ ...data ];\n  if (data.length > length) {\n    return data.slice(0, length);\n  }\n  const d = [ ...data ];\n  const add = length - d.length;\n\n  for (let index = 0; index < add; index++) {\n    switch (expand) {\n      case `undefined`: {\n        // @ts-expect-error all fine .....\n        d.push(undefined);\n        break;\n      }\n      case `repeat`: {\n        d.push(data[ index % data.length ]);\n        break;\n      }\n      case `first`: {\n        d.push(data[ 0 ]);\n        break;\n      }\n      case `last`: {\n        // @ts-expect-error all fine .....\n        d.push(data.at(-1));\n        break;\n      }\n      // No default\n    }\n  }\n  return d;\n};\n","import { isEqualDefault, isEqualValueDefault, type IsEqual } from \"./util/is-equal.js\";\nimport { arrayTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Returns _true_ if the two arrays have the same items at same indexes. \n * \n * Returns _false_ if arrays are of different length.\n * By default uses === semantics for equality checking.\n * \n * ```js\n * isEqual([ 1, 2, 3], [ 1, 2, 3 ]); // true\n * isEqual([ 1, 2, 3], [ 3, 2, 1 ]); // false\n * ```\n * \n * Compare by value\n * ```js\n * isEqual(a, b, isEqualValueDefault);\n * ```\n * \n * Custom compare, eg based on `name` field:\n * ```js\n * isEqual(a, b, (compareA, compareB) => compareA.name === compareB.name);\n * ```\n * @param arrayA \n * @param arrayB \n * @param equality Function to compare values\n */\nexport const isEqual = <V>(arrayA: V[], arrayB: V[], equality = isEqualDefault<V>): boolean => {\n  // TODO: 'eq' function could be a key-generating function too\n  resultThrow(\n    arrayTest(arrayA, `arrayA`),\n    arrayTest(arrayB, `arrayB`)\n  );\n\n  if (arrayA.length !== arrayB.length) return false;\n\n  for (let indexA = 0; indexA < arrayA.length; indexA++) {\n    if (!(equality(arrayA[ indexA ], arrayB[ indexA ]))) return false;\n  }\n  return true;\n}\n\n/**\n * Returns _true_ if all values in the array are the same. Uses value-based equality checking by default.\n * \n * @example Using default equality function\n * ```js\n * const a1 = [ 10, 10, 10 ];\n * containsIdenticalValues(a1); // True\n *\n * const a2 = [ { name:`Jane` }, { name:`John` } ];\n * containsIdenticalValues(a2); // True, even though object references are different\n * ```\n *\n * If we want to compare by value for objects that aren't readily\n * converted to JSON, you need to provide a function:\n *\n * ```js\n * containsIdenticalValues(someArray, (a, b) => {\n *  return (a.eventType === b.eventType);\n * });\n * ```\n *\n * Returns _true_ if `array` is empty.\n * @param array Array\n * @param equality Equality checker. Uses string-conversion checking by default\n * @returns\n */\nexport const containsIdenticalValues = <V>(\n  array: readonly V[] | V[],\n  equality?: IsEqual<V>\n): boolean => {\n  // TODO: 'equality' function could be a key-generating function too\n\n  if (!Array.isArray(array)) throw new Error(`Param 'array' is not an array.`);\n  if (array.length === 0) return true;\n  const eq = equality ?? isEqualValueDefault;\n  const a = array[ 0 ];\n  const r = array.some((v) => !eq(a, v));\n  if (r) return false;\n  return true;\n};","\nimport { arrayIndexTest, arrayTest, resultThrow } from \"@ixfx/guards\";\n\n\n\n/**\n * Returns two separate arrays of everything that `filter` returns _true_,\n * and everything it returns _false_ on. \n * \n * Same idea as the in-built Array.filter, but that only returns values for one case.\n * \n * ```js\n * const [ matching, nonMatching ] = filterAB(data, v => v.enabled);\n * // `matching` is a list of items from `data` where .enabled is true\n * // `nonMatching` is a list of items from `data` where .enabled is false\n * ```\n * @param data Array of data to filter\n * @param filter Function which returns _true_ to add items to the A list, or _false_ for items to add to the B list\n * @returns Array of two elements. The first is items that match `filter`, the second is items that do not.\n */\nexport const filterAB = <V>(\n  data: readonly V[],\n  filter: (a: V) => boolean\n): [ a: V[], b: V[] ] => {\n  const a: V[] = [];\n  const b: V[] = [];\n  for (const datum of data) {\n    if (filter(datum)) a.push(datum);\n    else b.push(datum);\n  }\n  return [ a, b ];\n};\n\n/**\n * Yields elements from `array` that match a given `predicate`, and moreover are between\n * the given `startIndex` (inclusive) and `endIndex` (exclusive).\n *\n * While this can be done with in the in-built `array.filter` function, it will\n * needlessly iterate through the whole array. It also avoids another alternative\n * of slicing the array before using `filter`.\n *\n * ```js\n * import { filterBetween } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Return 'registered' people between and including array indexes 5-10\n * const filtered = [...filterBetween(people, person => person.registered, 5, 10)];\n * ```\n * @param array Array to filter\n * @param predicate Filter function\n * @param startIndex Start index (defaults to 0)\n * @param endIndex End index (by default runs until end)\n */\nexport function* filterBetween<V>(\n  array: readonly V[] | V[],\n  predicate: (\n    value: V,\n    index: number,\n    array: readonly V[] | V[]\n  ) => boolean,\n  startIndex?: number,\n  endIndex?: number\n): Generator<V> {\n  resultThrow(arrayTest(array, `array`));\n  if (typeof startIndex === `undefined`) startIndex = 0;\n  if (typeof endIndex === `undefined`) endIndex = array.length; //- 1;\n\n  resultThrow(arrayIndexTest(array, startIndex, `startIndex`));\n  resultThrow(arrayIndexTest(array, endIndex - 1, `endIndex`));\n\n  for (let index = startIndex; index < endIndex; index++) {\n    if (predicate(array[ index ], index, array)) yield array[ index ];//t.push(array[ index ]);\n  }\n};\n\n","/**\n * Returns a 'flattened' copy of array, un-nesting arrays one level\n * ```js\n * flatten([1, [2, 3], [[4]] ]);\n * // Yields: [ 1, 2, 3, [4]];\n * ```\n * @param array\n * @returns\n */\nexport const flatten = (array: ReadonlyArray<any> | Array<any>): Array<any> =>\n  [ ...array ].flat();","/**\n * Computes the frequency of values by a grouping function.\n * \n * ```js\n * const data = [1,2,3,4,5,6,7,8,9,10];\n * // Returns 'odd' or 'even' for an input value\n * \n * const groupBy = v => v % 2 === 0 ? `even`:`odd`;\n * \n * const data = frequencyByGroup(groupBy, data);\n * // Yields map with:\n * //  key: 'even', value: 5\n * //  key: 'odd', value: 5\n * @param groupBy \n * @param data \n * @returns \n */\nexport const frequencyByGroup = <TValue, TGroup extends string | number>(groupBy: ((value: TValue) => TGroup), data: TValue[]): Map<TGroup, number> => {\n  if (!Array.isArray(data)) throw new TypeError(`Param 'array' is expected to be an array. Got type: '${ typeof data }'`);\n  const store = new Map<TGroup, number>();\n\n  for (const value of data) {\n    const group = groupBy(value);\n    if (typeof group !== `string` && typeof group !== `number`) {\n      throw new TypeError(`groupBy function is expected to return type string or number. Got type: '${ typeof group }' for value: '${ value }'`);\n    }\n    let groupValue = store.get(group);\n    groupValue ??= 0;\n    groupValue++;\n    store.set(group, groupValue);\n  }\n  return store;\n}","\n/**\n * Groups data by a function `grouper`, returning data as a map with string\n * keys and array values. Multiple values can be assigned to the same group.\n *\n * `grouper` must yield a string designated group for a given item.\n *\n * @example\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const data = [\n *  { age: 39, city: `London` },\n *  { age: 14, city: `Copenhagen` },\n *  { age: 23, city: `Stockholm` },\n *  { age: 56, city: `London` }\n * ];\n *\n * // Whatever the function returns will be the designated group\n * // for an item\n * const map = Arrays.groupBy(data, item => item.city);\n * ```\n *\n * This yields a Map with keys London, Stockholm and Copenhagen, and the corresponding values.\n *\n * ```\n * London: [{ age: 39, city: `London` }, { age: 56, city: `London` }]\n * Stockhom: [{ age: 23, city: `Stockholm` }]\n * Copenhagen: [{ age: 14, city: `Copenhagen` }]\n * ```\n * @param array Array to group\n * @param grouper Function that returns a key for a given item\n * @typeParam K Type of key to group by. Typically string.\n * @typeParam V Type of values\n * @returns Map\n */\nexport const groupBy = <K, V>(\n  array: Iterable<V>,\n  grouper: (item: V) => K\n) => {\n  const map = new Map<K, V[]>();\n\n  for (const a of array) {\n    const key = grouper(a);\n    let existing = map.get(key);\n    if (!existing) {\n      existing = [];\n      map.set(key, existing);\n    }\n    existing.push(a);\n  }\n  return map;\n};","import { isEqualDefault } from \"./util/is-equal.js\";\nimport { toStringDefault } from \"./util/to-string.js\";\n//import { additionalValues } from \"../iterables/sync/AdditionalValues.js\";\n\n/**\n * Combines the values of one or more arrays, removing duplicates.\n * ```js\n * const v = Arrays.uniqueDeep([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.uniqueDeep([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n * \n * By default uses Javascript's default equality checking\n * \n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * Iterables.additionalValues: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays\n * @param comparer\n * @returns\n */\nexport const uniqueDeep = <V>(\n  arrays:\n    | V[][]\n    | V[]\n    | readonly V[]\n    | readonly (readonly V[])[],\n  comparer = isEqualDefault<V>\n): V[] => {\n  const t: V[] = [];\n  const contains = (v: V) => {\n    for (const tValue of t) {\n      if (comparer(tValue, v)) return true;\n    }\n    return false;\n  }\n\n  const flattened = arrays.flat(10) as V[];\n\n  for (const v of flattened) {\n    if (!contains(v)) t.push(v);\n  }\n  return t;\n};\n\n/**\n * Combines the values of one or more arrays, removing duplicates.\n * Compares based on a string representation of object. Uses a Set\n * to avoid unnecessary comparisons, perhaps faster than `uniqueDeep`.\n * \n * ```js\n * const v = Arrays.unique([ [1, 2, 3, 4], [ 3, 4, 5, 6] ]);\n * // [ 1, 2, 3, 4, 5, 6]\n * ```\n *\n * A single array can be provided as well:\n * ```js\n * const v = Arrays.unique([ 1, 2, 3, 1, 2, 3 ]);\n * // [ 1, 2, 3 ]\n * ```\n * \n * By default uses JSON.toString() to compare values.\n * \n * See also:\n * * {@link intersection}: Overlap between two arrays\n * * Iterables.additionalValues: Yield values from an iterable not present in the other\n * * {@link containsDuplicateValues}: Returns true if array contains duplicates\n * @param arrays Array (or array of arrays) to examine\n * @param toString Function to convert values to a string for comparison purposes. By default uses JSON formatting.\n * @returns\n */\nexport const unique = <V>(\n  arrays:\n    | V[][]\n    | V[]\n    | readonly V[]\n    | readonly (readonly V[])[],\n  toString = toStringDefault\n): V[] => {\n  const matching = new Set<string>();\n  const t: V[] = [];\n  const flattened = arrays.flat(10) as V[];\n  for (const a of flattened) {\n    const stringRepresentation = toString(a);\n    if (matching.has(stringRepresentation)) continue;\n    matching.add(stringRepresentation);\n    t.push(a);\n  }\n  return t;\n}","/**\n * Inserts `values` at position `index`, shuffling remaining\n * items further down.\n * @param data \n * @param index \n * @param values \n * @returns \n */\nexport const insertAt = <V>(\n  data: readonly V[] | V[],\n  index: number,\n  ...values: V[]\n): V[] => {\n  if (!Array.isArray(data)) {\n    throw new TypeError(`Param 'data' is not an arry`);\n  }\n  return [ ...data.slice(0, index), ...values, ...data.slice(index + 1) ];\n};","import { containsIdenticalValues } from \"./equality.js\";\n\n/**\n * Returns an interleaving of two or more arrays. All arrays must be the same length.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const a = [`a`, `b`, `c`];\n * const b = [`1`, `2`, `3`];\n * const c = Arrays.interleave(a, b);\n * // Yields:\n * // [`a`, `1`, `b`, `2`, `c`, `3`]\n * ```\n * @param arrays\n * @returns\n */\nexport const interleave = <V>(\n  ...arrays: readonly (readonly V[])[] | V[][]\n): V[] => {\n  if (arrays.some((a) => !Array.isArray(a))) {\n    throw new Error(`All parameters must be an array`);\n  }\n  const lengths = arrays.map(a => (a as V[]).length);\n  if (!containsIdenticalValues(lengths)) {\n    throw new Error(`Arrays must be of same length`);\n  }\n\n  const returnValue: V[] = [];\n  const length = lengths[ 0 ];\n  for (let index = 0; index < length; index++) {\n    for (const array of arrays) {\n      returnValue.push(array[ index ]);\n    }\n  }\n  return returnValue;\n};\n","import { isEqualDefault, type IsEqual } from \"./util/is-equal.js\";\n\n\n/**\n * Returns the _intersection_ of two arrays: the elements that are in common.\n * \n * ```js\n * intersection([1, 2, 3], [2, 4, 6]);\n// returns [2]\n * ```\n * See also: \n * * {@link unique}: Unique set of items amongst one or more arrays\n * @param arrayA \n * @param arrayB \n * @param equality \n * @returns \n */\nexport const intersection = <V>(\n  arrayA: readonly V[] | V[],\n  arrayB: readonly V[] | V[],\n  equality: IsEqual<V> = isEqualDefault\n) => arrayA.filter((valueFromA) => arrayB.some((valueFromB) => equality(valueFromA, valueFromB)));\n","import type { MergeReconcile } from \"./types.js\";\n\n/**\n * Merges arrays left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also Core.Maps.mergeByKey if the input data is in Map form.\n *\n * For example, if we have the array A:\n * [`A-1`, `A-2`, `A-3`]\n *\n * And array B:\n * [`B-1`, `B-2`, `B-4`]\n *\n * And with the key function:\n * ```js\n * // Make a key for value based on last char\n * const keyFn = (v) => v.substr(-1, 1);\n * ```\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(keyFn, reconcile, arrayA, arrayB);\n * ```\n *\n * The final result will be:\n *\n * [`B!1`, `B!2`, `A-3`, `B-4`]\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param keyFunction Function to generate a unique key for data\n * @param reconcile Returns value to decide 'winner' when keys conflict.\n * @param arrays Arrays of data to merge\n */\nexport const mergeByKey = <V>(\n  keyFunction: (value: V) => string,\n  reconcile: MergeReconcile<V>,\n  ...arrays: readonly (readonly V[])[]\n): V[] => {\n  const result = new Map<string, V>();\n  for (const m of arrays) {\n    for (const mv of m) {\n      if (mv === undefined) continue;\n      const mk = keyFunction(mv);\n      let v = result.get(mk);\n      v = v ? reconcile(v, mv) : mv;\n      result.set(mk, v);\n    }\n  }\n  return [ ...result.values() ];\n};\n","import { resultThrow, arrayTest } from \"@ixfx/guards\";\n\n/**\n * Yields pairs made up of overlapping items from the input array.\n * \n * Throws an error if there are less than two entries.\n * \n * ```js\n * pairwise([1, 2, 3, 4, 5]);\n * Yields:\n * [ [1,2], [2,3], [3,4], [4,5] ]\n * ```\n * @param values \n */\nexport function* pairwise<T>(values: T[]) {\n  resultThrow(arrayTest(values, `values`));\n\n  if (values.length < 2) throw new Error(`Array needs to have at least two entries. Length: ${ values.length }`);\n\n  for (let index = 1; index < values.length; index++) {\n    yield [ values[ index - 1 ], values[ index ] ];\n  }\n}\n\n/**\n * Reduces in a pairwise fashion.\n *\n * Eg, if we have input array of [1, 2, 3, 4, 5], the\n * `reducer` fn will run with 1,2 as parameters, then 2,3, then 3,4 etc.\n * ```js\n * const values = [1, 2, 3, 4, 5]\n * reducePairwise(values, (acc, a, b) => {\n *  return acc + (b - a);\n * }, 0);\n * ```\n *\n * If input array has less than two elements, the initial value is returned.\n *\n * ```js\n * const reducer = (acc:string, a:string, b:string) => acc + `[${a}-${b}]`;\n * const result = reducePairwise(`a b c d e f g`.split(` `), reducer, `!`);\n * Yields: `![a-b][b-c][c-d][d-e][e-f][f-g]`\n * ```\n * @param array\n * @param reducer\n * @param initial\n * @returns\n */\nexport const pairwiseReduce = <V, X>(\n  array: readonly V[],\n  reducer: (accumulator: X, a: V, b: V) => X,\n  initial: X\n) => {\n  resultThrow(arrayTest(array, `arr`));\n  if (array.length < 2) return initial;\n  for (let index = 0; index < array.length - 1; index++) {\n    initial = reducer(initial, array[ index ], array[ index + 1 ]);\n  }\n  return initial;\n};\n","import { arrayTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Returns a shuffled copy of the input array.\n * @example\n * ```js\n * const d = [1, 2, 3, 4];\n * const s = shuffle(d);\n * // d: [1, 2, 3, 4], s: [3, 1, 2, 4]\n * ```\n * \n * It can be useful to randomly access each item from an array exactly once:\n * ```js\n * for (const value of shuffle(inputArray)) {\n *  // Do something with the value...\n * }\n * ```\n * @param dataToShuffle Input array\n * @param rand Random generator. `Math.random` by default.\n * @returns Copy with items moved around randomly\n * @typeParam V - Type of array items\n */\nexport const shuffle = <V>(\n  dataToShuffle: readonly V[],\n  rand: () => number = Math.random\n): V[] => {\n  resultThrow(arrayTest(dataToShuffle, `dataToShuffle`));\n\n  const array = [ ...dataToShuffle ];\n  for (let index = array.length - 1; index > 0; index--) {\n    const index_ = Math.floor(rand() * (index + 1));\n    [ array[ index ], array[ index_ ] ] = [ array[ index_ ], array[ index ] ];\n  }\n  return array;\n};\n\n/**\n * Returns a random element of an array\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomElement(v); // Yields `blue`, `red` or `orange`\n * ```\n *\n * Note that repeated calls might yield the same value\n * multiple times. If you want to random unique values, consider using {@link shuffle}.\n * \n * See also:\n * * {@link randomIndex} if you want a random index rather than value.\n * \n * @param array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomElement = <V>(\n  array: ArrayLike<V>,\n  rand: () => number = Math.random\n): V => {\n  resultThrow(arrayTest(array, `array`));\n  return array[ Math.floor(rand() * array.length) ];\n};\n\n/**\n * Returns a random array index.\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomIndex(v); // Yields 0, 1 or 2\n * ```\n *\n * Use {@link randomElement} if you want a value from `array`, not index.\n *\n * @param array Array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomIndex = <V>(\n  array: ArrayLike<V>,\n  rand: () => number = Math.random\n): number => Math.floor(rand() * array.length);\n","import { arrayIndexTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Removes an element at `index` index from `data`, returning the resulting array without modifying the original.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const v = [ 100, 20, 50 ];\n * const vv = Arrays.remove(2);\n *\n * Yields:\n *  v: [ 100, 20, 50 ]\n * vv: [ 100, 20 ]\n * ```\n *\n * Consider {@link without} if you want to remove an item by value.\n *\n * Throws an exception if `index` is outside the range of `data` array.\n * @param data Input array\n * @param index Index to remove\n * @typeParam V Type of array\n * @returns\n */\nexport const remove = <V>(\n  data: readonly V[] | V[],\n  index: number\n): V[] => {\n  if (!Array.isArray(data)) {\n    throw new TypeError(`'data' parameter should be an array`);\n  }\n  resultThrow(arrayIndexTest(data, index, `index`));\n\n  return [ ...data.slice(0, index), ...data.slice(index + 1) ];\n};","import { resultThrow, integerTest } from '@ixfx/guards';\n/**\n * Samples values from an array. \n * \n * If `amount` is less or equal to 1, it's treated as a percentage to sample.\n * Otherwise it's treated as every _n_th value to sample.\n *\n * @example \n * By percentage - get half of the items\n * ```\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const list = [1,2,3,4,5,6,7,8,9,10];\n * const sub = Arrays.sample(list, 0.5);\n * // Yields: [2, 4, 6, 8, 10]\n * ```\n *\n * @example\n * By steps - every third value\n * ```\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const list = [1,2,3,4,5,6,7,8,9,10];\n * const sub = Arrays.sample(list, 3);\n * // Yields:\n * // [3, 6, 9]\n * ```\n * @param array Array to sample\n * @param amount Amount, given as a percentage (0..1) or the number of interval (ie 3 for every third item)\n * @returns\n */\nexport const sample = <V>(array: ArrayLike<V>, amount: number): V[] => {\n  if (!Array.isArray(array)) throw new TypeError(`Param 'array' is not actually an array. Got type: ${ typeof array }`);\n  let subsampleSteps = 1;\n  if (amount <= 1) {\n    // Subsample based on a percentage\n    const numberOfItems = array.length * amount;\n    subsampleSteps = Math.round(array.length / numberOfItems);\n  } else {\n    subsampleSteps = amount;\n  }\n\n  resultThrow(integerTest(subsampleSteps, `positive`, `amount`));\n  if (subsampleSteps > array.length - 1) {\n    throw new Error(`Subsample steps exceeds array length`);\n  }\n  const r: V[] = [];\n  for (let index = subsampleSteps - 1; index < array.length; index += subsampleSteps) {\n    r.push(array[ index ]);\n  }\n  return r;\n};","import { arrayTest, resultThrow } from '@ixfx/guards';\n/**\n * Sorts an array of objects in ascending order\n * by the given property name, assuming it is a number.\n *\n * ```js\n * const data = [\n *  { size: 10, colour: `red` },\n *  { size: 20, colour: `blue` },\n *  { size: 5, colour: `pink` }\n * ];\n * const sorted = Arrays.sortByNumericProperty(data, `size`);\n *\n * Yields items ascending order:\n * [ { size: 5, colour: `pink` }, { size: 10, colour: `red` }, { size: 20, colour: `blue` } ]\n * ```\n * @param data\n * @param propertyName\n */\nexport const sortByNumericProperty = <V, K extends keyof V>(\n  data: readonly V[] | V[],\n  propertyName: K\n) => [ ...data ].sort((a, b) => {\n  resultThrow(arrayTest(data, `data`));\n  const av = a[ propertyName ];\n  const bv = b[ propertyName ];\n  if (av < bv) return -1;\n  if (av > bv) return 1;\n  return 0;\n});\n\n/**\n * Sorts an array of objects by some named property.\n * \n * ```js\n * const data = [\n *  { size: 10, colour: `red` },\n *  { size: 20, colour: `blue` },\n *  { size: 5, colour: `pink` }\n * ];\n * sortByProperty(data, `colour`);\n * \n * Yields [\n *  { size: 20, colour: `blue` },\n *  { size: 5, colour: `pink` }\n *  { size: 10, colour: `red` },\n * ]\n * ```\n * \n * You can also provide a custom comparer that is passed property values.\n * This function should return 0 if values are equal, 1 if `a > b` and -1 if `a < b`.\n * @param data \n * @param propertyName \n * @returns \n */\nexport const sortByProperty = <V, K extends keyof V>(\n  data: readonly V[] | V[],\n  propertyName: K,\n  comparer?: (a: any, b: any) => number\n) => [ ...data ].sort((a, b) => {\n  resultThrow(arrayTest(data, `data`));\n\n  const av = a[ propertyName ];\n  const bv = b[ propertyName ];\n  if (comparer === undefined) {\n    if (av < bv) return -1;\n    if (av > bv) return 1;\n    return 0;\n  } else {\n    return comparer(av, bv);\n  }\n});","/**\n * Yields all items in the input array, stopping when `predicate` returns _true_.\n * \n * @example Yield values until we hit 3\n * ```js\n * const data = [ 1, 2, 3, 4, 5 ];\n * until(data, v => v === 3)\n * // [ 1, 2 ]\n * ```\n */\nexport function until<V>(\n  data: readonly V[] | V[],\n  predicate: (v: V) => boolean\n): Generator<V>;\n\n/**\n * Yields all items in the input array, stopping when `predicate` returns _true_.\n * This version allows a value to be 'accumulated' somehow\n * \n * @example Yield values until a total of 4\n * ```js\n * const data = [ 1, 2, 3, 4, 5 ];\n * until(data, (v, accumulated) => [accumulated >= 6, accumulated + v ]);\n * // [ 1, 2, 3 ]\n * ```\n */\nexport function until<V, A>(\n  data: readonly V[] | V[],\n  predicate: (v: V, accumulator: A) => readonly [ stop: boolean, acc: A ],\n  initial: A\n): Generator<V>;\n\n/**\n * Yields all items in the input array for as long as `predicate` returns true.\n *\n * `predicate` yields arrays of `[stop:boolean, acc:A]`. The first value\n * is _true_ when the iteration should stop, and the `acc` is the accumulated value.\n * This allows `until` to be used to carry over some state from item to item.\n *\n * @example Stop when we hit an item with value of 3\n * ```js\n * const v = [...until([1,2,3,4,5], v => v === 3];\n * // [ 1, 2 ]\n * ```\n *\n * @example Stop when we reach a total, using 0 as initial value\n * ```js\n * // Stop when accumulated value reaches 6\n * const v = Arrays.until[1,2,3,4,5], (v, acc) => [acc >= 7, v+acc], 0);\n * // [1, 2, 3]\n * ```\n * @param data\n * @param predicate\n * @returns\n */\nexport function* until<V, A>(\n  data: readonly V[] | V[],\n  predicate: (v: V, accumulator?: A) => boolean | (readonly [ stop: boolean, acc: A ]),\n  initial?: A\n): Generator<V> {\n  let total = initial;\n  for (const datum of data) {\n    const r = predicate(datum, total);\n    if (typeof r === `boolean`) {\n      if (r) break;\n    } else {\n      const [ stop, accumulator ] = r;\n      if (stop) break;\n      total = accumulator;\n    }\n    yield datum;\n  }\n};","import { isEqualDefault, type IsEqual } from \"./util/is-equal.js\";\n\n/**\n * Returns a copy of an input array with _undefined_ values removed.\n * @param data \n * @returns \n */\nexport const withoutUndefined = <V>(data: readonly V[] | V[]): V[] => {\n  return data.filter(v => v !== undefined);\n}\n\n/**\n * Returns an array with value(s) omitted. \n * \n * If value is not found, result will be a copy of input.\n * Value checking is completed via the provided `comparer` function.\n * By default checking whether `a === b`. To compare based on value, use the `isEqualValueDefault` comparer.\n *\n * @example\n * ```js\n * const data = [100, 20, 40];\n * const filtered = without(data, 20); // [100, 40]\n * ```\n *\n * @example Using value-based comparison\n * ```js\n * const data = [{ name: `Alice` }, { name:`Sam` }];\n *\n * // This wouldn't work as expected, because the default comparer uses instance,\n * // not value:\n * without(data, { name: `Alice` });\n *\n * // So instead we can use a value comparer:\n * without(data, { name:`Alice` }, isEqualValueDefault);\n * ```\n *\n * @example Use a function\n * ```js\n * const data = [ { name: `Alice` }, { name:`Sam` }];\n * without(data, { name:`ALICE` }, (a, b) => {\n *  return (a.name.toLowerCase() === b.name.toLowerCase());\n * });\n * ```\n *\n * Consider {@link remove} to remove an item by index.\n *\n * @typeParam V - Type of array items\n * @param sourceArray Source array\n * @param toRemove Value(s) to remove\n * @param comparer Comparison function. If not provided `isEqualDefault` is used, which compares using `===`\n * @return Copy of array without value.\n */\nexport const without = <V>(\n  sourceArray: readonly V[] | V[],\n  toRemove: V | V[],\n  comparer: IsEqual<V> = isEqualDefault\n): V[] => {\n  if (Array.isArray(toRemove)) {\n    const returnArray: V[] = []\n    for (const source of sourceArray) {\n      if (!toRemove.some(v => comparer(source, v))) {\n        returnArray.push(source);\n      }\n    }\n    return returnArray;\n  } else {\n    return sourceArray.filter((v) => !comparer(v, toRemove));\n  }\n}","import { containsIdenticalValues } from \"./equality.js\";\n\n/**\n * Zip combines the elements of two or more arrays based on their index.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const a = [1,2,3];\n * const b = [`red`, `blue`, `green`];\n *\n * const c = Arrays.zip(a, b);\n * // Yields:\n * // [\n * //   [1, `red`],\n * //   [2, `blue`],\n * //   [3, `green`]\n * // ]\n * ```\n *\n * Typically the arrays you zip together are all about the same logical item. Eg, in the above example\n * perhaps `a` is size and `b` is colour. So thing #1 (at array index 0) is a red thing of size 1. Before\n * zipping we'd access it by `a[0]` and `b[0]`. After zipping, we'd have c[0], which is array of [1, `red`].\n * @param arrays\n * @returns Zipped together array\n */\nexport const zip = (\n  ...arrays: any[][] | readonly any[][] | readonly (readonly any[])[]\n): any[] => {\n  if (arrays.some((a) => !Array.isArray(a))) {\n    throw new Error(`All parameters must be an array`);\n  }\n  const lengths = arrays.map((a) => (a as any[]).length);\n  if (!containsIdenticalValues(lengths)) {\n    throw new Error(`Arrays must be of same length`);\n  }\n\n  const returnValue: any[] = [];\n  const length = lengths[ 0 ];\n\n  for (let index = 0; index < length; index++) {\n\n    returnValue.push(arrays.map((a) => a[ index ]));\n  }\n  return returnValue;\n};"],"mappings":"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"}