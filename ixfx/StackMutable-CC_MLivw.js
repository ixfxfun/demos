const e=(e,t,n)=>{let r=t.length+n.length,i=e.discardPolicy??`additions`,a=e.capacity??r,o=r-a;switch(e.debug&&console.log(`Stack.push: stackLen: ${t.length} potentialLen: ${r} toRemove: ${o} policy: ${i}`),i){case`additions`:return e.debug&&console.log(`Stack.push:DiscardAdditions: stackLen: ${t.length} slice: ${r-a} toAddLen: ${n.length}`),t.length===e.capacity?t:[...t,...n.slice(0,n.length-o)];case`newer`:return o>=t.length?n.slice(Math.max(0,n.length-a),Math.min(n.length,a)+1):(e.debug&&console.log(` from orig: ${JSON.stringify(t.slice(0,t.length-o))}`),[...t.slice(0,t.length-o),...n.slice(0,Math.min(n.length,a-o+1))]);case`older`:return[...t,...n].slice(o);default:throw Error(`Unknown discard policy ${i}`)}},t=(t,n,...r)=>{let i=n.length+r.length;return t.capacity&&i>t.capacity?e(t,n,r):[...n,...r]},n=(e,t)=>{if(t.length===0)throw Error(`Stack is empty`);return t.slice(0,-1)},r=(e,t)=>t.at(-1),i=(e,t)=>t.length===0,a=(e,t)=>e.capacity?t.length>=e.capacity:!1;var o=class{opts;data;constructor(e={},t=[]){this.opts=e,this.data=t}push(...e){return e.length===0||(this.data=t(this.opts,this.data,...e)),this.data.length}forEach(e){this.data.forEach(e)}forEachFromTop(e){[...this.data].reverse().forEach(e)}pop(){let e=r(this.opts,this.data);return this.data=n(this.opts,this.data),e}get isEmpty(){return i(this.opts,this.data)}get isFull(){return a(this.opts,this.data)}get peek(){return r(this.opts,this.data)}get length(){return this.data.length}};const s=(e={},...t)=>new o({...e},[...t]);export{r as a,e as c,a as i,s as n,n as o,i as r,t as s,o as t};