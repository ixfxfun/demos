{"version":3,"file":"sleep-BL2_YkuW.js","names":["value: unknown","range: StringGuardRange","optsOrMillis: SleepOpts<V>"],"sources":["../../packages/guards/src/string.ts","../../packages/core/src/sleep.ts"],"sourcesContent":["import type { GuardResult } from \"./types.js\";\nimport { throwFromResult } from \"./throw-from-result.js\";\n\nexport type StringGuardRange = `` | `non-empty`\n\n/**\n * Throws an error if parameter is not an string\n * @param value\n * @param parameterName\n */\nexport const stringTest = (value: unknown, range: StringGuardRange = ``, parameterName = `?`): GuardResult => {\n  if (typeof value !== `string`) return [ false, `Param '${ parameterName } is not type string. Got: ${ typeof value }` ];\n  switch (range) {\n    case `non-empty`:\n      if (value.length === 0) return [ false, `Param '${ parameterName } is empty` ];\n      break;\n  }\n  return [ true ];\n};\n\nexport const throwStringTest = (value: unknown, range: StringGuardRange = ``, parameterName = `?`) => {\n  throwFromResult(stringTest(value, range, parameterName));\n}\n\n","import { throwNumberTest } from '@ixfx/guards';\nimport { intervalToMs } from './interval-type.js';\nimport type { Interval } from './types.js';\n\nexport type SleepOpts<V> = Interval & Partial<{\n  readonly signal: AbortSignal;\n  readonly value: V;\n}>;\n\nif (typeof window === `undefined` || !(`requestAnimationFrame` in window)) {\n\n  if (typeof window === `undefined`) {\n    // @ts-expect-error\n    globalThis.requestAnimationFrame = (callback) => {\n      setTimeout(callback, 1);\n    }\n  }\n}\n\n/**\n * Returns after timeout period.\n *\n * @example In an async function\n * ```js\n * console.log(`Hello`);\n * await sleep(1000);\n * console.log(`There`); // Prints one second after\n * ```\n *\n * @example As a promise\n * ```js\n * console.log(`Hello`);\n * sleep({ millis: 1000 })\n *  .then(() => console.log(`There`)); // Prints one second after\n * ```\n *\n * If a timeout of 0 is given, `requestAnimationFrame` is used instead of `setTimeout`.\n *\n * {@link delay} and {@link sleep} are similar. `delay()` takes a parameter of what code to execute after the timeout, while `sleep()` just resolves after the timeout.\n *\n * A value can be provided, which is returned on awaking:\n * ```js\n * const v = await sleep({ seconds: 1, value: `hello`);\n * // v = `hello`\n * ```\n *\n * Provide an AbortSignal to cancel the sleep and throwing an exception\n * so code after the sleep doesn't happen.\n *\n * ```js\n * const ac = new AbortController();\n * setTimeout(() => { ac.abort(); }, 1000); // Abort after 1s\n *\n * // Sleep for 1min\n * await sleep({ minutes: 1, signal: ac.signal });\n * console.log(`Awake`); // This line doesn't get called because an exception is thrown when aborting\n * ```\n * @param optsOrMillis Milliseconds to sleep, or options\n * @return\n */\nexport const sleep = <V>(\n  optsOrMillis: SleepOpts<V>\n): Promise<V | undefined> => {\n  const timeoutMs = intervalToMs(optsOrMillis, 1);\n  const signal = optsOrMillis.signal;\n  const value = optsOrMillis.value;\n  throwNumberTest(timeoutMs, `positive`, `timeoutMs`);\n\n\n  if (timeoutMs === 0) {\n    return new Promise<V | undefined>((resolve) =>\n      requestAnimationFrame((_) => {\n        resolve(value);\n      })\n    );\n  } else {\n    return new Promise<V | undefined>((resolve, reject) => {\n      const onAbortSignal = () => {\n        clearTimeout(t);\n        if (signal) {\n          signal.removeEventListener(`abort`, onAbortSignal);\n          reject(new Error(signal.reason));\n        } else {\n          reject(new Error(`Cancelled`));\n        }\n      }\n\n      if (signal) {\n        signal.addEventListener(`abort`, onAbortSignal);\n      }\n      const t = setTimeout(() => {\n        signal?.removeEventListener(`abort`, onAbortSignal);\n        if (signal?.aborted) {\n          reject(new Error(signal.reason));\n          return;\n        }\n        resolve(value);\n      }, timeoutMs);\n    });\n  }\n};\n\n/**\n * Delays until `predicate` returns true.\n * Can be useful for synchronising with other async activities.\n * ```js\n * // Delay until 'count' reaches 5\n * await sleepWhile(() => count >= 5, 100);\n * ```\n * @param predicate \n * @param checkInterval \n */\nexport const sleepWhile = async (predicate: () => boolean, checkInterval: Interval = 100) => {\n  while (predicate()) {\n    await sleep(checkInterval);\n  }\n}"],"mappings":";;;;;;;;;AAUA,MAAa,aAAa,CAACA,OAAgBC,SAA2B,GAAG,iBAAiB,OAAoB;AAC5G,YAAW,WAAW,QAAS,QAAO,CAAE,QAAQ,SAAU,cAAe,mCAAoC,MAAO,CAAG;AACvH,SAAQ,OAAR;EACE,MAAM;AACJ,OAAI,MAAM,WAAW,EAAG,QAAO,CAAE,QAAQ,SAAU,cAAe,UAAY;AAC9E;CACH;AACD,QAAO,CAAE,IAAM;AAChB;AAED,MAAa,kBAAkB,CAACD,OAAgBC,SAA2B,GAAG,iBAAiB,OAAO;AACpG,iBAAgB,WAAW,OAAO,OAAO,cAAc,CAAC;AACzD;;;;ACbD,WAAW,YAAY,iBAAiB,0BAA0B,SAEhE;YAAW,YAAY,WAErB,YAAW,wBAAwB,CAAC,aAAa;AAC/C,aAAW,UAAU,EAAE;CACxB;AACF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CH,MAAa,QAAQ,CACnBC,iBAC2B;CAC3B,MAAM,YAAY,aAAa,cAAc,EAAE;CAC/C,MAAM,SAAS,aAAa;CAC5B,MAAM,QAAQ,aAAa;AAC3B,iBAAgB,YAAY,YAAY,WAAW;AAGnD,KAAI,cAAc,EAChB,QAAO,IAAI,QAAuB,CAAC,YACjC,sBAAsB,CAAC,MAAM;AAC3B,UAAQ,MAAM;CACf,EAAC;KAGJ,QAAO,IAAI,QAAuB,CAAC,SAAS,WAAW;EACrD,MAAM,gBAAgB,MAAM;AAC1B,gBAAa,EAAE;AACf,OAAI,QAAQ;AACV,WAAO,qBAAqB,QAAQ,cAAc;AAClD,WAAO,IAAI,MAAM,OAAO,QAAQ;GACjC,MACC,QAAO,IAAI,OAAO,YAAY;EAEjC;AAED,MAAI,OACF,QAAO,kBAAkB,QAAQ,cAAc;EAEjD,MAAM,IAAI,WAAW,MAAM;AACzB,WAAQ,qBAAqB,QAAQ,cAAc;AACnD,OAAI,QAAQ,SAAS;AACnB,WAAO,IAAI,MAAM,OAAO,QAAQ;AAChC;GACD;AACD,WAAQ,MAAM;EACf,GAAE,UAAU;CACd;AAEJ"}