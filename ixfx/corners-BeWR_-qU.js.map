{"version":3,"file":"corners-BeWR_-qU.js","names":["a: Point","b: Point","lines:Line[]","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","b","a","a?: Point3d | Point | number | Array<number> | ReadonlyArray<number>","b?: number | boolean","c?: number","a: Point | Point3d","xOrB?: Point | Point3d | number","y?: number","z?: number","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","pt: Writeable<Point>","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","pt: Writeable<Point>","a: Point","b?: Point","c?: Point","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","pt: Writeable<Point>","a1: Point | Point3d | number","ab2: Point | Point3d | number","ab3?: number","ab4?: number","ab5?: number","ab6?: number","pt: Writeable<Point>","pt: Point | Point3d","v: number","pt: Point","length","ptOrX: Point | number","y?: number","rect: RectPositioned | Rect","origin?: Point"],"sources":["../../packages/geometry/src/line/from-points.ts","../../packages/geometry/src/line/join-points-to-lines.ts","../../packages/geometry/src/point/get-point-parameter.ts","../../packages/geometry/src/point/distance.ts","../../packages/geometry/src/point/divider.ts","../../packages/geometry/src/point/subtract.ts","../../packages/geometry/src/point/point-type.ts","../../packages/geometry/src/point/angle.ts","../../packages/geometry/src/point/sum.ts","../../packages/geometry/src/point/multiply.ts","../../packages/geometry/src/point/magnitude.ts","../../packages/geometry/src/point/normalise.ts","../../packages/geometry/src/rect/corners.ts"],"sourcesContent":["import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nimport { guard as guardPoint } from '../point/guard.js';\n\n/**\n * Returns a line from two points\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line from 0,1 to 10,15\n * const line = Lines.fromPoints( { x:0, y:1 }, { x:10, y:15 });\n * // line is: { a: { x: 0, y: 1}, b: { x: 10, y: 15 } };\n * ```\n * @param a Start point\n * @param b End point\n * @returns \n */\nexport const fromPoints = (a: Point, b: Point): Line => {\n  guardPoint(a, `a`);\n  guardPoint(b, `b`);\n  a = Object.freeze({ ...a });\n  b = Object.freeze({ ...b });\n  return Object.freeze({\n    a: a,\n    b: b\n  });\n};\n\n","import type { Point } from \"../point/point-type.js\";\nimport { fromPoints } from \"./from-points.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n\n/**\n * Returns an array of lines that connects provided points. Note that line is not closed.\n * \n * Eg, if points a,b,c are provided, two lines are provided: a->b and b->c.\n * \n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const lines = Lines.joinPointsToLines(ptA, ptB, ptC);\n * // lines is an array of, well, lines\n * ```\n * @param points \n * @returns \n */\nexport const joinPointsToLines = (...points: ReadonlyArray<Point>): PolyLine => {\n  const lines:Line[] = [];\n\n  let start = points[ 0 ];\n\n  for (let index = 1; index < points.length; index++) {\n    //eslint-disable-next-line functional/immutable-data\n    lines.push(fromPoints(start, points[ index ]));\n    start = points[ index ];\n  }\n  return lines;\n};","import { isPoint, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n\nexport function getTwoPointParameters(a: Point, b: Point): [ a: Point, b: Point ];\nexport function getTwoPointParameters(a: Point3d, b: Point3d): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(a: Point, x: number, y: number): [ a: Point, b: Point ];\nexport function getTwoPointParameters(a: Point3d, x: number, y: number, z: number): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(ax: number, ay: number, bx: number, by: number): [ a: Point, b: Point ];\nexport function getTwoPointParameters(ax: number, ay: number, az: number, bx: number, by: number, bz: number): [ a: Point3d, b: Point3d ];\nexport function getTwoPointParameters(a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number) {\n  if (isPoint3d(a1) && isPoint3d(ab2)) return [ a1, ab2 ];\n  if (isPoint(a1) && isPoint(ab2)) return [ a1, ab2 ];\n  if (isPoint3d(a1)) {\n    const b = {\n      x: ab2,\n      y: ab3,\n      z: ab4\n    }\n    if (!isPoint3d(b)) throw new Error(`Expected x, y & z parameters`);\n    return [ a1, b ];\n  }\n  if (isPoint(a1)) {\n    const b = {\n      x: ab2,\n      y: ab3\n    }\n    if (!isPoint(b)) throw new Error(`Expected x & y parameters`);\n    return [ a1, b ];\n  }\n\n  if (typeof ab5 !== `undefined` && typeof ab4 !== `undefined`) {\n    const a = {\n      x: a1,\n      y: ab2,\n      z: ab3\n    };\n    const b = {\n      x: ab4,\n      y: ab5,\n      z: ab6\n    }\n    if (!isPoint3d(a)) throw new Error(`Expected x,y,z for first point`);\n    if (!isPoint3d(b)) throw new Error(`Expected x,y,z for second point`);\n    return [ a, b ];\n  }\n\n  const a = {\n    x: a1,\n    y: ab2\n  };\n  const b = {\n    x: ab3,\n    y: ab4\n  }\n  if (!isPoint(a)) throw new Error(`Expected x,y for first point`);\n  if (!isPoint(b)) throw new Error(`Expected x,y for second point`);\n  return [ a, b ];\n\n}\n\n/**\n * Returns a Point form of either a point, x,y params or x,y,z params.\n * If parameters are undefined, an empty point is returned (0, 0)\n * @ignore\n * @param a\n * @param b\n * @returns\n */\nexport function getPointParameter(\n  a?: Point3d | Point | number | Array<number> | ReadonlyArray<number>,\n  b?: number | boolean,\n  c?: number\n): Point | Point3d {\n  if (a === undefined) return { x: 0, y: 0 };\n\n  if (Array.isArray(a)) {\n    if (a.length === 0) return Object.freeze({ x: 0, y: 0 });\n    if (a.length === 1) return Object.freeze({ x: a[ 0 ], y: 0 });\n    if (a.length === 2) return Object.freeze({ x: a[ 0 ], y: a[ 1 ] });\n    if (a.length === 3) return Object.freeze({ x: a[ 0 ], y: a[ 1 ], z: a[ 2 ] });\n    throw new Error(\n      `Expected array to be 1-3 elements in length. Got ${ a.length }.`\n    );\n  }\n\n  if (isPoint(a)) {\n    return a;\n  } else if (typeof a !== `number` || typeof b !== `number`) {\n    throw new TypeError(\n      `Expected point or x,y as parameters. Got: a: ${ JSON.stringify(\n        a\n      ) } b: ${ JSON.stringify(b) }`\n    );\n  }\n\n  // x,y,z\n  if (typeof c === `number`) {\n    return Object.freeze({ x: a, y: b, z: c });\n  }\n  // x,y\n  return Object.freeze({ x: a, y: b });\n}","import { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from './point-type.js';\nimport { getPointParameter } from \"./get-point-parameter.js\";\n\nexport function distance(a: Point, b?: Point): number;\nexport function distance(a: Point, x: number, y: number): number;\n\n/**\n * Calculate distance between two points.\n * If both points have a `z` property, the distance is 3D distance is calculated.\n * If only one point has a `z`, it is ignored.\n *\n * ```js\n * // Distance between two points\n * const ptA = { x: 0.5, y:0.8 };\n * const ptB = { x: 1, y: 0.4 };\n * distance(ptA, ptB);\n * // Or, provide x,y as parameters\n * distance(ptA, 0.4, 0.9);\n *\n * // Distance from ptA to x: 0.5, y:0.8, z: 0.1\n * const ptC = { x: 0.5, y:0.5, z: 0.3 };\n * // With x,y,z as parameters:\n * distance(ptC, 0.5, 0.8, 0.1);\n * ```\n * @param a First point\n * @param xOrB Second point, or x coord\n * @param y y coord, if x coord is given\n * @param z Optional z coord, if x and y are given.\n * @returns\n */\nexport function distance(\n  a: Point | Point3d,\n  xOrB?: Point | Point3d | number,\n  y?: number,\n  z?: number\n): number {\n  const pt = getPointParameter(xOrB, y, z);\n  guard(pt, `b`);\n  guard(a, `a`);\n  return isPoint3d(pt) && isPoint3d(a) ? Math.hypot(pt.x - a.x, pt.y - a.y, pt.z - a.z) : Math.hypot(pt.x - a.x, pt.y - a.y);\n}\n","\nimport { getPointParameter, getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, guardNonZeroPoint, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function divide(a: Point, b: Point): Point;\nexport function divide(a: Point3d, b: Point3d): Point3d;\nexport function divide(a: Point, x: number, y: number): Point;\nexport function divide(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function divide(ax: number, ay: number, bx: number, by: number): Point;\nexport function divide(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points divide (a/b).\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when dividing a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * divide(ptA, ptB);\n * divide(x1, y1, x2, y2);\n * divide(ptA, x2, y2);\n * ```\n */\nexport function divide(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  if (ptB.x === 0) throw new TypeError('Cannot divide by zero (b.x is 0)');\n  if (ptB.y === 0) throw new TypeError('Cannot divide by zero (b.y is 0)');\n\n  const pt: Writeable<Point> = {\n    x: ptA.x / ptB.x,\n    y: ptA.y / ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    if (ptB.z === 0) throw new TypeError('Cannot divide by zero (b.z is 0)');\n\n    pt.z = (ptA.z ?? 0) / (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n\n\n/**\n * Returns a function that divides a point:\n * ```js\n * const f = divider(100, 200);\n * f(50,100); // Yields: { x: 0.5, y: 0.5 }\n * ```\n *\n * Input values can be Point, separate x,y and optional z values or an array:\n * ```js\n * const f = divider({ x: 100, y: 100 });\n * const f = divider( 100, 100 );\n * const f = divider([ 100, 100 ]);\n * ```\n *\n * Likewise the returned function an take these as inputs:\n * ```js\n * f({ x: 100, y: 100});\n * f( 100, 100 );\n * f([ 100, 100 ]);\n * ```\n *\n * Function throws if divisor has 0 for any coordinate (since we can't divide by 0)\n * @param a Divisor point, array of points or x\n * @param b Divisor y value\n * @param c Divisor z value\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport function divider(a: Point3d | Point | number | number[], b?: number, c?: number) {\n  const divisor = getPointParameter(a, b, c);\n  guardNonZeroPoint(divisor, `divisor`);\n\n  return (\n    aa: Point3d | Point | number | number[],\n    bb?: number,\n    cc?: number\n  ): Point => {\n    const dividend = getPointParameter(aa, bb, cc);\n\n    return typeof dividend.z === `undefined` ? Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n    }) : Object.freeze({\n      x: dividend.x / divisor.x,\n      y: dividend.y / divisor.y,\n      z: dividend.z / (divisor.z ?? 1),\n    });\n  };\n}\n","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function subtract(a: Point, b: Point): Point;\nexport function subtract(a: Point3d, b: Point3d): Point3d;\nexport function subtract(a: Point, x: number, y: number): Point;\nexport function subtract(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function subtract(ax: number, ay: number, bx: number, by: number): Point;\nexport function subtract(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points subtracted (a-b).\n * \n * `z` parameter is used if present. Uses a default value of 0 for 'z' when subtracting a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * subtract(ptA, ptB);\n * subtract(x1, y1, x2, y2);\n * subtract(ptA, x2, y2);\n * ```\n */\nexport function subtract(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  const pt: Writeable<Point> = {\n    x: ptA.x - ptB.x,\n    y: ptA.y - ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) - (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n","/**\n * A point, consisting of x, y and maybe z fields.\n */\nexport type Point = {\n  readonly x: number;\n  readonly y: number;\n  readonly z?: number;\n};\n\nexport type Point3d = Point & {\n  readonly z: number;\n};\n\n/**\n * Placeholder point: `{ x: NaN, y: NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder3d` get a point with `z` property.\n */\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Placeholder = Object.freeze({ x: Number.NaN, y: Number.NaN });\n\n/**\n * Placeholder point: `{x: NaN, y:NaN, z:NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder` to get a point without `z` property.\n */\nexport const Placeholder3d = Object.freeze({ x: Number.NaN, y: Number.NaN, z: Number.NaN });","import { piPi } from \"../pi.js\";\nimport { guard } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Returns the angle in radians between `a` and `b`.\n *\n * Eg if `a` is the origin, and `b` is another point,\n * in degrees one would get 0 to -180 when `b` was above `a`.\n *  -180 would be `b` in line with `a`.\n * Same for under `a`.\n *\n * Providing a third point `c` gives the interior angle, where `b` is the middle point.\n * \n * See also {@link angleRadianCircle} which returns coordinates on 0..Math.Pi*2\n * range. This avoids negative numbers.\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const angleRadian = (a: Point, b?: Point, c?: Point) => {\n  guard(a, `a`);\n\n  if (b === undefined) {\n    return Math.atan2(a.y, a.x);\n  }\n  guard(b, `b`);\n  if (c === undefined) {\n    return Math.atan2(b.y - a.y, b.x - a.x);\n  }\n\n  guard(c, `c`);\n  return Math.atan2(b.y - a.y, b.x - a.x) - Math.atan2(c.y - a.y, c.x - a.x);\n};\n\n/**\n * Returns the angle between point(s) using a radian circle system.\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param a \n * @param b \n * @param c \n * @returns \n */\nexport const angleRadianCircle = (a: Point, b?: Point, c?: Point) => {\n  const angle = angleRadian(a, b, c);\n  if (angle < 0) return angle + piPi\n  return angle;\n}","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function sum(a: Point, b: Point): Point;\nexport function sum(a: Point3d, b: Point3d): Point3d;\nexport function sum(a: Point, x: number, y: number): Point;\nexport function sum(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function sum(ax: number, ay: number, bx: number, by: number): Point;\nexport function sum(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points added.\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when adding a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * sum(ptA, ptB);\n * sum(x1, y1, x2, y2);\n * sum(ptA, x2, y2);\n * ```\n */\nexport function sum(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  const pt: Writeable<Point> = {\n    x: ptA.x + ptB.x,\n    y: ptA.y + ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) + (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\nimport type { Writeable } from \"@ixfx/core\";\n\nexport function multiply(a: Point, b: Point): Point;\nexport function multiply(a: Point3d, b: Point3d): Point3d;\nexport function multiply(a: Point, x: number, y: number): Point;\nexport function multiply(a: Point3d, x: number, y: number, z: number): Point3d;\nexport function multiply(ax: number, ay: number, bx: number, by: number): Point;\nexport function multiply(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n\n/**\n * Returns a Point with the x,y,z values of two points multiply (a/b).\n * \n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when multiplying a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * multiply(ptA, ptB);\n * multiply(x1, y1, x2, y2);\n * multiply(ptA, x2, y2);\n * ```\n */\nexport function multiply(\n  a1: Point | Point3d | number, ab2: Point | Point3d | number, ab3?: number, ab4?: number, ab5?: number, ab6?: number\n): Point | Point3d {\n  const [ ptA, ptB ] = getTwoPointParameters(a1 as any, ab2 as any, ab3 as any, ab4 as any, ab5 as any, ab6 as any);\n  guard(ptA, `a`);\n  guard(ptB, `b`);\n  const pt: Writeable<Point> = {\n    x: ptA.x * ptB.x,\n    y: ptA.y * ptB.y,\n  };\n  if (isPoint3d(ptA) || isPoint3d(ptB)) {\n    pt.z = (ptA.z ?? 0) * (ptB.z ?? 0);\n  };\n  return Object.freeze(pt);\n};\n\n/**\n * Multiplies all components by `v`.\n * Existing properties of `pt` are maintained.\n *\n * ```js\n * multiplyScalar({ x:2, y:4 }, 2);\n * // Yields: { x:4, y:8 }\n * ```\n * @param pt Point\n * @param v Value to multiply by\n * @returns\n */\nexport const multiplyScalar = (\n  pt: Point | Point3d,\n  v: number\n): Point | Point3d => {\n  return isPoint3d(pt) ? Object.freeze({\n    ...pt,\n    x: pt.x * v,\n    y: pt.y * v,\n    z: pt.z * v,\n  }) : Object.freeze({\n    ...pt,\n    x: pt.x * v,\n    y: pt.y * v,\n  });\n};\n\n","import { distance } from \"./distance.js\";\nimport { multiply } from \"./multiply.js\";\nimport type { Point } from \"./point-type.js\";\n\n/**\n * Clamps the magnitude of a point.\n * This is useful when using a Point as a vector, to limit forces.\n * @param pt\n * @param max Maximum magnitude (1 by default)\n * @param min Minimum magnitude (0 by default)\n * @returns\n */\nexport const clampMagnitude = (pt: Point, max = 1, min = 0): Point => {\n  const length = distance(pt);\n  let ratio = 1;\n  if (length > max) {\n    ratio = max / length;\n  } else if (length < min) {\n    ratio = min / length;\n  }\n  return ratio === 1 ? pt : multiply(pt, ratio, ratio);\n};","import { Empty } from \"./empty.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\nimport { isPoint } from \"./guard.js\";\nimport type { Point } from \"./point-type.js\";\n\nconst length = (ptOrX: Point | number, y?: number): number => {\n  if (isPoint(ptOrX)) {\n    y = ptOrX.y;\n    ptOrX = ptOrX.x;\n  }\n  if (y === undefined) throw new Error(`Expected y`);\n  return Math.hypot(ptOrX, y);\n};\n\n\n\n/**\n * Normalise point as a unit vector.\n *\n * ```js\n * normalise({x:10, y:20});\n * normalise(10, 20);\n * ```\n * @param ptOrX Point, or x value\n * @param y y value if first param is x\n * @returns\n */\nexport const normalise = (ptOrX: Point | number, y?: number): Point => {\n  const pt = getPointParameter(ptOrX, y);\n  const l = length(pt);\n  if (l === 0) return Empty;\n  return Object.freeze({\n    ...pt,\n    x: pt.x / l,\n    y: pt.y / l,\n  });\n};","import { type Point } from \"../point/point-type.js\";\nimport { getRectPositioned } from \"./guard.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n\n/**\n * Returns the four corners of a rectangle as an array of Points.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0};\n * const pts = Rects.corners(rect);\n * ```\n *\n * If the rectangle is not positioned, is origin can be provided.\n * Order of corners: ne, nw, sw, se\n * @param rect\n * @param origin\n * @returns\n */\nexport const corners = (\n  rect: RectPositioned | Rect,\n  origin?: Point\n): ReadonlyArray<Point> => {\n  const r = getRectPositioned(rect, origin);\n  return [\n    { x: r.x, y: r.y },\n    { x: r.x + r.width, y: r.y },\n    { x: r.x + r.width, y: r.y + r.height },\n    { x: r.x, y: r.y + r.height },\n  ];\n};"],"mappings":"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"}