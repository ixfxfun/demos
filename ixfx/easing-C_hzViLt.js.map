{"version":3,"file":"easing-C_hzViLt.js","names":["value: unknown","interpolate","amount: number","a: Point","b: Point","origin: Point","width: number","height: number","start: Point","end: Point","q: QuadraticBezier | CubicBezier","BezierLibrary","amount: number","handle: Point","cubicOrQuadratic: CubicBezier | QuadraticBezier","cubic1: Point","cubic2: Point","cubic: CubicBezier","cubic","t: number","_: Point","_point: Point","_intersectionThreshold: number","quadraticBezier: QuadraticBezier","quadratic","duration: Interval","opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean }","t: ModulationTimer | undefined","totalTicks: number","total: number","options: Partial<RelativeTimerOpts>","value: number","amt: number","frequency: number","options: Partial<TimerOpts>","fn: ((v: number) => number)","timer: CompletionTimer","pow","time","relative","ticks","Named"],"sources":["../../packages/guards/src/function.ts","../../packages/geometry/src/point/interpolate.ts","../../packages/geometry/src/rect/from-top-left.ts","../../packages/geometry/src/bezier/index.ts","../../packages/flow/src/timer.ts","../../packages/modulation/dist/src/gaussian.js","../../packages/modulation/dist/src/easing/easings-named.js","../../packages/modulation/dist/src/easing/line.js","../../packages/modulation/dist/src/modulator-timed.js","../../packages/modulation/dist/src/easing/index.js"],"sourcesContent":["import type { Result } from \"./types.js\";\n\nexport const isFunction = (object: unknown): object is (...args: any[]) => any => object instanceof Function;\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\nexport const functionTest = (value: unknown, parameterName = `?`): Result<Function, string> => {\n  if (value === undefined) return { success: false, error: `Param '${ parameterName }' is undefined. Expected: function.` };\n  if (value === null) return { success: false, error: `Param '${ parameterName }' is null. Expected: function.` };\n  if (typeof value !== `function`) return { success: false, error: `Param '${ parameterName }' is type '${ typeof value }'. Expected: function` };\n  return { success: true, value };\n}\n\n// export const throwFunctionTest = (value: unknown, parameterName = `?`) => {\n//   const [ ok, message ] = functionTest(value, parameterName);\n//   if (ok) return;\n//   throw new TypeError(message);\n// }","import type { Point } from \"./point-type.js\";\nimport { interpolate as lineInterpolate } from '../line/interpolate.js';\n\n/**\n * Returns a relative point between two points\n * ```js\n * interpolate(0.5, a, b); // Halfway point between a and b\n * ```\n *\n * Alias for Lines.interpolate(amount, a, b);\n *\n * @param amount Relative amount, 0-1\n * @param a\n * @param b\n * @param allowOverflow If true, length of line can be exceeded for `amount` of below 0 and above `1`.\n * @returns {@link Point}\n */\nexport const interpolate = (\n  amount: number,\n  a: Point,\n  b: Point,\n  allowOverflow = false\n): Point => lineInterpolate(amount, a, b, allowOverflow); //({x: (1-amt) * a.x + amt * b.x, y:(1-amt) * a.y + amt * b.y });\n","import type { Point } from \"../point/point-type.js\";\nimport { guardDim } from \"./guard.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\nimport { guard as PointsGuard } from '../point/guard.js';\n\n/**\n * Creates a rectangle from its top-left coordinate, a width and height.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Rectangle at 50,50 with width of 100, height of 200.\n * const rect = Rects.fromTopLeft({ x: 50, y:50 }, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromTopLeft = (\n  origin: Point,\n  width: number,\n  height: number\n): RectPositioned => {\n  guardDim(width, `width`);\n  guardDim(height, `height`);\n  PointsGuard(origin, `origin`);\n\n  return { x: origin.x, y: origin.y, width: width, height: height };\n};\n","import { Bezier as BezierLibrary } from 'bezier-js';\nimport { interpolate as LinesInterpolate } from '../line/interpolate.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/from-top-left.js';\nimport type { Point } from '../point/point-type.js';\nimport type { CubicBezier, CubicBezierPath, QuadraticBezier, QuadraticBezierPath } from './bezier-type.js';\nimport { isCubicBezier, isQuadraticBezier } from './guard.js';\nimport { to2d } from '../point/To.js';\nexport * from './bezier-type.js';\nexport * from './guard.js';\n/**\n * Returns a new quadratic bezier with specified bend amount\n *\n * @param {QuadraticBezier} b Curve\n * @param {number} [bend=0] Bend amount, from -1 to 1\n * @returns {QuadraticBezier}\n */\n// export const quadraticBend = (a: Point, b: Point, bend = 0): QuadraticBezier => quadraticSimple(a, b, bend);\n\n/**\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve.\n * \n * Use {@link interpolator} to calculate a point along the curve.\n * @param {Point} start Start of curve\n * @param {Point} end End of curve\n * @param {number} [bend=0] Bend amount, -1 to 1\n * @returns {QuadraticBezier}\n */\nexport const quadraticSimple = (start: Point, end: Point, bend = 0): QuadraticBezier => {\n  if (Number.isNaN(bend)) throw new Error(`bend is NaN`);\n  if (bend < -1 || bend > 1) throw new Error(`Expects bend range of -1 to 1`);\n\n  const middle = LinesInterpolate(0.5, start, end);\n  let target = middle;\n  if (end.y < start.y) {\n    // Upward slope\n    target = bend > 0 ? { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.max(start.x, end.x), y: Math.max(start.y, end.y) };\n  } else {\n    // Downward slope\n    target = bend > 0 ? { x: Math.max(start.x, end.x), y: Math.min(start.y, end.y) } :\n      { x: Math.min(start.x, end.x), y: Math.max(start.y, end.y) };\n  }\n\n  const handle = LinesInterpolate(Math.abs(bend), middle, target,);\n  return quadratic(start, end, handle);\n};\n\n/**\n * Returns a relative point on a simple quadratic \n * @param start Start\n * @param end  End\n * @param bend Bend (-1 to 1)\n * @param amt Amount\n * @returns Point\n */\n// export const computeQuadraticSimple = (start: Point, end: Point, bend: number, amt: number): Point => {\n//   const q = quadraticSimple(start, end, bend);\n//   const bzr = new BezierLibrary(q.a, q.quadratic, q.b);\n//   return bzr.compute(amt);\n// };\n\n/**\n * Interpolate cubic or quadratic bezier\n * ```js\n * const i = interpolator(myBezier);\n * \n * // Get point at 50%\n * i(0.5); // { x, y }\n * ```\n * @param q \n * @returns \n */\nexport const interpolator = (q: QuadraticBezier | CubicBezier): (amount: number) => Point => {\n  //console.log(q);\n  //if (isCubicBezier(q)) console.log(`is cubic`);\n  //const bzr = isCubicBezier(q) ? new BezierLibrary(to2d(q.a), to2d(q.cubic1), to2d(q.cubic2), to2d(q.b)) : new BezierLibrary(q.a, q.quadratic, q.b);\n  const bzr = isCubicBezier(q) ?\n    new BezierLibrary(q.a.x, q.a.y, q.cubic1.x, q.cubic1.y, q.cubic2.x, q.cubic2.y, q.b.x, q.b.y) :\n    new BezierLibrary(q.a, q.quadratic, q.b);\n\n  return (amount: number) => bzr.compute(amount);\n};\n\n//https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\nexport const quadraticToSvgString = (start: Point, end: Point, handle: Point): ReadonlyArray<string> => [ `M ${ start.x } ${ start.y } Q ${ handle.x } ${ handle.y } ${ end.x } ${ end.y }` ];\n\nexport const toPath = (cubicOrQuadratic: CubicBezier | QuadraticBezier): CubicBezierPath | QuadraticBezierPath => {\n  if (isCubicBezier(cubicOrQuadratic)) {\n    return cubicToPath(cubicOrQuadratic);\n  } else if (isQuadraticBezier(cubicOrQuadratic)) {\n    return quadratictoPath(cubicOrQuadratic);\n  } else {\n    throw new Error(`Unknown bezier type`);\n  }\n};\n\nexport const cubic = (start: Point, end: Point, cubic1: Point, cubic2: Point): CubicBezier => (\n  {\n    a: Object.freeze(start),\n    b: Object.freeze(end),\n    cubic1: Object.freeze(cubic1),\n    cubic2: Object.freeze(cubic2)\n  });\n\nconst cubicToPath = (cubic: CubicBezier): CubicBezierPath => {\n  const { a, cubic1, cubic2, b } = cubic;\n\n  const bzr = new BezierLibrary(a, cubic1, cubic2, b);\n  return Object.freeze({\n    ...cubic,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number) => {\n      throw new Error(`Not implemented`);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n    },\n    toSvgString: () => [ `brrup` ],\n    kind: `bezier/cubic`\n  });\n};\n\nexport const quadratic = (start: Point, end: Point, handle: Point): QuadraticBezier => ({\n  a: Object.freeze(start),\n  b: Object.freeze(end),\n  quadratic: Object.freeze(handle)\n});\n\n\nconst quadratictoPath = (quadraticBezier: QuadraticBezier): QuadraticBezierPath => {\n  const { a, b, quadratic } = quadraticBezier;\n  const bzr = new BezierLibrary(a, quadratic, b);\n  return Object.freeze({\n    ...quadraticBezier,\n    length: () => bzr.length(),\n    interpolate: (t: number) => bzr.compute(t),\n    nearest: (_: Point) => { throw new Error(`not implemented`); },\n    bbox: () => {\n      const { x, y } = bzr.bbox();\n      const xSize = x.size;\n      const ySize = y.size;\n      if (xSize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      if (ySize === undefined) throw new Error(`x.size not present on calculated bbox`);\n      return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n    },\n    distanceToPoint: (_point: Point): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    relativePosition: (_point: Point, _intersectionThreshold: number): number => {\n      throw new Error(`Not implemented`);\n\n    },\n    toString: () => bzr.toString(),\n    toSvgString: () => quadraticToSvgString(a, b, quadratic),\n    kind: `bezier/quadratic`\n  });\n};\n\n","import { clamp } from '@ixfx/numbers';\nimport { intervalToMs, type HasCompletion, type Interval } from '@ixfx/core';\n\n/**\n * Creates a timer\n */\nexport type TimerSource = () => Timer;\n\n/**\n * A timer instance.\n * {@link CompletionTimer} also contains an 'isDone' field.\n * \n * Implementations: {@link elapsedMillisecondsAbsolute}, {@link elapsedTicksAbsolute}, {@link frequencyTimer}\n */\nexport type Timer = {\n  reset(): void\n  get elapsed(): number\n};\n\n/**\n * A {@link Timer} that has a sense of completion, when `isDone` returns _true_.\n * See {@link relative}\n */\nexport type CompletionTimer = Timer & {\n  /**\n   * Returns _true_ if this timer has completed.\n   */\n  get isDone(): boolean\n}\n\nexport type ModulationTimer = CompletionTimer & {\n  mod(amt: number): void;\n};\n\n\nexport type TimerOpts = {\n  /**\n   * Timer to use. By default {@link elapsedMillisecondsAbsolute}.\n   */\n  readonly timer: Timer;\n};\n\n/**\n * Options for relative timer\n */\nexport type RelativeTimerOpts = TimerOpts & {\n  /**\n   * If true, returned value will be clamped to 0..1. False by default\n   */\n  readonly clampValue: boolean\n  readonly wrapValue: boolean\n};\n\n/**\n * A function that returns _true_ when an interval has elapsed\n *\n * ```js\n * import { hasElapsed } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const oneSecond = hasElapsed(1000);\n * \n * // Keep calling to check if time has elapsed.\n * // Will return _true_ when it has\n * oneSecond();\n * ```\n * \n * @param elapsed\n * @returns\n */\nexport function hasElapsed(elapsed: Interval): () => boolean {\n  const t = relative(intervalToMs(elapsed, 0), { timer: elapsedMillisecondsAbsolute(), clampValue: true });\n  return () => t.isDone;\n}\n\n// export const frequencyTimerSource =\n//   (frequency: number): TimerSource =>\n//     () =>\n//       frequencyTimer(frequency, { timer: elapsedMillisecondsAbsolute() });\n\n/**\n * Returns a function that returns the percentage of timer completion.\n * Starts when return function is first invoked.\n *\n * ```js\n * import * as Flow from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const timer = Flow.ofTotal(1000);\n * \n * // Call timer() to find out the completion\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Flow.ofTotal(1000, { clampValue: true });\n * ```\n *\n * Takes an {@link Interval} for more expressive time:\n * ```js\n * const timer = Flow.ofTotal({ mins: 4 });\n * ```\n * \n * Is a simple wrapper around {@link relative}.\n * @param duration\n * @see {@link ofTotalTicks} - Use ticks instead of time\n * @see {@link hasElapsed} - Simple _true/false_ if interval has elapsed\n * @returns\n */\nexport function ofTotal(\n  duration: Interval,\n  opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean } = {}\n): () => number {\n  const totalMs = intervalToMs(duration);\n  if (!totalMs) throw new Error(`Param 'duration' not valid`);\n  const timerOpts = {\n    ...opts,\n    timer: elapsedMillisecondsAbsolute(),\n  };\n  let t: ModulationTimer | undefined;\n  return () => {\n    t ??= relative(totalMs, timerOpts);\n    return t.elapsed;\n  }\n}\n\n/**\n * Returns a function that returns the percentage (0..1) of timer completion.\n * Uses 'ticks' as a measure. Use {@link ofTotal} if you want time-based.\n *\n * ```js\n * import * as Flow from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const timer = Flow.ofTotalTicks(1000);\n * timer(); // Returns 0..1\n * ```\n *\n * Note that timer can exceed 1 (100%). To cap it:\n * ```js\n * Flow.ofTotalTicks(1000, { clampValue: true });\n * ```\n *\n * This is a a simple wrapper around {@link relative}.\n * @see {@link ofTotal}\n * @see {@link hasElapsed}: Simple _true/false_ if interval has elapsed\n * @param totalTicks\n * @returns\n */\nexport function ofTotalTicks(totalTicks: number, opts: { readonly clampValue?: boolean, readonly wrapValue?: boolean } = {}\n): () => number {\n  const timerOpts = {\n    ...opts,\n    timer: elapsedTicksAbsolute(),\n  };\n  let t: ModulationTimer | undefined;\n  return () => {\n    t ??= relative(totalTicks, timerOpts);\n    return t.elapsed;\n  }\n}\n\n/**\n * Returns a {@link ModulationTimer} that is always at 100%.\n * Opposite: {@link timerNeverDone}.\n * @returns \n */\nexport const timerAlwaysDone = (): ModulationTimer => ({\n  elapsed: 1,\n  isDone: true,\n  reset(): void {\n\n  },\n  mod(amt) {\n\n  },\n})\n\n/**\n * Returns a {@link ModulationTimer} that is always at 0%.\n * Opposite: {@link timerAlwaysDone}.\n * @returns \n */\nexport const timerNeverDone = (): ModulationTimer => (\n  {\n    elapsed: 0,\n    isDone: false,\n    reset() {\n\n    },\n    mod() {\n\n    }\n  }\n);\n\n/**\n * Wraps a timer, returning a relative elapsed value based on\n * a given total. ie. percentage complete toward a total value.\n * This is useful because other parts of code don't need to know\n * about the absolute time values, you get a nice relative completion number.\n *\n * If no timer is specified, a milliseconds-based timer is used.\n *\n * ```js\n * const t = relative(1000);\n * t.elapsed;   // returns % completion (0...1)\n * ```\n * It can also use a tick based timer\n * ```js\n * // Timer that is 'done' at 100 ticks\n * const t = relative(100, { timer: ticksElapsedTimer() });\n * ```\n * \n * Additional fields/methods on the timer instance\n * ```js\n * t.isDone;  // _true_ if .elapsed has reached (or exceeded) 1\n * t.reset(); // start from zero again\n * ```\n *\n * Options:\n * * timer: timer to use. If not specified, `elapsedMillisecondsAbsolute()` is used.\n * * clampValue: if _true_, return value is clamped to 0..1 (default: _false_)\n * * wrapValue: if _true_, return value wraps around continously from 0..1..0 etc. (default: _false_)\n * \n * Note that `clampValue` and `wrapValue` are mutually exclusive: only one can be _true_, but both can be _false_.\n * \n * With options\n * ```js\n * // Total duration of 1000 ticks\n * const t = Timer.relative(1000, { timer: ticksElapsedTimer(); clampValue:true });\n * ```\n *\n * If `total` is Infinity, a 'always completed; timer is returned. Use a value of `NaN` for a\n * timer that always returns 0.\n * @private\n * @param total Total (of milliseconds or ticks, depending on timer source)\n * @param options Options\n * @returns Timer\n */\nexport const relative = (\n  total: number,\n  options: Partial<RelativeTimerOpts> = {}\n): ModulationTimer => {\n\n  if (!Number.isFinite(total)) {\n    return timerAlwaysDone()\n  } else if (Number.isNaN(total)) {\n    return timerNeverDone();\n  }\n\n  const clampValue = options.clampValue ?? false;\n  const wrapValue = options.wrapValue ?? false;\n  if (clampValue && wrapValue) throw new Error(`clampValue and wrapValue cannot both be enabled`);\n\n  let modulationAmount = 1;\n\n  // Create and starts timer\n  const timer = options.timer ?? elapsedMillisecondsAbsolute();\n  // Keep track of value to avoid over-advancing the tick counter\n  let lastValue = 0;\n  const computeElapsed = (value: number) => {\n    lastValue = value;\n    let v = value / (total * modulationAmount);\n    if (clampValue) v = clamp(v);\n    else if (wrapValue && v >= 1) v = v % 1;\n    return v;\n  }\n\n  return {\n    mod(amt: number) {\n      modulationAmount = amt;\n    },\n    get isDone() {\n      //const tmp = computeElapsed();\n      //console.log(`Timer.relative ${ tmp } elapsed: ${ timer.elapsed } total: ${ total }`)\n      return computeElapsed(lastValue) >= 1;\n    },\n    get elapsed() {\n      return computeElapsed(timer.elapsed);\n    },\n    reset: () => {\n      timer.reset();\n    }\n  };\n};\n\n\n/**\n * A timer based on frequency: cycles per unit of time. These timers return a number from\n * 0..1 indicating position with a cycle.\n *\n * In practice, timers are used to 'drive' something like an Oscillator.\n *\n * By default it uses elapsed clock time as a basis for frequency. ie., cycles per second.\n *\n * It returns a `ModulationTimer`, which allows for a modulation amount to be continually applied\n * to the calculation of the 'position' within a cycle.\n *\n * @example Prints around 0/0.5 each second, as timer is half a cycle per second\n * ```js\n * import { frequencyTimer } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * const t = frequencyTimer(0.5);\n * setInterval(() => {\n *  console.log(t.elapsed);\n * }, 1000);\n * ```\n * @param frequency Cycles\n * @param options Options for timer\n * @returns\n */\nexport const frequencyTimer = (\n  frequency: number,\n  options: Partial<TimerOpts> = {}\n): ModulationTimer => {\n  const timer = options.timer ?? elapsedMillisecondsAbsolute();\n  const cyclesPerSecond = frequency / 1000;\n  let modulationAmount = 1;\n\n  const computeElapsed = () => {\n    // Get position in a cycle\n    const v = timer.elapsed * (cyclesPerSecond * modulationAmount);\n\n    // Get fractional part\n    const f = v - Math.floor(v);\n    if (f < 0) {\n      throw new Error(\n        `Unexpected cycle fraction less than 0. Elapsed: ${ v } f: ${ f }`\n      );\n    }\n    if (f > 1) {\n      throw new Error(\n        `Unexpected cycle fraction more than 1. Elapsed: ${ v } f: ${ f }`\n      );\n    }\n    return f;\n  }\n  return {\n    mod: (amt: number) => {\n      modulationAmount = amt;\n    },\n    reset: () => {\n      timer.reset();\n    },\n    get isDone() {\n      return computeElapsed() >= 1;\n    },\n    get elapsed() {\n      return computeElapsed();\n    },\n  };\n};\n\n/**\n * A timer that uses clock time. Start time is from the point of invocation.\n *\n * ```js\n * const t = elapsedMillisecondsAbsolute();\n * t.reset(); // reset start\n * t.elapsed; // milliseconds since start\n * ```\n * @returns {Timer}\n * @see {ticksElapsedTimer}\n */\nexport const elapsedMillisecondsAbsolute = (): Timer => {\n  let start = performance.now();\n  return {\n    /**\n     * Reset timer\n     */\n    reset: () => {\n      start = performance.now();\n    },\n    /**\n     * Returns elapsed time since start\n     */\n    get elapsed() {\n      return performance.now() - start;\n    }\n  };\n};\n\n/**\n * A timer that progresses with each call to `elapsed`.\n *\n * The first call to elapsed will return 1.\n *\n * ```js\n * const timer = elapsedTicksAbsolute();\n * timer.reset(); // Reset to 0\n * timer.elapsed; // Number of ticks (and also increment ticks)\n * timer.peek;    // Number of ticks (without incrementing)\n * ```\n * \n * Like other {@link Timer} functions, returns with a `isDone` field,\n * but this will always return _true_.\n * @returns {Timer}\n * @see {elapsedMillisecondsAbsolute}\n */\nexport const elapsedTicksAbsolute = (): Timer & { peek: number } => {\n  let start = 0;\n  return {\n    /**\n     * Reset ticks to 0. The next call to `elapsed` will return 1.\n     */\n    reset: () => {\n      start = 0;\n    },\n    /**\n     * Get current ticks without incrementing.\n     */\n    get peek() {\n      return start;\n    },\n    /**\n     * Returns the number of elapsed ticks as well as\n     * incrementing the tick count. \n     * \n     * Minimum is 1\n     * \n     * Use {@link peek} to get the current ticks without incrementing.\n     */\n    get elapsed() {\n      return ++start;\n    }\n  };\n};\n\n\n/**\n * Wraps `timer`, computing a value based on its elapsed value.\n * `fn` creates this value.\n * \n * ```js\n * const t = timerWithFunction(v=>v/2, relativeTimer(1000));\n * t.compute();\n * ```\n * \n * In the above case, `relativeTimer(1000)` creates a timer that goes\n * from 0..1 over one second. `fn` will divide that value by 2, so\n * `t.compute()` will yield values 0..0.5.\n * \n * @param fn \n * @param timer \n * @returns \n */\nexport const timerWithFunction = (\n  fn: ((v: number) => number),\n  timer: CompletionTimer\n): HasCompletion & CompletionTimer & { compute: () => number } => {\n  if (typeof fn !== `function`) throw new Error(`Param 'fn' should be a function. Got: ${ typeof fn }`);\n  let startCount = 1;\n  return {\n    get elapsed() {\n      return timer.elapsed;\n    },\n    get isDone() {\n      return timer.isDone;\n    },\n    get runState() {\n      if (timer.isDone) return `idle`;\n      return `scheduled`;\n    },\n    /**\n     * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n     */\n    get startCount() {\n      return startCount;\n    },\n    get startCountTotal() {\n      return startCount;\n    },\n    compute: () => {\n      const elapsed = timer.elapsed;\n      return fn(elapsed);\n    },\n    reset: () => {\n      timer.reset();\n      startCount++;\n    },\n  };\n};","//const sqrt = Math.sqrt;\nconst pow = Math.pow;\n//const pi = Math.PI;\n//const piPi = Math.PI*2;\nconst gaussianA = 1 / Math.sqrt(2 * Math.PI);\n/**\n * Returns a roughly gaussian easing function\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = Easings.gaussian();\n * ```\n *\n * Try different positive and negative values for `stdDev` to pinch\n * or flatten the bell shape.\n * @param standardDeviation\n * @returns\n */\nexport const gaussian = (standardDeviation = 0.4) => {\n    //const a = 1 / sqrt(2 * pi);\n    const mean = 0.5;\n    return (t) => {\n        const f = gaussianA / standardDeviation;\n        // p:-8 pinched\n        let p = -2.5; // -1/1.25;\n        let c = (t - mean) / standardDeviation;\n        c *= c;\n        p *= c;\n        const v = f * pow(Math.E, p); // * (2/pi);//0.62;\n        if (v > 1)\n            return 1;\n        if (v < 0)\n            return 0;\n        return v;\n    };\n};\n","import { gaussian } from \"../gaussian.js\";\n// Easings from https://easings.net/\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst cos = Math.cos;\nconst pi = Math.PI;\nconst sin = Math.sin;\nexport const bounceOut = (x) => {\n    const n1 = 7.5625;\n    const d1 = 2.75;\n    if (x < 1 / d1) {\n        return n1 * x * x;\n    }\n    else if (x < 2 / d1) {\n        return n1 * (x -= 1.5 / d1) * x + 0.75;\n    }\n    else if (x < 2.5 / d1) {\n        return n1 * (x -= 2.25 / d1) * x + 0.9375;\n    }\n    else {\n        return n1 * (x -= 2.625 / d1) * x + 0.984_375;\n    }\n};\nexport const quintIn = (x) => x * x * x * x * x;\nexport const quintOut = (x) => 1 - pow(1 - x, 5);\nexport const arch = (x) => x * (1 - x) * 4;\nexport const smoothstep = (x) => x * x * (3 - 2 * x);\nexport const smootherstep = (x) => (x * (x * 6 - 15) + 10) * x * x * x;\nexport const sineIn = (x) => 1 - cos((x * pi) / 2);\nexport const sineOut = (x) => sin((x * pi) / 2);\nexport const quadIn = (x) => x * x;\nexport const quadOut = (x) => 1 - (1 - x) * (1 - x);\nexport const sineInOut = (x) => -(cos(pi * x) - 1) / 2;\nexport const quadInOut = (x) => x < 0.5 ? 2 * x * x : 1 - pow(-2 * x + 2, 2) / 2;\nexport const cubicIn = (x) => x * x * x;\nexport const cubicOut = (x) => 1 - pow(1 - x, 3);\nexport const quartIn = (x) => x * x * x * x;\nexport const quartOut = (x) => 1 - pow(1 - x, 4);\nexport const expoIn = (x) => (x === 0 ? 0 : pow(2, 10 * x - 10));\nexport const expoOut = (x) => (x === 1 ? 1 : 1 - pow(2, -10 * x));\nexport const quintInOut = (x) => x < 0.5 ? 16 * x * x * x * x * x : 1 - pow(-2 * x + 2, 5) / 2;\nexport const expoInOut = (x) => x === 0\n    ? 0\n    : x === 1\n        ? 1\n        // eslint-disable-next-line unicorn/no-nested-ternary\n        : x < 0.5\n            ? pow(2, 20 * x - 10) / 2\n            : (2 - pow(2, -20 * x + 10)) / 2;\nexport const circIn = (x) => 1 - sqrt(1 - pow(x, 2));\nexport const circOut = (x) => sqrt(1 - pow(x - 1, 2));\nexport const backIn = (x) => {\n    const c1 = 1.701_58;\n    const c3 = c1 + 1;\n    return c3 * x * x * x - c1 * x * x;\n};\nexport const backOut = (x) => {\n    const c1 = 1.701_58;\n    const c3 = c1 + 1;\n    return 1 + c3 * pow(x - 1, 3) + c1 * pow(x - 1, 2);\n};\nexport const circInOut = (x) => x < 0.5\n    ? (1 - sqrt(1 - pow(2 * x, 2))) / 2\n    : (sqrt(1 - pow(-2 * x + 2, 2)) + 1) / 2;\nexport const backInOut = (x) => {\n    const c1 = 1.701_58;\n    const c2 = c1 * 1.525;\n    return x < 0.5\n        ? (pow(2 * x, 2) * ((c2 + 1) * 2 * x - c2)) / 2\n        : (pow(2 * x - 2, 2) * ((c2 + 1) * (x * 2 - 2) + c2) + 2) / 2;\n};\nexport const elasticIn = (x) => {\n    const c4 = (2 * pi) / 3;\n    return x === 0\n        ? 0\n        : (x === 1\n            ? 1\n            : -pow(2, 10 * x - 10) * sin((x * 10 - 10.75) * c4));\n};\nexport const elasticOut = (x) => {\n    const c4 = (2 * pi) / 3;\n    return x === 0\n        ? 0\n        : (x === 1\n            ? 1\n            : pow(2, -10 * x) * sin((x * 10 - 0.75) * c4) + 1);\n};\nexport const bounceIn = (x) => 1 - bounceOut(1 - x);\nexport const bell = gaussian();\nexport const elasticInOut = (x) => {\n    const c5 = (2 * pi) / 4.5;\n    return x === 0\n        ? 0\n        : x === 1\n            ? 1\n            // eslint-disable-next-line unicorn/no-nested-ternary\n            : x < 0.5\n                ? -(pow(2, 20 * x - 10) * sin((20 * x - 11.125) * c5)) / 2\n                : (pow(2, -20 * x + 10) * sin((20 * x - 11.125) * c5)) / 2 + 1;\n};\nexport const bounceInOut = (x) => x < 0.5 ? (1 - bounceOut(1 - 2 * x)) / 2 : (1 + bounceOut(2 * x - 1)) / 2;\n","import { Points, Beziers } from '@ixfx/geometry';\nimport { scale } from '@ixfx/numbers';\n/**\n * Interpolates points along a line.\n * By default it's a straight line, so use `bend` to make a non-linear curve.\n * @param bend -1...1. -1 will pull line up, 1 will push it down.\n * @returns\n */\nexport const line = (bend = 0, warp = 0) => {\n    const max = 1;\n    const cubicB = {\n        x: scale(bend, -1, 1, 0, max),\n        y: scale(bend, -1, 1, max, 0),\n    };\n    // Add in bend as 'drive'\n    let cubicA = Points.interpolate(Math.abs(bend), Points.Empty, cubicB);\n    // Warp\n    if (bend !== 0 && warp > 0) {\n        if (bend > 0) {\n            cubicA = Points.interpolate(warp, cubicA, { x: 0, y: cubicB.x * 2 });\n        }\n        else {\n            cubicA = Points.interpolate(warp, cubicA, { x: cubicB.y * 2, y: 0 });\n        }\n    }\n    const bzr = Beziers.cubic(Points.Empty, Points.Unit, cubicA, cubicB);\n    const inter = Beziers.interpolator(bzr);\n    return (value) => inter(value);\n};\n","import { intervalToMs } from \"@ixfx/core\";\nimport * as Flow from '@ixfx/flow';\nimport { functionTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Produce values over time. When the modulate function is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n *\n * ```js\n * const fn = (t) => {\n *  // 't' will be values 0..1 where 1 represents end of time period.\n *  // Return some computed value based on 't'\n *  return t*Math.random();\n * }\n * const e = Modulate.time(fn, 1000);\n *\n * // Keep calling e() to get the current value\n * e();\n * ```\n * @param fn Modulate function\n * @param duration Duration\n * @returns\n */\nexport const time = (fn, duration) => {\n    resultThrow(functionTest(fn, `fn`));\n    let relative;\n    return () => {\n        if (typeof relative === `undefined`)\n            relative = Flow.ofTotal(duration, { clampValue: true });\n        return fn(relative());\n    };\n};\n/**\n * Creates an modulator based on clock time. Time\n * starts being counted when modulate function is created.\n *\n * `timeModulator` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n * @example Time based easing\n * ```\n * import { timeModulator } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = (t) => {\n *  // 't' will be a value 0..1 representing time elapsed. 1 being end of period.\n *  return t*Math.random();\n * }\n * const t = timeModulator(fn, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of modulator\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param fn Modulator\n * @param duration Duration\n * @returns ModulatorTimed\n */\nexport const timeModulator = (fn, duration) => {\n    resultThrow(functionTest(fn, `fn`));\n    const timer = Flow.elapsedMillisecondsAbsolute();\n    const durationMs = intervalToMs(duration);\n    if (durationMs === undefined)\n        throw new Error(`Param 'duration' not provided`);\n    const relativeTimer = Flow.relative(durationMs, {\n        timer,\n        clampValue: true\n    });\n    return Flow.timerWithFunction(fn, relativeTimer);\n};\n/**\n * Produce modulate values with each invocation. When the time is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n *\n * If you need to check if a modulator is done or reset it, consider {@link tickModulator}.\n *\n * ```js\n * const fn = (t) => {\n *  // 't' will be values 0..1 representing elapsed ticks toward totwal\n * }\n * const e = ticks(fn, 100);\n *\n * // Keep calling e() to get the current value\n * e();\n * ```\n * @param fn Function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns\n */\nexport const ticks = (fn, totalTicks) => {\n    resultThrow(functionTest(fn, `fn`));\n    let relative;\n    return () => {\n        if (typeof relative === `undefined`)\n            relative = Flow.ofTotalTicks(totalTicks, { clampValue: true });\n        return fn(relative());\n    };\n};\n/**\n * Creates an modulator based on ticks.\n *\n * `tickModulator` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based modulator\n * ```\n * import { tickModulator } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = (t) => {\n *  // 't' will be values 0..1 based on completion\n *  return Math.random() * t;\n * }\n * const t = tickModulator(fn, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param fn Modulate function that returns 0..1\n * @param durationTicks Duration in ticks\n * @returns ModulatorTimed\n */\nexport const tickModulator = (fn, durationTicks) => {\n    resultThrow(functionTest(fn, `fn`));\n    const timer = Flow.elapsedTicksAbsolute();\n    const relativeTimer = Flow.relative(durationTicks, {\n        timer,\n        clampValue: true\n    });\n    return Flow.timerWithFunction(fn, relativeTimer);\n};\n","import * as Named from './easings-named.js';\nimport { stringTest, resultThrow } from '@ixfx/guards';\nimport {} from '@ixfx/core';\nexport * as Named from './easings-named.js';\nexport * from './line.js';\nimport * as ModuleTimed from '../modulator-timed.js';\n/**\n * Creates an easing function\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const e = Easings.create({ duration: 1000, name: `quadIn` });\n * const e = Easings.create({ ticks: 100, name: `sineOut` });\n * const e = Easings.create({\n *  duration: 1000,\n *  fn: (v) => {\n *    // v will be 0..1 based on time\n *    return Math.random() * v\n *  }\n * });\n * ```\n * @param options\n * @returns\n */\nexport const create = (options) => {\n    const name = resolveEasingName(options.name ?? `quintIn`);\n    const fn = name ?? options.fn;\n    if (typeof fn === `undefined`)\n        throw new Error(`Either 'name' or 'fn' must be set`);\n    if (`duration` in options) {\n        return time(fn, options.duration);\n    }\n    else if (`ticks` in options) {\n        return ticks(fn, options.ticks);\n    }\n    else {\n        throw new Error(`Expected 'duration' or 'ticks' in options`);\n    }\n};\n/**\n * Creates an easing based on clock time. Time\n * starts being counted when easing function is created.\n *\n * `timeEasing` allows you to reset and check for completion.\n * Alternatively, use {@link time} which is a simple function that just returns a value.\n *\n *\n * @example Time based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.timeEasing(`quintIn`, 5*1000); // Will take 5 seconds to complete\n * ...\n * t.compute(); // Get current value of easing\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n *\n * Thisi function is just a wrapper around Modulator.timedModulator.\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration\n * @returns Easing\n */\nexport const timeEasing = (nameOrFunction, duration) => {\n    const fn = resolveEasingName(nameOrFunction);\n    return ModuleTimed.timeModulator(fn, duration);\n    // const timer = Timer.elapsedMillisecondsAbsolute();\n    // const durationMs = intervalToMs(duration);\n    // if (durationMs === undefined) throw new Error(`Param 'duration' not provided`);\n    // const relativeTimer = Timer.relative(\n    //   durationMs,\n    //   {\n    //     timer,\n    //     clampValue: true\n    //   });\n    // return Timer.timerWithFunction(fn, relativeTimer);\n};\n/**\n * Produce easing values over time. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n *\n * If you need to check if an easing is done or reset it, consider {@link timeEasing}.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Quad-in easing over one second\n * const e = Easings.time(`quadIn`, 1000);\n *\n * // Keep calling e() to get the current value\n * e();\n * ```\n *\n * This function is just a wrapper around Modulate.time\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param duration Duration\n * @returns\n */\nexport const time = (nameOrFunction, duration) => {\n    const fn = resolveEasingName(nameOrFunction);\n    return ModuleTimed.time(fn, duration);\n    // let relative: undefined | (() => number);\n    // return () => {\n    //   if (relative === undefined) relative = Timer.ofTotal(duration, { clampValue: true });\n    //   return fn(relative());\n    // }\n};\n/**\n * Produce easing values with each invocation. When the easing is complete, the final\n * value continues to return. Timer starts when return function is first invoked.\n *\n * If you need to check if an easing is done or reset it, consider {@link tickEasing}.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * // Quad-in easing over 100 ticks\n * const e = Easings.ticks(`quadIn`, 100);\n *\n * // Keep calling e() to get the current value\n * e();\n * ```\n *\n * This is just a wrapper around Modulator.ticks\n * @param nameOrFunction Easing name or a function that produces 0..1 scale\n * @param totalTicks Total length of ticks\n * @returns\n */\nexport const ticks = (nameOrFunction, totalTicks) => {\n    const fn = resolveEasingName(nameOrFunction);\n    return ModuleTimed.ticks(fn, totalTicks);\n    // let relative: undefined | (() => number);\n    // return () => {\n    //   if (relative === undefined) relative = Timer.ofTotalTicks(totalTicks, { clampValue: true });\n    //   return fn(relative());\n    // }\n};\n/**\n * Creates an easing based on ticks.\n *\n * `tickEasing` allows you to reset and check for completion.\n * Alternatively, use {@link ticks} which is a simple function that just returns a value.\n *\n * @example Tick-based easing\n * ```\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const t = Easings.tickEasing(`sineIn`, 1000);   // Will take 1000 ticks to complete\n * t.compute(); // Each call to `compute` progresses the tick count\n * t.reset();   // Reset to 0\n * t.isDone;    // _True_ if finished\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param durationTicks Duration in ticks\n * @returns Easing\n */\nexport const tickEasing = (nameOrFunction, durationTicks) => {\n    const fn = resolveEasingName(nameOrFunction);\n    return ModuleTimed.tickModulator(fn, durationTicks);\n    // const timer = Timer.elapsedTicksAbsolute();\n    // const relativeTimer = Timer.relative(\n    //   durationTicks,\n    //   {\n    //     timer,\n    //     clampValue: true\n    //   });\n    // return Timer.timerWithFunction(fn, relativeTimer);\n};\nconst resolveEasingName = (nameOrFunction) => {\n    const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n    if (typeof fn === `undefined`) {\n        const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${nameOrFunction}'`) : new Error(`Easing function not found`);\n        throw error;\n    }\n    return fn;\n};\n/**\n * Creates a new easing by name\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const e = Easings.create(`circInOut`, 1000, elapsedMillisecondsAbsolute);\n * ```\n * @param nameOrFunction Name of easing, or an easing function\n * @param duration Duration (meaning depends on timer source)\n * @param timerSource Timer source\n * @returns\n */\n// const create = function (\n//   nameOrFunction: EasingName | ((v: number) => number),\n//   duration: number,\n//   timerSource: TimerSource\n// ): Easing {\n//   const fn = typeof nameOrFunction === `function` ? nameOrFunction : get(nameOrFunction);\n//   if (fn === undefined) {\n//     const error = typeof nameOrFunction === `string` ? new Error(`Easing function not found: '${ nameOrFunction }'`) : new Error(`Easing function not found`);\n//     throw error;\n//   }\n//   // Get a relative version of timer\n//   const timer = relativeTimer(duration, {\n//     timer: timerSource(),\n//     clampValue: true,\n//   });\n//   let startCount = 1;\n//   return {\n//     get isDone() {\n//       return timer.isDone;\n//     },\n//     get runState() {\n//       if (timer.isDone) return `idle`;\n//       return `scheduled`;\n//     },\n//     /**\n//      * Returns 1 if it has been created, returns +1 for each additional time the timer has been reset.\n//      */\n//     get startCount() {\n//       return startCount;\n//     },\n//     get startCountTotal() {\n//       return startCount;\n//     },\n//     compute: () => {\n//       const relative = timer.elapsed;\n//       return fn(relative);\n//     },\n//     reset: () => {\n//       timer.reset();\n//       startCount++;\n//     },\n//   };\n// };\nlet easingsMap;\n/**\n * Returns an easing function by name. Throws an error if\n * easing is not found.\n *\n * ```js\n * import { Easings } from \"https://unpkg.com/ixfx/dist/modulation.js\";\n * const fn = Easings.get(`sineIn`);\n * // Returns 'eased' transformation of 0.5\n * fn(0.5);\n * ```\n * @param easingName eg `sineIn`\n * @returns Easing function\n */\nexport const get = function (easingName) {\n    resultThrow(stringTest(easingName, `non-empty`, `easingName`));\n    const found = cacheEasings().get(easingName.toLowerCase());\n    if (found === undefined)\n        throw new Error(`Easing not found: '${easingName}'`);\n    return found;\n};\n// Cache named easings\nfunction cacheEasings() {\n    if (easingsMap === undefined) {\n        easingsMap = new Map();\n        for (const [k, v] of Object.entries(Named)) {\n            easingsMap.set(k.toLowerCase(), v);\n        }\n        return easingsMap;\n    }\n    else\n        return easingsMap;\n}\n/**\n * Iterate over available easings.\n * @private\n * @returns Returns list of available easing names\n */\nexport function* getEasingNames() {\n    const map = cacheEasings();\n    yield* map.keys();\n}\n;\n"],"mappings":"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"}