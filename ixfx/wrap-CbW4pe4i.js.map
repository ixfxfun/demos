{"version":3,"file":"wrap-CbW4pe4i.js","names":[],"sources":["../../numbers/dist/src/wrap.js"],"sourcesContent":["/* eslint-disable unicorn/prevent-abbreviations */\nimport { numberTest, integerTest, resultThrow } from '@ixfx/guards';\n/**\n * Wraps an integer number within a specified range, defaulting to degrees (0-360). Use {@link wrap} for floating-point wrapping.\n *\n * This is useful for calculations involving degree angles and hue, which wrap from 0-360.\n * Eg: to add 200 to 200, we don't want 400, but 40.\n *\n * ```js\n * const v = wrapInteger(200+200, 0, 360); // 40\n * ```\n *\n * Or if we minus 100 from 10, we don't want -90 but 270\n * ```js\n * const v = wrapInteger(10-100, 0, 360); // 270\n * ```\n *\n * `wrapInteger` uses 0-360 as a default range, so both of these\n * examples could just as well be:\n *\n * ```js\n * wrapInteger(200+200);  // 40\n * wrapInteger(10-100);  // 270\n * ```\n *\n * Non-zero starting points can be used. A range of 20-70:\n * ```js\n * const v = wrapInteger(-20, 20, 70); // 50\n * ```\n *\n * Note that the minimum value is inclusive, while the maximum is _exclusive_.\n * So with the default range of 0-360, 360 is never reached:\n *\n * ```js\n * wrapInteger(360); // 0\n * wrapInteger(361); // 1\n * ```\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * @param v Value to wrap\n * @param min Integer minimum of range (default: 0). Inclusive\n * @param max Integer maximum of range (default: 360). Exlusive\n * @returns\n */\nexport const wrapInteger = (v, min = 0, max = 360) => {\n    resultThrow(integerTest(v, undefined, `v`), integerTest(min, undefined, `min`), integerTest(max, undefined, `max`));\n    if (v === min)\n        return min;\n    if (v === max)\n        return min; // Wraps\n    if (v > 0 && v < min)\n        v += min;\n    v -= min;\n    max -= min;\n    v = v % max;\n    if (v < 0)\n        v = max - Math.abs(v) + min;\n    return v + min;\n};\n/**\n * Wraps floating point numbers to be within a range (default: 0..1). Use {@link wrapInteger} if you want to wrap integer values.\n *\n * This logic makes sense for some things like rotation angle.\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * ```js\n * wrap(1.2);   // 0.2\n * wrap(2);     // 1.0\n * wrap(-0.2); // 0.8\n * ```\n *\n * A range can be provided too:\n * ```js\n * wrap(30, 20, 50);  \t // 30\n * wrap(60, 20, 50);    //  30\n * ```\n * @param v\n * @param min\n * @param max\n * @returns\n */\nexport const wrap = (v, min = 0, max = 1) => {\n    resultThrow(numberTest(v, ``, `min`), numberTest(min, ``, `min`), numberTest(max, ``, `max`));\n    if (v === min)\n        return min;\n    if (v === max)\n        return min; // Wraps\n    while (v <= min || v >= max) {\n        if (v === max)\n            break;\n        if (v === min)\n            break;\n        if (v > max) {\n            v = min + (v - max);\n        }\n        else if (v < min) {\n            v = max - (min - v);\n        }\n    }\n    return v;\n};\n/**\n * Performs a calculation within a wrapping number range. This is a lower-level function.\n * See also: {@link wrapInteger} for simple wrapping within a range.\n *\n * `min` and `max` define the start and end of the valid range, inclusive. Eg for hue degrees it'd be 0, 360.\n * `a` and `b` is the range you want to work in.\n *\n * For example, let's say you want to get the middle point between a hue of 30 and a hue of 330 (ie warmer colours):\n * ```js\n * wrapRange(0,360, (distance) => {\n *  // for a:0 and b:330, distance would be 90 from 30 degrees to 330 (via zero)\n *  return distance * 0.5; // eg return middle point\n * }, 30, 330);\n * ```\n *\n * The return value of the callback should be in the range of 0-distance. `wrapRange` will subsequently\n * conform it to the `min` and `max` range before it's returned to the caller.\n *\n * @param a Output start (eg. 60)\n * @param b Output end (eg 300)\n * @param min Range start (eg 0)\n * @param max Range end (eg 360)\n * @param fn Returns a computed value from 0 to `distance`.\n * @returns\n */\nexport const wrapRange = (min, max, fn, a, b) => {\n    let r = 0;\n    const distF = Math.abs(b - a);\n    // When b is wrapped forwards\n    const distFwrap = Math.abs(max - a + b);\n    // When b is wrapped backwards (10, 300)\n    const distBWrap = Math.abs(a + (360 - b));\n    const distMin = Math.min(distF, distFwrap, distBWrap);\n    if (distMin === distBWrap) {\n        // (10, 300) = 70\n        r = a - fn(distMin);\n    }\n    else if (distMin === distFwrap) {\n        // (300, 60) = 120\n        r = a + fn(distMin);\n    }\n    else {\n        // Forwards or backwards without wrapping\n        if (a > b) {\n            // (240,120) -- backwards\n            r = a - fn(distMin);\n        }\n        else {\n            // (120,240) -- forwards\n            r = a + fn(distMin);\n        }\n    }\n    return wrapInteger(r, min, max);\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;AAmFA,MAAa,OAAO,CAAC,GAAG,MAAM,GAAG,MAAM,MAAM;CACzC,YAAY,WAAW,GAAG,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,WAAW,KAAK,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC,EAAE,WAAW,KAAK,EAAE,EAAE,CAAC,GAAG,CAAC,CAAC,CAAC;AAC7F,KAAI,MAAM,IACN,QAAO;AACX,KAAI,MAAM,IACN,QAAO;AACX,QAAO,KAAK,OAAO,KAAK,KAAK;AACzB,MAAI,MAAM,IACN;AACJ,MAAI,MAAM,IACN;AACJ,MAAI,IAAI,KACJ,IAAI,OAAO,IAAI;WAEV,IAAI,KACT,IAAI,OAAO,MAAM;CAExB;AACD,QAAO;AACV"}