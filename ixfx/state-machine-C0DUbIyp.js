import{n as e}from"./chunk-CVLEGGlw.js";import{F as t,M as n,kt as r}from"./src-DdJCbM4z.js";import{i}from"./logger-o11drWM0.js";import{i as a,r as o,t as s}from"./random-EejSd_WN.js";import{t as c}from"./simple-event-emitter-DdjYDCSw.js";const l=async(e,t={},n)=>{let i=[],a=t.rank??r,s=Array.isArray(e)?e:[e];t.shuffle&&(s=o(s));for(let e=0;e<s.length;e++){let r=s[e],o;if(o=typeof r==`function`?await r(n):r,o!==void 0&&(i.push(o),i.sort(a)),t.stop!==void 0&&t.stop(o,i))break}return t.filter?i.filter(t.filter):i},u=async(e,t={},n)=>{let r=await l(e,t,n);if(!r||r.length===0)return;let i=t.at??-1;return r.at(i)},d=e=>Object.freeze({value:e.value,visited:[...e.visited],machine:e.machine}),f=(e,t)=>{let[n,r]=m(e);if(!n)throw Error(r);let i=t??Object.keys(n.states)[0];if(n.states[i]===void 0)throw TypeError(`Initial state ('${i}') not found`);let a=y(n.states);if(a===void 0)throw Error(`Could not normalise transitions`);return Object.freeze({value:i,visited:[],machine:Object.freeze(Object.fromEntries(a))})},p=e=>f(e.machine),m=e=>e===void 0?[void 0,`Parameter undefined`]:e===null?[void 0,`Parameter null`]:`states`in e?[e,``]:typeof e==`object`?[{states:e},``]:[void 0,`Unexpected type: ${typeof e}. Expected object`],h=e=>_(e).length===0,g=e=>{b(e);let t=e.machine[e.value];return t.length===1&&t[0].state===null?[]:t},_=e=>g(e).map(e=>e.state),v=e=>{let t=e=>{if(e===null)return{state:null};if(typeof e==`string`)return{state:e};if(typeof e==`object`&&`state`in e){let t=e.state;if(typeof t!=`string`)throw TypeError(`Target 'state' field is not a string. Got: ${typeof t}`);return`preconditions`in e?{state:t,preconditions:e.preconditions}:{state:t}}else throw Error(`Unexpected type: ${typeof e}. Expected string or object with 'state' field.`)};if(Array.isArray(e)){let n=!1,r=e.map(e=>{let r=t(e);if(!r)throw Error(`Invalid target`);return n||=r.state===null,r});if(n&&r.length>1)throw Error(`Cannot have null as an possible state`);return r}else{let n=t(e);return n?[n]:void 0}},y=e=>{let t=new Map;for(let[n,r]of Object.entries(e)){if(n===void 0)throw TypeError(`Top-level undefined state`);if(r===void 0)throw TypeError(`Undefined target state for ${n}`);if(t.has(n))throw Error(`State defined twice: ${n}`);if(n.includes(` `))throw Error(`State names cannot contain spaces`);t.set(n,[])}for(let[n,r]of Object.entries(e)){let e=v(r);if(e===void 0)throw Error(`Could not normalise target`);if(e!==null){let r=new Set;for(let i of e){if(r.has(i.state))throw Error(`Target state '${i.state}' already exists for '${n}'`);if(r.add(i.state),i.state!==null&&!t.has(i.state))throw Error(`Target state '${i.state}' is not defined as a top-level state. Defined under: '${n}'`)}t.set(n,e)}}return t},b=e=>{if(e===void 0)throw TypeError(`Param 'state' is undefined`);if(typeof e.value!=`string`)throw TypeError(`Existing state is not a string`)},x=(e,t)=>(b(e),w(e,t),Object.freeze({value:t,machine:e.machine,visited:a([e.visited,[e.value]])})),S=e=>{let t=g(e).at(0);if(!t||t.state===null)throw Error(`Not possible to move to a next state from '${e.value}`);return x(e,t.state)},C=(e,t)=>{try{return w(e,t),!0}catch{return!1}},w=(e,t)=>{if(t===null)throw Error(`Cannot transition to null state`);if(t===void 0)throw Error(`Cannot transition to undefined state`);if(typeof t!=`string`)throw TypeError(`Parameter 'toState' should be a string. Got: ${typeof t}`);let n=_(e);if(n.length===0)throw Error(`Machine is in terminal state`);if(!n.includes(t))throw Error(`Target state '${t}' not available at current state '${e.value}'. Possible states: ${n.join(`, `)}`)},T=(...e)=>{let t={};if(!Array.isArray(e))throw Error(`Expected array of strings`);if(e.length<=2)throw Error(`Expects at least two states`);for(let n=0;n<e.length;n++){let r=e[n];if(typeof r!=`string`)throw TypeError(`Expected array of strings. Got type '${typeof r}' at index ${n.toString()}`);t[r]=n===e.length-1?null:e[n+1]}return t},E=(...e)=>{let t={};if(!Array.isArray(e))throw Error(`Expected array of strings`);if(e.length<2)throw Error(`Expects at least two states`);for(let[n,r]of e.entries()){if(typeof r!=`string`)throw TypeError(`Expected array of strings. Got type '${typeof r}' at index ${n.toString()}`);t[r]=[]}for(let n=0;n<e.length;n++){let r=t[e[n]];n===e.length-1?e.length>1?r.push(e[n-1]):t[e[n]]=null:(r.push(e[n+1]),n>0&&r.push(e[n-1]))}return t};async function D(e,t){let n=Array.isArray(t)?{handlers:t}:t,a=i(n.debug,{category:`StateMachineDriver`}),o=new Map;for(let e of n.handlers){let t=Array.isArray(e.if)?e.if:[e.if];for(let n of t){if(typeof n!=`string`)throw TypeError(`Expected single or array of strings for the 'if' field. Got: '${typeof n}'.`);if(o.has(n))throw Error(`Multiple handlers defined for state '${n}'. There should be at most one.`);o.set(n,e)}}let c={rank:(e,t)=>r(e.score??0,t.score??0),shuffle:n.shuffleHandlers??!1},u=f(e);for(let[e]of o)if(u.machine[e]===void 0&&e!==`__fallback`)throw Error(`StateMachineDriver handler references a state ('${e}') which is not defined on the machine. Therefore this handler will never run.'`);return{reset:()=>{u=p(u)},getValue:()=>u.value,run:async()=>{a(`Run. State: ${u.value}`);let e=u.value,t=o.get(e);if(t===void 0&&(a(`  No handler for state '${e}', trying __fallback`),t=o.get(`__fallback`)),t===void 0){a(`  No __fallback handler`);return}let n=t.resultChoice===`first`?{...c,stop:e=>e?`reset`in e||`next`in e&&e.next!==void 0:!1}:c,r=await l(t.then,n,u);a(`  In state '${u.value}' results: ${r.length}. Choice: ${t.resultChoice}`);let i;switch(t.resultChoice??`highest`){case`highest`:i=r.at(-1);break;case`first`:i=r[0];break;case`lowest`:i=r.at(0);break;case`random`:i=s(r);break;default:throw Error(`Unknown 'resultChoice' option: ${t.resultChoice}. Expected highest, first, lowest or random`)}return a(`  Chosen result: ${JSON.stringify(i)}`),i?.reset?u=p(u):i&&i.next&&(typeof i.next==`boolean`?u=S(u):(a(JSON.stringify(r)),u=x(u,i.next))),u},to:e=>(u=x(u,e),u)}}var O=class extends c{#e;#t;#n;#r=!1;#i=!1;#a=n();constructor(e,t={}){super(),this.#n=t.debug??!1,this.#e=f(e,t.initial),this.#t=d(this.#e)}#o(e){this.#i!==e&&(this.#i=e,e?(this.#r=!0,setTimeout(()=>{this.#r&&(this.#r=!1,this.fireEvent(`stop`,{state:this.#e.value}))},2)):this.#r=!1)}get statesPossible(){return _(this.#e)}get statesDefined(){return Object.keys(this.#e.machine)}next(){let e=_(this.#e);return e.length===0?null:(this.state=e[0],e[0])}get isDone(){return h(this.#e)}reset(){this.#o(!1),this.#e=d(this.#t),this.#a=t()}validateTransition(e){w(this.#e,e)}isValid(e){return C(this.#e,e)}set state(e){let n=this.#e.value;e!==this.#e.value&&(this.#e=x(this.#e,e),this.#n&&console.log(`StateMachine: ${n} -> ${e}`),this.#a=t(),setTimeout(()=>{this.fireEvent(`change`,{newState:e,priorState:n})},1),h(this.#e)&&this.#o(!0))}get state(){return this.#e.value}get changedAt(){return this.#a()}get elapsed(){return this.#a()}},k=e({StateMachineWithEvents:()=>O,cloneState:()=>d,driver:()=>D,fromList:()=>T,fromListBidirectional:()=>E,init:()=>f,isDone:()=>h,isValidTransition:()=>C,next:()=>S,normaliseTargets:()=>v,possible:()=>_,possibleTargets:()=>g,reset:()=>p,to:()=>x,validateMachine:()=>m,validateTransition:()=>w});export{l as a,x as i,O as n,u as o,f as r,k as t};