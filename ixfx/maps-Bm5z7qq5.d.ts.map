{"version":3,"file":"maps-Bm5z7qq5.d.ts","names":["IsEqual","IDictionary","IWithEntries","ToString","getClosestIntegerKey","ReadonlyMap","findBySomeKey","T","Iterable","hasKeyValue","K","V","deleteByValueCompareMutate","Map","findEntryByPredicate","findEntryByValue","addValueMutate","addValue","addValueMutator","sortByValue","sortByValueProperty","Z","hasAnyValue","filterValues","Generator","toArray","fromIterable","fromObject","addObjectEntriesMutate","findValue","some","mapToObjectTransform","Record","Readonly","zipKeyValue","ArrayLike","transformMap","R","toObject","mapToArray","MergeReconcile","mergeByKey","GetOrGenerate","Promise","GetOrGenerateSync","getOrGenerateSync","getOrGenerate"],"sources":["../../core/dist/src/maps.d.ts"],"sourcesContent":["import { type IsEqual } from './is-equal.js';\nimport type { IDictionary, IWithEntries, ToString } from './types.js';\n/**\n * Gets the closest integer key to `target` in `data`.\n * * Requires map to have numbers as keys, not strings\n * * Math.round is used for rounding `target`.\n *\n * Examples:\n * ```js\n * // Assuming numeric keys 1, 2, 3, 4 exist:\n * getClosestIntegerKey(map, 3);    // 3\n * getClosestIntegerKey(map, 3.1);  // 3\n * getClosestIntegerKey(map, 3.5);  // 4\n * getClosestIntegerKey(map, 3.6);  // 4\n * getClosestIntegerKey(map, 100);  // 4\n * getClosestIntegerKey(map, -100); // 1\n * ```\n * @param data Map\n * @param target Target value\n * @returns\n */\nexport declare const getClosestIntegerKey: (data: ReadonlyMap<number, unknown>, target: number) => number;\n/**\n * Returns the first value in `data` that matches a key from `keys`.\n * ```js\n * // Iterate, yielding: `a.b.c.d`, `b.c.d`, `c.d`, `d`\n * const keys = Text.segmentsFromEnd(`a.b.c.d`);\n * // Gets first value that matches a key (starting from most precise)\n * const value = findBySomeKey(data, keys);\n * ```\n * @param data\n * @param keys\n * @returns\n */\nexport declare const findBySomeKey: <T>(data: ReadonlyMap<string, T>, keys: Iterable<string>) => T | undefined;\n/**\n * Returns true if map contains `value` under `key`, using `comparer` function. Use {@link hasAnyValue} if you don't care\n * what key value might be under.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n *\n * @example Find key value based on string equality\n * ```js\n * hasKeyValue(map,`hello`, `samantha`, (a, b) => a === b);\n * ```\n * @param map Map to search\n * @param key Key to search\n * @param value Value to search\n * @param comparer Function to determine match. By default uses === comparison.\n * @returns True if key is found\n */\nexport declare const hasKeyValue: <K, V>(map: ReadonlyMap<K, V>, key: K, value: V, comparer?: IsEqual<V>) => boolean;\n/**\n * Deletes all key/values from map where value matches `value`,\n * with optional comparer. Mutates map.\n *\n * ```js\n * // Compare fruits based on their colour property\n * const colourComparer = (a, b) => a.colour === b.colour;\n *\n * // Deletes all values where .colour = `red`\n * deleteByValueCompareMutate(map, { colour: `red` }, colourComparer);\n * ```\n * @param map\n * @param value\n * @param comparer Uses === equality by default. Use isEqualValueDefault to compare by value\n */\nexport declare const deleteByValueCompareMutate: <K, V>(map: Map<K, V>, value: V, comparer?: IsEqual<V>) => void;\n/**\n * Finds first entry by iterable value. Expects a map with an iterable as values.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = findEntryByPredicate(map, (value, key) => {\n *  return (value === 'b');\n * });\n * // Entry is: ['there', 'b']\n * ```\n *\n * An alternative is {@link findEntryByValue} to search by value.\n * @param map Map to search\n * @param predicate Filter function returns true when there is a match of value\n * @returns Entry, or _undefined_ if `filter` function never returns _true_\n */\nexport declare const findEntryByPredicate: <K, V>(map: IWithEntries<K, V>, predicate: (value: V, key: K) => boolean) => readonly [key: K, value: V] | undefined;\n/**\n * Finds first entry by value.\n *\n * ```js\n * const map = new Map();\n * map.set('hello', 'a');\n * map.set('there', 'b');\n *\n * const entry = findEntryByValue(map, 'b');\n * // Entry is: ['there', 'b']\n * ```\n *\n * Uses JS's === comparison by default. Consider using `isEqualValueDefault` to match by value.\n * An alternative is {@link findEntryByValue} to search by predicate function.\n * @param map Map to search\n * @param value Value to seek\n * @param isEqual Filter function which checks equality. Uses JS comparer by default.\n * @returns Entry, or _undefined_ if `value` not found.\n */\nexport declare const findEntryByValue: <K, V>(map: IWithEntries<K, V>, value: V, isEqual?: IsEqual<V>) => readonly [key: K, value: V] | undefined;\n/**\n * Adds items to a map only if their key doesn't already exist\n *\n * Uses provided {@link ToString} function to create keys for items. Item is only added if it doesn't already exist.\n * Thus the older item wins out, versus normal `Map.set` where the newest wins.\n *\n * Returns a copy of the input map.\n * @example\n * ```js\n * const map = new Map();\n * const peopleArray = [ _some people objects..._];\n * addKeepingExisting(map, p => p.name, ...peopleArray);\n * ```\n * @param set\n * @param hasher\n * @param values\n * @returns\n */\n/**\n * Mutates `map`, adding each value to it using a\n * function to produce a key. Use {@link addValue} for an immutable version.\n * ```\n * const map = new Map();\n * addValueMutate(map, v=>v.name, { name:`Jane`, size:10 }, { name:`Bob`, size: 9 });\n * // Map consists of entries:\n * // [ `Jane`, { name:`Jane`, size:10 } ],\n * // [ `Bob` { name:`Bob`, size: 9 } ]\n * ```\n *\n * Uses {@link addValueMutator} under the hood.\n * @param map Map to modify. If _undefined_, a new map is created\n * @param hasher Function to generate a string key for a given object value\n * @param values Values to add\n * @param collisionPolicy What to do if the key already exists\n * @returns Map instance\n */\nexport declare const addValueMutate: <V>(map: Map<string, V> | undefined, hasher: ToString<V>, collisionPolicy: `overwrite` | `skip` | `throw`, ...values: readonly V[]) => Map<string, V>;\n/**\n * Adds values to a map, returning a new, modified copy and leaving the original\n * intact.\n *\n * Use {@link addValueMutate} for a mutable\n * @param map Map to start with, or _undefined_ to automatically create a map\n * @param hasher Function to create keys for values\n * @param collisionPolicy What to do if a key already exists\n * @param values Values to add\n * @returns A new map containing values\n */\nexport declare const addValue: <V>(map: Map<string, V> | ReadonlyMap<string, V> | undefined, hasher: ToString<V>, collisionPolicy: `overwrite` | `skip` | `throw`, ...values: readonly V[]) => Map<string, V>;\n/**\n * Returns a function that adds values to a map, using a hashing function to produce a key.\n * Use {@link addValueMutate} if you don't need a reusable function.\n *\n * ```js\n * const map = new Map(); // Create map\n * const mutate = addValueMutator(map, v=>v.name); // Create a mutator using default 'overwrite' policy\n * mutate( { name:`Bob`, size:10 }, { name: `Alice`, size: 2 }); // Add values to map\n * mutate( {name: `Bob`, size: 11 }); // Change the value stored under key `Bob`.\n * map.get(`Bob`); // { name: `Bob`, size: 11 }\n * ```\n *\n * The 'collision policy' determines what to do if the key already exists. The default behaviour\n * is to overwrite the key, just as Map.set would.\n * ```js\n * const map = new Map();\n * const mutate = addValueMutator(map, v=>v.name, `skip`);\n * mutate( { name:`Bob`,size:10 }, { name: `Alice`, size: 2 }); // Add values to map\n * mutate( { name:`Bob`, size: 20 }); // This value would be skipped because map already contains 'Bob'\n * map.get(`Bob`); // { name: `Bob`, size: 10 }\n * ```\n *\n * @param map Map to modify\n * @param hasher Hashing function to make a key for a value\n * @param collisionPolicy What to do if a value is already stored under a key\n * @returns Function\n */\nexport declare const addValueMutator: <V>(map: Map<string, V>, hasher: ToString<V>, collisionPolicy?: `overwrite` | `skip` | `throw`) => (...values: readonly V[]) => Map<string, V>;\n/**\n * Returns a array of entries from a map, sorted by value.\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n *\n * // Compare by name\n * const comparer = (a, b) => defaultComparer(a.name, b.name);\n *\n * // Get sorted values\n * const sorted = Maps.sortByValue(m, comparer);\n * ```\n *\n * `sortByValue` takes a comparison function that should return -1, 0 or 1 to indicate order of `a` to `b`.\n * @param map\n * @param comparer\n * @returns\n */\nexport declare const sortByValue: <K, V>(map: ReadonlyMap<K, V>, comparer?: (a: V, b: V) => number) => [K, V][];\n/**\n * Returns an array of entries from a map, sorted by a property of the value\n *\n * ```js\n * const m = new Map();\n * m.set(`4491`, { name: `Bob` });\n * m.set(`2319`, { name: `Alice` });\n * const sorted = sortByValueProperty(m, `name`);\n * ```\n * @param map Map to sort\n * @param property Property of value\n * @param compareFunction Comparer. If unspecified, uses a default.\n */\nexport declare const sortByValueProperty: <K, V, Z>(map: ReadonlyMap<K, V>, property: string, compareFunction?: (a: Z, b: Z) => number) => [K, V][];\n/**\n * Returns _true_ if any key contains `value`, based on the provided `comparer` function. Use {@link hasKeyValue}\n * if you only want to find a value under a certain key.\n *\n * Having a comparer function is useful to check by value rather than object reference.\n * @example Finds value where name is 'samantha', regardless of other properties\n * ```js\n * hasAnyValue(map, {name:`samantha`}, (a, b) => a.name === b.name);\n * ```\n *\n * Works by comparing `value` against all values contained in `map` for equality using the provided `comparer`.\n *\n * @param map Map to search\n * @param value Value to find\n * @param comparer Function that determines matching. Should return true if `a` and `b` are considered equal.\n * @returns True if value is found\n */\nexport declare const hasAnyValue: <K, V>(map: ReadonlyMap<K, V>, value: V, comparer: IsEqual<V>) => boolean;\n/**\n * Returns values where `predicate` returns true.\n *\n * If you just want the first match, use `find`\n *\n * @example All people over thirty\n * ```js\n * // for-of loop\n * for (const v of filterValues(people, person => person.age > 30)) {\n *\n * }\n * // If you want an array\n * const overThirty = Array.from(filterValues(people, person => person.age > 30));\n * ```\n * @param map Map\n * @param predicate Filtering predicate\n * @returns Values that match predicate\n */\nexport declare function filterValues<V>(map: ReadonlyMap<string, V>, predicate: (v: V) => boolean): Generator<V, void, unknown>;\n/**\n * Copies data to an array\n * @param map\n * @returns\n */\nexport declare const toArray: <V>(map: ReadonlyMap<string, V>) => readonly V[];\n/**\n * Returns a Map from an iterable. By default throws an exception\n * if iterable contains duplicate values.\n *\n * ```js\n * const data = [\n *  { fruit: `granny-smith`, family: `apple`, colour: `green` },\n *  { fruit: `mango`, family: `stone-fruit`, colour: `orange` }\n * ];\n * const map = fromIterable(data, v => v.fruit);\n * map.get(`granny-smith`); // { fruit: `granny-smith`, family: `apple`, colour: `green` }\n * ```\n * @param data Input data\n * @param keyFunction Function which returns a string id. By default uses the JSON value of the object.\n * @param collisionPolicy By default, values with same key overwrite previous (`overwrite`)\n * @returns\n */\nexport declare const fromIterable: <V>(data: Iterable<V>, keyFunction?: (itemToMakeStringFor: V) => string, collisionPolicy?: `overwrite` | `skip` | `throw`) => ReadonlyMap<string, V>;\n/**\n * Returns a Map from an object, or array of objects.\n * Assumes the top-level properties of the object is the key.\n *\n * ```js\n * const data = {\n *  Sally: { name: `Sally`, colour: `red` },\n *  Bob: { name: `Bob`, colour: `pink` }\n * };\n * const map = fromObject(data);\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To add an object to an existing map, use {@link addObjectEntriesMutate}.\n * @param data\n * @returns\n */\nexport declare const fromObject: <V>(data: object | object[]) => ReadonlyMap<string, V>;\n/**\n * Adds an object to an existing map, mutating it.\n * It assumes a structure where each top-level property is a key:\n *\n * ```js\n * const data = {\n *  Sally: { colour: `red` },\n *  Bob:   { colour: `pink` }\n * };\n * const map = new Map();\n * addObjectEntriesMutate(map, data);\n *\n * map.get(`Sally`); // { name: `Sally`, colour: `red` }\n * ```\n *\n * To create a new map from an object, use {@link fromObject} instead.\n * @param map\n * @param data\n */\nexport declare const addObjectEntriesMutate: <V>(map: Map<string, V>, data: object) => void;\n/**\n * Returns the first found value that matches `predicate` or _undefined_.\n * To get an entry see {@link findEntryByPredicate}\n *\n * Use {@link some} if you don't care about the value, just whether it appears.\n * Use {@link filterValue} to get all value(s) that match `predicate`.\n *\n * @example First person over thirty\n * ```js\n * const overThirty = findValue(people, person => person.age > 30);\n * ```\n * @param map Map to search\n * @param predicate Function that returns true for a matching value\n * @returns Found value or _undefined_\n */\nexport declare const findValue: <K, V>(map: ReadonlyMap<K, V>, predicate: (v: V) => boolean) => V | undefined;\n/**\n * Returns _true_ if `predicate` yields _true_ for any value in `map`.\n * Use {@link findValue} if you want the matched value.\n * ```js\n * const map = new Map();\n * map.set(`fruit`, `apple`);\n * map.set(`colour`, `red`);\n * Maps.some(map, v => v === `red`);    // true\n * Maps.some(map, v => v === `orange`); // false\n * ```\n * @param map\n * @param predicate\n * @returns\n */\nexport declare const some: <V>(map: ReadonlyMap<string, V>, predicate: (v: V) => boolean) => boolean;\n/**\n * Converts a map to a simple object, transforming from type `T` to `K` as it does so. If no transforms are needed, use {@link toObject}.\n *\n * ```js\n * const map = new Map();\n * map.set(`name`, `Alice`);\n * map.set(`pet`, `dog`);\n *\n * const o = mapToObjectTransform(map, v => {\n *  ...v,\n *  registered: true\n * });\n *\n * // Yields: { name: `Alice`, pet: `dog`, registered: true }\n * ```\n *\n * If the goal is to create a new map with transformed values, use {@link transformMap}.\n * @param m\n * @param valueTransform\n * @typeParam T Value type of input map\n * @typeParam K Value type of destination map\n * @returns\n */\nexport declare const mapToObjectTransform: <T, K>(m: ReadonlyMap<string, T>, valueTransform: (value: T) => K) => Readonly<Record<string, K>>;\n/**\n * Zips together an array of keys and values into an object. Requires that\n * `keys` and `values` are the same length.\n *\n * @example\n * ```js\n * const o = zipKeyValue([`a`, `b`, `c`], [0, 1, 2])\n * Yields: { a: 0, b: 1, c: 2}\n *```\n * @param keys String keys\n * @param values Values\n * @typeParam V Type of values\n * @return Object with keys and values\n */\nexport declare const zipKeyValue: <V>(keys: readonly string[], values: ArrayLike<V | undefined>) => {\n    [k: string]: V | undefined;\n};\n/**\n * Like `Array.map`, but for a Map. Transforms from Map<K,V> to Map<K,R>, returning as a new Map.\n *\n * @example\n * ```js\n * const mapOfStrings = new Map();\n * mapOfStrings.set(`a`, `10`);\n * mapOfStrings.get(`a`); // Yields `10` (a string)\n *\n * // Convert a map of string->string to string->number\n * const mapOfInts = transformMap(mapOfStrings, (value, key) => parseInt(value));\n *\n * mapOfInts.get(`a`); // Yields 10 (a proper number)\n * ```\n *\n * If you want to combine values into a single object, consider instead  {@link mapToObjectTransform}.\n * @param source\n * @param transformer\n * @typeParam K Type of keys (generally a string)\n * @typeParam V Type of input map values\n * @typeParam R Type of output map values\n * @returns\n */\nexport declare const transformMap: <K, V, R>(source: ReadonlyMap<K, V>, transformer: (value: V, key: K) => R) => Map<K, R>;\n/**\n * Converts a `Map` to a plain object, useful for serializing to JSON.\n * To convert back to a map use {@link fromObject}.\n *\n * @example\n * ```js\n * const map = new Map();\n * map.set(`Sally`, { name: `Sally`, colour: `red` });\n * map.set(`Bob`, { name: `Bob`, colour: `pink });\n *\n * const objects = Maps.toObject(map);\n * // Yields: {\n * //  Sally: { name: `Sally`, colour: `red` },\n * //  Bob: { name: `Bob`, colour: `pink` }\n * // }\n * ```\n * @param m\n * @returns\n */\nexport declare const toObject: <T>(m: ReadonlyMap<string, T>) => Readonly<Record<string, T>>;\n/**\n * Converts Map to Array with a provided `transformer` function. Useful for plucking out certain properties\n * from contained values and for creating a new map based on transformed values from an input map.\n *\n * @example Get an array of ages from a map of Person objects\n * ```js\n * const person = { age: 29, name: `John`};\n * map.set(person.name, person);\n *\n * const ages = mapToArray(map, (key, person) => person.age);\n * // [29, ...]\n * ```\n *\n * In the above example, the `transformer` function returns a number, but it could\n * just as well return a transformed version of the input:\n *\n * ```js\n * // Return with random heights and uppercased name\n * mapToArray(map, (key, person) => ({\n *  ...person,\n *  height: Math.random(),\n *  name: person.name.toUpperCase();\n * }))\n * // Yields:\n * // [{height: 0.12, age: 29, name: \"JOHN\"}, ...]\n * ```\n * @param m\n * @param transformer A function that takes a key and item, returning a new item.\n * @returns\n */\nexport declare const mapToArray: <K, V, R>(m: ReadonlyMap<K, V>, transformer: (key: K, item: V) => R) => readonly R[];\n/**\n * Returns a result of `a` merged into `b`.\n * `b` is always the 'newer' data that takes\n * precedence.\n */\nexport type MergeReconcile<V> = (a: V, b: V) => V;\n/**\n * Merges maps left to right, using the provided\n * `reconcile` function to choose a winner when keys overlap.\n *\n * There's also @ixfx/arrays/mergeByKey if you don't already have a map.\n *\n * For example, if we have the map A:\n * 1 => `A-1`, 2 => `A-2`, 3 => `A-3`\n *\n * And map B:\n * 1 => `B-1`, 2 => `B-2`, 4 => `B-4`\n *\n * If they are merged with the reconile function:\n * ```js\n * const reconcile = (a, b) => b.replace(`-`, `!`);\n * const output = mergeByKey(reconcile, mapA, mapB);\n * ```\n *\n * The final result will be:\n *\n * 1 => `B!1`, 2 => `B!2`, 3 => `A-3`, 4 => `B-4`\n *\n * In this toy example, it's obvious how the reconciler transforms\n * data where the keys overlap. For the keys that do not overlap -\n * 3 and 4 in this example - they are copied unaltered.\n *\n * A practical use for `mergeByKey` has been in smoothing keypoints\n * from a TensorFlow pose. In this case, we want to smooth new keypoints\n * with older keypoints. But if a keypoint is not present, for it to be\n * passed through.\n *\n * @param reconcile\n * @param maps\n */\nexport declare const mergeByKey: <K, V>(reconcile: MergeReconcile<V>, ...maps: readonly ReadonlyMap<K, V>[]) => ReadonlyMap<K, V>;\nexport type GetOrGenerate<K, V, Z> = (key: K, args?: Z) => Promise<V>;\nexport type GetOrGenerateSync<K, V, Z> = (key: K, args?: Z) => V;\n/**\n * @inheritDoc getOrGenerate\n * @param map\n * @param fn\n * @returns\n */\nexport declare const getOrGenerateSync: <K, V, Z>(map: IDictionary<K, V>, fn: (key: K, args?: Z) => V) => (key: K, args?: Z) => V;\n/**\n * Returns a function that fetches a value from a map, or generates and sets it if not present.\n * Undefined is never returned, because if `fn` yields that, an error is thrown.\n *\n * See {@link getOrGenerateSync} for a synchronous version.\n *\n * ```\n * const m = getOrGenerate(new Map(), (key) => {\n *  return key.toUppercase();\n * });\n *\n * // Not contained in map, so it will run the uppercase function,\n * // setting the value to the key 'hello'.\n * const v = await m(`hello`);  // Yields 'HELLO'\n * const v1 = await m(`hello`); // Value exists, so it is returned ('HELLO')\n * ```\n *\n */\nexport declare const getOrGenerate: <K, V, Z>(map: IDictionary<K, V>, fn: (key: K, args?: Z) => Promise<V> | V) => GetOrGenerate<K, V, Z>;\n//# sourceMappingURL=maps.d.ts.map"],"mappings":"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"}