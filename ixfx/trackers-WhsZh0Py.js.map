{"version":3,"file":"trackers-WhsZh0Py.js","names":["index: number","values: KeyValue[]","sortStyle: KeyValueSortSyles","opts?: TrackedValueOpts","limit: number","reason: TrimReason","rawValues: V[]","last: TimestampedPrimitive<V>","values: TimestampedPrimitive<V>[]","#store","#keyString","#resetAfterSamples","#sampleLimit","#resetTimer","#fromTime","#events"],"sources":["../../packages/core/src/key-value.ts","../../packages/core/src/trackers/primitive-tracker.ts","../../packages/trackers/dist/src/frequency-mutable.js","../../packages/trackers/dist/src/number-tracker.js","../../packages/trackers/dist/src/interval-tracker.js","../../packages/trackers/dist/src/rate-tracker.js","../src/trackers.ts"],"sourcesContent":["\nimport type { KeyValue } from './types.js'\n//import { minMaxAvg as arrayMinMaxAvg } from '../../ixfx/src/numbers-compute.js';\n\nimport { defaultComparer } from './comparers.js';\n\n// const byKey = (reverse = false) => pipe(\n//   reverse ? reverseOrd(S.Ord) : S.Ord,\n//   contramap((v: KeyValue) => v[ 0 ])\n// );\n\n// export const byValueString = (reverse = false) => pipe(\n//   reverse ? reverseOrd(S.Ord) : S.Ord,\n//   contramap((v: KeyValue) => v[ 1 ] as string)\n// );\n\n// const byValueNumber = (reverse = false) => pipe(\n//   reverse ? reverseOrd(N.Ord) : N.Ord,\n//   contramap((v: KeyValue) => v[ 1 ] as number)\n// );\n\n// export const sortByKey = (reverse = false) => sort<KeyValue>(byKey(reverse));\n// export const sortByValueString = (reverse = false) => sort<KeyValue>(byValueString(reverse));\n// export const sortByValueNumber = (reverse = false) => sort<KeyValue>(byValueNumber(reverse));\n\nexport type KeyValueSorter = (data: KeyValue[]) => KeyValue[];\n\nconst sorterByValueIndex = (index: number, reverse = false) => {\n  return (values: KeyValue[]) => {\n    const s = values.toSorted((a, b) => {\n      return defaultComparer(a[ index ], b[ index ]);\n    });\n    if (reverse) return s.reverse();\n    return s;\n  }\n}\n\nexport type KeyValueSortSyles = `value` | `value-reverse` | `key` | `key-reverse`;\nexport const keyValueSorter = (sortStyle: KeyValueSortSyles): KeyValueSorter => {\n  switch (sortStyle) {\n    case `value`: {\n      return sorterByValueIndex(1, false);\n    }\n    case `value-reverse`: {\n      return sorterByValueIndex(1, true);\n    }\n    case `key`: {\n      return sorterByValueIndex(0, false);\n    }\n    case `key-reverse`: {\n      return sorterByValueIndex(0, true);\n    }\n    default: {\n      throw new Error(`Unknown sorting value '${ (sortStyle as string) }'. Expecting: value, value-reverse, key or key-reverse`);\n    }\n  }\n};\n\n\n// export const minMaxAvg = (entries: readonly KeyValue[], conversionFunction?: (v: KeyValue) => number) => {\n//   const converter = conversionFunction ?? ((v: KeyValue) => v[ 1 ] as number);\n//   const values = entries.map<number>(entry => converter(entry));\n//   return arrayMinMaxAvg(values);\n// };","import type { TrackedValueOpts } from \"./tracked-value.js\";\nimport { TrackerBase, type TrimReason } from \"./tracker-base.js\";\n\nexport type TimestampedPrimitive<V extends number | string> = {\n  at: number\n  value: V\n}\n\nexport abstract class PrimitiveTracker<\n  V extends number | string,\n  TResult\n> extends TrackerBase<V, TResult> {\n  values: V[];\n  timestamps: number[];\n\n  constructor(opts?: TrackedValueOpts) {\n    super(opts);\n    this.values = [];\n    this.timestamps = [];\n  }\n\n  /**\n   * Reduces size of value store to `limit`. Returns\n   * number of remaining items\n   * @param limit\n   */\n  trimStore(limit: number): number {\n    if (limit >= this.values.length) return this.values.length;\n    this.values = this.values.slice(-limit);\n    this.timestamps = this.timestamps.slice(-limit);\n    return this.values.length;\n  }\n\n  onTrimmed(reason: TrimReason) {\n    // no-op\n  }\n\n  get last(): V | undefined {\n    return this.values.at(-1);\n  }\n\n  get initial(): V | undefined {\n    return this.values.at(0);\n  }\n\n  /**\n   * Returns number of recorded values (this can include the initial value)\n   */\n  get size() {\n    return this.values.length;\n  }\n\n  /**\n   * Returns the elapsed time, in milliseconds since the instance was created\n   */\n  get elapsed(): number {\n    if (this.values.length < 0) throw new Error(`No values seen yet`);\n    return Date.now() - this.timestamps[ 0 ];\n  }\n\n  onReset() {\n    this.values = [];\n    this.timestamps = [];\n  }\n\n  /**\n   * Tracks a value\n   */\n  filterData(rawValues: V[]): TimestampedPrimitive<V>[] {\n    const lastValue = rawValues.at(-1);\n    const last: TimestampedPrimitive<V> = { value: lastValue as unknown as V, at: performance.now() };\n\n    const values: TimestampedPrimitive<V>[] = rawValues.map(value => ({\n      at: performance.now(),\n      value: value\n    }));\n\n    //const now = Date.now();\n    if (this.storeIntermediate) {\n      this.values.push(...rawValues);\n      this.timestamps.push(...values.map(v => v.at));\n    } else switch (this.values.length) {\n      case 0: {\n        // Add as initial value\n        this.values.push(last.value);\n        this.timestamps.push(last.at);\n        break;\n      }\n      case 2: {\n        // Replace last value\n        this.values[ 1 ] = last.value;\n        this.timestamps[ 1 ] = last.at;\n        break;\n      }\n      case 1: {\n        // Add last value\n        this.values.push(last.value);\n        this.timestamps.push(last.at);\n        break;\n      }\n      // No default\n    }\n\n    return values;\n  }\n}\n","import { keyValueSorter } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events';\nimport { numberArrayCompute } from '@ixfx/numbers';\nexport class FrequencyTracker extends SimpleEventEmitter {\n    #store;\n    #keyString;\n    /**\n     * Constructor\n     * @param keyString Function to key items. Uses JSON.stringify by default\n     */\n    constructor(keyString) {\n        super();\n        this.#store = new Map();\n        if (typeof keyString === `undefined`) {\n            keyString = (a) => {\n                if (a === undefined)\n                    throw new Error(`Cannot create key for undefined`);\n                return typeof a === `string` ? a : JSON.stringify(a);\n            };\n        }\n        this.#keyString = keyString;\n    }\n    /**\n     * Clear data. Fires `change` event\n     */\n    clear() {\n        this.#store.clear();\n        this.fireEvent(`change`, { context: this });\n    }\n    /**\n     * @returns Iterator over keys (ie. groups)\n     */\n    keys() {\n        return this.#store.keys();\n    }\n    /**\n     * @returns Iterator over frequency counts\n     */\n    values() {\n        return this.#store.values();\n    }\n    /**\n     * @returns Copy of entries as an array of `[key, count]`\n     */\n    toArray() {\n        return [...this.#store.entries()];\n    }\n    /**\n     * Returns a string with keys and counts, useful for debugging.\n     * @returns\n     */\n    debugString() {\n        let t = ``;\n        for (const [key, count] of this.#store.entries()) {\n            t += `${key}: ${count.toString()}, `;\n        }\n        if (t.endsWith(`, `))\n            return t.slice(0, Math.max(0, t.length - 2));\n        return t;\n    }\n    /**\n     *\n     * @param value Value to count\n     * @returns Frequency of value, or _undefined_ if it does not exist\n     */\n    frequencyOf(value) {\n        if (typeof value === `string`)\n            return this.#store.get(value);\n        const key = this.#keyString(value);\n        return this.#store.get(key);\n    }\n    /**\n     *\n     * @param value Value to count\n     * @returns Relative frequency of `value`, or _undefined_ if it does not exist\n     */\n    relativeFrequencyOf(value) {\n        let freq;\n        if (typeof value === `string`)\n            freq = this.#store.get(value);\n        else {\n            const key = this.#keyString(value);\n            freq = this.#store.get(key);\n        }\n        if (freq === undefined)\n            return;\n        const mma = this.computeValues();\n        return freq / mma.total;\n    }\n    /**\n     * Returns copy of entries as an array\n     * @returns Copy of entries as an array\n     */\n    entries() {\n        return [...this.#store.entries()];\n    }\n    /**\n     * Calculate min,max,avg,total & count from values\n     * @returns Returns `{min,max,avg,total}`\n     */\n    computeValues() {\n        const valuesAsNumbers = [...this.values()];\n        return numberArrayCompute(valuesAsNumbers);\n    }\n    /**\n     * Return entries sorted\n     * @param sortStyle Sorting style (default: _value_, ie. count)\n     * @returns Sorted array of [key,frequency]\n     */\n    entriesSorted(sortStyle = `value`) {\n        const s = keyValueSorter(sortStyle);\n        return s(this.entries());\n    }\n    /**\n     * Add one or more values, firing _change_ event.\n     * @param values Values to add. Fires _change_ event after adding item(s)\n     */\n    add(...values) {\n        if (typeof values === `undefined`)\n            throw new Error(`Param 'values' undefined`);\n        const keys = values.map(v => this.#keyString(v));\n        //const key = this.#keyString(value);\n        for (const key of keys) {\n            const score = this.#store.get(key) ?? 0;\n            this.#store.set(key, score + 1);\n        }\n        this.fireEvent(`change`, { context: this });\n    }\n}\n/**\n * Frequency keeps track of how many times a particular value is seen, but\n * unlike a Map it does not store the data. By default compares\n * items by value (via JSON.stringify).\n *\n * Create with {@link Trackers.frequency}.\n *\n * Fires `change` event when items are added or it is cleared.\n *\n * Overview\n * ```\n * const fh = Trackers.frequency();\n * fh.add(value); // adds a value\n * fh.clear();    // clears all data\n * fh.keys() / .values() // returns an iterator for keys and values\n * fh.toArray();  //  returns an array of data in the shape [[key,freq],[key,freq]...]\n * ```\n *\n * Usage\n * ```\n * const fh = Trackers.frequency();\n * fh.add(`apples`); // Count an occurence of `apples`\n * fh.add(`oranges)`;\n * fh.add(`apples`);\n *\n * const fhData = fh.toArray(); // Expect result [[`apples`, 2], [`oranges`, 1]]\n * fhData.forEach((d) => {\n *  const [key,freq] = d;\n *  console.log(`Key '${key}' occurred ${freq} time(s).`);\n * })\n * ```\n *\n * Custom key string\n * ```\n * const fh = Trackers.frequency( person => person.name);\n * // All people with name `Samantha` will be counted in same group\n * fh.add({name:`Samantha`, city:`Brisbane`});\n * ```\n * @typeParam V - Type of items\n */\nexport const frequency = (keyString) => new FrequencyTracker(keyString);\n","import { PrimitiveTracker } from \"@ixfx/core/trackers\";\nimport { minFast, maxFast, totalFast } from \"@ixfx/numbers\";\nexport class NumberTracker extends PrimitiveTracker {\n    total = 0;\n    min = Number.MAX_SAFE_INTEGER;\n    max = Number.MIN_SAFE_INTEGER;\n    get avg() {\n        return this.total / this.seenCount;\n    }\n    /**\n     * Difference between last value and initial.\n     * Eg. if last value was 10 and initial value was 5, 5 is returned (10 - 5)\n     * If either of those is missing, undefined is returned\n     */\n    difference() {\n        if (this.last === undefined)\n            return;\n        if (this.initial === undefined)\n            return;\n        return this.last - this.initial;\n    }\n    /**\n     * Relative difference between last value and initial.\n     * Eg if last value was 10 and initial value was 5, 2 is returned (200%)\n     */\n    relativeDifference() {\n        if (this.last === undefined)\n            return;\n        if (this.initial === undefined)\n            return;\n        return this.last / this.initial;\n    }\n    onReset() {\n        this.min = Number.MAX_SAFE_INTEGER;\n        this.max = Number.MIN_SAFE_INTEGER;\n        this.total = 0;\n        super.onReset();\n    }\n    /**\n     * When trimmed, recomputes to set total/min/max to be based on\n     * current values.\n     * @param reason\n     */\n    onTrimmed(reason) {\n        this.min = minFast(this.values);\n        this.max = maxFast(this.values);\n        this.total = totalFast(this.values);\n    }\n    computeResults(values) {\n        if (values.some((v) => Number.isNaN(v)))\n            throw new Error(`Cannot add NaN`);\n        const numbers = values.map(value => value.value);\n        this.total = numbers.reduce((accumulator, v) => accumulator + v, this.total);\n        this.min = Math.min(...numbers, this.min);\n        this.max = Math.max(...numbers, this.max);\n        const r = {\n            max: this.max,\n            min: this.min,\n            total: this.total,\n            avg: this.avg\n        };\n        return r;\n    }\n    getMinMaxAvg() {\n        return {\n            min: this.min,\n            max: this.max,\n            avg: this.avg,\n        };\n    }\n}\n/**\n * Keeps track of the total, min, max and avg in a stream of values. By default values\n * are not stored.\n *\n * Usage:\n *\n * ```js\n * import { number } from 'https://unpkg.com/ixfx/dist/trackers.js';\n *\n * const t = number();\n * t.seen(10);\n *\n * t.avg / t.min/ t.max\n * t.initial; // initial value\n * t.size;    // number of seen values\n * t.elapsed; // milliseconds since intialisation\n * t.last;    // last value\n * ```\n *\n * To get `{ avg, min, max, total }`\n * ```\n * t.getMinMax()\n * ```\n *\n * Use `t.reset()` to clear everything.\n *\n * Trackers can automatically reset after a given number of samples\n * ```\n * // reset after 100 samples\n * const t = number({ resetAfterSamples: 100 });\n * ```\n *\n * To store values, use the `storeIntermediate` option:\n *\n * ```js\n * const t = number({ storeIntermediate: true });\n * ```\n *\n * Difference between last value and initial value:\n * ```js\n * t.relativeDifference();\n * ```\n *\n * Get raw data (if it is being stored):\n * ```js\n * t.values; // array of numbers\n * t.timestampes; // array of millisecond times, indexes correspond to t.values\n * ```\n */\nexport const number = (opts = {}) => new NumberTracker(opts);\n","import { NumberTracker } from './number-tracker.js';\n/**\n * A `Tracker` that tracks interval between calls to `mark()`\n */\nexport class IntervalTracker extends NumberTracker {\n    lastMark = 0;\n    mark() {\n        if (this.lastMark > 0) {\n            this.seen(performance.now() - this.lastMark);\n        }\n        this.lastMark = performance.now();\n    }\n}\n/**\n * Returns a new {@link IntervalTracker} instance. IntervalTracker\n * records the interval between each call to `mark`.\n *\n * ```js\n * import { interval } from 'https://unpkg.com/ixfx/dist/trackers.js';\n *\n * const t = interval();\n *\n * // Call `mark` to record an interval\n * t.mark();\n * ...\n * t.mark();\n *\n * // Get average time in milliseconds between calls to `mark`\n * t.avg;\n *\n * // Longest and shortest times are available too...\n * t.min / t.max\n * ```\n *\n * Interval tracker can automatically reset after a given number of samples:\n *\n * ```\n * // Reset after 100 samples\n * const t = interval({ resetAfterSamples: 100} );\n * ```\n * @param options Options for tracker\n * @returns New interval tracker\n */\nexport const interval = (options) => new IntervalTracker(options);\n","import { timeout } from \"@ixfx/flow\";\n/**\n * Tracks the rate of events.\n * It's also able to compute the min,max and average interval between events.\n *\n * @example\n * ```js\n * const clicks = Trackers.rate();\n *\n * // Mark when a click happens\n * document.addEventListener(`click`, () => clicks.mark());\n *\n * // Get details\n * clicks.perSecond; // How many clicks per second\n * clicks.perMinute; // How many clicks per minute\n * ```\n *\n * `timeoutInterval` is a useful option to make the tracker reset\n * after some period without `mark()` being called.\n *\n * Another useful option is `sampleLimit`, which sets an upper bound\n * for how many events to track. A smaller value means the results\n * will more accurately track, but it might be less smooth.\n *\n * ```js\n * // Eg reset tracker after 5 seconds of inactivity\n * const clicks = Trackers.rate({\n *  sampleLimit: 10,\n *  timeoutInterval: { secs: 5 }\n * });\n * ```\n */\nexport class RateTracker {\n    #events = [];\n    #fromTime;\n    #resetAfterSamples;\n    #sampleLimit;\n    #resetTimer;\n    constructor(opts = {}) {\n        this.#resetAfterSamples = opts.resetAfterSamples ?? Number.MAX_SAFE_INTEGER;\n        this.#sampleLimit = opts.sampleLimit ?? Number.MAX_SAFE_INTEGER;\n        if (opts.timeoutInterval) {\n            this.#resetTimer = timeout(() => {\n                this.reset();\n            }, opts.timeoutInterval);\n        }\n        this.#fromTime = performance.now();\n    }\n    /**\n     * Mark that an event has happened\n     */\n    mark() {\n        if (this.#events.length >= this.#resetAfterSamples) {\n            this.reset();\n        }\n        else if (this.#events.length >= this.#sampleLimit) {\n            this.#events = this.#events.slice(1);\n            this.#fromTime = this.#events[0];\n        }\n        this.#events.push(performance.now());\n        if (this.#resetTimer) {\n            this.#resetTimer.start();\n        }\n    }\n    /**\n     * Compute {min,max,avg} for the interval _between_ events.\n     * @returns\n     */\n    computeIntervals() {\n        const intervals = [];\n        let min = Number.MAX_SAFE_INTEGER;\n        let max = Number.MIN_SAFE_INTEGER;\n        let total = 0;\n        let count = 0;\n        let start = 0;\n        for (const event of this.#events) {\n            if (count > 0) {\n                const index = event - start;\n                min = Math.min(index, min);\n                max = Math.max(index, max);\n                total += index;\n                intervals.push(index);\n            }\n            start = event;\n            count++;\n        }\n        const avg = total / count;\n        return {\n            min, max, avg\n        };\n    }\n    /**\n     * Returns the time period (in milliseconds) that encompasses\n     * the data set. Eg, a result of 1000 means there's data that\n     * covers a one second period.\n     */\n    get elapsed() {\n        return performance.now() - this.#fromTime;\n    }\n    /**\n     * Resets the tracker.\n     */\n    reset() {\n        this.#events = [];\n        this.#fromTime = performance.now();\n    }\n    /**\n     * Get the number of events per second\n     */\n    get perSecond() {\n        return this.#events.length / (this.elapsed / 1000);\n    }\n    /**\n     * Get the number of events per minute\n     */\n    get perMinute() {\n        return this.#events.length / (this.elapsed / 1000 / 60);\n    }\n}\n/**\n * @inheritdoc RateTracker\n * @param opts\n * @returns\n */\nexport const rate = (opts = {}) => new RateTracker(opts);\n","export * from '@ixfx/trackers';"],"mappings":";;;;;;;;;AA2BA,MAAM,qBAAqB,CAACA,OAAe,UAAU,UAAU;AAC7D,QAAO,CAACC,WAAuB;EAC7B,MAAM,IAAI,OAAO,SAAS,CAAC,GAAG,MAAM;AAClC,UAAO,gBAAgB,EAAG,QAAS,EAAG,OAAQ;EAC/C,EAAC;AACF,MAAI,QAAS,QAAO,EAAE,SAAS;AAC/B,SAAO;CACR;AACF;AAGD,MAAa,iBAAiB,CAACC,cAAiD;AAC9E,SAAQ,WAAR;EACE,MAAM,OACJ,QAAO,mBAAmB,GAAG,MAAM;EAErC,MAAM,eACJ,QAAO,mBAAmB,GAAG,KAAK;EAEpC,MAAM,KACJ,QAAO,mBAAmB,GAAG,MAAM;EAErC,MAAM,aACJ,QAAO,mBAAmB,GAAG,KAAK;EAEpC,QACE,OAAM,IAAI,OAAO,yBAA2B,UAAsB;CAErE;AACF;;;;AChDD,IAAsB,mBAAtB,cAGU,YAAwB;CAChC;CACA;CAEA,YAAYC,MAAyB;AACnC,QAAM,KAAK;AACX,OAAK,SAAS,CAAE;AAChB,OAAK,aAAa,CAAE;CACrB;;;;;;CAOD,UAAUC,OAAuB;AAC/B,MAAI,SAAS,KAAK,OAAO,OAAQ,QAAO,KAAK,OAAO;AACpD,OAAK,SAAS,KAAK,OAAO,OAAO,MAAM;AACvC,OAAK,aAAa,KAAK,WAAW,OAAO,MAAM;AAC/C,SAAO,KAAK,OAAO;CACpB;CAED,UAAUC,QAAoB,CAE7B;CAED,IAAI,OAAsB;AACxB,SAAO,KAAK,OAAO,GAAG,GAAG;CAC1B;CAED,IAAI,UAAyB;AAC3B,SAAO,KAAK,OAAO,GAAG,EAAE;CACzB;;;;CAKD,IAAI,OAAO;AACT,SAAO,KAAK,OAAO;CACpB;;;;CAKD,IAAI,UAAkB;AACpB,MAAI,KAAK,OAAO,SAAS,EAAG,OAAM,IAAI,OAAO;AAC7C,SAAO,KAAK,KAAK,GAAG,KAAK,WAAY;CACtC;CAED,UAAU;AACR,OAAK,SAAS,CAAE;AAChB,OAAK,aAAa,CAAE;CACrB;;;;CAKD,WAAWC,WAA2C;EACpD,MAAM,YAAY,UAAU,GAAG,GAAG;EAClC,MAAMC,OAAgC;GAAE,OAAO;GAA2B,IAAI,YAAY,KAAK;EAAE;EAEjG,MAAMC,SAAoC,UAAU,IAAI,YAAU;GAChE,IAAI,YAAY,KAAK;GACd;EACR,GAAE;AAGH,MAAI,KAAK,mBAAmB;AAC1B,QAAK,OAAO,KAAK,GAAG,UAAU;AAC9B,QAAK,WAAW,KAAK,GAAG,OAAO,IAAI,OAAK,EAAE,GAAG,CAAC;EAC/C,MAAM,SAAQ,KAAK,OAAO,QAApB;GACL,KAAK,GAAG;AAEN,SAAK,OAAO,KAAK,KAAK,MAAM;AAC5B,SAAK,WAAW,KAAK,KAAK,GAAG;AAC7B;GACD;GACD,KAAK,GAAG;AAEN,SAAK,OAAQ,KAAM,KAAK;AACxB,SAAK,WAAY,KAAM,KAAK;AAC5B;GACD;GACD,KAAK,GAAG;AAEN,SAAK,OAAO,KAAK,KAAK,MAAM;AAC5B,SAAK,WAAW,KAAK,KAAK,GAAG;AAC7B;GACD;EAEF;AAED,SAAO;CACR;AACF;;;;ACtGD,IAAa,mBAAb,cAAsC,mBAAmB;CACrD;CACA;;;;;CAKA,YAAY,WAAW;AACnB,SAAO;AACP,OAAKC,SAAS,IAAI;AAClB,aAAW,eAAe,WACtB,aAAY,CAAC,MAAM;AACf,OAAI,aACA,OAAM,IAAI,OAAO;AACrB,iBAAc,OAAO,UAAU,IAAI,KAAK,UAAU,EAAE;EACvD;AAEL,OAAKC,aAAa;CACrB;;;;CAID,QAAQ;AACJ,OAAKD,OAAO,OAAO;AACnB,OAAK,WAAW,SAAS,EAAE,SAAS,KAAM,EAAC;CAC9C;;;;CAID,OAAO;AACH,SAAO,KAAKA,OAAO,MAAM;CAC5B;;;;CAID,SAAS;AACL,SAAO,KAAKA,OAAO,QAAQ;CAC9B;;;;CAID,UAAU;AACN,SAAO,CAAC,GAAG,KAAKA,OAAO,SAAS,AAAC;CACpC;;;;;CAKD,cAAc;EACV,IAAI,KAAK;AACT,OAAK,MAAM,CAAC,KAAK,MAAM,IAAI,KAAKA,OAAO,SAAS,CAC5C,OAAM,EAAE,IAAI,IAAI,MAAM,UAAU,CAAC;AAErC,MAAI,EAAE,UAAU,IAAI,CAChB,QAAO,EAAE,MAAM,GAAG,KAAK,IAAI,GAAG,EAAE,SAAS,EAAE,CAAC;AAChD,SAAO;CACV;;;;;;CAMD,YAAY,OAAO;AACf,aAAW,WAAW,QAClB,QAAO,KAAKA,OAAO,IAAI,MAAM;EACjC,MAAM,MAAM,KAAKC,WAAW,MAAM;AAClC,SAAO,KAAKD,OAAO,IAAI,IAAI;CAC9B;;;;;;CAMD,oBAAoB,OAAO;EACvB,IAAI;AACJ,aAAW,WAAW,QAClB,QAAO,KAAKA,OAAO,IAAI,MAAM;OAC5B;GACD,MAAM,MAAM,KAAKC,WAAW,MAAM;AAClC,UAAO,KAAKD,OAAO,IAAI,IAAI;EAC9B;AACD,MAAI,gBACA;EACJ,MAAM,MAAM,KAAK,eAAe;AAChC,SAAO,OAAO,IAAI;CACrB;;;;;CAKD,UAAU;AACN,SAAO,CAAC,GAAG,KAAKA,OAAO,SAAS,AAAC;CACpC;;;;;CAKD,gBAAgB;EACZ,MAAM,kBAAkB,CAAC,GAAG,KAAK,QAAQ,AAAC;AAC1C,SAAO,mBAAmB,gBAAgB;CAC7C;;;;;;CAMD,cAAc,aAAa,QAAQ;EAC/B,MAAM,IAAI,eAAe,UAAU;AACnC,SAAO,EAAE,KAAK,SAAS,CAAC;CAC3B;;;;;CAKD,IAAI,GAAG,QAAQ;AACX,aAAW,YAAY,WACnB,OAAM,IAAI,OAAO;EACrB,MAAM,OAAO,OAAO,IAAI,OAAK,KAAKC,WAAW,EAAE,CAAC;AAEhD,OAAK,MAAM,OAAO,MAAM;GACpB,MAAM,QAAQ,KAAKD,OAAO,IAAI,IAAI,IAAI;AACtC,QAAKA,OAAO,IAAI,KAAK,QAAQ,EAAE;EAClC;AACD,OAAK,WAAW,SAAS,EAAE,SAAS,KAAM,EAAC;CAC9C;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCD,MAAa,YAAY,CAAC,cAAc,IAAI,iBAAiB;;;;ACvK7D,IAAa,gBAAb,cAAmC,iBAAiB;CAChD,QAAQ;CACR,MAAM,OAAO;CACb,MAAM,OAAO;CACb,IAAI,MAAM;AACN,SAAO,KAAK,QAAQ,KAAK;CAC5B;;;;;;CAMD,aAAa;AACT,MAAI,KAAK,gBACL;AACJ,MAAI,KAAK,mBACL;AACJ,SAAO,KAAK,OAAO,KAAK;CAC3B;;;;;CAKD,qBAAqB;AACjB,MAAI,KAAK,gBACL;AACJ,MAAI,KAAK,mBACL;AACJ,SAAO,KAAK,OAAO,KAAK;CAC3B;CACD,UAAU;AACN,OAAK,MAAM,OAAO;AAClB,OAAK,MAAM,OAAO;AAClB,OAAK,QAAQ;AACb,QAAM,SAAS;CAClB;;;;;;CAMD,UAAU,QAAQ;AACd,OAAK,MAAM,QAAQ,KAAK,OAAO;AAC/B,OAAK,MAAM,QAAQ,KAAK,OAAO;AAC/B,OAAK,QAAQ,UAAU,KAAK,OAAO;CACtC;CACD,eAAe,QAAQ;AACnB,MAAI,OAAO,KAAK,CAAC,MAAM,OAAO,MAAM,EAAE,CAAC,CACnC,OAAM,IAAI,OAAO;EACrB,MAAM,UAAU,OAAO,IAAI,WAAS,MAAM,MAAM;AAChD,OAAK,QAAQ,QAAQ,OAAO,CAAC,aAAa,MAAM,cAAc,GAAG,KAAK,MAAM;AAC5E,OAAK,MAAM,KAAK,IAAI,GAAG,SAAS,KAAK,IAAI;AACzC,OAAK,MAAM,KAAK,IAAI,GAAG,SAAS,KAAK,IAAI;EACzC,MAAM,IAAI;GACN,KAAK,KAAK;GACV,KAAK,KAAK;GACV,OAAO,KAAK;GACZ,KAAK,KAAK;EACb;AACD,SAAO;CACV;CACD,eAAe;AACX,SAAO;GACH,KAAK,KAAK;GACV,KAAK,KAAK;GACV,KAAK,KAAK;EACb;CACJ;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDD,MAAa,SAAS,CAAC,OAAO,CAAE,MAAK,IAAI,cAAc;;;;;;;ACpHvD,IAAa,kBAAb,cAAqC,cAAc;CAC/C,WAAW;CACX,OAAO;AACH,MAAI,KAAK,WAAW,EAChB,MAAK,KAAK,YAAY,KAAK,GAAG,KAAK,SAAS;AAEhD,OAAK,WAAW,YAAY,KAAK;CACpC;AACJ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+BD,MAAa,WAAW,CAAC,YAAY,IAAI,gBAAgB;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACXzD,IAAa,cAAb,MAAyB;CACrB,UAAU,CAAE;CACZ;CACA;CACA;CACA;CACA,YAAY,OAAO,CAAE,GAAE;AACnB,OAAKE,qBAAqB,KAAK,qBAAqB,OAAO;AAC3D,OAAKC,eAAe,KAAK,eAAe,OAAO;AAC/C,MAAI,KAAK,gBACL,MAAKC,cAAc,QAAQ,MAAM;AAC7B,QAAK,OAAO;EACf,GAAE,KAAK,gBAAgB;AAE5B,OAAKC,YAAY,YAAY,KAAK;CACrC;;;;CAID,OAAO;AACH,MAAI,KAAKC,QAAQ,UAAU,KAAKJ,mBAC5B,MAAK,OAAO;WAEP,KAAKI,QAAQ,UAAU,KAAKH,cAAc;AAC/C,QAAKG,UAAU,KAAKA,QAAQ,MAAM,EAAE;AACpC,QAAKD,YAAY,KAAKC,QAAQ;EACjC;AACD,OAAKA,QAAQ,KAAK,YAAY,KAAK,CAAC;AACpC,MAAI,KAAKF,YACL,MAAKA,YAAY,OAAO;CAE/B;;;;;CAKD,mBAAmB;EACf,MAAM,YAAY,CAAE;EACpB,IAAI,MAAM,OAAO;EACjB,IAAI,MAAM,OAAO;EACjB,IAAI,QAAQ;EACZ,IAAI,QAAQ;EACZ,IAAI,QAAQ;AACZ,OAAK,MAAM,SAAS,KAAKE,SAAS;AAC9B,OAAI,QAAQ,GAAG;IACX,MAAM,QAAQ,QAAQ;AACtB,UAAM,KAAK,IAAI,OAAO,IAAI;AAC1B,UAAM,KAAK,IAAI,OAAO,IAAI;AAC1B,aAAS;AACT,cAAU,KAAK,MAAM;GACxB;AACD,WAAQ;AACR;EACH;EACD,MAAM,MAAM,QAAQ;AACpB,SAAO;GACH;GAAK;GAAK;EACb;CACJ;;;;;;CAMD,IAAI,UAAU;AACV,SAAO,YAAY,KAAK,GAAG,KAAKD;CACnC;;;;CAID,QAAQ;AACJ,OAAKC,UAAU,CAAE;AACjB,OAAKD,YAAY,YAAY,KAAK;CACrC;;;;CAID,IAAI,YAAY;AACZ,SAAO,KAAKC,QAAQ,UAAU,KAAK,UAAU;CAChD;;;;CAID,IAAI,YAAY;AACZ,SAAO,KAAKA,QAAQ,UAAU,KAAK,UAAU,MAAO;CACvD;AACJ;;;;;;AAMD,MAAa,OAAO,CAAC,OAAO,CAAE,MAAK,IAAI,YAAY"}