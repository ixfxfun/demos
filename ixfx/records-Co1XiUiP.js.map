{"version":3,"file":"records-Co1XiUiP.js","names":["value: unknown","value: string | number","domQueryOrEl: string | V | null | undefined","selectors: QueryOrElements","a: object","b: object","a: TValue[]","b: TValue[]","eq: IsEqual<TValue>","key: string","cc: CompareChangeSet<number>","a: object | null","b: object | null","eq: IsEqual<T>","removed: string[]","source: T","entries: [ key: string, value: any ][]","object: TSource","mapFunction: (args: MapObjectArgs) => TFieldValue","target: V","deepProbe: boolean","entries: [ key: string, value: any ][]","a: V","b: Partial<V>","options: Partial<CompareDataOptions<V>>","path: string","value: any","o: any","split: string[]","allowShapeChange: boolean","object: Record<string, any>","o: object","prefix: string","maxDepth: number","object: Record<TKeySource, unknown>","mapFunction: (key: TKeySource) => TKeyDestination"],"sources":["../../packages/guards/src/object.ts","../../packages/core/src/is-integer.ts","../../packages/dom/src/resolve-el.ts","../../packages/core/src/records/compare.ts","../../packages/core/src/records/clone-from-fields.ts","../../packages/core/src/records/map-object.ts","../../packages/core/src/records/pathed.ts","../../packages/core/src/records/index.ts"],"sourcesContent":["import type { Result } from \"./types.js\";\n\n/**\n * Tests_if `value` is a plain object\n * \n * ```js\n * isPlainObject(`text`); // false\n * isPlainObject(document); // false\n * isPlainObject({ hello: `there` }); // true\n * ```\n * @param value \n * @returns \n */\nexport const testPlainObject = (value: unknown): Result<object, string> => {\n  if (typeof value !== `object` || value === null) return { success: false, error: `Value is null or not object type` };\n  const prototype = Object.getPrototypeOf(value);\n  const t = (prototype === null || prototype === Object.prototype || Object.getPrototypeOf(prototype) === null) && !(Symbol.toStringTag in value) && !(Symbol.iterator in value);\n  if (t) return { success: true, value };\n  return { success: false, error: `Fancy object` };\n}\n\n/**\n * Tests if `value` is primitive value (bigint,number,string or boolean) or plain object\n * @param value \n * @returns \n */\nexport const testPlainObjectOrPrimitive = (value: unknown): Result<object | bigint | number | string | boolean, string> => {\n  const t = typeof value;\n  if (t === `symbol`) return { success: false, error: `Symbol type` };\n  if (t === `function`) return { success: false, error: `Function type` };\n  if (t === `bigint`) return { success: true, value: value as bigint };\n  if (t === `number`) return { success: true, value: value as number };\n  if (t === `string`) return { success: true, value: value as string };\n  if (t === `boolean`) return { success: true, value: value as boolean };\n  return testPlainObject(value);\n}","/**\n * Returns _true_ if `value` is an integer. Parses string input, but\n * all other data types return _false_.\n * \n * ```js\n * isInteger(1);      // true\n * isInteger(1.1);    // false\n * isInteger(`1`);    // true\n * isInteger(`1.1`);  // false\n * isInteger(true);   // false\n * isInteger(false);  // false\n * ```\n * \n * Returns _false_ for _undefined_, NaN, booleans and infinite numbers.\n * @param value \n * @returns \n */\nexport const isInteger = (value: string | number) => {\n  if (value === undefined) return false;\n  if (typeof value === `string`) {\n    const v = Number.parseInt(value);\n    if (Number.isNaN(v)) return false;\n    if (v.toString() === value.toString()) return true;\n    return false;\n  }\n  if (typeof value === `number`) {\n    if (Number.isNaN(value)) return false;\n    if (!Number.isFinite(value)) return false;\n    if (Math.round(value) === value) return true;\n    return false;\n  }\n  return false;\n}","import { resultToError, type Result } from \"@ixfx/core\";\n\n/**\n * Resolves either a string or HTML element to an element.\n * Useful when an argument is either an HTML element or query.\n *\n * ```js\n * resolveEl(`#someId`);\n * resolveEl(someElement);\n * ```\n * @param domQueryOrEl\n * @returns\n */\nexport const resolveEl = <V extends Element>(domQueryOrEl: string | V | null | undefined): V => {\n  const r = resolveElementTry(domQueryOrEl);\n  if (r.success) return r.value;\n  throw resultToError(r);\n}\n\nexport const resolveElementTry = <V extends Element>(domQueryOrEl: string | V | null | undefined): Result<V> => {\n  if (typeof domQueryOrEl === `string`) {\n    const d = document.querySelector(domQueryOrEl);\n    if (d === null) {\n      const error = domQueryOrEl.startsWith(`#`) ? `Query '${ domQueryOrEl }' did not match anything. Try '#id', 'div', or '.class'`\n        : `Query '${ domQueryOrEl }' did not match anything. Did you mean '#${ domQueryOrEl }?`;\n      return { success: false, error };\n\n    }\n    domQueryOrEl = d as V;\n  } else if (domQueryOrEl === null) {\n    return { success: false, error: `Param 'domQueryOrEl' is null` };\n  } else if (domQueryOrEl === undefined) {\n    return { success: false, error: `Param 'domQueryOrEl' is undefined` };\n  }\n  const el = domQueryOrEl;\n  return { success: true, value: el };\n};\n\nexport type QueryOrElements = string | Element[] | HTMLElement[] | HTMLElement | Element\n\nexport const resolveEls = (selectors: QueryOrElements): HTMLElement[] => {\n  if (selectors === undefined) return [];\n  if (selectors === null) return [];\n  if (Array.isArray(selectors)) return selectors as HTMLElement[];\n  if (typeof selectors === `string`) {\n    const elements = [ ...document.querySelectorAll(selectors) ]\n    return elements as HTMLElement[]\n  }\n  return [ selectors as HTMLElement ];\n}","import { mapObjectKeys } from '@ixfx/core/records';\nimport { compareIterableValuesShallow, isEqualDefault, type IsEqual } from '@ixfx/core';\nimport type { ChangeRecord, CompareChangeSet } from '../types-compare.js';\n\n\n/**\n * Compares the keys of two objects, returning a set of those in\n * common, and those in either A or B exclusively.\n * ```js\n * const a = { colour: `red`, intensity: 5 };\n * const b = { colour: `pink`, size: 10 };\n * const c = compareObjectKeys(a, b);\n * // c.shared = [ `colour` ]\n * // c.a = [ `intensity` ]\n * // c.b = [ `size`  ]\n * ```\n * @param a \n * @param b \n * @returns \n */\nexport const compareObjectKeys = (a: object, b: object) => {\n  const c = compareIterableValuesShallow(Object.keys(a), Object.keys(b));\n  return c;\n}\n\n/**\n * Returns the changed fields from A -> B. It's assumed that A and B have the same shape.\n * ie. returns an object that only consists of fields which have changed in B compared to A.\n * \n * ```js\n * const a = { msg: `hi`, v: 10 };\n * \n * changedDataFields(a, { msg: `hi`,   v: 10 }); // {}\n * changedDataFields(a, { msg: `hi!!`, v: 10 }); // { msg: `hi!!` }\n * changedDataFields(a, { msg: `hi!!` });       // { msg: `hi!!`, v: undefined }\n * ```\n * \n * Under the hood, we use {@link compareObjectData}(a, b, true). If B has additional or removed fields,\n * this is considered an error.\n * \n * If a field is an array, the whole array is returned, rather than a diff.\n * @param a \n * @param b \n */\nexport const changedObjectDataFields = (a: object, b: object) => {\n  const r = compareObjectData(a, b, true);\n  if (Object.entries(r.added).length > 0) throw new Error(`Shape of data has changed`);\n  if (Object.entries(r.removed).length > 0) throw new Error(`Shape of data has changed`);\n\n  const output = compareResultToObject(r, b);\n  return output;\n}\n\nconst compareResultToObject = <TKey extends string | number>(r: CompareChangeSet<TKey>, b: object): Record<string, unknown> | object[] => {\n  const output = {}\n\n  if (r.isArray) {\n    return b as object[];\n  }\n\n  for (const entry of Object.entries(r.changed)) {\n    (output as object)[ entry[ 0 ] ] = entry[ 1 ];\n  }\n\n  for (const entry of Object.entries(r.added)) {\n    (output as object)[ entry[ 0 ] ] = entry[ 1 ];\n  }\n\n\n  for (const childEntry of Object.entries(r.children)) {\n    const childResult = childEntry[ 1 ] as CompareChangeSet<TKey>;\n    if (childResult.hasChanged) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n      (output as object)[ childEntry[ 0 ] ] = compareResultToObject(childResult, b[ childEntry[ 0 ] ]);\n    }\n  }\n  return output;\n}\n\n/**\n * Produces a {@link CompareChangeSet} between two arrays.\n * \n * @param a Earlier array to compare\n * @param b Later array to compare\n * @param eq Equality comparison for values\n * @returns Change set.\n */\nexport const compareArrays = <TValue>(a: TValue[], b: TValue[], eq: IsEqual<TValue> = isEqualDefault<TValue>): CompareChangeSet<number> => {\n  if (!Array.isArray(a)) throw new Error(`Param 'a' is not an array`);\n  if (!Array.isArray(b)) throw new Error(`Param 'b' is not an array`);\n  const c = compareObjectData(a, b, false, eq);\n  if (!c.isArray) throw new Error(`Change set does not have arrays as parameters`);\n\n  const convert = (key: string): number => {\n    if (key.startsWith(`_`)) {\n      return Number.parseInt(key.slice(1));\n    } else throw new Error(`Unexpected key '${ key }'`);\n  }\n  const cc: CompareChangeSet<number> = {\n    ...c,\n    added: mapObjectKeys(c.added, convert),\n    changed: mapObjectKeys(c.changed, convert),\n    removed: c.removed.map(v => convert(v)),\n    summary: c.summary.map(value => {\n      return [ value[ 0 ], convert(value[ 1 ]), value[ 2 ] ];\n    })\n  }\n  return cc;\n}\n\n/**\n * Compares A to B. Assumes they are simple objects, essentially key-value pairs, where the \n * values are primitive values or other simple objects. It also works with arrays.\n * \n * Uses === equality semantics by default.\n * @param a \n * @param b \n */\nexport const compareObjectData = <T>(a: object | null, b: object | null, assumeSameShape = false, eq: IsEqual<T> = isEqualDefault): CompareChangeSet<string> => {\n  a ??= {};\n  b ??= {};\n  const entriesA = Object.entries(a);\n  const entriesB = Object.entries(b);\n\n  const scannedKeys = new Set<string>();\n  const changed = {}\n  const added = {}\n  const children = {}\n  const removed: string[] = [];\n  const isArray = Array.isArray(a);\n\n  const summary = new Array<ChangeRecord<string>>();\n  let hasChanged = false;\n\n  // Look for existing entries of A that are modified\n  for (const entry of entriesA) {\n    const outputKey = isArray ? `_${ entry[ 0 ] }` : entry[ 0 ]\n    const aValue = entry[ 1 ] as unknown;\n    const bValue = b[ entry[ 0 ] ] as unknown;\n    scannedKeys.add(entry[ 0 ]);\n\n    if (bValue === undefined) {\n      // B does not have a key from A\n      hasChanged = true;\n      if (assumeSameShape && !isArray) {\n        // If we're assuming it's the same shape, then _undefined_ is actually the value\n        changed[ outputKey ] = bValue;\n        summary.push([ `mutate`, outputKey, bValue ]);\n      } else {\n        // Key removed\n        removed.push(outputKey);\n        summary.push([ `del`, outputKey, aValue ]);\n      }\n      continue;\n    }\n\n    if (typeof aValue === `object`) {\n      const r = compareObjectData(aValue, bValue as object, assumeSameShape, eq);\n      if (r.hasChanged) hasChanged = true;\n      children[ outputKey ] = r;\n      const childSummary = r.summary.map(sum => { return [ sum[ 0 ], outputKey + `.` + sum[ 1 ], sum[ 2 ] ] }) as ChangeRecord<string>[];\n      summary.push(...childSummary);\n    } else {\n      if (!eq(aValue as T, bValue as T)) {\n        changed[ outputKey ] = bValue;\n        hasChanged = true;\n        summary.push([ `mutate`, outputKey, bValue ]);\n      }\n    }\n  }\n\n  // Look for entries in B that weren't in A\n  if (!assumeSameShape || isArray) {\n    for (const entry of entriesB) {\n      const key = isArray ? `_${ entry[ 0 ] }` : entry[ 0 ]\n\n      if (scannedKeys.has(entry[ 0 ])) continue;\n      added[ key ] = entry[ 1 ] as unknown;\n      hasChanged = true;\n      summary.push([ `add`, key, entry[ 1 ] ])\n    }\n  }\n  return {\n    changed, added, removed, children, hasChanged, isArray, summary\n  }\n}","import { testPlainObjectOrPrimitive } from \"@ixfx/guards\";\n\nexport const cloneFromFields = <T extends object>(source: T) => {\n\n  const entries: [ key: string, value: any ][] = [];\n  for (const field in source) {\n    const value = (source)[ field ];\n    if (testPlainObjectOrPrimitive(value as unknown)) {\n      entries.push([ field, value ]);\n    }\n  }\n  return Object.fromEntries(entries) as T;\n}","import type { RemapObjectPropertyType } from \"../ts-utility.js\";\n\n/**\n * Maps the top-level properties of an object through a map function.\n * That is, run each of the values of an object through a function,\n * setting the result onto the same key structure as original.\n * \n * It is NOT recursive.\n *\n * The mapping function gets a single args object, consisting of `{ value, field, index }`,\n * where 'value' is the value of the field, 'field' the name, and 'index' a numeric count.\n * @example Double the value of all fields\n * ```js\n * const rect = { width: 100, height: 250 };\n * const doubled = mapObjectShallow(rect, args => {\n *  return args.value*2;\n * });\n * // Yields: { width: 200, height: 500 }\n * ```\n *\n * Since the map callback gets the name of the property, it can do context-dependent things.\n * ```js\n * const rect = { width: 100, height: 250, colour: 'red' }\n * const doubled = mapObjectShallow(rect, args => {\n *  if (args.field === 'width') return args.value*3;\n *  else if (typeof args.value === 'number') return args.value*2;\n *  return args.value;\n * });\n * // Yields: { width: 300, height: 500, colour: 'red' }\n * ```\n * In addition to bulk processing, it allows remapping of property types.\n *\n * In terms of type-safety, the mapped properties are assumed to have the\n * same type.\n *\n * ```js\n * const o = {\n *  x: 10,\n *  y: 20,\n *  width: 200,\n *  height: 200\n * }\n *\n * // Make each property use an averager instead\n * const oAvg = mapObjectShallow(o, args => {\n *  return movingAverage(10);\n * });\n *\n * // Instead of { x:number, y:number... }, we now have { x:movingAverage(), y:movingAverage()... }\n * // Add a value to the averager\n * oAvg.x.add(20);\n * ```\n */\nexport const mapObjectShallow = <\n  TSource extends Record<string, any>,\n  TFieldValue,\n>(\n  object: TSource,\n  mapFunction: (args: MapObjectArgs) => TFieldValue\n\n): RemapObjectPropertyType<TSource, TFieldValue> => {\n  type MapResult = [ field: string, value: TFieldValue ];\n  const entries = Object.entries(object);\n  const mapped = entries.map(([ sourceField, sourceFieldValue ], index) => [\n    sourceField,\n    mapFunction({ value: sourceFieldValue, field: sourceField, index, path: sourceField }),\n  ]) as MapResult[];\n  return Object.fromEntries(mapped) as RemapObjectPropertyType<TSource, TFieldValue>;\n};\n\nexport type MapObjectArgs = {\n  field: string\n  path: string\n  value: any\n  index: number\n}\n\n/**\n * Maps the contents of `data` using `mapper` as a structured set of map functions.\n * ```js\n * const a = {\n *  person: {\n *    size: 20\n *  }\n *  hello: `there`\n * }\n * mapObjectByObject(a, {\n *  person: {\n *    size: (value, context) => {\n *      return value * 2\n *    }\n *  }\n * });\n * // Yields: { person: { size: 40 }, hello: `there` }\n * ```\n * @param data \n * @param mapper \n * @returns \n */\nexport function mapObjectByObject(data: object, mapper: Record<string, (value: any, context: any) => any>) {\n  const entries = Object.entries(data);\n  for (const entry of entries) {\n    if (entry[ 0 ] in mapper) {\n      const m = mapper[ entry[ 0 ] ];\n      entry[ 1 ] = (typeof m === `object`) ?\n        mapObjectByObject(entry[ 1 ] as object, m) :\n        m(entry[ 1 ], data);\n    }\n  }\n  return Object.fromEntries(entries);\n}","import { recordEntriesDepthFirst } from \"@ixfx/core/records\";\nimport { isPrimitive, isInteger, isEqualContextString } from '@ixfx/core';\nimport { testPlainObjectOrPrimitive } from '@ixfx/guards';\nimport type { IsEqualContext } from '@ixfx/core';\nimport { compareObjectKeys } from './compare.js';\nimport type { Result } from '@ixfx/core';\n\nexport type PathData<V> = {\n  path: string\n  value: V\n}\n\nexport type PathDataChange<V> = PathData<V> & {\n  previous?: V\n  state: `change` | `added` | `removed`\n}\n\nexport type CompareDataOptions<V> = {\n  /**\n   * If _true_, it treats the B value as a partial\n   * version of B. Only the things present in B are compared.\n   * Omissions from B are not treated as removed keys.\n   */\n  asPartial: boolean\n  /**\n   * If _true_ (default), if a value is undefined,\n   * it signals that the key itself is removed.\n   */\n  undefinedValueMeansRemoved: boolean\n  pathPrefix: string\n  /**\n   * Comparison function for values. By default uses\n   * JSON.stringify() to compare by value.\n   */\n  eq: IsEqualContext<V>\n  /**\n   * If true, inherited fields are also compared.\n   * This is necessary for events, for example.\n   * \n   * Only plain-object values are used, the other keys are ignored.\n   */\n  deepEntries: boolean\n\n  /**\n   * If _true_, includes fields that are present in B, but missing in A.\n   * _False_ by default.\n   */\n  includeMissingFromA: boolean\n\n  /**\n   * If _true_, emits a change under the path of a parent if its child has changed.\n   * If _false_ (default) only changed keys are emitted.\n   * \n   * Eg if data is: \n   * `{ colour: { h:0.5, s: 0.3, l: 0.5 }}`\n   * and we compare with:\n   * `{ colour: { h:1, s: 0.3, l: 0.5 }}`\n   * \n   * By default only 'colour.h' is emitted. If _true_ is set, 'colour' and 'colour.h' is emitted.\n   */\n  includeParents: boolean\n}\n\nconst getEntries = <V extends Record<string, any>>(target: V, deepProbe: boolean) => {\n  if (target === undefined) throw new Error(`Param 'target' is undefined`);\n  if (target === null) throw new Error(`Param 'target' is null`);\n  if (typeof target !== `object`) throw new Error(`Param 'target' is not an object (got: ${ typeof target })`);\n  if (deepProbe) {\n    const entries: [ key: string, value: any ][] = [];\n    for (const field in target) {\n      const value = (target as any)[ field ];\n      if (testPlainObjectOrPrimitive(value as unknown)) {\n        entries.push([ field, value ]);\n      }\n    }\n    return entries;\n  } else {\n    return Object.entries(target);\n  }\n}\n\n/**\n * Scans object, producing a list of changed fields where B's value (newer) differs from A (older).\n * \n * Options:\n * - `deepEntries` (_false_): If _false_ Object.entries are used to scan the object. However this won't work for some objects, eg event args, thus _true_ is needed.\n * - `eq` (JSON.stringify): By-value comparison function\n * - `includeMissingFromA` (_false): If _true_ includes fields present on B but missing on A.\n * - `asPartial` (_false): If _true_, treats B as a partial update to B. This means that things missing from B are not considered removals.\n * @param a 'Old' value\n * @param b 'New' value\n * @param options Options for comparison\n * @returns \n */\nexport function* compareData<V extends Record<string, any>>(a: V, b: Partial<V>, options: Partial<CompareDataOptions<V>> = {}): Generator<PathDataChange<any>> {\n  if (typeof a === `undefined`) {\n    yield {\n      path: options.pathPrefix ?? ``,\n      value: b,\n      state: `added`\n    };\n    return;\n  }\n  if (typeof b === `undefined`) {\n    yield { path: options.pathPrefix ?? ``, previous: a, value: undefined, state: `removed` }\n    return;\n  }\n  const asPartial = options.asPartial ?? false;\n  const undefinedValueMeansRemoved = options.undefinedValueMeansRemoved ?? false;\n  const pathPrefix = options.pathPrefix ?? ``;\n  const deepEntries = options.deepEntries ?? false;\n  const eq = options.eq ?? isEqualContextString;\n  const includeMissingFromA = options.includeMissingFromA ?? false;\n  const includeParents = options.includeParents ?? false;\n\n  //console.log(`Pathed.compareData: a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) } prefix: ${ pathPrefix }`);\n\n  if (isPrimitive(a) && isPrimitive(b)) {\n    if (a !== b) yield { path: pathPrefix, value: b, previous: a, state: `change` };\n    return;\n  }\n  if (isPrimitive(b)) {\n    yield { path: pathPrefix, value: b, previous: a, state: `change` };\n    return;\n  }\n  const entriesA = getEntries(a, deepEntries);\n  const entriesAKeys = new Set<string>();\n  for (const [ key, valueA ] of entriesA) {\n    entriesAKeys.add(key);\n\n    const keyOfAInB = key in b;\n    const valueOfKeyInB = b[ key ];\n    //console.log(`Pathed.compareData Pathed.compareDataA key: ${ key } valueA: ${ JSON.stringify(valueA) }`);\n\n    if (typeof valueA === `object` && valueA !== null) {\n      if (keyOfAInB) {\n        //console.log(`Pathed.compareData key ${ key } exists in B. value:`, valueB);\n        if (valueOfKeyInB === undefined) {\n          throw new Error(`Pathed.compareData Value for key ${ key } is undefined`);\n        } else {\n          const sub = [ ...compareData(valueA, valueOfKeyInB, {\n            ...options,\n            pathPrefix: pathPrefix + key + `.`\n          }) ];\n          if (sub.length > 0) {\n            for (const s of sub) yield s;\n            if (includeParents) {\n              yield { path: pathPrefix + key, value: b[ key ], previous: valueA, state: `change` };\n            }\n          }\n        }\n      } else {\n        if (asPartial) continue;\n        //throw new Error(`Key does not exist in B. Key: '${ key }'. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n        yield { path: pathPrefix + key, value: undefined, previous: valueA, state: `removed` }\n      }\n    } else {\n      const subPath = pathPrefix + key;\n      if (keyOfAInB) {\n        // B contains key from A\n        if (valueOfKeyInB === undefined && undefinedValueMeansRemoved) {\n          //console.error(`Pathed.compareData (2) value for B is undefined. key: ${ key }. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n          yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n        } else {\n          if (!eq(valueA, valueOfKeyInB, subPath)) {\n            //console.log(`Pathed.compareData  value changed. A: ${ valueA } B: ${ valueB } subPath: ${ subPath }`)\n            yield { path: subPath, previous: valueA, value: valueOfKeyInB, state: `change` };\n          }\n        }\n      } else {\n        // B does not contain key from A\n        if (asPartial) continue; // Ignore\n        yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n      }\n    }\n  }\n\n  if (includeMissingFromA) {\n    const entriesB = getEntries(b, deepEntries);\n    for (const [ key, valueB ] of entriesB) {\n      if (entriesAKeys.has(key)) continue;\n      // Key in B that's not in A\n      //console.log(`Pathed.compareDataB key: ${ key } value: ${ valueB }`);\n      yield { path: pathPrefix + key, previous: undefined, value: valueB, state: `added` };\n    }\n  }\n}\n\n/**\n * Returns a copy of `source` with `changes` applied.\n * @param source \n * @param changes \n */\nexport const applyChanges = <V extends Record<string, any>>(source: V, changes: PathDataChange<any>[]): V => {\n  for (const change of changes) {\n    source = updateByPath(source, change.path, change.value);\n  }\n  return source;\n}\n\n/**\n * Returns a copy of `target` object with a specified path changed to `value`.\n * \n * ```js\n * const a = {\n *  message: `Hello`,\n *  position: { x: 10, y: 20 }\n * }\n * \n * const a1 = updateByPath(a, `message`, `new message`);\n * // a1 = { message: `new message`, position: { x: 10, y: 20 }}\n * const a2 = updateByPath(a, `position.x`, 20);\n * // a2 = { message: `hello`, position: { x: 20, y: 20 }}\n * ```\n * \n * Paths can also be array indexes:\n * ```js\n * updateByPath([`a`,`b`,`c`], 2, `d`);\n * // Yields: [ `a`, `b`, `d` ]\n * ```\n * \n * By default, only existing array indexes can be updated. Use the `allowShapeChange` parameter \n * to allow setting arbitrary indexes.\n * ```js\n * // Throws because array index 3 is undefined\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`);\n * \n * // With allowShapeChange flag\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`, true);\n * // Returns: [ `a`, `b`, `c`, `d` ]\n * ```\n * \n * Throws an error if:\n * * `path` cannot be resolved (eg. `position.z` in the above example)\n * * `value` applied to `target` results in the object having a different shape (eg missing a field, field\n * changing type, or array index out of bounds). Use `allowShapeChange` to suppress this error.\n * * Path is undefined or not a string\n * * Target is undefined/null\n * @param target Object to update\n * @param path Path to set value\n * @param value Value to set\n * @param allowShapeChange By default _false_, throwing an error if an update change the shape of the original object.\n * @returns \n */\nexport const updateByPath = <V extends Record<string, any>>(target: V, path: string, value: any, allowShapeChange = false): V => {\n  if (path === undefined) throw new Error(`Parameter 'path' is undefined`);\n  if (typeof path !== `string`) throw new Error(`Parameter 'path' should be a string. Got: ${ typeof path }`);\n  if (target === undefined) throw new Error(`Parameter 'target' is undefined`);\n  if (target === null) throw new Error(`Parameter 'target' is null`);\n\n  const split = path.split(`.`);\n  const r = updateByPathImpl(target, split, value, allowShapeChange);\n  return r as V;\n}\n\nconst updateByPathImpl = (o: any, split: string[], value: any, allowShapeChange: boolean): any => {\n  if (split.length === 0) {\n    //console.log(`Pathed.updateByPathImpl o: ${ JSON.stringify(o) } value: ${ JSON.stringify(value) }`);\n\n    if (allowShapeChange) return value; // yolo\n\n    if (Array.isArray(o) && !Array.isArray(value)) throw new Error(`Expected array value, got: '${ JSON.stringify(value) }'. Set allowShapeChange=true to ignore.`);\n    if (!Array.isArray(o) && Array.isArray(value)) throw new Error(`Unexpected array value, got: '${ JSON.stringify(value) }'. Set allowShapeChange=true to ignore.`);\n\n    if (typeof o !== typeof value) throw new Error(`Cannot reassign object type. (${ typeof o } -> ${ typeof value }). Set allowShapeChange=true to ignore.`);\n\n    // Make sure new value has the same set of keys\n    if (typeof o === `object` && !Array.isArray(o)) {\n      const c = compareObjectKeys(o, value);\n      if (c.a.length > 0) {\n        throw new Error(`New value is missing key(s): ${ c.a.join(`,`) }`);\n      }\n      if (c.b.length > 0) {\n        throw new Error(`New value cannot add new key(s): ${ c.b.join(`,`) }`);\n      }\n    }\n    return value;\n  }\n  const start = split.shift();\n  if (!start) return value;\n\n  const isInt = isInteger(start);\n  if (isInt && Array.isArray(o)) {\n    const index = Number.parseInt(start);\n    if (index >= o.length && !allowShapeChange) throw new Error(`Array index ${ index.toString() } is outside of the existing length of ${ o.length.toString() }. Use allowShapeChange=true to permit this.`);\n    const copy = [ ...o ];\n    copy[ index ] = updateByPathImpl(copy[ index ], split, value, allowShapeChange);\n\n    return copy;\n  } else if (start in o) {\n    const copy = { ...o };\n    copy[ start ] = updateByPathImpl(copy[ start ], split, value, allowShapeChange);\n    return copy;\n  } else {\n    throw new Error(`Path ${ start } not found in data`);\n  }\n}\n\n/**\n * Gets the data at `path` in `object`. Assumes '.' separates each segment of path.\n * ```js\n * getField({ name: { first: `Thom`, last: `Yorke` }}, `name.first`); // 'Thom'\n * getField({ colours: [`red`, `green`, `blue` ]}, `colours.1`); // `green`\n * ```\n * \n * Returns _undefined_ if path could not be resolved.\n * \n * Throws if:\n * * `path` is not a string or empty\n * * `object` is _undefined_ or null\n * @param object \n * @param path \n * @returns \n */\nexport const getField = <V>(object: Record<string, any>, path: string): Result<V> => {\n  if (typeof path !== `string`) throw new Error(`Param 'path' ought to be a string. Got: '${ typeof path }'`);\n  if (path.length === 0) throw new Error(`Param string 'path' is empty`);\n  if (object === undefined) throw new Error(`Param 'object' is undefined`);\n  if (object === null) throw new Error(`Param 'object' is null`);\n\n  const split = path.split(`.`);\n  const v = getFieldImpl<V>(object, split);\n  return v;\n}\n\nconst getFieldImpl = <V>(object: Record<string, any>, split: string[]): Result<V> => {\n  if (object === undefined) throw new Error(`Param 'object' is undefined`);\n  if (split.length === 0) throw new Error(`Path has run out`);\n  const start = split.shift();\n  if (!start) throw new Error(`Unexpected empty split path`);\n\n  const isInt = isInteger(start);\n  if (isInt && Array.isArray(object)) { //(arrayStart === 0 && arrayEnd === start.length - 1 && Array.isArray(o)) {\n    const index = Number.parseInt(start); //start.slice(1, -1));\n    //console.log(`getFieldImpl index: ${ index } value: ${ object[ index ] }`);\n    if (typeof object[ index ] === `undefined`) {\n      return { success: false, error: `Index '${ index }' does not exist. Length: ${ object.length }` };\n    }\n\n    if (split.length === 0) {\n      return { value: object[ index ] as V, success: true };\n    } else {\n      return getFieldImpl(object[ index ], split);\n    }\n  } else if (typeof object === `object` && start in object) {\n    //console.log(`start in object. Start: ${ start } Len: ${ split.length } Object`, object);\n\n    if (split.length === 0) {\n      return { value: object[ start ] as V, success: true };\n    } else {\n      return getFieldImpl(object[ start ], split);\n    }\n  } else {\n    return { success: false, error: `Path '${ start }' not found` };\n  }\n}\n\n\n/**\n * Iterates 'paths' for all the fields on `o`\n * ```\n * const d = {\n *  accel: { x: 1, y: 2, z: 3 },\n *  gyro: { x: 4, y: 5, z: 6 }\n * };\n * const paths = [...getFieldPaths(d)];\n * // Yields [ `accel`, `gyro`, `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * Use {@link getField} to fetch data based on a path\n *\n * If object is _null_ or _undefined_, no results are returned.\n * \n * If `onlyLeaves` is _true_ (default: _false_), only 'leaf' nodes are included. \n * Leaf nodes are those that contain a primitive value.\n * ```js\n * const paths = getFieldPaths(d, true);\n * // Yields [ `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * @param object Object to get paths for.\n * @param onlyLeaves If true, only paths with a primitive value are returned.\n * @returns\n */\nexport function* getPaths(object: object | null, onlyLeaves = false): Generator<string> {\n  if (object === undefined || object === null) return;\n  const iter = recordEntriesDepthFirst(object);\n  for (const c of iter) {\n    if (c.nodeValue === undefined && onlyLeaves) continue;\n    let path = c.name;\n    if (c.ancestors.length > 0) path = c.ancestors.join(`.`) + `.` + path;\n    yield path;\n  }\n};\n\n/**\n * Returns a representation of the object as a set of paths and data.\n * ```js\n * const o = { name: `hello`, size: 20, colour: { r:200, g:100, b:40 } }\n * const pd = [...getPathsAndData(o)];\n * // Yields:\n * // [ \n * // { path: `name`, value: `hello` },\n * // { path: `size`, value: `20` },\n * // { path: `colour.r`, value: `200` },\n * // { path: `colour.g`, value: `100` },\n * // { path: `colour.b`, value: `40` }\n * //]\n * ```\n * @param o Object to get paths and data for\n * @param maxDepth Set maximum recursion depth. By default unlimited.\n * @param prefix Manually set a path prefix if it's necessary\n * @returns \n */\nexport function* getPathsAndData(o: object, onlyLeaves = false, maxDepth = Number.MAX_SAFE_INTEGER, prefix = ``): Generator<PathData<any>> {\n  if (o === null) return;\n  if (o === undefined) return;\n  yield* getPathsAndDataImpl(o, prefix, onlyLeaves, maxDepth);\n}\n\nfunction* getPathsAndDataImpl(o: object, prefix: string, onlyLeaves = false, maxDepth: number): Generator<PathData<any>> {\n  if (maxDepth <= 0) return;\n  if (typeof o !== `object`) return;\n  for (const entries of Object.entries(o)) {\n    const sub = (prefix.length > 0 ? prefix + `.` : ``) + entries[ 0 ];\n    const value = entries[ 1 ];\n    const leaf = (typeof value !== `object`);\n\n    if (onlyLeaves && leaf || !onlyLeaves) {\n      yield { path: sub, value };\n    }\n    yield* getPathsAndDataImpl(value, sub, onlyLeaves, maxDepth - 1);\n  }\n}","export * from './compare.js';\nexport * from './clone-from-fields.js';\nexport * from './map-object.js';\nexport * from './traverse.js';\nexport * from './merge.js';\nexport * from './keys-to-numbers.js';\nexport type * from '../types-compare.js';\nexport * from './pathed.js';\n\n/**\n * Maps the keys of an object, returning a transformed object.\n * ```js\n * const input = {\n *  hello: `there`,\n *  chap: `chappie`\n * }\n * \n * mapObjectKeys(input, key => key.toUppercase());\n * \n * // Yields: { HELLO: `there`, CHAP: `chappie` }\n * ```\n * @param object \n * @param mapFunction \n * @returns \n */\nexport const mapObjectKeys = <TKeySource extends string | number | symbol, TKeyDestination extends string | number | symbol>(object: Record<TKeySource, unknown>, mapFunction: (key: TKeySource) => TKeyDestination) => {\n  const destinationObject = {};\n  for (const entries of Object.entries(object)) {\n    const key = mapFunction(entries[ 0 ] as TKeySource);\n    (destinationObject as Record<TKeyDestination, unknown>)[ key ] = entries[ 1 ];\n  }\n  return destinationObject as Record<TKeyDestination, unknown>;\n}\n"],"mappings":"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"}