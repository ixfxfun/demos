{"version":3,"file":"pathed-4cNmhNti.js","names":[],"sources":["../../core/dist/src/pathed.js"],"sourcesContent":["import { recordEntriesDepthFirst } from \"@ixfx/core/records\";\nimport { isPrimitive, isInteger, isEqualContextString, defaultToString } from '@ixfx/core';\nimport { testPlainObjectOrPrimitive } from '@ixfx/guards';\nimport { compareObjectKeys } from './records/compare.js';\n/**\n * Get the entries for `target`.\n *\n * 'deep probe' uses alternative means to get entries of object, since `Object.entries`\n * can fail for some objects.\n * @param target Object to get entries from\n * @param deepProbe If true\n * @returns\n */\nconst getEntries = (target, deepProbe) => {\n    if (target === undefined)\n        throw new Error(`Param 'target' is undefined`);\n    if (target === null)\n        throw new Error(`Param 'target' is null`);\n    if (typeof target !== `object`)\n        throw new Error(`Param 'target' is not an object (got: ${typeof target})`);\n    if (deepProbe) {\n        const entries = [];\n        for (const field in target) {\n            const value = target[field];\n            if (testPlainObjectOrPrimitive(value)) {\n                entries.push([field, value]);\n            }\n        }\n        return entries;\n    }\n    else {\n        return Object.entries(target);\n    }\n};\n/**\n * Scans object, producing a list of changed fields where B's value (newer) differs from A (older).\n *\n * Options:\n * - `deepEntries` (_false_): If _false_ Object.entries are used to scan the object. However this won't work for some objects, eg event args, thus _true_ is needed.\n * - `eq` (JSON.stringify): By-value comparison function\n * - `includeMissingFromA` (_false): If _true_ includes fields present on B but missing on A.\n * - `asPartial` (_false): If _true_, treats B as a partial update to B. This means that things missing from B are not considered removals.\n * @param a 'Old' value\n * @param b 'New' value\n * @param options Options for comparison\n * @returns\n */\nexport function* compareData(a, b, options = {}) {\n    //console.log(`compareData a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) } opts: ${ options }`)\n    if (typeof a === `undefined`) {\n        yield {\n            path: options.pathPrefix ?? ``,\n            value: b,\n            state: `added`\n        };\n        return;\n    }\n    if (typeof b === `undefined`) {\n        yield { path: options.pathPrefix ?? ``, previous: a, value: undefined, state: `removed` };\n        return;\n    }\n    const asPartial = options.asPartial ?? false;\n    const skipInstances = options.skipInstances ?? new WeakSet();\n    const undefinedValueMeansRemoved = options.undefinedValueMeansRemoved ?? false;\n    const pathPrefix = options.pathPrefix ?? ``;\n    const deepEntries = options.deepEntries ?? false;\n    const eq = options.eq ?? isEqualContextString;\n    const includeMissingFromA = options.includeMissingFromA ?? false;\n    const includeParents = options.includeParents ?? false;\n    //console.log(`Pathed.compareData: a: ${ JSON.stringify(a) } b: ${ JSON.stringify(b) } prefix: ${ pathPrefix }`);\n    if (isPrimitive(a) && isPrimitive(b)) {\n        if (a !== b)\n            yield { path: pathPrefix, value: b, previous: a, state: `change` };\n        return;\n    }\n    if (isPrimitive(b)) {\n        yield { path: pathPrefix, value: b, previous: a, state: `change` };\n        return;\n    }\n    const entriesA = getEntries(a, deepEntries);\n    const entriesAKeys = new Set();\n    for (const [key, valueA] of entriesA) {\n        entriesAKeys.add(key);\n        const keyOfAInB = key in b;\n        const valueOfKeyInB = b[key];\n        //console.log(`Pathed.compareData Pathed.compareDataA key: ${ key } valueA: ${ defaultToString(valueA) }  valueAType: ${ typeof valueA } entriesCount: ${ entriesA.length }`);\n        if (typeof valueA === `object` && valueA !== null) {\n            if (skipInstances.has(valueA))\n                continue; // Already seen\n            skipInstances.add(valueA);\n            if (keyOfAInB) {\n                //console.log(`Pathed.compareData key ${ key } exists in B. value:`, valueOfKeyInB);\n                if (valueOfKeyInB === undefined) {\n                    throw new Error(`Pathed.compareData Value for key ${key} is undefined`);\n                }\n                else {\n                    const sub = [...compareData(valueA, valueOfKeyInB, {\n                            ...options,\n                            skipInstances,\n                            pathPrefix: pathPrefix + key + `.`\n                        })];\n                    if (sub.length > 0) {\n                        for (const s of sub)\n                            yield s;\n                        if (includeParents) {\n                            yield { path: pathPrefix + key, value: b[key], previous: valueA, state: `change` };\n                        }\n                    }\n                }\n            }\n            else {\n                if (asPartial)\n                    continue;\n                //throw new Error(`Key does not exist in B. Key: '${ key }'. B: ${ JSON.stringify(b) } A: ${ JSON.stringify(a) }`);\n                yield { path: pathPrefix + key, value: undefined, previous: valueA, state: `removed` };\n            }\n        }\n        else {\n            const subPath = pathPrefix + key;\n            if (keyOfAInB) {\n                // B contains key from A\n                if (valueOfKeyInB === undefined && undefinedValueMeansRemoved) {\n                    //console.error(`Pathed.compareData (2) value for B is undefined. key: ${ key }. B: ${ defaultToString(b) } A: ${ defaultToString(a) }`);\n                    yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n                }\n                else {\n                    if (!eq(valueA, valueOfKeyInB, subPath)) {\n                        //console.log(`Pathed.compareData  value changed. A: ${ valueA } B: ${ valueOfKeyInB } subPath: ${ subPath }`)\n                        yield { path: subPath, previous: valueA, value: valueOfKeyInB, state: `change` };\n                    }\n                }\n            }\n            else {\n                // B does not contain key from A\n                if (asPartial)\n                    continue; // Ignore\n                yield { path: subPath, previous: valueA, value: undefined, state: `removed` };\n            }\n        }\n    }\n    if (includeMissingFromA) {\n        const entriesB = getEntries(b, deepEntries);\n        for (const [key, valueB] of entriesB) {\n            if (entriesAKeys.has(key))\n                continue;\n            // Key in B that's not in A\n            //console.log(`Pathed.compareDataB key: ${ key } value: ${ valueB }`);\n            yield { path: pathPrefix + key, previous: undefined, value: valueB, state: `added` };\n        }\n    }\n}\n/**\n * Returns a copy of `source` with `changes` applied.\n * @param source\n * @param changes\n */\nexport const applyChanges = (source, changes) => {\n    for (const change of changes) {\n        source = updateByPath(source, change.path, change.value);\n    }\n    return source;\n};\n/**\n * Returns a copy of `target` object with a specified path changed to `value`.\n *\n * ```js\n * const a = {\n *  message: `Hello`,\n *  position: { x: 10, y: 20 }\n * }\n *\n * const a1 = updateByPath(a, `message`, `new message`);\n * // a1 = { message: `new message`, position: { x: 10, y: 20 }}\n * const a2 = updateByPath(a, `position.x`, 20);\n * // a2 = { message: `hello`, position: { x: 20, y: 20 }}\n * ```\n *\n * Paths can also be array indexes:\n * ```js\n * updateByPath([`a`,`b`,`c`], 2, `d`);\n * // Yields: [ `a`, `b`, `d` ]\n * ```\n *\n * By default, only existing array indexes can be updated. Use the `allowShapeChange` parameter\n * to allow setting arbitrary indexes.\n * ```js\n * // Throws because array index 3 is undefined\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`);\n *\n * // With allowShapeChange flag\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`, true);\n * // Returns: [ `a`, `b`, `c`, `d` ]\n * ```\n *\n * Throws an error if:\n * * `path` cannot be resolved (eg. `position.z` in the above example)\n * * `value` applied to `target` results in the object having a different shape (eg missing a field, field\n * changing type, or array index out of bounds). Use `allowShapeChange` to suppress this error.\n * * Path is undefined or not a string\n * * Target is undefined/null\n * @param target Object to update\n * @param path Path to set value\n * @param value Value to set\n * @param allowShapeChange By default _false_, throwing an error if an update change the shape of the original object.\n * @returns\n */\nexport const updateByPath = (target, path, value, allowShapeChange = false) => {\n    if (path === undefined)\n        throw new Error(`Parameter 'path' is undefined`);\n    if (typeof path !== `string`)\n        throw new Error(`Parameter 'path' should be a string. Got: ${typeof path}`);\n    if (target === undefined)\n        throw new Error(`Parameter 'target' is undefined`);\n    if (target === null)\n        throw new Error(`Parameter 'target' is null`);\n    const split = path.split(`.`);\n    const r = updateByPathImpl(target, split, value, allowShapeChange);\n    return r;\n};\nconst updateByPathImpl = (o, split, value, allowShapeChange) => {\n    if (split.length === 0) {\n        //console.log(`Pathed.updateByPathImpl o: ${ JSON.stringify(o) } value: ${ JSON.stringify(value) }`);\n        if (allowShapeChange)\n            return value; // yolo\n        if (Array.isArray(o) && !Array.isArray(value))\n            throw new Error(`Expected array value, got: '${JSON.stringify(value)}'. Set allowShapeChange=true to ignore.`);\n        if (!Array.isArray(o) && Array.isArray(value))\n            throw new Error(`Unexpected array value, got: '${JSON.stringify(value)}'. Set allowShapeChange=true to ignore.`);\n        if (typeof o !== typeof value)\n            throw new Error(`Cannot reassign object type. (${typeof o} -> ${typeof value}). Set allowShapeChange=true to ignore.`);\n        // Make sure new value has the same set of keys\n        if (typeof o === `object` && !Array.isArray(o)) {\n            const c = compareObjectKeys(o, value);\n            if (c.a.length > 0) {\n                throw new Error(`New value is missing key(s): ${c.a.join(`,`)}`);\n            }\n            if (c.b.length > 0) {\n                throw new Error(`New value cannot add new key(s): ${c.b.join(`,`)}`);\n            }\n        }\n        return value;\n    }\n    const start = split.shift();\n    if (!start)\n        return value;\n    const isInt = isInteger(start);\n    if (isInt && Array.isArray(o)) {\n        const index = Number.parseInt(start);\n        if (index >= o.length && !allowShapeChange)\n            throw new Error(`Array index ${index.toString()} is outside of the existing length of ${o.length.toString()}. Use allowShapeChange=true to permit this.`);\n        const copy = [...o];\n        copy[index] = updateByPathImpl(copy[index], split, value, allowShapeChange);\n        return copy;\n    }\n    else if (start in o) {\n        const copy = { ...o };\n        copy[start] = updateByPathImpl(copy[start], split, value, allowShapeChange);\n        return copy;\n    }\n    else {\n        throw new Error(`Path ${start} not found in data`);\n    }\n};\n/**\n * Gets the data at `path` in `object`. Assumes '.' separates each segment of path.\n *\n * ```js\n * getField({ name: { first: `Thom`, last: `Yorke` }}, `name.first`); // { value: `Thom`  success: true }\n * getField({ colours: [`red`, `green`, `blue` ]}, `colours.1`);      // { value: `green` success: true }\n * ```\n *\n * Returns an error result with more details, eg `{ success: false, error: 'Path could not be found' }`\n *\n * Throws if:\n * * `path` is not a string or empty\n * * `object` is _undefined_ or null\n * @param object Object to query\n * @param path Path\n * @param separator Separator of chunks of path. Defaults to '.'\n * @returns\n */\nexport const getField = (object, path, separator = `.`) => {\n    if (typeof path !== `string`)\n        throw new Error(`Param 'path' ought to be a string. Got: '${typeof path}'`);\n    if (path.length === 0)\n        throw new Error(`Param string 'path' is empty`);\n    if (object === undefined)\n        throw new Error(`Param 'object' is undefined`);\n    if (object === null)\n        throw new Error(`Param 'object' is null`);\n    const split = path.split(separator);\n    const v = getFieldImpl(object, split, path);\n    return v;\n};\nconst getFieldImpl = (object, split, position) => {\n    if (object === undefined)\n        return { success: false, error: `Param 'object' is undefined. Position: ${position}` };\n    if (split.length === 0)\n        return { success: false, error: `Path has been exhausted. position: ${position}` };\n    const start = split.shift();\n    if (!start)\n        return { success: false, error: `Unexpected empty split path. Position: ${position}` };\n    const isInt = isInteger(start);\n    if (isInt && Array.isArray(object)) { //(arrayStart === 0 && arrayEnd === start.length - 1 && Array.isArray(o)) {\n        const index = Number.parseInt(start); //start.slice(1, -1));\n        //console.log(`getFieldImpl index: ${ index } value: ${ object[ index ] }`);\n        if (typeof object[index] === `undefined`) {\n            return { success: false, error: `Index '${index}' does not exist. Length: ${object.length}. Position: ${position}` };\n        }\n        if (split.length === 0) {\n            return { value: object[index], success: true };\n        }\n        else {\n            return getFieldImpl(object[index], split, split.join(`.`));\n        }\n    }\n    else if (typeof object === `object` && start in object) {\n        //console.log(`start in object. Start: ${ start } Len: ${ split.length } Object`, object);\n        if (split.length === 0) {\n            return { value: object[start], success: true };\n        }\n        else {\n            return getFieldImpl(object[start], split, split.join(`.`));\n        }\n    }\n    else {\n        return { success: false, error: `Path '${start}' not found. Position: ${position}` };\n    }\n};\n/**\n * Iterates 'paths' for all the fields on `o`\n * ```\n * const d = {\n *  accel: { x: 1, y: 2, z: 3 },\n *  gyro: { x: 4, y: 5, z: 6 }\n * };\n * const paths = [...getFieldPaths(d)];\n * // Yields [ `accel`, `gyro`, `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * Use {@link getField} to fetch data based on a path\n *\n * If object is _null_ or _undefined_, no results are returned.\n *\n * If `onlyLeaves` is _true_ (default: _false_), only 'leaf' nodes are included.\n * Leaf nodes are those that contain a primitive value.\n * ```js\n * const paths = getFieldPaths(d, true);\n * // Yields [ `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * @param object Object to get paths for.\n * @param onlyLeaves If true, only paths with a primitive value are returned.\n * @returns\n */\nexport function* getPaths(object, onlyLeaves = false) {\n    if (object === undefined || object === null)\n        return;\n    const iter = recordEntriesDepthFirst(object);\n    for (const c of iter) {\n        if (c.nodeValue === undefined && onlyLeaves)\n            continue;\n        let path = c.name;\n        if (c.ancestors.length > 0)\n            path = c.ancestors.join(`.`) + `.` + path;\n        yield path;\n    }\n}\n;\n/**\n * Returns a representation of the object as a set of paths and data.\n * ```js\n * const o = { name: `hello`, size: 20, colour: { r:200, g:100, b:40 } }\n * const pd = [...getPathsAndData(o)];\n * // Yields:\n * // [\n * // { path: `name`, value: `hello` },\n * // { path: `size`, value: `20` },\n * // { path: `colour.r`, value: `200` },\n * // { path: `colour.g`, value: `100` },\n * // { path: `colour.b`, value: `40` }\n * //]\n * ```\n * @param o Object to get paths and data for\n * @param maxDepth Set maximum recursion depth. By default unlimited.\n * @param prefix Manually set a path prefix if it's necessary\n * @returns\n */\nexport function* getPathsAndData(o, onlyLeaves = false, maxDepth = Number.MAX_SAFE_INTEGER, prefix = ``) {\n    if (o === null)\n        return;\n    if (o === undefined)\n        return;\n    yield* getPathsAndDataImpl(o, prefix, onlyLeaves, maxDepth);\n}\nfunction* getPathsAndDataImpl(o, prefix, onlyLeaves = false, maxDepth) {\n    if (maxDepth <= 0)\n        return;\n    if (typeof o !== `object`)\n        return;\n    for (const entries of Object.entries(o)) {\n        const sub = (prefix.length > 0 ? prefix + `.` : ``) + entries[0];\n        const value = entries[1];\n        const leaf = (typeof value !== `object`);\n        if (onlyLeaves && leaf || !onlyLeaves) {\n            yield { path: sub, value };\n        }\n        yield* getPathsAndDataImpl(value, sub, onlyLeaves, maxDepth - 1);\n    }\n}\n"],"mappings":"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"}