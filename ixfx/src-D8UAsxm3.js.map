{"version":3,"file":"src-D8UAsxm3.js","names":["v: any","last","it: Iterable<V>","returnValue: V | undefined","f: (v: V) => X","max","a: V","b: V","max: V | undefined","min","min: V | undefined","last","it: AsyncIterable<V>","opts: Partial<{ abort: AbortSignal }>","returnValue: V | undefined","max","a: V","b: V","max: V | undefined","min","min: V | undefined","it: AsyncIterableIterator<V> | IterableIterator<V>","options: SleepOpts<any>","value: IteratorResult<V> | undefined","it: AsyncIterable<V> | Iterable<V>","a: V","b: V"],"sources":["../../packages/iterables/src/guard.ts","../../packages/iterables/src/sync.ts","../../packages/iterables/src/async.ts","../../packages/iterables/src/index.ts"],"sourcesContent":["\n\nexport const isAsyncIterable = (v: any): v is AsyncIterable<any> => {\n  if (typeof v !== `object`) return false;\n  if (v === null) return false;\n  return Symbol.asyncIterator in v;\n\n}\n\nexport const isIterable = (v: any): v is Iterable<any> => {\n  if (typeof v !== `object`) return false;\n  if (v === null) return false;\n  return Symbol.iterator in v;\n\n}\n\n","import { type ToString, toStringDefault } from '@ixfx/core';\nimport { type IsEqual, intervalToMs } from '@ixfx/core';\nimport { isIterable } from './guard.js';\n//import { intervalToMs } from '../flow/IntervalType.js';\nimport type { ToArrayOptions } from './types.js';\nexport { slice } from './sync/slice.js';\nexport { reduce } from './sync/reduce.js';\n\nexport function* uniqueByValue<T>(input: Iterable<T>, toString: ToString<T> = toStringDefault, seen: Set<string> = new Set<string>()): Generator<T> {\n  for (const v of input) {\n    const key = toString(v);\n    if (seen.has(key)) continue;\n    seen.add(key);\n    yield v;\n  }\n}\n\n/**\n * Calls `callback` whenever the generator produces a value.\n * \n * When using `asCallback`, call it with `await` to let generator \n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n * \n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input \n * @param callback \n */\nexport function asCallback<V>(input: Iterable<V>, callback: (v: V) => unknown, onDone?: () => void) {\n  for (const value of input) {\n    callback(value);\n  }\n  if (onDone) onDone();\n}\n\n/**\n * Returns a function that yields a value from a generator.\n * ```js\n * const spring = yieldNumber(Oscillators.spring());\n *\n * spring(); // latest value\n * ```\n *\n * Instead of:\n * ```js\n * const spring = Oscillators.spring();\n *\n * spring.next().value\n * ```\n *\n * A `defaultValue` can be provided if the source generator returns undefined:\n * ```js\n * const spring = yieldNumber(Oscillators.spring(), 0);\n * spring(); // Returns 0 if the generator returns undefined\n * ```\n * @param generator\n * @param defaultValue\n * @returns\n */\nexport function yieldNumber(\n  generator: Generator<number>,\n  defaultValue?: number\n) {\n\n  return (): number | undefined => {\n    const v: number | undefined = generator.next().value as number | undefined;\n    if (v === undefined) return defaultValue;\n    return v;\n  };\n}\n\n/**\n * Return first value from an iterable, or _undefined_ if\n * no values are generated\n * @param it\n * @returns\n */\nexport function first<V>(it: Iterable<V>): V | undefined {\n  for (const value of it) {\n    return value;\n  }\n}\n\n/**\n * Returns last value from an iterable, or _undefined_\n * if no values are generated\n * @param it\n */\nexport function last<V>(it: Iterable<V>): V | undefined {\n  let returnValue: V | undefined;\n  for (const value of it) {\n    returnValue = value;\n  }\n  return returnValue;\n}\n\n/**\n * Yields chunks of the iterable `it` such that the end of a chunk is the\n * start of the next chunk.\n *\n * Eg, with the input [1,2,3,4,5] and a size of 2, we would get back\n * [1,2], [2,3], [3,4], [4,5].\n *\n *\n * @param it\n * @param size\n * @returns\n */\nexport function* chunksOverlapping<V>(it: Iterable<V>, size: number) {\n  if (size <= 1) throw new Error(`Size should be at least 2`);\n\n  //eslint-disable-next-line functional/no-let\n  let buffer: V[] = [];\n\n  for (const v of it) {\n    //eslint-disable-next-line functional/immutable-data\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      //eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      buffer = [ buffer.at(-1)! ];\n    }\n  }\n  if (buffer.length <= 1) return;\n\n  if (buffer.length > 0) yield buffer;\n}\n\n\nexport function* chunks<V>(it: Iterable<V>, size: number) {\n  //eslint-disable-next-line functional/no-let\n  let buffer: V[] = [];\n\n  for (const v of it) {\n    //eslint-disable-next-line functional/immutable-data\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      buffer = [];\n    }\n  }\n  if (buffer.length > 0) yield buffer;\n}\n\nexport function* concat<V>(...its: readonly Iterable<V>[]) {\n  for (const it of its) yield* it;\n}\n\nexport function* dropWhile<V>(\n  it: Iterable<V>,\n  f: (v: V) => boolean\n) {\n  for (const v of it) {\n    if (!f(v)) {\n      yield v;\n    }\n  }\n}\n\n/**\n* Loops over a generator until it finishes, calling `callback`.\n* Useful if you don't care about the value generator produces, just the number of loops.\n* \n* ```js\n* until(count(5), () => {\n* // do something 5 times\n* });\n* ```\n* \n* If you want the value from the generator, use a `for of` loop as usual.\n* If `callback` explicitly returns _false_, the generator is aborted.\n* @param it Generator to run\n* @param callback Code to call for each iteration\n*/\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = (it: Iterable<any>, callback: () => (void | boolean | never)) => {\n  for (const _ of it) {\n    const value = callback();\n    if (typeof value === `boolean` && !value) break;\n  }\n}\n\nexport const next = <T>(it: Generator<T>) => {\n  return () => {\n    const r = it.next();\n    if (r.done) return;\n    return r.value;\n  }\n}\n\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport function equals<V>(\n  it1: IterableIterator<V>,\n  it2: IterableIterator<V>,\n  equality?: IsEqual<V>\n) {\n  //it1 = it1[Symbol.iterator]();\n  //it2 = it2[Symbol.iterator]();\n\n  while (true) {\n    const index1 = it1.next(),\n      index2 = it2.next();\n    if (equality !== undefined) {\n      if (!equality(index1.value, index2.value)) return false;\n    } else if (index1.value !== index2.value) return false;\n    if (index1.done ?? index2.done) return index1.done && index2.done;\n  }\n}\n\nexport function every<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  for (const v of it) {\n    const result = f(v);\n    if (!result) return false;\n  }\n  return true;\n}\n\n\nexport function* fill<V>(it: Iterable<V>, v: V) {\n  // https://surma.github.io/underdash/\n\n\n  for (const _ of it) yield v;\n}\n\n/**\n * Iterates over `iterator` (iterable/array), calling `fn` for each value.\n * If `fn` returns _false_, iterator cancels.\n *\n * Over the default JS `forEach` function, this one allows you to exit the\n * iteration early.\n *\n * @example\n * ```js\n * import { Sync } from \"https://unpkg.com/ixfx/dist/iterables.js\"\n * Sync.forEach(count(5), () => console.log(`Hi`));  // Prints `Hi` 5x\n * Sync.forEach(count(5), i => console.log(i));      // Prints 0 1 2 3 4\n * Sync.forEach([0,1,2,3,4], i => console.log(i));   // Prints 0 1 2 3 4\n * ```\n *\n * Use {@link forEach} if you want to use an async `iterator` and async `fn`.\n * \n * Alternatives:\n * * {@link Flow.repeat}/{@link Flow.repeatSync}: if you want to call something a given number of times and get the result\n * @param iterator Iterable or array\n * @typeParam T Type of iterable's values\n * @param fn Function to call for each item. If function returns _false_, iteration cancels\n */\nexport function forEach<T>(iterator: Iterable<T> | T[], fn: (v: T) => boolean | void) {\n  for (const v of iterator) {\n    const result = fn(v);\n    if (typeof result === `boolean` && !result) break;\n  }\n}\n\n/**\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport function* filter<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    if (!f(v)) continue;\n    yield v;\n  }\n}\n\nexport function find<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    if (f(v)) return v;\n  }\n}\n\nexport function* flatten<V>(it: Iterable<V>) {\n  // https://surma.github.io/underdash/\n  for (const v of it) {\n    if (typeof v === `object`) {\n      if (Array.isArray(v)) {\n        for (const vv of v) yield vv;\n      } else if (isIterable(v)) {\n        for (const vv of v) {\n          yield vv;\n        }\n      }\n    } else {\n      yield v;\n    }\n\n  }\n}\n\n\n/**\n * Maps an iterable of type `V` to type `X`.\n * ```js\n * map([1, 2, 3], e => e*e)\n * returns [1, 4, 9]\n * ```\n * @param it\n * @param f\n */\n\nexport function* map<V, X>(it: Iterable<V>, f: (v: V) => X) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    yield f(v);\n  }\n}\n\nexport function* max<V>(it: Iterable<V>, gt = (a: V, b: V) => a > b): Generator<V> {\n  let max: V | undefined;\n  for (const v of it) {\n    if (max === undefined) {\n      max = v;\n      yield max;\n      continue;\n    }\n    if (gt(v, max)) {\n      max = v;\n      yield max;\n    }\n  }\n  return max;\n}\n\nexport function* min<V>(it: Iterable<V>, gt = (a: V, b: V) => a > b) {\n  let min: V | undefined;\n  for (const v of it) {\n    if (min === undefined) {\n      min = v;\n      yield min;\n    }\n    if (gt(min, v)) {\n      min = v;\n      yield min;\n    }\n  }\n}\n\n\n\nexport function some<V>(it: Iterable<V>, f: (v: V) => boolean) {\n  // https://surma.github.io/underdash/\n\n  for (const v of it) {\n    if (f(v)) return true;\n  }\n  return false;\n}\n\n// export function* takeWhile<V>(it: Iterable<V>, f: (v: V) => boolean) {\n//   // https://surma.github.io/underdash/\n//   for (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\n\nexport function* repeat<T>(genCreator: () => Iterable<T>, repeatsOrSignal: number | AbortSignal): Generator<T> {\n  const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n  const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n  let count = repeats;\n\n  while (true) {\n    for (const v of genCreator()) {\n      yield v;\n      if (signal?.aborted) break;\n    }\n    if (Number.isFinite(repeats)) {\n      count--;\n      if (count === 0) break;\n    }\n    if (signal?.aborted) break;\n  }\n}\n\n\nexport function* unique<V>(\n  iterable: Iterable<V> | Iterable<V>[]\n) {\n  // Adapted from https://surma.github.io/underdash/\n  const buffer: any[] = [];\n  let itera: Iterable<V>[] = [];\n  itera = Array.isArray(iterable) ? iterable : [ iterable ];\n  for (const it of itera) {\n    for (const v of it) {\n      if (buffer.includes(v)) continue;\n      buffer.push(v);\n      yield v;\n    }\n  }\n}\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\n\nexport function* zip<V>(...its: readonly Iterable<V>[]) {\n  // https://surma.github.io/underdash/\n  const iits = its.map((it) => it[ Symbol.iterator ]());\n\n  while (true) {\n    const vs = iits.map((it) => it.next());\n    if (vs.some((v) => v.done)) return;\n    yield vs.map((v) => v.value as V);\n  }\n}\n\nexport function* fromIterable<T>(iterable: Iterable<T>) {\n  for (const v of iterable) {\n    yield v;\n  }\n}\n\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a limit via the options or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param options Options when converting to array.\n * @returns\n */\n\nexport function toArray<V>(\n  it: Iterable<V>,\n  options: Partial<ToArrayOptions> = {}\n): V[] {\n  const result: V[] = [];\n  const started = Date.now();\n  const whileFunction = options.while;\n  const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n  const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n  for (const v of it) {\n    if (whileFunction) {\n      if (!whileFunction(result.length)) break;\n    }\n    if (result.length >= maxItems) break;\n    if (Date.now() - started > maxElapsed) break;\n    result.push(v);\n  }\n  return result;\n}\n\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param array Array of values\n */\nexport function* fromArray<V>(array: V[]): Generator<V> {\n  for (const v of array) {\n    yield v;\n  }\n}","import { intervalToMs, type Interval, type IsEqual, toStringDefault } from '@ixfx/core';\nimport { sleep, type SleepOpts } from '@ixfx/core';\nimport type { ForEachOptions, ToArrayOptions } from './types.js';\nimport { isAsyncIterable, isIterable } from './guard.js';\n\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * \n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport async function* fromArray<V>(array: V[], interval: Interval = 1): AsyncGenerator<V> {\n  for (const v of array) {\n    yield v;\n    await sleep(interval);\n  }\n}\n\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport async function* fromIterable<V>(iterable: Iterable<V> | AsyncIterable<V>, interval: Interval = 1): AsyncGenerator<V> {\n  for await (const v of iterable) {\n    yield v;\n    await sleep(interval);\n  }\n}\n\nexport async function* chunks<V>(it: AsyncIterable<V>, size: number) {\n  // Source: https://surma.github.io/underdash/\n  let buffer: V[] = [];\n  for await (const v of it) {\n    buffer.push(v);\n    if (buffer.length === size) {\n      yield buffer;\n      buffer = [];\n    }\n  }\n  if (buffer.length > 0) yield buffer;\n}\n\n\nexport async function* concat<V>(...its: readonly AsyncIterable<V>[]) {\n  // Source: https://surma.github.io/underdash/\n  for await (const it of its) yield* it;\n}\n\nexport async function* dropWhile<V>(\n  it: AsyncIterable<V>,\n  f: (v: V) => boolean\n) {\n  for await (const v of it) {\n    if (!f(v)) {\n      yield v;\n    }\n  }\n}\n\n/**\n * Loops over a generator until it finishes, calling `callback`.\n * Useful if you don't care about the value generator produces, just the number of loops.\n * \n * In this version, we do a `for await of` over `gen`, and also `await callback()`. \n\n * ```js\n * await until(count(5), () => {\n * // do something 5 times\n * });\n * ```\n * \n * If you want the value from the generator, use a `for of` loop as usual.\n * \n * If `callback` explicitly returns _false_, the generator is aborted.\n * @param it Generator to run\n * @param callback Code to call for each iteration\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport const until = async (it: AsyncIterable<any> | Iterable<any>, callback: () => (void | Promise<boolean> | undefined | boolean | Promise<undefined> | Promise<void>)): Promise<undefined> => {\n  for await (const _ of it) {\n    const value = await callback();\n    if (typeof value === `boolean` && !value) break;\n  }\n}\n\n/**\n * This generator will repeat another generator up until some condition. This is the version\n * that can handle async generators.\n * \n * For example, {@link count} will count from 0..number and then finish:\n * ```js\n * for (const v of count(5)) {\n *  // v: 0, 1, 2, 3, 4\n * }\n * ```\n * \n * But what if we want to repeat the count? We have to provide a function to create the generator,\n * rather than using the generator directly, since it's \"one time use\"\n * ```js\n * for await (const v of repeat(() => count(5))) {\n *  // v: 0, 1, 2, 3, 4, 0, 1, 2, 3, 4, 0, ...\n *  // warning: never ends\n * }\n * ```\n * \n * Limiting the number of repeats can be done by passing in extra parameters\n * ```js\n * repeat(generator, { count: 5} ); // Iterate over `generator` five times\n * ```\n * \n * ```js\n * const ac = new AbortController();\n * repeat(generator, { signal: ac.signal }); // Pass in signal\n * ...\n * ac.abort(); // Trigger signal at some point\n * ```\n * @param genCreator \n * @param repeatsOrSignal \n */\nexport const repeat = async function*<T>(genCreator: () => Iterable<T> | AsyncIterable<T>, repeatsOrSignal: number | AbortSignal): AsyncGenerator<T> {\n  const repeats = typeof repeatsOrSignal === `number` ? repeatsOrSignal : Number.POSITIVE_INFINITY;\n  const signal = typeof repeatsOrSignal === `number` ? undefined : repeatsOrSignal;\n  let count = repeats;\n\n  while (true) {\n    for await (const v of genCreator()) {\n      yield v;\n      if (signal?.aborted) break;\n    }\n    if (Number.isFinite(repeats)) {\n      count--;\n      if (count === 0) break;\n    }\n    if (signal?.aborted) break;\n  }\n}\n\n/**\n * Returns true if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport async function equals<V>(\n  it1: AsyncIterable<V>,\n  it2: AsyncIterable<V>,\n  equality?: IsEqual<V>\n) {\n  // https://surma.github.io/underdash/\n  const iit1 = it1[ Symbol.asyncIterator ]();// it1[ Symbol.iterator ]();\n  const iit2 = it2[ Symbol.asyncIterator ]();\n  while (true) {\n    const index1 = await iit1.next();\n    const index2 = await iit2.next();\n    if (equality !== undefined) {\n      if (!equality(index1.value, index2.value)) return false;\n    } else if (index1.value !== index2.value) return false;\n    if (index1.done ?? index2.done) return index1.done && index2.done;\n  }\n}\n\nexport async function every<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  for await (const v of it) {\n    const result = await f(v);\n    if (!result) return false;\n  }\n  return true;\n}\n\nexport async function* fill<V>(it: AsyncIterable<V>, v: V) {\n  // https://surma.github.io/underdash/\n  for await (const _ of it) yield v;\n}\n\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * @param it\n * @param f\n */\nexport async function* filter<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (!await f(v)) continue;\n    yield v;\n  }\n}\n\n\nexport async function find<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (await f(v)) return v;\n  }\n}\n\n\nexport async function* flatten<V>(it: AsyncIterable<V>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (typeof v === `object`) {\n      if (Array.isArray(v)) {\n        for (const vv of v) yield vv;\n      } else if (isAsyncIterable(v)) {\n        for await (const vv of v) {\n          yield vv;\n        }\n      } else if (isIterable(v)) {\n        for (const vv of v) {\n          yield vv;\n        }\n      }\n    } else {\n      yield v;\n    }\n\n  }\n}\n\n/**\n * Iterates over an async iterable or array, calling `fn` for each value, with optional\n * interval between each loop. If the async `fn` returns _false_, iterator cancels.\n *\n * ```\n * import { forEach } from \"https://unpkg.com/ixfx/dist/flow.js\"\n * // Prints items from array every second\n * await forEach([0,1,2,3], i => console.log(i), 1000);\n * ```\n *\n * ```\n * // Retry up to five times, with 5 seconds between each attempt\n * await forEach(count(5), i=> {\n *  try {\n *    await doSomething();\n *    return false; // Succeeded, exit early\n *  } catch (ex) {\n *    console.log(ex);\n *    return true; // Keep trying\n *  }\n * }, 5000);\n * ```\n * @param iterator Iterable thing to loop over\n * @param fn Function to invoke on each item. If it returns _false_ loop ends.\n * @param options Options\n * @typeParam V Type of iterable\n */\nexport const forEach = async function <T>(\n  iterator: AsyncIterable<T> | T[],\n  fn: (v?: T) => Promise<boolean> | Promise<void> | boolean | void,\n  options: Partial<ForEachOptions> = {}\n) {\n  const interval = options.interval;\n  if (Array.isArray(iterator)) {\n    // Handle array\n    for (const x of iterator) {\n      const r = await fn(x);\n      if (typeof r === `boolean` && !r) break;\n      if (interval) await sleep(interval);\n    }\n  } else {\n    // Handle an async iterator\n    for await (const x of iterator) {\n      const r = await fn(x);\n      if (typeof r === `boolean` && !r) break;\n      if (interval) await sleep(interval);\n    }\n  }\n};\n\n// export async function forEach<V>(it: AsyncIterable<V>, f: (v: V) => void | boolean | Promise<boolean | void>) {\n//   // https://surma.github.io/underdash/\n//   for await (const v of it) {\n//     const result = await f(v);\n//     if (typeof result === `boolean` && !result) break;\n//   }\n// }\n\n/**\n * Returns last value from an iterable, or _undefined_\n * if no values are generated\n * @param it\n */\nexport async function last<V>(it: AsyncIterable<V>, opts: Partial<{ abort: AbortSignal }> = {}): Promise<V | undefined> {\n  const abort = opts.abort;\n  let returnValue: V | undefined;\n\n  for await (const value of it) {\n    if (abort?.aborted) return undefined;\n    returnValue = value;\n  }\n  return returnValue;\n}\n\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n * \n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\n\nexport async function* map<V, X>(it: AsyncIterable<V>, f: (v: V) => X) {\n  // https://surma.github.io/underdash/\n\n  for await (const v of it) {\n    yield f(v);\n  }\n}\n\n\nexport async function* max<V>(it: AsyncIterable<V>, gt = ((a: V, b: V) => a > b)) {\n  let max: V | undefined;\n  for await (const v of it) {\n    if (max === undefined) {\n      max = v;\n      yield (max);\n      continue;\n    }\n    // If V is bigger than max, we have a new max\n    if (gt(v, max)) {\n      max = v;\n      yield v;\n    }\n  }\n}\n\n/**\n * Returns the minimum seen of an iterable as it changes.\n * Streaming result: works with endless iterables.\n * \n * Note that `gt` function returns true if A is _greater_ than B, even\n * though we're looking for the minimum.\n * \n * ```js\n * // Rank objects based on 'v' value\n * const rank = (a,b) => a.v > b.v;\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns\n */\nexport async function* min<V>(it: AsyncIterable<V>, gt = (a: V, b: V) => a > b) {\n  let min: V | undefined;\n  for await (const v of it) {\n    if (min === undefined) {\n      min = v;\n      yield min;\n      continue;\n    }\n    // If min is bigger than V, V is the new min\n    if (gt(min, v)) {\n      min = v;\n      yield v;\n    }\n  }\n  return min;\n}\n\nexport async function reduce<V>(\n  it: AsyncIterable<V>,\n  f: (accumulator: V, current: V) => V,\n  start: V\n) {\n  // https://surma.github.io/underdash/\n\n  for await (const v of it) start = f(start, v);\n  return start;\n}\n\n/**\n * Calls `callback` whenever the async generator produces a value.\n * \n * When using `asCallback`, call it with `await` to let generator \n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n * \n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input \n * @param callback \n */\nexport async function asCallback<V>(input: AsyncIterable<V>, callback: (v: V) => unknown, onDone?: () => void) {\n  for await (const value of input) {\n    callback(value);\n  }\n  if (onDone) onDone();\n}\n\nexport async function* slice<V>(\n  it: AsyncIterable<V>,\n  start = 0,\n  end = Number.POSITIVE_INFINITY\n) {\n  console.log(`Async slice start: ${ start }`);\n\n  // https://surma.github.io/underdash/\n  const iit = it[ Symbol.asyncIterator ]();\n  if (end < start) throw new Error(`Param 'end' should be more than 'start'`);\n\n  for (; start > 0; start--, end--) await iit.next();\n\n  for await (const v of it) {\n    if (end-- > 0) {\n      yield v;\n    } else {\n      break;\n    }\n  }\n}\n\n/**\n * Enumerates over an input iterable, with a delay between items.\n * @param it \n * @param delay \n */\nexport async function* withDelay<V>(it: Iterable<V>, delay: Interval) {\n  for (const v of it) {\n    await sleep(delay);\n    yield v;\n  }\n}\n\n/***\n * Returns the next IteratorResult,\n * throwing an error if it does not happen\n * within `interval` (default: 1s)\n */\nexport async function nextWithTimeout<V>(it: AsyncIterableIterator<V> | IterableIterator<V>, options: SleepOpts<any>) {\n  const ms = intervalToMs(options, 1000);\n\n  const value: IteratorResult<V> | undefined = await Promise.race([\n    (async () => {\n      await sleep({ millis: ms, signal: options.signal });\n\n      return undefined;\n    })(),\n    (async () => {\n      return await it.next();\n    })()\n  ]);\n  if (value === undefined) throw new Error(`Timeout`);\n  return value;\n}\n\nexport async function some<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>) {\n  // https://surma.github.io/underdash/\n  for await (const v of it) {\n    if (await f(v)) return true;\n  }\n  return false;\n}\n\n// export async function* takeWhile<V>(\n//   it: AsyncIterable<V>,\n//   f: (v: V) => boolean\n// ) {\n//   // https://surma.github.io/underdash/\n\n//   for await (const v of it) {\n//     if (!f(v)) return;\n//     yield v;\n//   }\n// }\n\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide limits via the options.\n * ```js\n * // Return maximum five items\n * const data = await toArray(iterable, { limit: 5 });\n * // Return results for a maximum of 5 seconds\n * const data = await toArray(iterable, { elapsed: 5000 });\n * ```\n * Note that limits are ORed, `toArray` will finish if either of them is true.\n * \n * @param it Asynchronous iterable\n * @param options Options when converting to array\n * @returns\n */\nexport async function toArray<V>(it: AsyncIterable<V>, options: Partial<ToArrayOptions> = {}): Promise<V[]> {\n  // https://2ality.com/2016/10/asynchronous-iteration.html\n  const result: V[] = [];\n  const iterator = it[ Symbol.asyncIterator ]();\n  const started = Date.now();\n  const maxItems = options.limit ?? Number.POSITIVE_INFINITY;\n  const whileFunction = options.while;\n  const maxElapsed = intervalToMs(options.elapsed, Number.POSITIVE_INFINITY);\n\n  while (result.length < maxItems && (Date.now() - started < maxElapsed)) {\n    if (whileFunction) {\n      if (!whileFunction(result.length)) break;\n    }\n    const r = await iterator.next();\n    if (r.done) break;\n    //eslint-disable-next-line functional/immutable-data\n    result.push(r.value);\n  }\n  return result;\n}\n\n\nexport async function* unique<V>(\n  iterable: AsyncIterable<V> | AsyncIterable<V>[]\n) {\n  const buffer: any[] = [];\n  const itera: AsyncIterable<V>[] = Array.isArray(iterable) ? iterable : [ iterable ];\n  for await (const it of itera) {\n    for await (const v of it) {\n      if (buffer.includes(v)) continue;\n      buffer.push(v);\n      yield v;\n    }\n  }\n}\n\nexport async function* uniqueByValue<T>(input: AsyncIterable<T>, toString: (value: T) => string = toStringDefault, seen: Set<string> = new Set<string>()): AsyncGenerator<T> {\n  for await (const v of input) {\n    const key = toString(v);\n    if (seen.has(key)) continue;\n    seen.add(key);\n    yield v;\n  }\n}\n\n/**\n * Returns unique items from iterables, given a particular key function\n * ```js\n * unique([{i:0,v:2},{i:1,v:3},{i:2,v:2}], e => e.v);\n * Yields:  [{i:0,v:2},{i:1,v:3}]\n * @param it\n * @param f\n */\n\n// export async function* unique<V>(\n//   it: AsyncIterable<V>,\n//   f: (id: V) => V = (id) => id\n// ) {\n//   // https://surma.github.io/underdash/\n//   const buffer: Array<V> = [];\n\n//   for await (const v of it) {\n//     const fv = f(v);\n//     if (buffer.includes(fv)) continue;\n//     buffer.push(fv);\n//     yield v;\n//   }\n// }\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport async function* zip<V>(...its: readonly AsyncIterable<V>[]) {\n  // https://surma.github.io/underdash/\n  const iits = its.map((it) => it[ Symbol.asyncIterator ]());\n\n  while (true) {\n    const vs = await Promise.all(iits.map((it) => it.next()));\n    if (vs.some((v) => v.done)) return;\n    yield vs.map((v) => v.value as V);\n  }\n}\n","\n\n\n\nimport * as Async from './async.js';\nimport * as Sync from './sync.js';\nexport * as Async from './async.js';\nexport * as Sync from './sync.js';\nexport * from './compare-values.js';\nexport * from './from-event.js';\nexport * from './guard.js';\nexport * from './types.js';\n\nimport { isAsyncIterable } from './guard.js';\n//import * as Chains from './chain/index.js';\n// import type { Interval } from '../flow/IntervalType.js';\n\nimport { toStringDefault, type Interval } from '@ixfx/core';\n//import type { GenFactoryNoInput } from './chain/Types.js';\nimport type { ForEachOptions, ToArrayOptions, IteratorControllerOptions, IteratorControllerState } from './types.js';\n\nexport * from './numbers-compute.js';\n\nexport function min<V>(it: AsyncIterable<V>, gt?: (a: V, b: V) => boolean): AsyncGenerator<V>;\nexport function min<V>(it: Iterable<V>, gt?: (a: V, b: V) => boolean): Generator<V>;\n\n\n/**\n * Returns a stream of minimum values.\n * \n * Streaming result: works with endless iterables.\n * \n * ```js\n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], (a, b) => a.v > b.v);\n * // Yields: {i:2, v:1}, {i:2,v:-2}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns Yields minimum values\n */\nexport function min<V>(it: AsyncIterable<V> | Iterable<V>, gt = (a: V, b: V) => a > b): AsyncGenerator<V> | Generator<V> {\n  return isAsyncIterable(it) ? Async.min(it, gt) : Sync.min(it, gt);\n}\n\nexport function max<V>(it: AsyncIterable<V>, gt?: (a: V, b: V) => boolean): AsyncGenerator<V>;\nexport function max<V>(it: Iterable<V>, gt?: (a: V, b: V) => boolean): Generator<V>;\n\n/**\n * Returns the maximum value of an iterable as it changes.\n * Streaming result: works with endless iterables.\n * \n * ```js\n * // Rank values by their 'v' field\n * const rank = (a,b) => a.v > b.v;\n * \n * min([\n *  {i:0,v:1},\n *  {i:1,v:9},\n *  {i:2,v:-2}\n * ], rank);\n * // Yields: {i:0,v:1}, {i:1,v:9}\n * ```\n * @param it Iterable\n * @param gt Should return _true_ if `a` is greater than `b`.\n * @returns Iterable of maximum values\n */\nexport function max<V>(it: AsyncIterable<V> | Iterable<V>, gt = (a: V, b: V) => a > b): AsyncGenerator<V> | Generator<V> {\n  return isAsyncIterable(it) ? Async.max(it, gt) : Sync.max(it, gt);\n}\n\nexport function dropWhile<V>(it: AsyncIterable<V>, f: (v: V) => boolean): AsyncGenerator<V>;\nexport function dropWhile<V>(it: Iterable<V>, f: (v: V) => boolean): Generator<V>;\n\n/**\n * Drops elements that do not meet the predicate `f`.\n * Streaming result: works with endless iterables.\n * \n * ```js\n * dropWhile([1, 2, 3, 4], e => e < 3);\n * returns [3, 4]\n * ```\n * @param it\n * @param f\n */\nexport function dropWhile<V>(it: AsyncIterable<V> | Iterable<V>, f: (v: V) => boolean): AsyncGenerator<V> | Generator<V> {\n  return isAsyncIterable(it) ? Async.dropWhile(it, f) : Sync.dropWhile(it, f);\n}\n\nexport function until(it: AsyncIterable<any>, f: () => Promise<boolean> | Promise<undefined>): Promise<undefined>;\nexport function until(it: Iterable<any>, f: () => boolean | never): void;\nexport function until(it: Iterable<any>, f: () => Promise<boolean>): Promise<undefined>;\n\n/**\n* Loops over a generator until it finishes, calling `callback`.\n* Useful if you don't care about the value generator produces, just the number of loops.\n* \n* ```js\n* until(count(5), () => {\n* // do something 5 times\n* });\n* ```\n* \n* If you want the value from the generator, use a `for of` loop as usual.\n* If `callback` explicitly returns _false_, the generator is aborted.\n* \n* This does not work for infinite generators, `callback` will never be called.\n* @param it Generator to run\n* @param callback Code to call for each iteration\n*/\nexport function until(it: AsyncIterable<any> | Iterable<any>, callback: () => Promise<boolean> | never | boolean | Promise<undefined>): Promise<undefined> | undefined {\n  if (isAsyncIterable(it)) {\n    return Async.until(it, callback);\n  } else {\n    // @ts-expect-error\n    Sync.until(it, callback);\n  }\n}\n\n\nexport function chunks<V>(it: Iterable<V>, size: number): Generator<V[]>;\nexport function chunks<V>(it: AsyncIterable<V>, size: number): AsyncGenerator<V[]>;\n\n/**\n * Breaks an iterable into array chunks\n * \n * Streaming: works with infinite iterables.\n * \n * ```js\n * chunks([1,2,3,4,5,6,7,8,9,10], 3);\n * // Yields [[1, 2, 3], [4, 5, 6], [7, 8, 9], [10]]\n * ```\n * @param it\n * @param size\n */\nexport function chunks<V>(it: AsyncIterable<V> | Iterable<V>, size: number): Generator<V[]> | AsyncGenerator<V[]> {\n  return isAsyncIterable(it) ? Async.chunks(it, size) : Sync.chunks(it, size);\n}\n\nexport function filter<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): AsyncGenerator<V>;\nexport function filter<V>(it: AsyncIterable<V>, f: (v: V) => boolean): Generator<V>;\n\n/**\n * Filters an iterable, only yielding items which match `f`.\n *\n * ```js\n * filter([1, 2, 3, 4], e => e % 2 == 0);\n * returns [2, 4]\n * ```\n * \n * When using async iterables, `f` can be async as well.\n * @param it\n * @param f\n */\nexport function filter<V>(it: AsyncIterable<V> | Iterable<V>, f: (v: V) => boolean | Promise<boolean>): AsyncGenerator<V> | Generator<V> {\n\n  return isAsyncIterable(it) ? Async.filter(it, f) : Sync.filter(it, f as (v: V) => boolean);\n}\n\n\nexport function fill<V>(it: AsyncIterable<V>, v: V): AsyncGenerator<V>;\nexport function fill<V>(it: Iterable<V>, v: V): Generator<V>;\n\n/**\n * Yields `v` for each item within `it`.\n *\n * ```js\n * fill([1, 2, 3], 0);\n * // Yields: [0, 0, 0]\n * ```\n * \n * This is like a `map` where we return a fixed value, ignoring the input.\n * @param it\n * @param v\n */\nexport function fill<V>(it: AsyncIterable<V> | Iterable<V>, v: V): AsyncGenerator<V> | Generator<V> {\n  return isAsyncIterable(it) ? Async.fill(it, v) : Sync.fill(it, v);\n}\n\nexport function concat<V>(...its: Iterable<V>[]): Generator<V>;\nexport function concat<V>(...its: AsyncIterable<V>[]): AsyncGenerator<V>;\n\n\n/**\n * Return concatenation of iterators.\n * \n * Non-streaming: If one of the input iterables is endless, the other ones won't\n * be processed.\n * @param its\n */\nexport function concat<V>(...its: Iterable<V>[] | AsyncIterable<V>[]): AsyncGenerator<V> | Generator<V> {\n  return isAsyncIterable(its[ 0 ]) ? Async.concat(...its as AsyncIterable<V>[]) : Sync.concat(...its as Iterable<V>[]);\n}\n\nexport function find<V>(it: V[] | Iterable<V>, f: (v: V) => boolean): V | undefined;\nexport function find<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): Promise<V | undefined>;\n\n/**\n * Returns first item from iterable `it` that matches predicate `f`\n * ```js\n * find([1, 2, 3, 4], e => e > 2);\n * // Yields: 3\n * ```\n * \n * When using async iterables, `f` can be async as well.\n * @param it\n * @param f\n * @returns\n */\nexport function find<V>(it: V[] | Iterable<V> | AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): Promise<V | undefined> | V | undefined {\n\n  return isAsyncIterable(it) ? Async.find(it, f) : Sync.find(it, f as (v: V) => boolean);\n}\n\n/**\n * Execute function `f` for each item in iterable.\n * If `f` returns _false_, iteration stops.\n * ```js\n * forEach(iterable, v => {\n *  // do something with value\n * });\n * ```\n * \n * When using an async iterable, `fn` can also be async.\n * @param it Iterable or array\n * @param fn Function to execute\n */\n// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\nexport function forEach<T>(it: T[] | AsyncIterable<T> | Iterable<T>, fn: (v: T | undefined) => boolean | Promise<boolean> | void | Promise<void>, options: Partial<ForEachOptions> = {}) {\n  if (isAsyncIterable(it)) {\n    return Async.forEach(it, fn, options);\n  } else {\n    Sync.forEach(it, fn as (v: T) => boolean);\n  }\n}\n\nexport function map<V, X>(it: AsyncIterable<V>, f: (v: V) => Promise<X> | X): Generator<X>;\nexport function map<V, X>(it: V[] | Iterable<V>, f: (v: V) => X): Generator<X>;\n\n/**\n * Maps an iterable through function `f`\n * ```js\n * // For every input value, multiply it by itself\n * map([1, 2, 3], e => e*e)\n * // Yields: 1, 4, 9\n * ```\n * \n * It can also be used to transform types:\n * ```js\n * map([1, 2, 3], e => { value: e });\n * // Yields: { value: 1 }, { value: 2 }, { value: 3 }\n * ```\n * @param it\n * @param f\n */\nexport function map<V, X>(it: V[] | AsyncIterable<V> | Iterable<V>, f: (v: V) => X | Promise<X>) {\n  return isAsyncIterable(it) ? Async.map(it, f) : Sync.map(it, f);\n}\n\nexport function fromArray<V>(array: V[], interval: Interval): AsyncGenerator<V>;\nexport function fromArray<V>(array: V[]): Generator<V>;\n\n/**\n * Yield values from `array`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * \n * @param array Array of values\n * @param interval Interval (defaults: 1ms)\n */\nexport function fromArray<V>(array: V[], interval?: Interval): AsyncGenerator<V> | Generator<V> {\n  return interval === undefined ? Sync.fromArray(array) : Async.fromArray(array, interval);\n}\n\nexport function flatten<V>(it: AsyncIterable<V[] | V>): AsyncIterable<V>;\nexport function flatten<V>(it: Iterable<V[] | V> | V[]): Iterable<V>;\n\n/**\n * Returns a 'flattened' copy of array, un-nesting arrays one level.\n * Streaming: works with unlimited iterables.\n * ```js\n * flatten([1, [2, 3], [[4]]]);\n * // Yields: [1, 2, 3, [4]];\n * ```\n * @param it\n */\nexport function flatten<V>(it: V[] | AsyncIterable<V | V[]> | Iterable<V | V[]>): AsyncIterable<V> | Iterable<V> {\n  return isAsyncIterable(it) ? Async.flatten(it) : Sync.flatten(it);\n}\n\nexport function some<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): Promise<boolean>\nexport function some<V>(it: Iterable<V> | V[], f: (v: V) => boolean): boolean\n\n/**\n * Returns true the first time `f` returns true. Useful for spotting any occurrence of\n * data, and exiting quickly\n * ```js\n * some([1, 2, 3, 4], e => e % 3 === 0);\n * // Yields: true\n * ```\n * @param it Iterable\n * @param f Filter function\n * @returns\n */\nexport function some<V>(it: AsyncIterable<V> | Iterable<V>, f: (v: V) => boolean | Promise<boolean>): boolean | Promise<boolean> {\n  return isAsyncIterable(it) ? Async.some(it, f) : Sync.some(it, f as (v: V) => boolean);\n}\n\nexport function last<V>(it: AsyncIterable<V>): Promise<V | undefined>\nexport function last<V>(it: Iterable<V>): V\n\n/**\n * Returns the last item of an iterable, or _undefined_ if it yields no results.\n * @param it \n * @returns \n */\nexport function last<V>(it: AsyncIterable<V> | Iterable<V>): undefined | V | Promise<V | undefined> {\n  return isAsyncIterable(it) ? Async.last(it) : Sync.last(it);\n}\n\nexport function reduce<V>(it: AsyncIterable<V>, f: (accumulator: V, current: V) => V, start: V): Promise<V>;\nexport function reduce<V>(it: Iterable<V> | V[], f: (accumulator: V, current: V) => V, start: V): V;\n\n/**\n * Reduce for iterables\n * ```js\n * reduce([1, 2, 3], (acc, cur) => acc + cur, 0);\n * // Yields: 6\n * ```\n * @param it Iterable\n * @param f Function\n * @param start Start value\n * @returns\n */\nexport function reduce<V>(it: AsyncIterable<V> | Iterable<V> | V[], f: (accumulator: V, current: V) => V, start: V): Promise<V> | V {\n  return isAsyncIterable(it) ? Async.reduce(it, f, start) : Sync.reduce(it, f, start);\n}\n\nexport function slice<V>(it: AsyncIterable<V>, start?: number, end?: number): AsyncGenerator<V>;\nexport function slice<V>(it: Iterable<V> | V[], start?: number, end?: number): Generator<V>;\n/**\n * Returns a section from an iterable.\n * \n * 'end' is the end index, not the number of items.\n * \n * ```js\n * // Return five items from step 10\n * slice(it, 10, 15);\n * ```\n * @param it Iterable\n * @param start Start step\n * @param end Exclusive end step (or until completion)\n */\nexport function slice<V>(\n  it: Iterable<V> | AsyncIterable<V> | V[],\n  start = 0,\n  end = Number.POSITIVE_INFINITY\n) {\n  return isAsyncIterable(it) ? Async.slice(it, start, end) : Sync.slice(it, start, end);\n}\n\nexport function unique<V>(iterable: Iterable<V> | Iterable<V>[]): Generator<V>;\nexport function unique<V>(iterable: AsyncIterable<V> | AsyncIterable<V>[]): AsyncGenerator<V>;\n\n\n/**\n * Returns unique items from an iterable or\n * array of iterables.\n *\n * ```js\n * const data = [ 'apples', 'oranges' ]\n * const data2 = [ 'oranges', 'pears' ]\n * const unique = [...unique([data,data2]];\n * // Yields: [ 'apples', 'oranges', 'pears' ]\n * ```\n *\n * Uses object reference to compare values.\n * Use {@link uniqueByValue} if this doesn't suffice.\n * @param iterable Iterable, or array of iterables\n */\nexport function unique<V>(iterable: V[] | AsyncIterable<V> | Iterable<V> | Iterable<V>[] | AsyncIterable<V>[]): Generator<V> | AsyncGenerator<V> {\n  if (Array.isArray(iterable)) {\n    if (iterable.length === 0) return Sync.fromArray([]);\n    return isAsyncIterable(iterable[ 0 ]) ? Async.unique(iterable as AsyncIterable<V>[]) : Sync.unique(iterable as Iterable<V>[]);\n  } else if (isAsyncIterable(iterable)) {\n    return Async.unique(iterable);\n  } else {\n    return Sync.unique(iterable);\n  }\n}\n\nexport function uniqueByValue<T>(input: Iterable<T> | T[], toString: (v: T) => string, seen?: Set<string>): Generator<T>;\nexport function uniqueByValue<T>(input: AsyncIterable<T>, toString: (v: T) => string, seen?: Set<string>): AsyncGenerator<T>;\n\n/**\n * Filters the `input` iterable, only yielding unique values. Use {@link unique} to compare\n * by object reference instead.\n * \n * Streaming: Works with unbounded iterables.\n * \n * ```js\n * const d = ['a', 'b', 'c', 'b', 'd' ];\n * for (const v of uniqueByValue(d)) {\n *  // Yields: 'a', 'b', 'c', 'd'\n * // (extra 'b' is skipped)\n * }\n * ```\n * \n * By default, JSON.stringify is used to create a string representing value. These are added\n * to a Set of strings, which is how we keep track of uniqueness. If the value is already a string it is used as-is.\n * \n * This allows you to have custom logic for what determines uniqueness. Eg, using a single field\n * of an object as an identifier:\n * \n * ```js\n * const people = [\n *  { name: `Mary`, size: 20 }, { name: `Abdul`, size: 19 }, { name: `Mary`, size: 5 }\n * ]\n * for (const v of uniqueByValue(d, v=>v.name)) {\n *  // Yields: { name: `Mary`, size: 20 }, { name: `Abdul`, size: 19 }\n *  // Second 'Mary' is skipped because name is the same, even though size field is different.\n * }\n * ```\n * \n * If you want to keep track of the set of keys, or prime it with some existing data, provide a Set instance:\n * ```js\n * const unique = new Set();\n * unique.add(`b`);\n * const d = [`a`, `b`, `c`];\n * for (const v of uniqueByValue(d, toStringDefault, unique)) {\n *  // Yields: `a`, `c`\n *  // `b` is skipped because it was already in set\n * }\n * // After completion, `unique` contains `a`, `b` and `c`.\n * ```\n * \n * Creating your own Set is useful for tracking unique values across several calls to `uniqueByValue`.\n * @param input \n * @param seen \n * @param toString \n */\nexport function* uniqueByValue<T>(input: AsyncIterable<T> | Iterable<T> | T[], toString: (v: T) => string = toStringDefault, seen: Set<string> = new Set<string>()): Generator<T> | AsyncGenerator<T> {\n  return isAsyncIterable(input) ? Async.uniqueByValue(input, toString, seen) : Sync.uniqueByValue(input, toString, seen);\n}\n\nexport function toArray<V>(it: AsyncIterable<V>, options?: Partial<ToArrayOptions>): Promise<V[]>;\nexport function toArray<V>(it: Iterable<V>, options?: Partial<ToArrayOptions>): V[];\n\n/**\n * Returns an array of values from an iterator.\n *\n * ```js\n * const data = await toArray(adsrIterable(opts, 10));\n * ```\n *\n * Note: If the iterator is infinite, be sure to provide a `count` or the function\n * will never return.\n *\n * @param it Asynchronous iterable\n * @param count Number of items to return, by default all.\n * @returns\n */\n\nexport function toArray<V>(it: Iterable<V> | AsyncIterable<V>, options: Partial<ToArrayOptions> = {}): V[] | Promise<V[]> {\n  return isAsyncIterable(it) ? Async.toArray(it, options) : Sync.toArray(it, options);\n}\n\nexport function every<V>(it: Iterable<V> | V[], f: (v: V) => boolean): boolean\nexport function every<V>(it: AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): Promise<boolean>\n\n/**\n * Returns _true_ if `f` returns _true_ for\n * every item in iterable.\n * \n * Streaming: If an infinite iterable is used, function will never return value.\n * @param it\n * @param f\n * @returns\n */\nexport function every<V>(it: Iterable<V> | V[] | AsyncIterable<V>, f: (v: V) => boolean | Promise<boolean>): Promise<boolean> | boolean {\n  return isAsyncIterable(it) ? Async.every(it, f) : Sync.every(it, f as (v: V) => boolean);\n}\n\nexport function equals<V>(it1: AsyncIterable<V>, it2: AsyncIterable<V>, equality?: (a: V, b: V) => boolean): Promise<boolean>\nexport function equals<V>(it1: IterableIterator<V>, it2: IterableIterator<V>, equality?: (a: V, b: V) => boolean): boolean\n\n/**\n * Returns _true_ if items in two iterables are equal, as\n * determined by the `equality` function.\n * Order matters. It compares items at the same 'step' of each iterable.\n * @param it1\n * @param it2\n * @param equality\n * @returns\n */\nexport function equals<V>(it1: AsyncIterable<V> | IterableIterator<V>, it2: AsyncIterable<V> | IterableIterator<V>, equality?: (a: V, b: V) => boolean) {\n  const as = isAsyncIterable(it1) && isAsyncIterable(it2);\n  return as ? Async.equals(it1, it2, equality) : Sync.equals(it1 as IterableIterator<V>, it2 as IterableIterator<V>, equality);\n}\n\nexport function zip<V>(...its: readonly AsyncIterable<V>[]): Generator<V[]>;\nexport function zip<V>(...its: readonly Iterable<V>[]): Generator<V>;\n\n\n/**\n * Combine same-positioned items from several iterables\n * ```js\n * zip( [1, 2, 3], [4, 5, 6], [7, 8, 9] );\n * Yields: [ [1, 4, 7], [2, 5, 8], [3, 6, 9] ]\n * ```\n * @param its\n * @returns\n */\nexport function zip<V>(...its: readonly AsyncIterable<V>[] | readonly Iterable<V>[]) {\n  if (its.length === 0) return Sync.fromArray([]);\n  return isAsyncIterable(its[ 0 ]) ? Async.zip(...its as readonly AsyncIterable<V>[]) : Sync.zip(...its as readonly Iterable<V>[]);\n}\n\nexport function fromIterable<V>(iterable: Iterable<V>): Generator<V>\nexport function fromIterable<V>(iterable: AsyncIterable<V> | Iterable<V>, interval: Interval): AsyncGenerator<V>\n\n/**\n * Yield values from `iterable`, one at a time.\n * Use `interval` to add time between each item.\n * The first item is yielded without delay.\n * @param iterable Iterable or AsyncIterable\n * @param [interval=1] Interval to wait between yield\n */\nexport function fromIterable<V>(iterable: Iterable<V> | AsyncIterable<V>, interval?: Interval): AsyncGenerator<V> | Generator<V> {\n  if (isAsyncIterable(iterable) || interval !== undefined) return Async.fromIterable(iterable, interval);\n  return Sync.fromIterable(iterable);\n}\n\n/**\n * Access `callback` as an iterable:\n * ```js\n * const fn = () => Math.random();\n * for (const v of fromFunction(fn)) {\n *  // Generate infinite random numbers\n * }\n * ```\n * \n * Use {@link fromFunctionAwaited} to await `callback`.\n * @param callback Function that generates a value\n */\nexport function* fromFunction<T>(callback: () => T) {\n  while (true) {\n    const v = callback();\n    yield v;\n  }\n}\n\n/**\n * Access awaited `callback` as an iterable:\n * ```js\n * const fn = () => Math.random();\n * for await (const v of fromFunctionAwaited(fn)) {\n *  // Generate infinite random numbers\n * }\n * ```\n * \n * `callback` can be async, result is awaited.\n * This requires the use of `for await`.\n * Use {@link fromFunction} otherwise;\n * @param callback \n */\nexport async function* fromFunctionAwaited<T>(callback: () => Promise<T> | T) {\n  while (true) {\n    const v = await callback();\n    yield v;\n  }\n}\n\n\n/**\n * Calls `callback` whenever the generator produces a value.\n * \n * When using `asCallback`, call it with `await` to let generator \n * run its course before continuing:\n * ```js\n * await asCallback(tick({ interval:1000, loops:5 }), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints after 5 seconds\n * ```\n * \n * Or if you skip the `await`, code continues and callback will still run:\n * ```js\n * asCallback(tick({ interval: 1000, loops: 5}), x => {\n *  // Gets called 5 times, with 1000ms interval\n * });\n * console.log(`Hi`); // Prints immediately\n * ```\n * @param input \n * @param callback \n */\nexport function asCallback<V>(input: AsyncIterable<V> | Iterable<V>, callback: (v: V) => unknown, onDone?: () => void) {\n  if (isAsyncIterable(input)) {\n    return Async.asCallback(input, callback);\n  } else {\n    Sync.asCallback(input, callback); return;\n  }\n}\n\n"],"mappings":";;;;AAEA,MAAa,kBAAkB,CAACA,MAAoC;AAClE,YAAW,OAAO,QAAS,QAAO;AAClC,KAAI,MAAM,KAAM,QAAO;AACvB,QAAO,OAAO,iBAAiB;AAEhC;AAED,MAAa,aAAa,CAACA,MAA+B;AACxD,YAAW,OAAO,QAAS,QAAO;AAClC,KAAI,MAAM,KAAM,QAAO;AACvB,QAAO,OAAO,YAAY;AAE3B;;;;;;;;;ACqFD,SAAgBC,OAAQC,IAAgC;CACtD,IAAIC;AACJ,MAAK,MAAM,SAAS,GAClB,eAAc;AAEhB,QAAO;AACR;;;;;;;;;;AA8ND,UAAiB,IAAUD,IAAiBE,GAAgB;AAG1D,MAAK,MAAM,KAAK,GACd,OAAM,EAAE,EAAE;AAEb;AAED,UAAiBC,MAAOH,IAAiB,KAAK,CAACI,GAAMC,MAAS,IAAI,GAAiB;CACjF,IAAIC;AACJ,MAAK,MAAM,KAAK,IAAI;AAClB,MAAIH,kBAAmB;AACrB,WAAM;AACN,SAAMA;AACN;EACD;AACD,MAAI,GAAG,GAAGA,MAAI,EAAE;AACd,WAAM;AACN,SAAMA;EACP;CACF;AACD,QAAOA;AACR;AAED,UAAiBI,MAAOP,IAAiB,KAAK,CAACI,GAAMC,MAAS,IAAI,GAAG;CACnE,IAAIG;AACJ,MAAK,MAAM,KAAK,IAAI;AAClB,MAAID,kBAAmB;AACrB,WAAM;AACN,SAAMA;EACP;AACD,MAAI,GAAGA,OAAK,EAAE,EAAE;AACd,WAAM;AACN,SAAMA;EACP;CACF;AACF;;;;;;;;;ACrED,eAAsBE,OAAQC,IAAsBC,OAAwC,CAAE,GAA0B;CACtH,MAAM,QAAQ,KAAK;CACnB,IAAIC;AAEJ,YAAW,MAAM,SAAS,IAAI;AAC5B,MAAI,OAAO,QAAS;AACpB,gBAAc;CACf;AACD,QAAO;AACR;AA4BD,gBAAuBC,MAAOH,IAAsB,KAAM,CAACI,GAAMC,MAAS,IAAI,GAAI;CAChF,IAAIC;AACJ,YAAW,MAAM,KAAK,IAAI;AACxB,MAAIH,kBAAmB;AACrB,WAAM;AACN,SAAOA;AACP;EACD;AAED,MAAI,GAAG,GAAGA,MAAI,EAAE;AACd,WAAM;AACN,SAAM;EACP;CACF;AACF;;;;;;;;;;;;;;;;;;;;;;AAuBD,gBAAuBI,MAAOP,IAAsB,KAAK,CAACI,GAAMC,MAAS,IAAI,GAAG;CAC9E,IAAIG;AACJ,YAAW,MAAM,KAAK,IAAI;AACxB,MAAID,kBAAmB;AACrB,WAAM;AACN,SAAMA;AACN;EACD;AAED,MAAI,GAAGA,OAAK,EAAE,EAAE;AACd,WAAM;AACN,SAAM;EACP;CACF;AACD,QAAOA;AACR;;;;;;AAiFD,eAAsB,gBAAmBE,IAAoDC,SAAyB;CACpH,MAAM,KAAK,aAAa,SAAS,IAAK;CAEtC,MAAMC,QAAuC,MAAM,QAAQ,KAAK,CAC9D,CAAC,YAAY;AACX,QAAM,MAAM;GAAE,QAAQ;GAAI,QAAQ,QAAQ;EAAQ,EAAC;AAEnD;CACD,IAAG,EACJ,CAAC,YAAY;AACX,SAAO,MAAM,GAAG,MAAM;CACvB,IAAG,AACL,EAAC;AACF,KAAI,iBAAqB,OAAM,IAAI,OAAO;AAC1C,QAAO;AACR;;;;;;;;;;;;;;;;;;;;;ACnbD,SAAgB,IAAOC,IAAoC,KAAK,CAACC,GAAMC,MAAS,IAAI,GAAqC;AACvH,QAAO,gBAAgB,GAAG,GAAG,MAAU,IAAI,GAAG,GAAG,MAAS,IAAI,GAAG;AAClE;;;;;;;;;;;;;;;;;;;;AAwBD,SAAgB,IAAOF,IAAoC,KAAK,CAACC,GAAMC,MAAS,IAAI,GAAqC;AACvH,QAAO,gBAAgB,GAAG,GAAG,MAAU,IAAI,GAAG,GAAG,MAAS,IAAI,GAAG;AAClE;;;;;;AAuPD,SAAgB,KAAQF,IAA4E;AAClG,QAAO,gBAAgB,GAAG,GAAG,OAAW,GAAG,GAAG,OAAU,GAAG;AAC5D"}