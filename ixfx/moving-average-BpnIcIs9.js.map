{"version":3,"file":"moving-average-BpnIcIs9.js","names":[],"sources":["../../numbers/dist/src/moving-average.js"],"sourcesContent":["import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { BasicQueueMutable } from \"./util/queue-mutable.js\";\nimport { averageWeighted } from \"./average-weighted.js\";\nimport { average } from \"./numeric-arrays.js\";\nconst PiPi = Math.PI * 2;\n/**\n * A moving average calculator (exponential weighted moving average) which does not keep track of\n * previous samples. Less accurate, but uses less system resources.\n *\n * The `scaling` parameter determines smoothing. A value of `1` means that\n * the latest value is used as the average - that is, no smoothing. Higher numbers\n * introduce progressively more smoothing by weighting the accumulated prior average more heavily.\n *\n * ```\n * const ma = movingAverageLight(); // default scaling of 3\n * ma(50);  // 50\n * ma(100); // 75\n * ma(75);  // 75\n * ma(0);   // 50\n * ```\n *\n * Note that the final average of 50 is pretty far from the last value of 0. To make it more responsive,\n * we could use a lower scaling factor: `movingAverageLight(2)`. This yields a final average of `37.5` instead.\n *\n * @param scaling Scaling factor. 1 is no smoothing. Default: 3\n * @returns Function that adds to average.\n */\nexport const movingAverageLight = (scaling = 3) => {\n    resultThrow(numberTest(scaling, `aboveZero`, `scaling`));\n    let average = 0;\n    let count = 0;\n    return (v) => {\n        const r = numberTest(v, ``, `v`);\n        if (r.success && v !== undefined) {\n            // Valid number\n            count++;\n            average = average + (v - average) / Math.min(count, scaling);\n        }\n        return average;\n    };\n};\n/**\n * Creates a moving average for a set number of `samples`.\n * It returns a function which in turn yields an average value.\n *\n * Moving average are useful for computing the average over a recent set of numbers.\n * A lower number of samples produces a computed value that is lower-latency yet more jittery.\n * A higher number of samples produces a smoother computed value which takes longer to respond to\n * changes in data.\n *\n * Sample size is considered with respect to the level of latency/smoothness trade-off, and also\n * the rate at which new data is added to the moving average.\n *\n *\n * ```js\n * const ma = movingAverage(10);\n * ma(10); // 10\n * ma(5);  // 7.5\n * ```\n *\n * A weighting function can be provided to shape how the average is\n * calculated - eg privileging the most recent data over older data.\n * It uses `Arrays.averageWeighted` under the hood.\n *\n * ```js\n * import { movingAverage } from '@ixfx/numbers.js';\n * import { gaussian } from '@ixfx/modulation.js';\n *\n * // Give more weight to data in middle of sampling window\n * const ma = movingAverage(100, gaussian());\n * ```\n *\n * Because it keeps track of `samples` previous data, there is a memory impact. A lighter version is {@link movingAverageLight} which does not keep a buffer of prior data, but can't be as easily fine-tuned.\n * @param samples Number of samples to compute average from\n * @param weighter Optional weighting function\n * @returns\n */\nexport const movingAverage = (samples = 100, weighter) => {\n    const q = new BasicQueueMutable();\n    return (v) => {\n        const r = numberTest(v);\n        if (r.success && v !== undefined) {\n            q.enqueue(v);\n            while (q.size > samples) {\n                q.dequeue();\n            }\n        }\n        return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n    };\n};\n// export const movingAverageTimed = (\n//   updateRateMs = 200,\n//   value = 0,\n//   scaling = 3\n// ): MovingAverage => {\n//   throwNumberTest(scaling, `aboveZero`, `scaling`);\n//   throwNumberTest(updateRateMs, `aboveZero`, `decayRateMs`);\n//   const mal = movingAverageLight(scaling);\n//   //eslint-disable-next-line functional/no-let\n//   let timer = 0;\n//   const reschedule = () => {\n//     if (timer !== 0) clearTimeout(timer);\n//     // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n//     // @ts-ignore\n//     timer = setTimeout(decay, updateRateMs) as number;\n//   };\n//   const decay = () => {\n//     mal.add(value);\n//     if (!mal.isDisposed) setTimeout(decay, updateRateMs);\n//   };\n//   const ma: MovingAverage = {\n//     add(v: number) {\n//       reschedule();\n//       return mal.add(v);\n//     },\n//     dispose() {\n//       mal.dispose();\n//     },\n//     clear: function (): void {\n//       mal.clear();\n//     },\n//     compute: function (): number {\n//       return mal.compute();\n//     },\n//     isDisposed: false,\n//   };\n//   return ma;\n// };\nconst smoothingFactor = (timeDelta, cutoff) => {\n    const r = PiPi * cutoff * timeDelta;\n    return r / (r + 1);\n};\nconst exponentialSmoothing = (smoothingFactor, value, previous) => {\n    return smoothingFactor * value + (1 - smoothingFactor) * previous;\n};\n/**\n * Noise filtering\n *\n * Algorithm: https://gery.casiez.net/1euro/\n *\n * Based on [Jaan Tollander de Balsch's implementation](https://jaantollander.com/post/noise-filtering-using-one-euro-filter/)\n * @param cutoffMin Default: 1\n * @param speedCoefficient Default: 0\n * @param cutoffDefault Default: 1\n */\nexport const noiseFilter = (cutoffMin = 1, speedCoefficient = 0, cutoffDefault = 1) => {\n    let previousValue = 0;\n    let derivativeLast = 0;\n    let timestampLast = 0;\n    const compute = (value, timestamp) => {\n        timestamp ??= performance.now();\n        const timeDelta = timestamp - timestampLast;\n        // Filtered derivative\n        const s = smoothingFactor(timeDelta, cutoffDefault);\n        const valueDelta = (value - previousValue) / timeDelta;\n        const derivative = exponentialSmoothing(s, valueDelta, derivativeLast);\n        // Filtered signal\n        const cutoff = cutoffMin + speedCoefficient * Math.abs(derivative);\n        const a = smoothingFactor(timeDelta, cutoff);\n        const smoothed = exponentialSmoothing(a, value, previousValue);\n        previousValue = smoothed;\n        derivativeLast = derivative;\n        timestampLast = timestamp;\n        return smoothed;\n    };\n    return compute;\n};\n"],"mappings":";;;AAIA,MAAM,OAAO,KAAK,KAAK;;;;;;;;;;;;;;;;;;;;;;;AAuBvB,MAAa,qBAAqB,CAAC,UAAU,MAAM;CAC/C,YAAY,WAAW,SAAS,CAAC,SAAS,CAAC,EAAE,CAAC,OAAO,CAAC,CAAC,CAAC;CACxD,IAAI,UAAU;CACd,IAAI,QAAQ;AACZ,QAAO,CAAC,MAAM;EACV,MAAM,IAAI,WAAW,GAAG,EAAE,EAAE,CAAC,CAAC,CAAC,CAAC;AAChC,MAAI,EAAE,WAAW,MAAM,QAAW;GAE9B;GACA,UAAU,WAAW,IAAI,WAAW,KAAK,IAAI,OAAO,QAAQ;EAC/D;AACD,SAAO;CACV;AACJ"}