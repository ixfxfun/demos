{"version":3,"file":"pathed-DGKJECMt.d.ts","names":["ChangeKind","ChangeRecord","TKey","CompareChangeSet","Record","IsEqual","CompareChangeSet","compareObjectKeys","changedObjectDataFields","Record","compareArrays","TValue","compareObjectData","T","cloneFromFields","T","RemapObjectPropertyType","mapObjectShallow","Record","TSource","MapObjectArgs","TFieldValue","mapObjectByObject","mapObjectKeys","TKeySource","Record","TKeyDestination","RecordEntry","Readonly","RecordEntryWithAncestors","RecordEntryStatic","PathOpts","RecordChildrenOptions","prettyPrintEntries","recordEntryPrettyPrint","Partial","recordChildren","T","IterableIterator","recordEntriesDepthFirst","getRecordEntryByPath","traceRecordEntryByPath","Iterable","OptionalPropertyNames","T","K","Record","SpreadProperties","L","R","P","Exclude","Id","U","SpreadTwo","Pick","Spread","A","mergeObjects","keysToNumbers","T","Record","IsEqualContext","Result","PathData","V","PathDataChange","CompareDataOptions","WeakSet","compareData","Record","Partial","Generator","applyChanges","updateByPath","getField","getPaths","getPathsAndData"],"sources":["../../core/dist/src/types-compare.d.ts","../../core/dist/src/records/compare.d.ts","../../core/dist/src/records/clone-from-fields.d.ts","../../core/dist/src/records/map-object.d.ts","../../core/dist/src/records/map-object-keys.d.ts","../../core/dist/src/records/traverse.d.ts","../../core/dist/src/records/merge.d.ts","../../core/dist/src/records/keys-to-numbers.d.ts","../../core/dist/src/records/index.d.ts","../../core/dist/src/pathed.d.ts"],"sourcesContent":["/**\n * Kind of change\n */\nexport type ChangeKind = `mutate` | `add` | `del`;\n/**\n * Change record\n */\nexport type ChangeRecord<TKey extends string | number | symbol> = [kind: ChangeKind, path: TKey, value: unknown];\n/**\n * Result of compareObjectData\n */\nexport type CompareChangeSet<TKey extends string | number> = {\n    /**\n     * _True_ if there are any changes\n     */\n    hasChanged: boolean;\n    /**\n     * Results for child objects\n     */\n    children: Record<TKey, CompareChangeSet<string | number>>;\n    /**\n     * Values that have changed\n     */\n    changed: Record<TKey, unknown>;\n    /**\n     * Fields that have been added\n     */\n    added: Record<TKey, unknown>;\n    /**\n     * Fields that have been removed\n     */\n    removed: TKey[];\n    /**\n     * _True_ if value is an array\n     */\n    isArray: boolean;\n    /**\n     * Summary of changes\n     */\n    summary: ChangeRecord<TKey>[];\n};\n//# sourceMappingURL=types-compare.d.ts.map","import { type IsEqual } from '@ixfx/core';\nimport type { CompareChangeSet } from '../types-compare.js';\n/**\n * Compares the keys of two objects, returning a set of those in\n * common, and those in either A or B exclusively.\n * ```js\n * const a = { colour: `red`, intensity: 5 };\n * const b = { colour: `pink`, size: 10 };\n * const c = compareObjectKeys(a, b);\n * // c.shared = [ `colour` ]\n * // c.a = [ `intensity` ]\n * // c.b = [ `size`  ]\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const compareObjectKeys: (a: object, b: object) => {\n    shared: string[];\n    isSame: boolean;\n    a: string[];\n    b: string[];\n};\n/**\n * Returns the changed fields from A -> B. It's assumed that A and B have the same shape.\n * ie. returns an object that only consists of fields which have changed in B compared to A.\n *\n * ```js\n * const a = { msg: `hi`, v: 10 };\n *\n * changedObjectDataFields(a, { msg: `hi`,   v: 10 }); // {}\n * changedObjectDataFields(a, { msg: `hi!!`, v: 10 }); // { msg: `hi!!` }\n * changedObjectDataFields(a, { msg: `hi!!` });       // { msg: `hi!!`, v: undefined }\n * ```\n *\n * If B has additional or removed fields, this is considered an error.\n *\n * If a field is an array, the whole array is returned, rather than a diff.\n * @param a\n * @param b\n */\nexport declare const changedObjectDataFields: (a: object, b: object) => Record<string, unknown> | object[];\n/**\n * Produces a {@link CompareChangeSet} between two arrays.\n *\n * @param a Earlier array to compare\n * @param b Later array to compare\n * @param eq Equality comparison for values\n * @returns Change set.\n */\nexport declare const compareArrays: <TValue>(a: TValue[], b: TValue[], eq?: IsEqual<TValue>) => CompareChangeSet<number>;\n/**\n * Compares A to B. Assumes they are simple objects, essentially key-value pairs, where the\n * values are primitive values or other simple objects. It also works with arrays.\n *\n * Uses === equality semantics by default.\n * @param a\n * @param b\n */\nexport declare const compareObjectData: <T>(a: object | null, b: object | null, assumeSameShape?: boolean, eq?: IsEqual<T>) => CompareChangeSet<string>;\n//# sourceMappingURL=compare.d.ts.map","export declare const cloneFromFields: <T extends object>(source: T) => T;\n//# sourceMappingURL=clone-from-fields.d.ts.map","import type { RemapObjectPropertyType } from \"../ts-utility.js\";\n/**\n * Maps the top-level properties of an object through a map function.\n * That is, run each of the values of an object through a function,\n * setting the result onto the same key structure as original.\n *\n * It is NOT recursive.\n *\n * The mapping function gets a single args object, consisting of `{ value, field, index }`,\n * where 'value' is the value of the field, 'field' the name, and 'index' a numeric count.\n * @example Double the value of all fields\n * ```js\n * const rect = { width: 100, height: 250 };\n * const doubled = mapObjectShallow(rect, args => {\n *  return args.value*2;\n * });\n * // Yields: { width: 200, height: 500 }\n * ```\n *\n * Since the map callback gets the name of the property, it can do context-dependent things.\n * ```js\n * const rect = { width: 100, height: 250, colour: 'red' }\n * const doubled = mapObjectShallow(rect, args => {\n *  if (args.field === 'width') return args.value*3;\n *  else if (typeof args.value === 'number') return args.value*2;\n *  return args.value;\n * });\n * // Yields: { width: 300, height: 500, colour: 'red' }\n * ```\n * In addition to bulk processing, it allows remapping of property types.\n *\n * In terms of type-safety, the mapped properties are assumed to have the\n * same type.\n *\n * ```js\n * const o = {\n *  x: 10,\n *  y: 20,\n *  width: 200,\n *  height: 200\n * }\n *\n * // Make each property use an averager instead\n * const oAvg = mapObjectShallow(o, args => {\n *  return movingAverage(10);\n * });\n *\n * // Instead of { x:number, y:number... }, we now have { x:movingAverage(), y:movingAverage()... }\n * // Add a value to the averager\n * oAvg.x.add(20);\n * ```\n */\nexport declare const mapObjectShallow: <TSource extends Record<string, any>, TFieldValue>(object: TSource, mapFunction: (args: MapObjectArgs) => TFieldValue) => RemapObjectPropertyType<TSource, TFieldValue>;\nexport type MapObjectArgs = {\n    field: string;\n    path: string;\n    value: any;\n    index: number;\n};\n/**\n * Maps the contents of `data` using `mapper` as a structured set of map functions.\n * ```js\n * const a = {\n *  person: {\n *    size: 20\n *  }\n *  hello: `there`\n * }\n * mapObjectByObject(a, {\n *  person: {\n *    size: (value, context) => {\n *      return value * 2\n *    }\n *  }\n * });\n * // Yields: { person: { size: 40 }, hello: `there` }\n * ```\n * @param data\n * @param mapper\n * @returns\n */\nexport declare function mapObjectByObject(data: object, mapper: Record<string, (value: any, context: any) => any>): {\n    [k: string]: any;\n};\n//# sourceMappingURL=map-object.d.ts.map","/**\n * Maps the keys of an object, returning a transformed object.\n * ```js\n * const input = {\n *  hello: `there`,\n *  chap: `chappie`\n * }\n *\n * mapObjectKeys(input, key => key.toUppercase());\n *\n * // Yields: { HELLO: `there`, CHAP: `chappie` }\n * ```\n * @param object\n * @param mapFunction\n * @returns\n */\nexport declare const mapObjectKeys: <TKeySource extends string | number | symbol, TKeyDestination extends string | number | symbol>(object: Record<TKeySource, unknown>, mapFunction: (key: TKeySource) => TKeyDestination) => Record<TKeyDestination, unknown>;\n//# sourceMappingURL=map-object-keys.d.ts.map","export type RecordEntry = Readonly<{\n    name: string;\n    sourceValue: any;\n    nodeValue: any;\n}>;\nexport type RecordEntryWithAncestors = Readonly<{\n    name: string;\n    sourceValue: any;\n    nodeValue: any;\n    ancestors: string[];\n}>;\nexport type RecordEntryStatic = Readonly<{\n    name: string;\n    value: any;\n    ancestors: string[];\n}>;\n/**\n * Options for parsing a path\n */\nexport type PathOpts = {\n    /**\n     * Separator for path, eg '.'\n     */\n    readonly separator?: string;\n};\nexport type RecordChildrenOptions = Readonly<{\n    /**\n     * If set, only uses leaves or branches. 'none' means there is no filter.\n     */\n    filter: `none` | `leaves` | `branches`;\n    /**\n     * Default name to use. This is necessary in some cases, eg a root object.\n     */\n    name: string;\n}>;\n/**\n * Helper function to get a 'friendly' string representation of an array of {@link RecordEntry}.\n * @param entries\n * @returns\n */\nexport declare function prettyPrintEntries(entries: readonly RecordEntry[]): string;\n/**\n * Returns a human-friendly debug string for a tree-like structure\n * ```js\n * console.log(Trees.prettyPrint(obj));\n * ```\n * @param indent\n * @param node\n * @param options\n * @returns\n */\nexport declare const recordEntryPrettyPrint: (node: object, indent?: number, options?: Partial<RecordChildrenOptions>) => string;\n/**\n * Returns the direct children of a tree-like object as a pairing\n * of node name and value. Supports basic objects, Maps and arrays.\n *\n * Sub-children are included as an object blob.\n *\n * @example Simple object\n * ```js\n * const o = {\n *  colour: {\n *    r: 0.5, g: 0.5, b: 0.5\n *  }\n * };\n *\n * const children = [ ...Trees.children(o) ];\n * // Children:\n * // [\n * //  { name: \"colour\", value: { b: 0.5, g: 0.5, r: 0.5 } }\n * // ]\n * const subChildren = [ ...Trees.children(o.colour) ];\n * // [ { name: \"r\", value: 0.5 }, { name: \"g\", value: 0.5 }, { name: \"b\", value: 0.5 } ]\n * ```\n *\n * Arrays are assigned a name based on index.\n * @example Arrays\n * ```js\n * const colours = [ { r: 1, g: 0, b: 0 }, { r: 0, g: 1, b: 0 }, { r: 0, g: 0, b: 1 } ];\n * // Children:\n * // [\n * //  { name: \"array[0]\", value: {r:1,g:0,b:0} },\n * //  { name: \"array[1]\", value: {r:0,g:1,b:0} },\n * //  { name: \"array[2]\", value: {r:0,g:0,b:1} },\n * // ]\n * ```\n *\n * Pass in `options.name` (eg 'colours') to have names generated as 'colours[0]', etc.\n * Options can also be used to filter children. By default all direct children are returned.\n * @param node\n * @param options\n */\nexport declare function recordChildren<T extends object>(node: T, options?: Partial<RecordChildrenOptions>): IterableIterator<RecordEntry>;\nexport declare function recordEntriesDepthFirst<T extends object>(node: T, options?: Partial<RecordChildrenOptions>, ancestors?: string[]): IterableIterator<RecordEntryWithAncestors>;\n/**\n * Returns the closest matching entry, tracing `path` in an array, Map or simple object.\n * Returns an entry with _undefined_ value at the point where tracing stopped.\n * Use {@link traceRecordEntryByPath} to step through all the segments.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * Trees.getByPath('jane.address.postcode', people); // '.' default separator\n * // ['postcode', 1000]\n * Trees.getByPath('jane.address.country.state', people);\n * // ['country', undefined] - since full path could not be resolved.\n * ```\n * @param path Path, eg `jane.address.postcode`\n * @param node Node to look within\n * @param options Options for parsing path. By default '.' is used as a separator\n * @returns\n */\nexport declare function getRecordEntryByPath<T extends object>(path: string, node: T, options?: PathOpts): RecordEntry;\n/**\n * Enumerates over children of `node` towards the node named in `path`.\n * This is useful if you want to get the interim steps to the target node.\n *\n * Use {@link getRecordEntryByPath} if you don't care about interim steps.\n *\n * ```js\n * const people = {\n *  jane: {\n *   address: {\n *    postcode: 1000,\n *    street: 'West St',\n *    city: 'Blahville'\n *   },\n * colour: 'red'\n *  }\n * }\n * for (const p of Trees.traceByPath('jane.address.street', people)) {\n * // { name: \"jane\", value: { address: { postcode: 1000,street: 'West St', city: 'Blahville' }, colour: 'red'} },\n * // { name: \"address\", value: { postcode: 1000, street: 'West St', city: 'Blahville' } },\n * // { name: \"street\", value: \"West St\" } }\n * }\n * ```\n *\n * Results stop when the path can't be followed any further.\n * The last entry will have a name of the last sought path segment, and _undefined_ as its value.\n *\n * @param path Path to traverse\n * @param node Starting node\n * @param options Options for path traversal logic\n * @returns\n */\nexport declare function traceRecordEntryByPath<T extends object>(path: string, node: T, options?: PathOpts): Iterable<RecordEntryWithAncestors>;\n//# sourceMappingURL=traverse.d.ts.map","type OptionalPropertyNames<T> = {\n    [K in keyof T]-?: ({} extends Record<K, T[K]> ? K : never);\n}[keyof T];\ntype SpreadProperties<L, R, K extends keyof L & keyof R> = {\n    [P in K]: L[P] | Exclude<R[P], undefined>;\n};\ntype Id<T> = T extends infer U ? {\n    [K in keyof U]: U[K];\n} : never;\ntype SpreadTwo<L, R> = Id<Pick<L, Exclude<keyof L, keyof R>> & Pick<R, Exclude<keyof R, OptionalPropertyNames<R>>> & Pick<R, Exclude<OptionalPropertyNames<R>, keyof L>> & SpreadProperties<L, R, OptionalPropertyNames<R> & keyof L>>;\nexport type Spread<A extends readonly [...any]> = A extends [infer L, ...infer R] ? SpreadTwo<L, Spread<R>> : unknown;\nexport declare function mergeObjects<A extends object[]>(...a: [...A]): Spread<A>;\nexport {};\n//# sourceMappingURL=merge.d.ts.map","/**\n * Returns a copy of `object` with integer numbers as keys instead of whatever it has.\n * ```js\n * keysToNumbers({ '1': true }); // Yields: { 1: true }\n * ```\n *\n * The `onInvalidKey` sets how to handle keys that cannot be converted to integers.\n * * 'throw' (default): throws an exception\n * * 'ignore': that key & value is ignored\n * * 'keep': uses the string key instead\n *\n *\n * ```js\n * keysToNumber({ hello: 'there' }, `ignore`); // Yields: {  }\n * keysToNumber({ hello: 'there' }, `throw`);  // Exception\n * keysToNumber({ hello: 'there' }, `keep`);   // Yields: { hello: 'there' }\n * ```\n *\n * Floating-point numbers will be converted to integer by rounding.\n * ```js\n * keysToNumbers({ '2.4': 'hello' }); // Yields: { 2: 'hello' }\n * ```\n * @param object\n * @param onInvalidKey\n * @returns\n */\nexport declare const keysToNumbers: <T>(object: Record<string | number | symbol, T>, onInvalidKey?: `throw` | `ignore` | `keep`) => Record<number, T>;\n//# sourceMappingURL=keys-to-numbers.d.ts.map","export * from './compare.js';\nexport * from './clone-from-fields.js';\nexport * from './map-object.js';\nexport * from './map-object-keys.js';\nexport * from './traverse.js';\nexport * from './merge.js';\nexport * from './keys-to-numbers.js';\nexport type * from '../types-compare.js';\n//# sourceMappingURL=index.d.ts.map","import type { IsEqualContext } from '@ixfx/core';\nimport type { Result } from '@ixfx/guards';\n/**\n * Data at a particular path\n */\nexport type PathData<V> = {\n    /**\n     * Path\n     */\n    path: string;\n    /**\n     * Value\n     */\n    value: V;\n};\n/**\n * A change to a value\n */\nexport type PathDataChange<V> = PathData<V> & {\n    /**\n     * Previous value, if any\n     */\n    previous?: V;\n    /**\n     * Nature of the change\n     */\n    state: `change` | `added` | `removed`;\n};\n/**\n * Compare data\n */\nexport type CompareDataOptions<V> = {\n    /**\n     * If _true_, it treats the B value as a partial\n     * version of B. Only the things present in B are compared.\n     * Omissions from B are not treated as removed keys.\n     */\n    asPartial: boolean;\n    /**\n     * If _true_ (default), if a value is undefined,\n     * it signals that the key itself is removed.\n     */\n    undefinedValueMeansRemoved: boolean;\n    pathPrefix: string;\n    /**\n     * Comparison function for values. By default uses\n     * JSON.stringify() to compare by value.\n     */\n    eq: IsEqualContext<V>;\n    /**\n     * If true, inherited fields are also compared.\n     * This is necessary for events, for example.\n     *\n     * Only plain-object values are used, the other keys are ignored.\n     */\n    deepEntries: boolean;\n    /**\n     * If _true_, includes fields that are present in B, but missing in A.\n     * _False_ by default.\n     */\n    includeMissingFromA: boolean;\n    /**\n     * If _true_, emits a change under the path of a parent if its child has changed.\n     * If _false_ (default) only changed keys are emitted.\n     *\n     * Eg if data is:\n     * `{ colour: { h:0.5, s: 0.3, l: 0.5 }}`\n     * and we compare with:\n     * `{ colour: { h:1, s: 0.3, l: 0.5 }}`\n     *\n     * By default only 'colour.h' is emitted. If _true_ is set, 'colour' and 'colour.h' is emitted.\n     */\n    includeParents: boolean;\n    skipInstances: WeakSet<any>;\n};\n/**\n * Scans object, producing a list of changed fields where B's value (newer) differs from A (older).\n *\n * Options:\n * - `deepEntries` (_false_): If _false_ Object.entries are used to scan the object. However this won't work for some objects, eg event args, thus _true_ is needed.\n * - `eq` (JSON.stringify): By-value comparison function\n * - `includeMissingFromA` (_false): If _true_ includes fields present on B but missing on A.\n * - `asPartial` (_false): If _true_, treats B as a partial update to B. This means that things missing from B are not considered removals.\n * @param a 'Old' value\n * @param b 'New' value\n * @param options Options for comparison\n * @returns\n */\nexport declare function compareData<V extends Record<string, any>>(a: V, b: Partial<V>, options?: Partial<CompareDataOptions<V>>): Generator<PathDataChange<any>>;\n/**\n * Returns a copy of `source` with `changes` applied.\n * @param source\n * @param changes\n */\nexport declare const applyChanges: <V extends Record<string, any>>(source: V, changes: PathDataChange<any>[]) => V;\n/**\n * Returns a copy of `target` object with a specified path changed to `value`.\n *\n * ```js\n * const a = {\n *  message: `Hello`,\n *  position: { x: 10, y: 20 }\n * }\n *\n * const a1 = updateByPath(a, `message`, `new message`);\n * // a1 = { message: `new message`, position: { x: 10, y: 20 }}\n * const a2 = updateByPath(a, `position.x`, 20);\n * // a2 = { message: `hello`, position: { x: 20, y: 20 }}\n * ```\n *\n * Paths can also be array indexes:\n * ```js\n * updateByPath([`a`,`b`,`c`], 2, `d`);\n * // Yields: [ `a`, `b`, `d` ]\n * ```\n *\n * By default, only existing array indexes can be updated. Use the `allowShapeChange` parameter\n * to allow setting arbitrary indexes.\n * ```js\n * // Throws because array index 3 is undefined\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`);\n *\n * // With allowShapeChange flag\n * updateByPath([ `a`, `b`, `c` ], `3`, `d`, true);\n * // Returns: [ `a`, `b`, `c`, `d` ]\n * ```\n *\n * Throws an error if:\n * * `path` cannot be resolved (eg. `position.z` in the above example)\n * * `value` applied to `target` results in the object having a different shape (eg missing a field, field\n * changing type, or array index out of bounds). Use `allowShapeChange` to suppress this error.\n * * Path is undefined or not a string\n * * Target is undefined/null\n * @param target Object to update\n * @param path Path to set value\n * @param value Value to set\n * @param allowShapeChange By default _false_, throwing an error if an update change the shape of the original object.\n * @returns\n */\nexport declare const updateByPath: <V extends Record<string, any>>(target: V, path: string, value: any, allowShapeChange?: boolean) => V;\n/**\n * Gets the data at `path` in `object`. Assumes '.' separates each segment of path.\n *\n * ```js\n * getField({ name: { first: `Thom`, last: `Yorke` }}, `name.first`); // { value: `Thom`  success: true }\n * getField({ colours: [`red`, `green`, `blue` ]}, `colours.1`);      // { value: `green` success: true }\n * ```\n *\n * Returns an error result with more details, eg `{ success: false, error: 'Path could not be found' }`\n *\n * Throws if:\n * * `path` is not a string or empty\n * * `object` is _undefined_ or null\n * @param object Object to query\n * @param path Path\n * @param separator Separator of chunks of path. Defaults to '.'\n * @returns\n */\nexport declare const getField: <V>(object: Record<string, any>, path: string, separator?: string) => Result<V, any>;\n/**\n * Iterates 'paths' for all the fields on `o`\n * ```\n * const d = {\n *  accel: { x: 1, y: 2, z: 3 },\n *  gyro: { x: 4, y: 5, z: 6 }\n * };\n * const paths = [...getFieldPaths(d)];\n * // Yields [ `accel`, `gyro`, `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * Use {@link getField} to fetch data based on a path\n *\n * If object is _null_ or _undefined_, no results are returned.\n *\n * If `onlyLeaves` is _true_ (default: _false_), only 'leaf' nodes are included.\n * Leaf nodes are those that contain a primitive value.\n * ```js\n * const paths = getFieldPaths(d, true);\n * // Yields [ `accel.x`, `accel.y`,`accel.z`,`gyro.x`,`gyro.y`,`gyro.z` ]\n * ```\n *\n * @param object Object to get paths for.\n * @param onlyLeaves If true, only paths with a primitive value are returned.\n * @returns\n */\nexport declare function getPaths(object: object | null, onlyLeaves?: boolean): Generator<string>;\n/**\n * Returns a representation of the object as a set of paths and data.\n * ```js\n * const o = { name: `hello`, size: 20, colour: { r:200, g:100, b:40 } }\n * const pd = [...getPathsAndData(o)];\n * // Yields:\n * // [\n * // { path: `name`, value: `hello` },\n * // { path: `size`, value: `20` },\n * // { path: `colour.r`, value: `200` },\n * // { path: `colour.g`, value: `100` },\n * // { path: `colour.b`, value: `40` }\n * //]\n * ```\n * @param o Object to get paths and data for\n * @param maxDepth Set maximum recursion depth. By default unlimited.\n * @param prefix Manually set a path prefix if it's necessary\n * @returns\n */\nexport declare function getPathsAndData(o: object, onlyLeaves?: boolean, maxDepth?: number, prefix?: string): Generator<PathData<any>>;\n//# sourceMappingURL=pathed.d.ts.map"],"mappings":"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"}