{"version":3,"file":"src-D9XCZEsz.js","names":["manual","run","iterator","field","event","field","value","event","field","elapsed","debounce","debounceReactive","elapsed","interpolate","interpolateFunction","max","min","average","sum","tally","rank","annotate","event","event","init","elapsed","array","ArraysRemove","filter","count","insertAt","ArraysInsertAt","remove","count","elapsed","target","init","event","process","source","rank","to","transform"],"sources":["../packages/rx/dist/src/util.js","../packages/rx/dist/src/from/function.js","../packages/rx/dist/src/from/iterator.js","../packages/rx/dist/src/resolve-source.js","../packages/rx/dist/src/cache.js","../packages/rx/dist/src/init-stream.js","../packages/rx/dist/src/sinks/dom.js","../packages/rx/dist/src/to-readable.js","../packages/rx/dist/src/ops/annotate.js","../packages/rx/dist/src/ops/chunk.js","../packages/rx/dist/src/ops/transform.js","../packages/rx/dist/src/ops/clone-from-fields.js","../packages/rx/dist/src/ops/combine-latest-to-array.js","../packages/rx/dist/src/from/object.js","../packages/rx/dist/src/ops/combine-latest-to-object.js","../packages/rx/dist/src/ops/compute-with-previous.js","../packages/rx/dist/src/reactives/debounce.js","../packages/rx/dist/src/ops/debounce.js","../packages/rx/dist/src/ops/elapsed.js","../packages/rx/dist/src/ops/field.js","../packages/rx/dist/src/ops/filter.js","../packages/rx/dist/src/ops/interpolate.js","../packages/rx/dist/src/ops/math.js","../packages/rx/dist/src/ops/pipe.js","../packages/rx/dist/src/ops/single-from-array.js","../packages/rx/dist/src/ops/split.js","../packages/rx/dist/src/ops/switcher.js","../packages/rx/dist/src/ops/sync-to-array.js","../packages/rx/dist/src/ops/sync-to-object.js","../packages/rx/dist/src/ops/tap.js","../packages/rx/dist/src/ops/throttle.js","../packages/rx/dist/src/ops/timeout-value.js","../packages/rx/dist/src/ops/timeout-ping.js","../packages/rx/dist/src/ops/value-to-ping.js","../packages/rx/dist/src/ops/with-value.js","../packages/rx/dist/src/from/array.js","../packages/rx/dist/src/from/array-object.js","../packages/rx/dist/src/from/boolean.js","../packages/rx/dist/src/from/count.js","../packages/rx/dist/src/from/derived.js","../packages/rx/dist/src/from/event.js","../packages/rx/dist/src/from/merged.js","../packages/rx/dist/src/from/number.js","../packages/rx/dist/src/types.js","../packages/rx/dist/src/from/object-proxy.js","../packages/rx/dist/src/from/observable.js","../packages/rx/dist/src/from/string.js","../packages/rx/dist/src/from/index.js","../packages/rx/dist/src/collections/responsive-queue.js","../packages/rx/dist/src/collections/index.js","../packages/rx/dist/src/graph.js","../packages/rx/dist/src/to-array.js","../packages/rx/dist/src/to-generator.js","../packages/rx/dist/src/wrap.js","../packages/rx/dist/src/index.js"],"sourcesContent":["import { isIterable } from \"@ixfx/iterables\";\nexport function messageIsSignal(message) {\n    if (message.value !== undefined)\n        return false;\n    if (`signal` in message && message.signal !== undefined)\n        return true;\n    return false;\n}\nexport function messageIsDoneSignal(message) {\n    if (message.value !== undefined)\n        return false;\n    if (`signal` in message && message.signal === `done`)\n        return true;\n    return false;\n}\n/**\n * Returns _true_ if `v` has a non-undefined value. Note that sometimes\n * _undefined_ is a legal value to pass\n * @param v\n * @returns\n */\nexport function messageHasValue(v) {\n    if (v.value !== undefined)\n        return true;\n    return false;\n}\nexport const isPingable = (rx) => {\n    if (!isReactive(rx))\n        return false;\n    if (`ping` in rx) {\n        return true;\n    }\n    return false;\n};\nexport const hasLast = (rx) => {\n    if (!isReactive(rx))\n        return false;\n    if (`last` in rx) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        const v = rx.last();\n        if (v !== undefined)\n            return true;\n    }\n    return false;\n};\n/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx\n * @returns\n */\nexport const isReactive = (rx) => {\n    if (typeof rx !== `object`)\n        return false;\n    if (rx === null)\n        return false;\n    return (`on` in rx && `onValue` in rx);\n};\n/**\n * Returns true if `rx` is a disposable reactive.\n * @param rx\n * @returns\n */\n// export const isDisposable = <V>(rx: Reactive<V> | ReactiveWritable<V>): rx is ReactiveDisposable<V> => {\n//   if (!isReactive(rx)) return false;\n//   return (`isDisposed` in rx && `dispose` in rx);\n// }\n/**\n * Returns _true_ if `rx` is a writable Reactive\n * @param rx\n * @returns\n */\nexport const isWritable = (rx) => {\n    if (!isReactive(rx))\n        return false;\n    if (`set` in rx)\n        return true;\n    return false;\n};\nexport const isWrapped = (v) => {\n    if (typeof v !== `object`)\n        return false;\n    if (!(`source` in v))\n        return false;\n    if (!(`annotate` in v))\n        return false;\n    return true;\n};\n// export const opify = <TIn, TOut = TIn,>(fn: (source: ReactiveOrSource<TIn>, ...args: Array<any>) => Reactive<TOut>, ...args: Array<any>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     return fn(source, ...args);\n//   }\n// }\nexport const opify = (fn, ...args) => {\n    return (source) => {\n        return fn(source, ...args);\n    };\n};\nexport const isTriggerValue = (t) => (`value` in t);\nexport const isTriggerFunction = (t) => (`fn` in t);\nexport const isTriggerGenerator = (t) => isIterable(t);\nexport const isTrigger = (t) => {\n    if (typeof t !== `object`)\n        return false;\n    if (isTriggerValue(t))\n        return true;\n    if (isTriggerFunction(t))\n        return true;\n    if (isTriggerGenerator(t))\n        return true;\n    return false;\n};\n/**\n * Resolves a trigger value.\n *\n * A trigger can be a value, a function or generator. Value triggers never complete.\n * A trigger function is considered complete if it returns undefined.\n * A trigger generator is considered complete if it returns done.\n *\n * Returns `[value, _false_]` if we have a value and trigger is not completed.\n * Returns `[value, _true_]` trigger is completed\n * @param t\n * @returns\n */\nexport function resolveTriggerValue(t) {\n    if (isTriggerValue(t))\n        return [t.value, false];\n    if (isTriggerFunction(t)) {\n        const v = t.fn();\n        if (v === undefined)\n            return [undefined, true];\n        return [v, false];\n    }\n    if (isTriggerGenerator(t)) {\n        const v = t.gen.next();\n        if (v.done)\n            return [undefined, true];\n        return [v.value, false];\n    }\n    throw new Error(`Invalid trigger. Missing 'value' or 'fn' fields`);\n}\n","import { continuously, intervalToMs } from \"@ixfx/core\";\nimport { getErrorMessage } from \"@ixfx/debug\";\nimport { sleep } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\n/**\n * Produces a reactive from the basis of a function. `callback` is executed, with its result emitted via the returned reactive.\n *\n * ```js\n * // Produce a random number every second\n * const r = Rx.From.func(Math.random, { interval: 1000 });\n * ```\n *\n * `callback` can be called repeatedly by providing the `interval` option to set the rate of repeat.\n * Looping can be limited with `options.maximumRepeats`, or passing a signal `options.signal`\n * and then activating it.\n * ```js\n * // Reactive that emits a random number every second, five times\n * const r1 = Rx.From.func(Math.random, { interval: 1000, maximumRepeats: 5 }\n * ```\n *\n * ```js\n * // Generate a random number every second until ac.abort() is called\n * const ac = new AbortController();\n * const r2 = Rx.From.func(Math.random, { interval: 1000, signal: ac.signal });\n * ```\n *\n * The third option is for `callback` to fire the provided abort function.\n * ```js\n * Rx.From.func((abort) => {\n *  if (Math.random() > 0.5) abort('Random exit');\n *  return 1;\n * });\n * ```\n *\n * By default has a laziness of 'very' meaning that `callback` is run only when there's a subscriber\n * By default stream closes if `callback` throws an error. Use `options.closeOnError:'ignore'` to change.\n * @param callback\n * @param options\n * @returns\n */\nexport function func(callback, options = {}) {\n    const maximumRepeats = options.maximumRepeats ?? Number.MAX_SAFE_INTEGER;\n    const closeOnError = options.closeOnError ?? true;\n    const intervalMs = options.interval ? intervalToMs(options.interval) : -1;\n    let manual = options.manual ?? false;\n    // If niether interval or manual is set, assume manual\n    if (options.interval === undefined && options.manual === undefined)\n        manual = true;\n    if (manual && options.interval)\n        throw new Error(`If option 'manual' is set, option 'interval' cannot be used`);\n    const predelay = intervalToMs(options.predelay, 0);\n    const lazy = options.lazy ?? `very`;\n    const signal = options.signal;\n    const internalAbort = new AbortController();\n    const internalAbortCallback = (reason) => { internalAbort.abort(reason); };\n    let sentResults = 0;\n    let enabled = false;\n    const done = (reason) => {\n        events.dispose(reason);\n        enabled = false;\n        if (run)\n            run.cancel();\n    };\n    const ping = async () => {\n        if (!enabled)\n            return false;\n        if (predelay)\n            await sleep(predelay);\n        if (sentResults >= maximumRepeats) {\n            done(`Maximum repeats reached ${maximumRepeats.toString()}`);\n            return false;\n        }\n        //console.log(`sent: ${ sentResults } max: ${ maximumRepeats }`);\n        try {\n            if (signal?.aborted) {\n                done(`Signal (${signal.aborted})`);\n                return false;\n            }\n            const value = await callback(internalAbortCallback);\n            sentResults++;\n            events.set(value);\n            return true;\n        }\n        catch (error) {\n            if (closeOnError) {\n                done(`Function error: ${getErrorMessage(error)}`);\n                return false;\n            }\n            else {\n                events.signal(`warn`, getErrorMessage(error));\n                return true;\n            }\n        }\n    };\n    const run = manual ? undefined : continuously(async () => {\n        const pingResult = await ping();\n        if (!pingResult)\n            return false;\n        // if (!loop) {\n        //   done(`fromFunction done`);\n        //   return false; // Stop loop\n        // }\n        if (internalAbort.signal.aborted) {\n            done(`callback function aborted (${internalAbort.signal.reason})`);\n            return false;\n        }\n    }, intervalMs);\n    const events = initLazyStream({\n        lazy,\n        onStart() {\n            enabled = true;\n            if (run)\n                run.start();\n        },\n        onStop() {\n            enabled = false;\n            if (run)\n                run.cancel();\n        },\n    });\n    if (lazy === `never` && run)\n        run.start();\n    return { ...events, ping };\n}\n","import { nextWithTimeout } from \"@ixfx/iterables/async\";\nimport { intervalToMs } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\nimport { isAsyncIterable } from \"@ixfx/iterables\";\nimport * as StateMachine from \"@ixfx/flow/state-machine\";\n/**\n * Creates a Reactive from an AsyncGenerator or Generator\n * @param gen\n * @returns\n */\n// export function readFromGenerator<V>(gen: AsyncGenerator<V> | Generator<V>) {\n//   const rx = initStream<V>();\n//   // eslint-disable-next-line @typescript-eslint/no-misused-promises\n//   setTimeout(async () => {\n//     try {\n//       for await (const value of gen) {\n//         rx.set(value);\n//       }\n//       rx.dispose(`Source generator complete`);\n//     } catch (error) {\n//       console.error(error);\n//       rx.dispose(`Error while iterating`);\n//     }\n//   }, 1);\n//   return rx;\n// }\n/**\n * Creates a readable reactive based on a (async)generator or iterator\n * ```js\n * // Generator a random value every 5 seconds\n * const valuesOverTime = Flow.interval(() => Math.random(), 5000);\n * // Wrap the generator\n * const r = Rx.From.iterator(time);\n * // Get notified when there is a new value\n * r.onValue(v => {\n *   console.log(v);\n * });\n * ```\n *\n * Awaiting values could potentially hang code. Thus there is a `readTimeout`, the maximum time to wait for a value from the generator. Default: 5 minutes.\n * If `signal` is given, this will also cancel waiting for the value.\n * @param source\n */\nexport function iterator(source, options = {}) {\n    const lazy = options.lazy ?? `very`;\n    const log = options.traceLifecycle ? (message) => { console.log(`Rx.From.iterator ${message}`); } : (_) => { };\n    const readIntervalMs = intervalToMs(options.readInterval, 5);\n    const readTimeoutMs = intervalToMs(options.readTimeout, 5 * 60 * 1000);\n    const whenStopped = options.whenStopped ?? `continue`;\n    let iterator;\n    //let reading = false;\n    let ourAc;\n    let sm = StateMachine.init({\n        idle: [`wait_for_next`],\n        wait_for_next: [`processing_result`, `stopping`, `disposed`],\n        processing_result: [`queued`, `disposed`, `stopping`],\n        queued: [`wait_for_next`, `disposed`, `stopping`],\n        stopping: `idle`,\n        disposed: null\n    }, `idle`);\n    const onExternalSignal = () => {\n        log(`onExternalSignal`);\n        ourAc?.abort(options.signal?.reason);\n    };\n    if (options.signal) {\n        options.signal.addEventListener(`abort`, onExternalSignal, { once: true });\n    }\n    ;\n    const read = async () => {\n        log(`read. State: ${sm.value}`);\n        ourAc = new AbortController();\n        try {\n            sm = StateMachine.to(sm, `wait_for_next`);\n            const v = await nextWithTimeout(iterator, { signal: ourAc.signal, millis: readTimeoutMs });\n            sm = StateMachine.to(sm, `processing_result`);\n            ourAc.abort(`nextWithTimeout completed`);\n            if (v.done) {\n                log(`read v.done true`);\n                events.dispose(`Generator complete`);\n                //reading = false;\n                sm = StateMachine.to(sm, `disposed`);\n            }\n            //if (!reading) return;\n            if (sm.value === `stopping`) {\n                log(`read. sm.value = stopping`);\n                sm = StateMachine.to(sm, `idle`);\n                return;\n            }\n            if (sm.value === `disposed`) {\n                log(`read. sm.value = disposed`);\n                return;\n            }\n            events.set(v.value);\n        }\n        catch (error) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n            events.dispose(`Generator error: ${error.toString()}`);\n            return;\n        }\n        //if (events.isDisposed()) return;\n        //if (!reading) return;\n        if (sm.value === `processing_result`) {\n            sm = StateMachine.to(sm, `queued`);\n            log(`scheduling read. State: ${sm.value}`);\n            // eslint-disable-next-line @typescript-eslint/no-misused-promises\n            setTimeout(read, readIntervalMs);\n        }\n        else {\n            sm = StateMachine.to(sm, `idle`);\n        }\n    };\n    const events = initLazyStream({\n        ...options,\n        lazy,\n        onStart() {\n            log(`onStart state: ${sm.value} whenStopped: ${whenStopped}`);\n            if (sm.value !== `idle`)\n                return;\n            if ((sm.value === `idle` && whenStopped === `reset`) || iterator === undefined) {\n                iterator = isAsyncIterable(source) ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();\n            }\n            //reading = true;\n            void read();\n        },\n        onStop() {\n            log(`onStop state: ${sm.value} whenStopped: ${whenStopped}`);\n            //reading = false;\n            sm = StateMachine.to(sm, `stopping`);\n            if (whenStopped === `reset`) {\n                log(`onStop reiniting iterator`);\n                iterator = isAsyncIterable(source) ? source[Symbol.asyncIterator]() : source[Symbol.iterator]();\n            }\n        },\n        onDispose(reason) {\n            log(`onDispose (${reason})`);\n            ourAc?.abort(`Rx.From.iterator disposed (${reason})`);\n            if (options.signal)\n                options.signal.removeEventListener(`abort`, onExternalSignal);\n        },\n    });\n    // const readingStart = () => {\n    // }\n    //if (!lazy) readingStart();\n    // return {\n    //   on: events.on,\n    //   value: events.value,\n    //   dispose: events.dispose,\n    //   isDisposed: events.isDisposed\n    // }\n    return events;\n}\n","import { isAsyncIterable, isIterable } from \"@ixfx/iterables\";\nimport { func } from \"./from/function.js\";\nimport { iterator } from \"./from/iterator.js\";\nimport { isReactive, isWrapped } from \"./util.js\";\n/**\n * Resolves various kinds of sources into a Reactive.\n * If `source` is an iterable/generator, it gets wrapped via `generator()`.\n *\n * Default options:\n * * generator: `{ lazy: true, interval: 5 }`\n * @param source\n * @returns\n */\nexport const resolveSource = (source, options = {}) => {\n    if (isReactive(source))\n        return source;\n    const generatorOptions = options.generator ?? { lazy: `initial`, interval: 5 };\n    const functionOptions = options.function ?? { lazy: `very` };\n    if (Array.isArray(source)) {\n        return iterator(source.values(), generatorOptions);\n    }\n    else if (typeof source === `function`) {\n        return func(source, functionOptions);\n    }\n    else if (typeof source === `object`) {\n        //console.log(`resolveSource is object`);\n        if (isWrapped(source)) {\n            //console.log(`resolveSource is object - wrapped`);\n            return source.source;\n        }\n        if (isIterable(source) || isAsyncIterable(source)) {\n            //console.log(`resolveSource is object - iterable`);\n            return iterator(source, generatorOptions);\n        }\n    }\n    throw new TypeError(`Unable to resolve source. Supports: array, Reactive, Async/Iterable. Got type: ${typeof source}`);\n};\n","/**\n * Wrapes an input stream to cache values, optionally providing an initial value\n * @param r\n * @param initialValue\n * @returns\n */\nexport function cache(r, initialValue) {\n    let lastValue = initialValue;\n    r.onValue(value => {\n        lastValue = value;\n    });\n    return {\n        ...r,\n        last() {\n            return lastValue;\n        },\n        resetCachedValue() {\n            lastValue = undefined;\n        }\n    };\n}\n","import { DispatchList } from \"@ixfx/flow\";\nimport { resolveSource } from \"./resolve-source.js\";\nimport { messageHasValue, messageIsSignal } from \"./util.js\";\nimport { cache } from \"./cache.js\";\n/**\n * Initialise a stream based on an upstream source.\n * Calls initLazyStream under the hood.\n *\n * Options:\n * * onValue: called when upstream emits a value (default: does nothing with upstream value)\n * * lazy: laziness of stream (default: 'initial')\n * * disposeIfSourceDone: disposes stream if upstream disposes (default: true)\n * @ignore\n * @param upstreamSource\n * @param options\n * @returns\n */\nexport function initUpstream(upstreamSource, options) {\n    const lazy = options.lazy ?? `initial`;\n    const disposeIfSourceDone = options.disposeIfSourceDone ?? true;\n    const onValue = options.onValue ?? ((_v) => { });\n    const source = resolveSource(upstreamSource);\n    let unsub;\n    const debugLabel = options.debugLabel ? `[${options.debugLabel}]` : ``;\n    //console.log(`initUpstream${ debugLabel } creating`);\n    const onStop = () => {\n        //console.log(`Rx.initStream${ debugLabel } stop`);\n        if (unsub === undefined)\n            return;\n        unsub();\n        unsub = undefined;\n        if (options.onStop)\n            options.onStop();\n    };\n    const onStart = () => {\n        //console.log(`Rx.initStream${ debugLabel } start unsub ${ unsub !== undefined }`);\n        if (unsub !== undefined)\n            return;\n        if (options.onStart)\n            options.onStart();\n        unsub = source.on(value => {\n            //console.log(`Rx.initStream${ debugLabel } onValue`, value);\n            if (messageIsSignal(value)) {\n                if (value.signal === `done`) {\n                    onStop();\n                    events.signal(value.signal, value.context);\n                    if (disposeIfSourceDone)\n                        events.dispose(`Upstream source ${debugLabel} has completed (${value.context ?? ``})`);\n                }\n                else {\n                    //events.through_(value);\n                    events.signal(value.signal, value.context);\n                }\n            }\n            else if (messageHasValue(value)) {\n                //lastValue = value.value;\n                onValue(value.value);\n            }\n        });\n    };\n    //const initOpts = \n    // const events:ReactiveInitialStream<Out>|ReactiveStream<Out> = ((`initialValue` in options) && options.initialValue !== undefined) ?\n    //   initLazyStreamWithInitial<Out>({ ...initOpts, initialValue: options.initialValue }) :\n    //   initLazyStream<Out>(initOpts);\n    //console.log(`initUpstream${ debugLabel } creating initLazyStream`);\n    const events = initLazyStream({\n        ...options,\n        lazy,\n        onStart,\n        onStop\n    });\n    return events;\n}\n/**\n * Initialises a lazy stream with an initial value.\n * Uses {@link initLazyStream} and {@link cache} together.\n * @param options\n * @returns\n */\nexport function initLazyStreamWithInitial(options) {\n    const r = initLazyStream(options);\n    const c = cache(r, options.initialValue);\n    return c;\n}\n/**\n * Initialises a lazy stream\n * Consider also: {@link initLazyStreamWithInitial}\n *\n * @param options\n * @returns\n */\nexport function initLazyStream(options) {\n    const lazy = options.lazy ?? `initial`;\n    const onStop = options.onStop ?? (() => { });\n    const onStart = options.onStart ?? (() => { });\n    const debugLabel = options.debugLabel ? `[${options.debugLabel}]` : ``;\n    const events = initStream({\n        ...options,\n        onFirstSubscribe() {\n            if (lazy !== `never`) {\n                //console.log(`initLazyStream${ debugLabel } onFirstSubscribe, lazy: ${ lazy }. Calling onStart`);\n                onStart();\n            }\n        },\n        onNoSubscribers() {\n            if (lazy === `very`) {\n                //console.log(`initLazyStream${ debugLabel } onNoSubscribers, lazy: ${ lazy }. Calling onStop`);\n                onStop();\n            }\n        },\n    });\n    if (lazy === `never`)\n        onStart();\n    return events;\n}\n/**\n * Initialises a new stream.\n *\n * Options:\n * * onFirstSubscribe: Called when there is a subscriber after there have been no subscribers.\n * * onNoSubscribers: Called when there are no more subscribers. 'onFirstSubscriber' will be called next time a subscriber is added.\n *\n * Alternatives:\n * * {@link initLazyStream} - a stream with callbacks for when there is some/none subscribers\n * @ignore\n * @param options\n * @returns\n */\nexport function initStream(options = {}) {\n    let dispatcher;\n    let disposed = false;\n    let firstSubscribe = false;\n    let emptySubscriptions = true;\n    const onFirstSubscribe = options.onFirstSubscribe ?? undefined;\n    const onNoSubscribers = options.onNoSubscribers ?? undefined;\n    const debugLabel = options.debugLabel ? `[${options.debugLabel}]` : ``;\n    const isEmpty = () => {\n        if (dispatcher === undefined)\n            return;\n        if (!dispatcher.isEmpty)\n            return;\n        if (!emptySubscriptions) {\n            emptySubscriptions = true;\n            firstSubscribe = false;\n            if (onNoSubscribers)\n                onNoSubscribers();\n        }\n    };\n    const subscribe = (handler) => {\n        if (disposed)\n            throw new Error(`Disposed, cannot subscribe ${debugLabel}`);\n        if (dispatcher === undefined)\n            dispatcher = new DispatchList();\n        //console.log(`initStream${ debugLabel } subscribe handler:`, handler);\n        const id = dispatcher.add(handler);\n        emptySubscriptions = false;\n        if (!firstSubscribe) {\n            firstSubscribe = true;\n            //if (onFirstSubscribe) setTimeout(() => { onFirstSubscribe() }, 10);\n            if (onFirstSubscribe)\n                onFirstSubscribe();\n        }\n        return () => {\n            dispatcher?.remove(id);\n            isEmpty();\n        };\n    };\n    return {\n        dispose: (reason) => {\n            if (disposed)\n                return;\n            dispatcher?.notify({ value: undefined, signal: `done`, context: `Disposed: ${reason}` });\n            disposed = true;\n            if (options.onDispose)\n                options.onDispose(reason);\n        },\n        isDisposed: () => {\n            return disposed;\n        },\n        removeAllSubscribers: () => {\n            dispatcher?.clear();\n            isEmpty();\n        },\n        set: (v) => {\n            if (disposed)\n                throw new Error(`${debugLabel} Disposed, cannot set`);\n            dispatcher?.notify({ value: v });\n        },\n        // through: (pass: Passed<V>) => {\n        //   if (disposed) throw new Error(`Disposed, cannot through`);\n        //   dispatcher?.notify(pass)\n        // },\n        signal: (signal, context) => {\n            if (disposed)\n                throw new Error(`${debugLabel} Disposed, cannot signal`);\n            dispatcher?.notify({ signal, value: undefined, context });\n        },\n        on: (handler) => subscribe(handler),\n        onValue: (handler) => {\n            const unsub = subscribe(message => {\n                //console.log(`initStream${ debugLabel } onValue wrapper`, message);\n                if (messageHasValue(message)) {\n                    handler(message.value);\n                }\n            });\n            return unsub;\n        }\n    };\n}\n","import { setProperty } from \"@ixfx/dom\";\nimport { resolveSource } from \"../resolve-source.js\";\n/**\n * Values from `input` are set to the textContent/innerHTML of an element.\n * ```js\n * const rxSource = Rx.From.string('hello');\n * const rxSet = Rx.Sinks.setHtmlText(rxSource, { query: })\n * ```\n * @param rxOrSource\n * @param optionsOrElementOrQuery\n */\nexport const setHtmlText = (rxOrSource, optionsOrElementOrQuery) => {\n    let el;\n    let options;\n    if (typeof optionsOrElementOrQuery === `string`) {\n        options = { query: optionsOrElementOrQuery };\n    }\n    if (typeof optionsOrElementOrQuery === `object`) {\n        if (`nodeName` in optionsOrElementOrQuery) {\n            options = { el: optionsOrElementOrQuery };\n        }\n        else {\n            options = optionsOrElementOrQuery;\n        }\n    }\n    if (options === undefined)\n        throw new TypeError(`Missing element as second parameter or option`);\n    if (`el` in options) {\n        el = options.el;\n    }\n    else if (`query` in options) {\n        el = document.querySelector(options.query);\n    }\n    else {\n        throw new TypeError(`Options does not include 'el' or 'query' fields`);\n    }\n    if (el === null || el === undefined)\n        throw new Error(`Element could not be resolved.`);\n    const stream = resolveSource(rxOrSource);\n    const setter = setProperty(options.asHtml ? `innerHTML` : `textContent`, el);\n    const off = stream.onValue(value => {\n        setter(value);\n    });\n    return off;\n};\n","/***\n * Returns a read-only version of `stream`\n */\nexport const toReadable = (stream) => ({\n    on: stream.on,\n    dispose: stream.dispose,\n    isDisposed: stream.isDisposed,\n    onValue: stream.onValue\n});\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport { resolveSource, syncToObject } from \"../index.js\";\n/**\n * Annotates values from `source`. Output values will be\n * in the form `{ value: TIn, annotation: TAnnotation }`.\n * Where `TIn` is the type of the input, and `TAnnotation` is\n * the return type of the annotator function.\n *\n * Example calculating area from width & height:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const annotated = Rx.Ops.annotate(data, v => {\n *  return { area: v.w * v.h }\n * });\n * const data = await Rx.toArray(annotated);\n * // Data =  [ { value: { w:1, h:3 }, annotation: { area:3 } } ...]\n * ```\n *\n * If you would rather annotate and have values merge with the input,\n * use `transform`:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const withArea = Rx.Ops.transform(data, v => {\n *  return { ...v, area: v.w * v.h }\n * });\n * const data = await Rx.toArray(withArea);\n * // Data =  [ { w:1, h:3, area:3 }, ...]\n * ```\n */\nexport function annotate(input, annotator, options = {}) {\n    const upstream = initUpstream(input, {\n        ...options,\n        onValue(value) {\n            const annotation = annotator(value);\n            upstream.set({ value, annotation });\n        },\n    });\n    return toReadable(upstream);\n}\n/**\n * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n *\n * ```js\n * const data = Rx.From.array([ 1, 2, 3 ]);\n * const annotated = Rx.Ops.annotateWithOp(data, Rx.Ops.sum());\n * const data = await annotated.toArray(annotated);\n * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n * ```\n * @param annotatorOp Operator to generate annotations\n * @param input Input stream\n * @returns\n */\nexport function annotateWithOp(input, annotatorOp) {\n    const inputStream = resolveSource(input);\n    // Create annotations from input\n    const stream = annotatorOp(inputStream);\n    const synced = syncToObject({\n        value: inputStream,\n        annotation: stream\n    });\n    return synced;\n}\n","import { QueueMutable } from \"@ixfx/collections\";\nimport { timeout } from \"@ixfx/flow\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Queue from `source`, emitting when thresholds are reached.\n * The resulting Reactive produces arrays.\n *\n * Can use a combination of elapsed time or number of data items.\n *\n * By default options are OR'ed together.\n *\n * ```js\n * // Emit data in chunks of 5 items\n * chunk(source, { quantity: 5 });\n * // Emit a chunk of data every second\n * chunk(source, { elapsed: 1000 });\n * ```\n * @param source\n * @param options\n * @returns\n */\nexport function chunk(source, options = {}) {\n    const queue = new QueueMutable();\n    const quantity = options.quantity ?? 0;\n    const returnRemainder = options.returnRemainder ?? true;\n    const upstreamOpts = {\n        ...options,\n        onStop() {\n            if (returnRemainder && !queue.isEmpty) {\n                const data = queue.toArray();\n                queue.clear();\n                upstream.set(data);\n            }\n        },\n        onValue(value) {\n            queue.enqueue(value);\n            if (quantity > 0 && queue.length >= quantity) {\n                // Reached quantity limit\n                send();\n            }\n            // Start timer\n            if (timer !== undefined && timer.runState === `idle`) {\n                timer.start();\n            }\n        },\n    };\n    const upstream = initUpstream(source, upstreamOpts);\n    //let testElapsed = performance.now();\n    const send = () => {\n        //console.log(`Elapsed: ${ performance.now() - testElapsed }`);\n        //testElapsed = performance.now();\n        if (queue.isEmpty)\n            return;\n        // Reset timer\n        if (timer !== undefined)\n            timer.start();\n        // Fire queued data\n        const data = queue.toArray();\n        queue.clear();\n        setTimeout(() => { upstream.set(data); });\n    };\n    const timer = options.elapsed ? timeout(send, options.elapsed) : undefined;\n    // const trigger = () => {\n    //   const now = performance.now();\n    //   let byElapsed = false;\n    //   let byLimit = false;\n    //   if (elapsed > 0 && (now - lastFire > elapsed)) {\n    //     lastFire = now;\n    //     byElapsed = true;\n    //   }\n    //   if (limit > 0 && queue.length >= limit) {\n    //     byLimit = true;\n    //   }\n    //   if (logic === `or` && (!byElapsed && !byLimit)) return;\n    //   if (logic === `and` && (!byElapsed || !byLimit)) return;\n    //   send();\n    // }\n    return toReadable(upstream);\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Transforms values from `source` using the `transformer` function.\n * @param transformer\n * @returns\n */\nexport function transform(input, transformer, options = {}) {\n    const traceInput = options.traceInput ?? false;\n    const traceOutput = options.traceOutput ?? false;\n    const upstream = initUpstream(input, {\n        lazy: `initial`,\n        ...options,\n        onValue(value) {\n            const t = transformer(value);\n            if (traceInput && traceOutput) {\n                console.log(`Rx.Ops.transform input: ${JSON.stringify(value)} output: ${JSON.stringify(t)}`);\n            }\n            else if (traceInput) {\n                console.log(`Rx.Ops.transform input: ${JSON.stringify(value)}`);\n            }\n            else if (traceOutput) {\n                console.log(`Rx.Ops.transform output: ${JSON.stringify(t)}`);\n            }\n            upstream.set(t);\n        },\n    });\n    return toReadable(upstream);\n}\n","import { testPlainObjectOrPrimitive } from \"@ixfx/guards\";\nimport { transform } from \"./transform.js\";\n/**\n * Create a new object from input, based on cloning fields rather than a destructured copy.\n * This is useful for event args.\n * @param source\n * @returns\n */\nexport const cloneFromFields = (source) => {\n    return transform(source, (v) => {\n        const entries = [];\n        for (const field in v) {\n            const value = (v)[field];\n            if (testPlainObjectOrPrimitive(value)) {\n                entries.push([field, value]);\n            }\n        }\n        return Object.fromEntries(entries);\n    });\n};\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { messageIsDoneSignal, messageHasValue } from \"../util.js\";\n/**\n * Monitors input reactive values, storing values as they happen to an array.\n * Whenever a new value is emitted, the whole array is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n *\n * See {@link combineLatestToObject} to combine streams by name into an object, rather than array.\n *\n * ```\n * const sources = [\n *  Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToArray(sources);\n * r.onValue(value => {\n *  // Value will be an array of last value from each source:\n *  // [number,number]\n * });\n * ```\n *\n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToArray} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n *\n * Set `onSourceDone` to choose behaviour if a source stops. By default it\n * is 'break', meaning the whole merged stream stops.\n *\n * Note: unlike RxJS's `combineLatest`, does not wait for each source to emit once\n * before emitting first value.\n * @param reactiveSources Sources to merge\n * @param options Options for merging\n * @returns\n */\nexport function combineLatestToArray(reactiveSources, options = {}) {\n    const event = initStream();\n    const onSourceDone = options.onSourceDone ?? `break`;\n    const data = [];\n    const sources = reactiveSources.map(source => resolveSource(source));\n    const noop = () => { };\n    const sourceOff = sources.map(_ => noop);\n    const doneSources = sources.map(_ => false);\n    const unsub = () => {\n        for (const v of sourceOff) {\n            v();\n        }\n    };\n    for (const [index, v] of sources.entries()) {\n        data[index] = undefined;\n        sourceOff[index] = v.on(message => {\n            if (messageIsDoneSignal(message)) {\n                doneSources[index] = true;\n                sourceOff[index]();\n                sourceOff[index] = noop;\n                if (onSourceDone === `break`) {\n                    unsub();\n                    event.dispose(`Source has completed and 'break' is set`);\n                    return;\n                }\n                if (!doneSources.includes(false)) {\n                    // All sources are done\n                    unsub();\n                    event.dispose(`All sources completed`);\n                }\n            }\n            else if (messageHasValue(message)) {\n                data[index] = message.value;\n                event.set([...data]);\n            }\n        });\n    }\n    return {\n        dispose: event.dispose,\n        isDisposed: event.isDisposed,\n        on: event.on,\n        onValue: event.onValue\n    };\n}\n","import { DispatchList } from \"@ixfx/flow\";\nimport { Pathed } from \"@ixfx/core\";\nimport { initStream } from \"../init-stream.js\";\nimport { isEqualContextString } from \"@ixfx/core\";\nimport { wildcard } from \"@ixfx/core/text\";\nimport { resultIsError, resultThrow, resultThrowSingle, resultToError } from \"@ixfx/guards\";\n/**\n * Creates a Reactive wrapper with the shape of the input object.\n *\n * Changing the wrapped object directly does not update the Reactive.\n * Instead, to update values use:\n * * `set()`, 'resets' the whole object\n * * `update()` changes a particular field\n *\n * Consider using {@link From.objectProxy} to return a object with properties that can be\n * set in the usual way yet is also Reactive.\n *\n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onValue(changed => {\n * });\n * o.set({ name: `mary`, level: 3 });\n *\n * // `onValue` will get called, with `changed` having a value of:\n * // { name: `mary`, level: 3 }\n * ```\n *\n * Use `last()` to get the most recently set value.\n *\n * `onDiff` subscribes to a rough diff of the object.\n *\n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onDiff(diffValue => {\n *  const diff = diffValue.value;\n * })\n * o.set({ name: `mary`, level: 3 });\n *\n * // onDiff would fire with `diff` of:\n * [\n *  { path: `name`, previous: `bob`, value: `mary` },\n *  { path: `level`, previous: 2, value: 3 }\n * ]\n * ```\n *\n * You can also listen to updates on a field via `onField`.\n * ```js\n * o.onField(`name`, value => {\n *  // Called whenever the 'name' field is updated\n * });\n * ```\n * @param initialValue  Initial value\n * @param options Options\n * @returns\n */\nexport function object(initialValue, options = {}) {\n    const eq = options.eq ?? isEqualContextString;\n    const setEvent = initStream();\n    const diffEvent = initStream();\n    //const fieldChangeEvents = new Map<string, DispatchList<ObjectFieldHandler>>;\n    const fieldChangeEvents = [];\n    let value = initialValue;\n    let disposed = false;\n    const set = (v) => {\n        const diff = [...Pathed.compareData(value ?? {}, v, { ...options, includeMissingFromA: true })];\n        if (diff.length === 0)\n            return;\n        value = v;\n        setEvent.set(v);\n        diffEvent.set(diff);\n    };\n    const fireFieldUpdate = (field, value) => {\n        for (const [matcher, pattern, list] of fieldChangeEvents) {\n            if (matcher(field)) {\n                list.notify({ fieldName: field, pattern, value });\n            }\n        }\n        //const l = fieldChangeEvents.get(field.toLowerCase());\n        //if (l === undefined) return;\n        //l.notify(value);\n    };\n    const updateCompareOptions = {\n        asPartial: true,\n        includeParents: true\n    };\n    const update = (toMerge) => {\n        //console.log(`Rx.From.object update: toMerge: ${ JSON.stringify(toMerge) } value: ${ JSON.stringify(value) }`);\n        if (value === undefined) {\n            value = toMerge;\n            setEvent.set(value);\n            for (const [k, v] of Object.entries(toMerge)) {\n                fireFieldUpdate(k, v);\n            }\n            return value;\n        }\n        else {\n            const diff = [...Pathed.compareData(value, toMerge, updateCompareOptions)];\n            //const diffWithoutRemoved = diff.filter(d => d.state !== `removed`);\n            if (diff.length === 0)\n                return value; // No changes\n            value = {\n                ...value,\n                ...toMerge\n            };\n            setEvent.set(value);\n            diffEvent.set(diff);\n            //console.log(`diff`, diff);\n            for (const d of diff) {\n                fireFieldUpdate(d.path, d.value);\n            }\n            return value;\n        }\n    };\n    const updateField = (path, valueForField) => {\n        if (value === undefined)\n            throw new Error(`Cannot update value when it has not already been set`);\n        //console.log(`Rx.Sources.Object.updateField path: ${ path } value: ${ JSON.stringify(valueForField) }`);\n        const existing = Pathed.getField(value, path);\n        //resultThrowSingle(existing);\n        if (resultIsError(existing)) {\n            throw resultToError(existing);\n        }\n        //console.log(`Rx.fromObject.updateField path: ${ path } existing: ${ JSON.stringify(existing) }`);\n        if (eq(existing.value, valueForField, path)) {\n            //console.log(`Rx.object.updateField identical existing: ${ existing } value: ${ valueForField } path: ${ path }`);\n            return;\n        }\n        let diff = [...Pathed.compareData(existing.value, valueForField, { ...options, includeMissingFromA: true })];\n        diff = diff.map(d => {\n            if (d.path.length > 0)\n                return { ...d, path: path + `.` + d.path };\n            return { ...d, path };\n        });\n        //console.log(`Rx.fromObject.updateField diff path: ${ path }`, diff);\n        const o = Pathed.updateByPath(value, path, valueForField, true);\n        value = o;\n        //diffEvent.set([ { path, value: valueForField, previous: existing } ]);\n        setEvent.set(o);\n        diffEvent.set(diff);\n        fireFieldUpdate(path, valueForField);\n        //console.log(`Rx.fromObject.updateField: path: '${ path }' value: '${ JSON.stringify(valueForField) }' o: ${ JSON.stringify(o) }`);\n    };\n    const dispose = (reason) => {\n        if (disposed)\n            return;\n        diffEvent.dispose(reason);\n        setEvent.dispose(reason);\n        disposed = true;\n    };\n    return {\n        dispose,\n        isDisposed() {\n            return disposed;\n        },\n        /**\n         * Update a field.\n         * Exception is thrown if field does not exist\n         */\n        updateField,\n        last: () => value,\n        on: setEvent.on,\n        onValue: setEvent.onValue,\n        onDiff: diffEvent.onValue,\n        onField(fieldPattern, handler) {\n            const matcher = wildcard(fieldPattern);\n            const listeners = new DispatchList();\n            fieldChangeEvents.push([matcher, fieldPattern, listeners]);\n            const id = listeners.add(handler);\n            return () => listeners.remove(id);\n            // let listeners = fieldChangeEvents.get(fieldName.toLowerCase());\n            // if (listeners === undefined) {\n            //   listeners = new DispatchList();\n            //   fieldChangeEvents.set(fieldName.toLowerCase(), listeners);\n            // }\n            // const id = listeners.add((value) => {\n            //   setTimeout(() => { handler(value, fieldName) }, 1);\n            // });\n            // return () => listeners.remove(id);\n        },\n        /**\n         * Set the whole object\n         */\n        set,\n        /**\n         * Update the object with a partial set of fields and values\n         */\n        update\n    };\n}\n","import * as MapFns from \"@ixfx/core/maps\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { messageIsDoneSignal, messageHasValue, isWritable } from \"../util.js\";\nimport { object } from \"../from/object.js\";\n/**\n * Monitors input reactive values, storing values as they happen to an object.\n * Whenever a new value is emitted, the whole object is sent out, containing current\n * values from each source (or _undefined_ if not yet emitted)\n *\n * See {@link combineLatestToArray} to combine streams by name into an array instead.\n *\n * ```\n * const sources = {\n *  fast: Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  slow: Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToObject(sources);\n * r.onValue(value => {\n *  // 'value' will be an object containing the labelled latest\n *  // values from each source.\n *  // { fast: number, slow: number }\n * });\n * ```\n *\n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToObject} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n *\n * This source ends if all source streams end.\n * @param reactiveSources Sources to merge\n * @param options Options for merging\n * @returns\n */\nexport function combineLatestToObject(reactiveSources, options = {}) {\n    const disposeSources = options.disposeSources ?? true;\n    const event = object(undefined);\n    const onSourceDone = options.onSourceDone ?? `break`;\n    const emitInitial = options.emitInitial ?? true;\n    let emitInitialDone = false;\n    const states = new Map();\n    for (const [key, source] of Object.entries(reactiveSources)) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        const initialData = (`last` in source) ? source.last() : undefined;\n        //console.log(`initialData: ${ initialData } src: ${ (source as any).last() }`);\n        const s = {\n            source: resolveSource(source),\n            done: false,\n            data: initialData,\n            off: () => { }\n        };\n        states.set(key, s);\n    }\n    const sources = Object.fromEntries(Object.entries(states).map(entry => [entry[0], entry[1].source]));\n    const someUnfinished = () => MapFns.some(states, v => !v.done);\n    const unsub = () => {\n        //console.log(`Rx.MergeToObject.unsub states: ${ [ ...states.keys() ].join(`,`) }`);\n        for (const state of states.values())\n            state.off();\n    };\n    const getData = () => {\n        const r = {};\n        for (const [key, state] of states) {\n            const d = state.data;\n            if (d !== undefined) {\n                r[key] = state.data;\n            }\n        }\n        //console.log(`Rx.Ops.CombineLatestToObject getData`, r);\n        return r;\n    };\n    const trigger = () => {\n        emitInitialDone = true;\n        const d = getData();\n        //console.log(`Rx.Ops.combineLatestToObject trigger`, d);\n        event.set(d);\n    };\n    const wireUpState = (state) => {\n        state.off = state.source.on(message => {\n            if (messageIsDoneSignal(message)) {\n                state.done = true;\n                state.off();\n                state.off = () => { };\n                if (onSourceDone === `break`) {\n                    unsub();\n                    event.dispose(`Source has completed and 'break' is behaviour`);\n                    return;\n                }\n                if (!someUnfinished()) {\n                    // All sources are done\n                    unsub();\n                    event.dispose(`All sources completed`);\n                }\n            }\n            else if (messageHasValue(message)) {\n                state.data = message.value;\n                trigger();\n            }\n        });\n    };\n    for (const state of states.values()) {\n        wireUpState(state);\n    }\n    if (!emitInitialDone && emitInitial) {\n        //console.log(`Rx.Ops.CombineLatestToObject emitting initial`);\n        trigger();\n    }\n    return {\n        ...event,\n        hasSource(field) {\n            return states.has(field);\n        },\n        replaceSource(field, source) {\n            const state = states.get(field);\n            if (state === undefined)\n                throw new Error(`Field does not exist: '${field}'`);\n            state.off();\n            const s = resolveSource(source);\n            state.source = s;\n            wireUpState(state);\n        },\n        setWith(data) {\n            const written = {};\n            for (const [key, value] of Object.entries(data)) {\n                const state = states.get(key);\n                if (state !== undefined) {\n                    if (isWritable(state.source)) {\n                        state.source.set(value);\n                        written[key] = value;\n                    }\n                    state.data = value;\n                }\n            }\n            return written;\n        },\n        sources,\n        last() {\n            return getData();\n        },\n        dispose(reason) {\n            unsub();\n            event.dispose(reason);\n            if (disposeSources) {\n                for (const v of states.values()) {\n                    v.source.dispose(`Part of disposed mergeToObject`);\n                }\n            }\n        }\n    };\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport { hasLast } from \"../util.js\";\n/**\n * When there is a value from `input`, or the reactive is pinged,\n * this reactive emits the result of `fn`.\n *\n * `fn` is provided the previous value as well as the most recent value.\n *\n * If no previous value is available, the current value is emitted and `fn` is not called.\n * @param input\n * @param fn\n * @returns\n */\nexport function computeWithPrevious(input, fn) {\n    let previousValue;\n    let currentValue;\n    if (hasLast(input)) {\n        currentValue = previousValue = input.last();\n    }\n    const trigger = () => {\n        if (previousValue === undefined && currentValue !== undefined) {\n            previousValue = currentValue;\n            upstream.set(previousValue);\n        }\n        else if (previousValue !== undefined && currentValue !== undefined) {\n            const vv = fn(previousValue, currentValue);\n            //console.log(`vv: ${ vv } prev: ${ previousValue } target: ${ target }`)\n            previousValue = vv;\n            upstream.set(vv);\n        }\n    };\n    const upstream = initUpstream(input, {\n        lazy: \"very\",\n        debugLabel: `computeWithPrevious`,\n        onValue(value) {\n            //console.log(`onValue ${ value }`);\n            currentValue = value;\n            trigger();\n        },\n    });\n    if (currentValue)\n        trigger();\n    return {\n        ...toReadable(upstream),\n        ping: () => {\n            if (currentValue !== undefined)\n                trigger();\n        }\n    };\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { timeout } from \"@ixfx/flow\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Debounce waits for `elapsed` time after the last received value before emitting it.\n *\n * If a flurry of values are received that are within the interval, it won't emit anything. But then\n * as soon as there is a gap in the messages that meets the interval, the last received value is sent out.\n *\n * `debounce` always emits with at least `elapsed` as a delay after a value received. While {@link throttle} potentially\n * sends immediately, if it's outside of the elapsed period.\n *\n * This is a subtly different logic to {@link throttle}. `throttle` more eagerly sends the first value, potentially\n * not sending later values. `debouce` however will send later values, potentially ignoring earlier ones.\n * @param source\n * @param options\n * @returns\n */\nexport function debounce(source, options = {}) {\n    const elapsed = intervalToMs(options.elapsed, 50);\n    let lastValue;\n    const timer = timeout(() => {\n        const v = lastValue;\n        if (v) {\n            upstream.set(v);\n            lastValue = undefined;\n        }\n    }, elapsed);\n    const upstream = initUpstream(source, {\n        ...options,\n        onValue(value) {\n            lastValue = value;\n            timer.start();\n        }\n    });\n    return toReadable(upstream);\n}\n","import { debounce as debounceReactive } from \"../reactives/debounce.js\";\nexport function debounce(options) {\n    return (source) => {\n        return debounceReactive(source, options);\n    };\n}\n","import { transform } from \"./transform.js\";\n/**\n * Emits time in milliseconds since last message.\n * If it is the first value, 0 is used.\n * @param input\n * @returns\n */\nexport const elapsed = (input) => {\n    let last = 0;\n    return transform(input, (_ignored) => {\n        const elapsed = last === 0 ? 0 : Date.now() - last;\n        last = Date.now();\n        return elapsed;\n    });\n};\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * From a source value, yields a field from it. Only works\n * if stream values are objects.\n *\n * If a source value doesn't have that field, it is skipped.\n *\n * @returns\n */\nexport function field(fieldSource, fieldName, options = {}) {\n    const fallbackFieldValue = options.fallbackFieldValue;\n    const fallbackObject = options.fallbackObject;\n    const upstream = initUpstream(fieldSource, {\n        disposeIfSourceDone: true,\n        ...options,\n        onValue(value) {\n            let v;\n            // 1. Try to read from value\n            if (fieldName in value) {\n                v = value[fieldName];\n            }\n            else if (fallbackObject && fieldName in fallbackObject) {\n                // 2. Read from fallback object\n                v = fallbackObject[fieldName];\n            }\n            // 3. Use fallback value\n            if (v === undefined) {\n                v = fallbackFieldValue;\n            }\n            if (v !== undefined) {\n                upstream.set(v);\n            }\n        },\n    });\n    return toReadable(upstream);\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Passes all values where `predicate` function returns _true_.\n */\nexport function filter(input, predicate, options) {\n    if (typeof predicate !== `function`)\n        throw new TypeError(`Param 'predicate' should be a function`);\n    const upstream = initUpstream(input, {\n        ...options,\n        onValue(value) {\n            if (predicate(value)) {\n                upstream.set(value);\n            }\n        },\n    });\n    return toReadable(upstream);\n}\n/**\n * Drops all values where `predicate` function returns _true_.\n */\nexport function drop(input, predicate, options) {\n    if (typeof predicate !== `function`)\n        throw new TypeError(`Param 'predicate' should be a function`);\n    const upstream = initUpstream(input, {\n        ...options,\n        onValue(value) {\n            if (!predicate(value)) {\n                upstream.set(value);\n            }\n        },\n    });\n    return toReadable(upstream);\n}\n","import { interpolate as interpolateFunction } from \"@ixfx/modulation\";\nimport { computeWithPrevious } from \"./compute-with-previous.js\";\n/**\n * Interpolates to the source value.\n *\n * Outputs one value for every input value. Thus, to interpolation\n * over time, it's necessary to get the source to emit values at the desired rate.\n *\n * Options can specify an easing name or custom transform of easing progress.\n * @param input\n * @param options\n * @returns\n */\nexport function interpolate(input, options = {}) {\n    const amount = options.amount ?? 0.1;\n    const snapAt = options.snapAt ?? 0.99;\n    const index = interpolateFunction(amount, options);\n    return computeWithPrevious(input, (previous, target) => {\n        const v = index(previous, target);\n        if (target > previous) {\n            if (v / target >= snapAt)\n                return target;\n        }\n        return v;\n    });\n}\n/**\n * From the basis of an input stream of values, run a function over\n * each value. The function takes in the last value from the stream as well as the current.\n * @param input\n * @param fn\n * @returns\n */\n// export function interpolateToTarget<TIn>(input: ReactiveOrSource<TIn>, fn: (previous: TIn, target: TIn) => TIn): ReactivePingable<TIn> {\n//   let previousValue: TIn | undefined;\n//   let target: TIn | undefined;\n//   if (hasLast(input)) {\n//     target = previousValue = input.last();\n//   }\n//   const ping = () => {\n//     if (previousValue === undefined && target !== undefined) {\n//       previousValue = target;\n//     } else if (previousValue !== undefined && target !== undefined) {\n//       previousValue = fn(previousValue, target);\n//     }\n//     upstream.set(previousValue!);\n//   }\n//   const upstream = initUpstream<TIn, TIn>(input, {\n//     lazy: \"very\",\n//     debugLabel: `computeWithPrevious`,\n//     onValue(value) {\n//       target = value;\n//       ping();\n//     },\n//   })\n//   if (target) ping();\n//   return {\n//     ...toReadable(upstream),\n//     ping: () => {\n//       if (target !== undefined) ping()\n//     }\n//   }\n// }\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport * as Proc from '@ixfx/process';\nexport function max(input, options) {\n    const p = Proc.max();\n    return process(p, `max`, input, options);\n}\nexport function min(input, options) {\n    const p = Proc.min();\n    return process(p, `min`, input, options);\n}\nexport function average(input, options) {\n    const p = Proc.average();\n    return process(p, `average`, input, options);\n}\nexport function sum(input, options) {\n    const p = Proc.sum();\n    return process(p, `sum`, input, options);\n}\nexport function tally(input, options = {}) {\n    const countArrayItems = options.countArrayItems ?? true;\n    const p = Proc.tally(countArrayItems);\n    return process(p, `tally`, input, options);\n}\nexport function rank(input, rank, options) {\n    const p = Proc.rank(rank, options);\n    return process(p, `rank`, input, options);\n}\nfunction process(processor, annotationField, input, options = {}) {\n    const annotate = options.annotate;\n    let previous;\n    const skipUndefined = options.skipUndefined ?? true;\n    const skipIdentical = options.skipIdentical ?? true;\n    const upstream = initUpstream(input, {\n        ...options,\n        onValue(value) {\n            const x = processor(value);\n            if (x === undefined && skipUndefined)\n                return;\n            if (skipIdentical && x === previous)\n                return;\n            previous = x;\n            if (annotate) {\n                // eslint-disable-next-line unicorn/prevent-abbreviations\n                const ret = { value };\n                ret[annotationField] = x;\n                upstream.set(ret);\n            }\n            else {\n                upstream.set(x);\n            }\n        },\n    });\n    return toReadable(upstream);\n}\n//todo testing for annotation and non - annotated\n// rankArray\n// chunk, reduce\n// debounce, delay\n// duration, take\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../util.js\";\n/**\n * Pipes the output of one stream into another, in order.\n * The stream returned is a new stream which captures the final output.\n *\n * If any stream in the pipe closes the whole pipe is closed.\n * @param streams\n * @returns\n */\nexport const pipe = (...streams) => {\n    const event = initStream();\n    const unsubs = [];\n    const performDispose = (reason) => {\n        for (const s of streams) {\n            if (!s.isDisposed)\n                s.dispose(reason);\n        }\n        for (const s of unsubs) {\n            s();\n        }\n        event.dispose(reason);\n    };\n    for (let index = 0; index < streams.length; index++) {\n        unsubs.push(streams[index].on((message) => {\n            const isLast = index === streams.length - 1;\n            if (messageHasValue(message)) {\n                if (isLast) {\n                    // Last stream, send to output\n                    event.set(message.value);\n                }\n                else {\n                    // @ts-expect-error\n                    streams[index + 1].set(message.value);\n                }\n            }\n            else if (messageIsDoneSignal(message)) {\n                performDispose(`Upstream disposed`);\n            }\n        }));\n    }\n    return {\n        on: event.on,\n        onValue: event.onValue,\n        dispose(reason) {\n            performDispose(reason);\n        },\n        isDisposed() {\n            return event.isDisposed();\n        },\n    };\n};\n","import { shuffle } from \"@ixfx/arrays\";\nimport { initUpstream } from \"../init-stream.js\";\n/**\n * For a stream that emits arrays of values, this op will select a single value.\n *\n * Can select based on:\n * * predicate: a function that returns _true_ for a value\n * * at: selection based on array index (can be combined with random ordering to select a random value)\n *\n * ```js\n * // If source is Reactive<Array<number>>, picks the first even number\n * singleFromArray(source, {\n *  predicate: v => v % 2 === 0\n * });\n *\n * // Selects a random value from source\n * singleFromArray(source, {\n *  order: `random`,\n *  at: 0\n * });\n * ```\n *\n * If neither `predicate` or `at` options are given, exception is thrown.\n * @param source Source to read from\n * @param options Options for selection\n * @returns\n */\nexport function singleFromArray(source, options = {}) {\n    const order = options.order ?? `default`;\n    if (!options.at && !options.predicate)\n        throw new Error(`Options must have 'predicate' or 'at' fields`);\n    let preprocess = (values) => values;\n    if (order === `random`)\n        preprocess = shuffle;\n    else if (typeof order === `function`)\n        preprocess = (values) => values.toSorted(order);\n    const upstream = initUpstream(source, {\n        onValue(values) {\n            values = preprocess(values);\n            if (options.predicate) {\n                for (const v of values) {\n                    if (options.predicate(v)) {\n                        upstream.set(v);\n                    }\n                }\n            }\n            else if (options.at) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                upstream.set(values.at(options.at));\n            }\n        },\n    });\n    return upstream;\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\n/**\n * Creates a set of streams each of which receives data from `source`.\n * By default these are lazy and dispose if the upstream source closes.\n *\n * See also {@link splitLabelled} to split into named streams.\n * @param rxOrSource\n * @param options\n * @returns\n */\nexport const split = (rxOrSource, options = {}) => {\n    const quantity = options.quantity ?? 2;\n    const outputs = [];\n    const source = resolveSource(rxOrSource);\n    for (let index = 0; index < quantity; index++) {\n        outputs.push(initUpstream(source, { disposeIfSourceDone: true, lazy: `initial` }));\n    }\n    return outputs;\n};\n/**\n * Splits `source` into several duplicated streams.\n * Returns an object with keys according to `labels`.\n * Each value is a stream which echos the values from `source`.\n * ```js\n * const { a, b, c} = splitLabelled(source, `a`, `b`, `c`);\n * // a, b, c are Reactive types\n * ```\n *\n * See also {@link split} to get an unlabelled split\n * @param rxOrSource\n * @param labels\n * @returns\n */\nexport const splitLabelled = (rxOrSource, labels) => {\n    const source = resolveSource(rxOrSource);\n    const t = {};\n    for (const label of labels) {\n        t[label] = initUpstream(source, { lazy: `initial`, disposeIfSourceDone: true });\n    }\n    return t;\n};\n","import { initStream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../util.js\";\n/**\n * Switcher generates several output streams, labelled according to the values of `cases`.\n * Values from `source` are fed to the output streams if their associated predicate function returns _true_.\n *\n * In this way, we can split one input stream into several output streams, each potentially getting a different\n * subset of the input.\n *\n * With `options`, you can specify whether to send to multiple outputs if several match, or just the first (default behaviour).\n *\n * The below example shows setting up a switcher and consuming the output streams.\n * @example\n * ```js\n * // Initialise a reactive number, starting at 0\n * const switcherSource = Reactive.number(0);\n * // Set up the switcher\n * const x = Reactive.switcher(switcherSource, {\n *  even: v => v % 2 === 0,\n *  odd: v => v % 2 !== 0\n * });\n * // Listen for outputs from each of the resulting streams\n * x.even.on(msg => {\n *   log(`even: ${msg.value}`);\n * });\n * x.odd.on(msg => {\n *   log(`odd: ${msg.value}`);\n * })\n * // Set new values to the number source, counting upwards\n * // ...this will in turn trigger the outputs above\n * setInterval(() => {\n *   switcherSource.set(switcherSource.last() + 1);\n * }, 1000);\n * ```\n *\n * If `source` closes, all the output streams will be closed as well.\n * @param reactiveOrSource\n * @param cases\n * @param options\n * @returns\n */\nexport const switcher = (reactiveOrSource, cases, options = {}) => {\n    // return (r: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n    const match = options.match ?? `first`;\n    const source = resolveSource(reactiveOrSource);\n    let disposed = false;\n    // Setup output streams\n    const t = {};\n    for (const label of Object.keys(cases)) {\n        t[label] = initStream();\n    }\n    const performDispose = () => {\n        if (disposed)\n            return;\n        unsub();\n        disposed = true;\n        for (const stream of Object.values(t)) {\n            stream.dispose(`switcher source dispose`);\n        }\n    };\n    // Listen to source\n    const unsub = source.on(message => {\n        // Got a value\n        if (messageHasValue(message)) {\n            for (const [lbl, pred] of Object.entries(cases)) {\n                if (pred(message.value)) {\n                    t[lbl].set(message.value);\n                    if (match === `first`)\n                        break;\n                }\n            }\n        }\n        else if (messageIsDoneSignal(message)) {\n            performDispose();\n        }\n    });\n    return t;\n    // }\n};\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { intervalToMs } from \"@ixfx/core\";\nimport { initStream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { messageIsSignal } from \"../util.js\";\n/**\n * Waits for all sources to produce a value, sending the combined results as an array.\n * After sending, it waits again for each source to send at least one value.\n *\n * Use {@link syncToObject} to output objects based on labelled sources rather than an array of values.\n *\n * Pace will be set by the slowest source. Alternatively, use {@link combineLatestToArray} where the rate is determined by fastest source.\n *\n * Only complete results are sent. For example if source A & B finish and source C is still producing values,\n * synchronisation is not possible because A & B stopped producing values. Thus the stream will self-terminate\n * after `maximumWait` (2 seconds). The newer values from C are lost.\n */\nexport function syncToArray(reactiveSources, options = {}) {\n    const onSourceDone = options.onSourceDone ?? `break`;\n    const finalValue = options.finalValue ?? `undefined`;\n    const maximumWait = intervalToMs(options.maximumWait, 2000);\n    let watchdog;\n    const data = [];\n    //const finalData: Array<RxValueTypes<T> | undefined> = [];\n    // Resolve sources\n    //const sources = reactiveSources.map(source => resolveSource(source));\n    //const noop = () => {/*no-op*/ }\n    //const sourcesUnsub: Array<Unsubscriber> = sources.map(_ => noop);\n    const states = reactiveSources.map(source => ({\n        finalData: undefined,\n        done: false,\n        source: resolveSource(source),\n        unsub: () => { }\n    }));\n    const unsubscribe = () => {\n        for (const s of states) {\n            s.unsub();\n            s.unsub = () => { };\n        }\n    };\n    const isDataSetComplete = () => {\n        for (let index = 0; index < data.length; index++) {\n            if (onSourceDone === `allow` && states[index].done)\n                continue;\n            if (data[index] === undefined)\n                return false;\n        }\n        return true;\n    };\n    const hasIncompleteSource = () => states.some(s => !s.done);\n    const resetDataSet = () => {\n        for (let index = 0; index < data.length; index++) {\n            if (finalValue === `last` && states[index].done)\n                continue; // Don't overwrite\n            data[index] = undefined;\n        }\n    };\n    const onWatchdog = () => {\n        done(`Sync timeout exceeded (${maximumWait.toString()})`);\n    };\n    const done = (reason) => {\n        if (watchdog)\n            clearTimeout(watchdog);\n        unsubscribe();\n        event.dispose(reason);\n    };\n    const init = () => {\n        watchdog = setTimeout(onWatchdog, maximumWait);\n        for (const [index, state] of states.entries()) {\n            data[index] = undefined; // init array positions to be undefined\n            state.unsub = state.source.on(valueChanged => {\n                if (messageIsSignal(valueChanged)) {\n                    if (valueChanged.signal === `done`) {\n                        state.finalData = data[index];\n                        state.unsub();\n                        state.done = true;\n                        state.unsub = () => { };\n                        if (finalValue === `undefined`)\n                            data[index] = undefined;\n                        if (onSourceDone === `break`) {\n                            done(`Source '${index.toString()}' done, and onSourceDone:'break' is set`);\n                            return;\n                        }\n                        if (!hasIncompleteSource()) {\n                            done(`All sources done`);\n                            return;\n                        }\n                    }\n                    return;\n                }\n                data[index] = valueChanged.value;\n                if (isDataSetComplete()) {\n                    // All array elements contain values\n                    // Emit data and reset\n                    event.set([...data]);\n                    resetDataSet();\n                    if (watchdog)\n                        clearTimeout(watchdog);\n                    watchdog = setTimeout(onWatchdog, maximumWait);\n                }\n            });\n        }\n    };\n    const event = initStream({\n        onFirstSubscribe() {\n            unsubscribe();\n            init();\n        },\n        onNoSubscribers() {\n            if (watchdog)\n                clearTimeout(watchdog);\n            unsubscribe();\n        },\n    });\n    return {\n        dispose: event.dispose,\n        isDisposed: event.isDisposed,\n        on: event.on,\n        onValue: event.onValue\n    };\n}\n","import { zipKeyValue } from \"@ixfx/core/maps\";\nimport { syncToArray } from \"./sync-to-array.js\";\nimport { transform } from \"./transform.js\";\nexport function syncToObject(reactiveSources, options = {}) {\n    const keys = Object.keys(reactiveSources);\n    const values = Object.values(reactiveSources);\n    const s = syncToArray(values, options);\n    const st = transform(s, (streamValues) => {\n        return zipKeyValue(keys, streamValues);\n    });\n    return st;\n}\n","import { resolveSource } from \"../resolve-source.js\";\n/**\n * 'Taps' the values from 'input', passing them to the 'process' function.\n * Return stream is the input stream, unaffected by what 'process' does.\n * @param input Input stream\n * @param processors List of processors\n * @returns\n */\nexport function tapProcess(input, ...processors) {\n    const inputStream = resolveSource(input);\n    // @ts-expect-error\n    const chain = Process.flow(...processors);\n    inputStream.onValue(value => {\n        chain(value);\n    });\n    return inputStream;\n}\n/**\n * 'Taps' the values from 'input', passing them to 'diverged'\n * Returns the original input stream, unaffected by what 'diverged' does.\n * @param input Input stream\n * @param diverged Stream to write to\n * @returns\n */\nexport function tapStream(input, diverged) {\n    const inputStream = resolveSource(input);\n    inputStream.onValue(value => {\n        diverged.set(value);\n    });\n    return inputStream;\n}\n/**\n * Create a parallel 'tap' of processing\n * @param input Input stream\n * @param ops Series of ops to process data\n * @returns\n */\nexport const tapOps = (input, ...ops) => {\n    for (const op of ops) {\n        // @ts-expect-error\n        input = op(input);\n    }\n    return input;\n};\n","import { intervalToMs } from \"@ixfx/core\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * Only allow a value through if a minimum amount of time has elapsed.\n * since the last value. This effectively slows down a source to a given number\n * of values/ms. Values emitted by the source which are too fast are discarded.\n *\n * Throttle will fire on the first value received.\n *\n * In more detail:\n * Every time throttle passes a value, it records the time it allowed something through. For every\n * value received, it checks the elapsed time against this timestamp, throwing away values if\n * the period hasn't elapsed.\n *\n * With this logic, a fury of values of the source might be discarded if they fall within the elapsed time\n * window. But then if there is not a new value for a while, the actual duration between values can be longer\n * than expected. This is in contrast to {@link debounce}, which will emit the last value received after a duration,\n * even if the source stops sending.\n * @param options\n * @returns\n */\nexport function throttle(throttleSource, options = {}) {\n    const elapsed = intervalToMs(options.elapsed, 0);\n    let lastFire = performance.now();\n    let lastValue;\n    const upstream = initUpstream(throttleSource, {\n        ...options,\n        onValue(value) {\n            lastValue = value;\n            trigger();\n        },\n    });\n    const trigger = () => {\n        const now = performance.now();\n        if (elapsed > 0 && (now - lastFire > elapsed)) {\n            lastFire = now;\n            if (lastValue !== undefined) {\n                upstream.set(lastValue);\n            }\n        }\n    };\n    return toReadable(upstream);\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { isTrigger, resolveTriggerValue } from \"../util.js\";\n/**\n * Emits a value if `source` does not emit a value after `interval`\n * has elapsed. This can be useful to reset a reactive to some\n * 'zero' state if nothing is going on.\n *\n * If `source` emits faster than the `interval`, it won't get triggered.\n *\n * Default for 'timeout': 1000s.\n *\n * ```js\n * // Emit 'hello' if 'source' doesn't emit a value after 1 minute\n * const r = Rx.timeoutValue(source, { value: 'hello', interval: { mins: 1 } });\n * ```\n *\n * Can also emit results from a function or generator\n * ```js\n * // Emits a random number if 'source' doesn't emit a value after 500ms\n * const r = Rx.timeoutValue(source, { fn: Math.random, interval: 500 });\n * ```\n *\n * If `immediate` option is _true_ (default), the timer starts from stream initialisation.\n * Otherwise it won't start until it observes the first value from `source`.\n * @param source\n * @param options\n */\nexport function timeoutValue(source, options) {\n    let timer;\n    const immediate = options.immediate ?? true;\n    const repeat = options.repeat ?? false;\n    const timeoutMs = intervalToMs(options.interval, 1000);\n    if (!isTrigger(options)) {\n        throw new Error(`Param 'options' does not contain trigger 'value' or 'fn' fields`);\n    }\n    // Send value from trigger\n    const sendFallback = () => {\n        const [value, done] = resolveTriggerValue(options);\n        if (done) {\n            events.dispose(`Trigger completed`);\n        }\n        else {\n            if (events.isDisposed())\n                return;\n            events.set(value);\n            if (repeat) {\n                timer = setTimeout(sendFallback, timeoutMs);\n            }\n        }\n    };\n    const events = initUpstream(source, {\n        disposeIfSourceDone: true,\n        // Received a value from upstream source\n        onValue(v) {\n            // Reset timeout\n            if (timer)\n                clearTimeout(timer);\n            timer = setTimeout(sendFallback, timeoutMs);\n            // Emit value\n            events.set(v);\n        },\n        onDispose() {\n            if (timer)\n                clearTimeout(timer);\n        },\n    });\n    if (immediate && !timer) {\n        timer = setTimeout(sendFallback, timeoutMs);\n    }\n    return events;\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { isPingable, isTrigger, messageHasValue, messageIsDoneSignal, resolveTriggerValue } from \"../util.js\";\n/**\n * Pings a reactive if no value is emitted at after `interval`.\n * Returns `source`.\n *\n * ```js\n * // Ping `source` if no value is emitted after one minute\n * const r = Rx.timeoutPing(source, { mins: 1 });\n * ```\n *\n * Behavior can be stopped using an abort signal.\n * @see {@link ReactivePingable}\n * @param source\n * @param options\n */\nexport function timeoutPing(source, options) {\n    let timer;\n    const rx = resolveSource(source);\n    const abort = options.abort;\n    const timeoutMs = intervalToMs(options, 1000);\n    // Send ping\n    const sendPing = () => {\n        if (abort?.aborted || rx.isDisposed()) {\n            off();\n            return;\n        }\n        if (isPingable(rx))\n            rx.ping(); // ignore if not pingable\n        timer = setTimeout(sendPing, timeoutMs);\n    };\n    const cancel = () => {\n        if (timer)\n            clearTimeout(timer);\n    };\n    const off = rx.on(message => {\n        if (messageHasValue(message)) {\n            // Reset timeout\n            cancel();\n            timer = setTimeout(sendPing, timeoutMs);\n        }\n        else if (messageIsDoneSignal(message)) {\n            off();\n            cancel();\n        }\n    });\n    timer = setTimeout(sendPing, timeoutMs);\n    return rx;\n}\n","import { initStream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport { messageHasValue, messageIsDoneSignal, messageIsSignal } from \"../util.js\";\n/**\n * Pings `target` whenever `source` emits a value. The value itself is ignored, it just\n * acts as a trigger.\n *\n * Returns a new stream capturing the output of `target`.\n *\n * It `source` or `target` closes, output stream closes too.\n *\n * @returns\n */\nexport function valueToPing(source, target, options = {}) {\n    const lazy = options.lazy ?? `initial`;\n    const signal = options.signal;\n    const sourceRx = resolveSource(source);\n    const gate = options.gate ?? ((value) => true);\n    let upstreamOff;\n    let downstreamOff;\n    if (signal) {\n        signal.addEventListener(`abort`, () => {\n            done(`Abort signal ${signal.reason}`);\n        }, { once: true });\n    }\n    const events = initStream({\n        onFirstSubscribe() {\n            if (lazy !== `never` && upstreamOff === undefined)\n                start();\n        },\n        onNoSubscribers() {\n            // Unsubscribe from source if we're very lazy\n            // Stay subscribed if we're only initially lazy or not lazy at all\n            if (lazy === `very` && upstreamOff !== undefined) {\n                upstreamOff();\n                upstreamOff = undefined;\n            }\n        },\n    });\n    const start = () => {\n        //console.log(`Rx.valueToPing  start`);\n        upstreamOff = sourceRx.on(message => {\n            if (messageIsDoneSignal(message)) {\n                done(`Upstream closed`);\n            }\n            else if (messageIsSignal(message)) {\n                events.signal(message.signal);\n            }\n            else if (messageHasValue(message)) {\n                //console.log(`Rx.valueToPing got value: ${ message.value }`);\n                if (gate(message.value)) {\n                    target.ping();\n                }\n            }\n        });\n        downstreamOff = target.on(message => {\n            if (messageIsDoneSignal(message)) {\n                done(`Downstream closed`);\n            }\n            else if (messageIsSignal(message)) {\n                events.signal(message.signal, message.context);\n            }\n            else if (messageHasValue(message)) {\n                events.set(message.value);\n            }\n        });\n    };\n    const done = (reason) => {\n        events.dispose(reason);\n        if (upstreamOff)\n            upstreamOff();\n        if (downstreamOff)\n            downstreamOff();\n    };\n    if (lazy === `never`)\n        start();\n    return events;\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\n/**\n * A reactive where the last value can be read at any time.\n * An initial value must be provided.\n * ```js\n * const r = Rx.withValue(source, { initial: `hello` });\n * r.last(); // Read last value\n * ```\n *\n * Warning: Since most reactives only active when subscribed to, it's important to also subscribe\n * to the results of `r` for this flow to happen. Alternatively, use `lazy: 'never'` as an option.\n * @param input\n * @param options\n * @returns\n */\nexport function withValue(input, options) {\n    let lastValue = options.initial;\n    const upstream = initUpstream(input, {\n        ...options,\n        onValue(value) {\n            //console.log(`Rx.Ops.WithValue onValue: ${ value }`);\n            lastValue = value;\n            upstream.set(value);\n        },\n    });\n    const readable = toReadable(upstream);\n    return {\n        ...readable,\n        last() {\n            return lastValue;\n        },\n    };\n}\n","import { continuously } from \"@ixfx/core\";\nimport { intervalToMs } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\nexport const of = (source, options = {}) => {\n    if (Array.isArray(source)) {\n        return array(source, options);\n    }\n    else { }\n};\n/**\n * Reads the contents of `array` into a Reactive, with optional time interval\n * between values. A copy of the array is used, so changes will not\n * affect the reactive.\n *\n * See also {@link arrayObject} which monitors changes to array values.\n *\n * Reads items from an array with a given interval, by default 5ms\n *\n * ```js\n * const data = [`apples`, `oranges`, `pears` ];\n * const rx = Rx.From.array(data);\n * rx.onValue(v => {\n *  // v will be each fruit in turn\n * })\n * ```\n *\n * Note that there is the possibility of missing values since there is delay between subscribing and when items start getting emitted.\n * If a new subscriber connects to the reactive, they won't get values already emitted.\n * @param sourceArray\n * @param options\n * @returns\n */\nexport const array = (sourceArray, options = {}) => {\n    const lazy = options.lazy ?? `initial`;\n    const signal = options.signal;\n    const whenStopped = options.whenStopped ?? `continue`;\n    const debugLifecycle = options.debugLifecycle ?? false;\n    const array = [...sourceArray];\n    if (lazy !== `very` && whenStopped === `reset`)\n        throw new Error(`whenStopped:'reset' has no effect with 'lazy:${lazy}'. Use lazy:'very' instead.`);\n    const intervalMs = intervalToMs(options.interval, 5);\n    let index = 0;\n    let lastValue = array[0];\n    const s = initLazyStream({\n        ...options,\n        lazy,\n        onStart() {\n            if (debugLifecycle)\n                console.log(`Rx.readFromArray:onStart`);\n            c.start();\n        },\n        onStop() {\n            if (debugLifecycle)\n                console.log(`Rx.readFromArray:onStop. whenStopped: ${whenStopped} index: ${index}`);\n            c.cancel();\n            if (whenStopped === `reset`)\n                index = 0;\n        },\n        // onFirstSubscribe() {\n        //   if (debugLifecycle) console.log(`Rx.readFromArray:onFirstSubscribe lazy: ${ lazy } runState: '${ c.runState }'`);\n        //   // Start if in lazy mode and not running\n        //   if (lazy !== `never` && c.runState === `idle`) c.start();\n        // },\n        // onNoSubscribers() {\n        //   if (debugLifecycle) console.log(`Rx.readFromArray:onNoSubscribers lazy: ${ lazy } runState: '${ c.runState }' whenStopped: '${ whenStopped }'`);\n        //   if (lazy === `very`) {\n        //     c.cancel();\n        //     if (whenStopped === `reset`) {\n        //       index = 0;\n        //     }\n        //   }\n        // }\n    });\n    const c = continuously(() => {\n        if (signal?.aborted) {\n            s.dispose(`Signalled (${signal.reason})`);\n            return false; // stop looping\n        }\n        lastValue = array[index];\n        index++;\n        s.set(lastValue);\n        if (index === array.length) {\n            s.dispose(`Source array complete`);\n            return false; // stop loop\n        }\n    }, intervalMs);\n    if (!lazy)\n        c.start();\n    return {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        dispose: s.dispose,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        isDisposed: s.isDisposed,\n        isDone() {\n            return index === array.length;\n        },\n        last() {\n            return lastValue;\n        },\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        on: s.on,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        onValue: s.onValue\n    };\n};\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { isEqualValueDefault } from \"@ixfx/core\";\nimport { initStream } from \"../init-stream.js\";\nimport { compareArrays } from \"@ixfx/core/records\";\nimport { remove as ArraysRemove, insertAt as ArraysInsertAt } from '@ixfx/arrays';\n/**\n * Wraps an array object.\n *\n * It returns an reactive along with some array-ish functions to manipulating it.\n * @param initialValue\n * @param options\n * @returns\n */\nexport function arrayObject(initialValue = [], options = {}) {\n    const eq = options.eq ?? isEqualValueDefault;\n    const setEvent = initStream();\n    //const diffEvent = initStream<Array<Immutable.Change<any>>>();\n    const arrayEvent = initStream();\n    let value = initialValue;\n    let disposed = false;\n    const set = (replacement) => {\n        const diff = compareArrays(value, replacement, eq);\n        //console.log(`Rx.fromArray.set diff`, diff);\n        //if (diff.length === 0) return;\n        //diffEvent.set(diff);\n        value = replacement;\n        setEvent.set([...replacement]);\n    };\n    const setAt = (index, v) => {\n        value[index] = v;\n        setEvent.set([...value]);\n    };\n    const push = (v) => {\n        value = [...value, v];\n        setEvent.set([...value]);\n        const cr = [`add`, value.length - 1, v];\n        arrayEvent.set([cr]);\n    };\n    const deleteAt = (index) => {\n        const valueChanged = ArraysRemove(value, index);\n        if (valueChanged.length === value.length)\n            return; // no change\n        const diff = compareArrays(value, valueChanged, eq);\n        //console.log(diff.summary);\n        value = valueChanged;\n        setEvent.set([...value]);\n        arrayEvent.set(diff.summary);\n    };\n    const deleteWhere = (filter) => {\n        const valueChanged = value.filter(v => !filter(v));\n        const count = value.length - valueChanged.length;\n        const diff = compareArrays(value, valueChanged, eq);\n        value = valueChanged;\n        setEvent.set([...value]);\n        arrayEvent.set(diff.summary);\n        return count;\n    };\n    const insertAt = (index, v) => {\n        const valueChanged = ArraysInsertAt(value, index, v);\n        const diff = compareArrays(value, valueChanged, eq);\n        value = valueChanged;\n        setEvent.set([...value]);\n        arrayEvent.set(diff.summary);\n    };\n    // const update = (toMerge: Partial<V>) => {\n    //   // eslint-disable-next-line unicorn/prefer-ternary\n    //   if (value === undefined) {\n    //     value = toMerge as V;\n    //   } else {\n    //     const diff = Immutable.compareData(toMerge, value);\n    //     // console.log(`Rx.fromObject.update value: ${ JSON.stringify(value) }`);\n    //     // console.log(`Rx.fromObject.update  diff: ${ JSON.stringify(diff) }`);\n    //     if (diff.length === 0) return; // No changes\n    //     value = {\n    //       ...value,\n    //       ...toMerge\n    //     }\n    //     diffEvent.set(diff);\n    //   }\n    //   setEvent.set(value);\n    // }\n    const dispose = (reason) => {\n        if (disposed)\n            return;\n        //diffEvent.dispose(reason);\n        setEvent.dispose(reason);\n        disposed = true;\n    };\n    const r = {\n        dispose,\n        isDisposed() {\n            return disposed;\n        },\n        last: () => value,\n        on: setEvent.on,\n        onArray: arrayEvent.on,\n        onValue: setEvent.onValue,\n        setAt,\n        push,\n        deleteAt,\n        deleteWhere,\n        insertAt,\n        /**\n         * Set the whole object\n         */\n        set\n    };\n    return r;\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nexport function boolean(initialValue) {\n    let value = initialValue;\n    const events = initStream();\n    const set = (v) => {\n        value = v;\n        events.set(v);\n    };\n    return {\n        dispose: events.dispose,\n        isDisposed: events.isDisposed,\n        last: () => value,\n        on: events.on,\n        onValue: events.onValue,\n        set\n    };\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { continuously } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\n/**\n * Produces an incrementing value. By default starts at 0 and counts\n * forever, incrementing every second.\n *\n * ```js\n * const r = Rx.From.count();\n * r.onValue(c => {\n *  // 0, 1, 2, 3 ... every second\n * });\n * ```\n *\n * The `limit` is exclusive\n * ```js\n * const r = Rx.From.count({limit:5});\n * // Yields 0,1,2,3,4\n * ```\n *\n * If limit is less than start, it will count down instead.\n * ```js\n * const r = Rx.count({start:5, limit: 0});\n * // Yie:ds 5,4,3,2,1\n * ```\n *\n * ```js\n * // Count 10, 12, 14 ... every 500ms\n * const r = Rx.From.count({ start: 10, amount: 2, interval: 500 });\n * ```\n *\n * In addition to setting `limit` (which is exclusive), you can stop with an abort signal\n * ```js\n * const ac = new AbortController();\n * const r = Rx.From.count({signal:ac.signal});\n * ...\n * ac.abort(`stop`);\n * ```\n * @param options\n */\nexport function count(options = {}) {\n    const lazy = options.lazy ?? `initial`;\n    const interval = intervalToMs(options.interval, 1000);\n    const amount = options.amount ?? 1;\n    const offset = options.offset ?? 0;\n    let produced = 0;\n    let value = offset;\n    const done = (reason) => {\n        events.dispose(reason);\n    };\n    const timer = continuously(() => {\n        if (options.signal?.aborted) {\n            done(`Aborted (${options.signal.reason})`);\n            return false;\n        }\n        events.set(value);\n        value += 1;\n        produced++;\n        if (produced >= amount) {\n            done(`Limit reached`);\n            return false;\n        }\n    }, interval);\n    const events = initLazyStream({\n        onStart() {\n            timer.start();\n        },\n        onStop() {\n            timer.cancel();\n        },\n        onDispose() {\n            timer.cancel();\n        },\n        lazy\n    });\n    return events;\n}\n","import { isEqualValueDefault } from \"@ixfx/core\";\nimport { cache } from \"../cache.js\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { combineLatestToObject } from \"../ops/combine-latest-to-object.js\";\nexport function derived(fn, reactiveSources, options = {}) {\n    const ignoreIdentical = options.ignoreIdentical ?? true;\n    const eq = options.eq ?? (isEqualValueDefault);\n    const sources = combineLatestToObject(reactiveSources);\n    const handle = (v) => {\n        const last = output.last();\n        const vv = fn(v);\n        if (vv !== undefined) {\n            if (ignoreIdentical && last !== undefined) {\n                if (eq(vv, last))\n                    return vv;\n            }\n            output.set(vv);\n        }\n        return vv;\n    };\n    // When the combined stream emits a value, output it\n    const s = initUpstream(sources, {\n        ...options,\n        onValue(v) {\n            handle(v);\n        },\n    });\n    const output = cache(s, fn(sources.last()));\n    return output;\n}\n","import { field } from \"../ops/field.js\";\nimport { object } from \"./object.js\";\nimport { initLazyStream, initLazyStreamWithInitial, initStream } from \"../init-stream.js\";\nimport { elapsedInterval } from \"@ixfx/core/elapsed\";\n/**\n * Fired when `eventName` fires on `target`.\n *\n * Rather than whole event args being emitted on the stream,\n * it plucks a field from the event args, or if that's missing, from the target.\n *\n * ```js\n * // Emits the the value of a field named 'x'\n * // on the change event args\n * eventField(el, `pointermove`, `x`);\n * ```\n * @param targetOrQuery Event target, HTML element or HTML query (eg '#someId')\n * @param eventName Name of event, eg. 'pointermove'\n * @param fieldName Name of field, eg 'x'\n * @param initialValue Initial data\n * @param options Options for source\n */\nexport function eventField(targetOrQuery, eventName, fieldName, initialValue, options = {}) {\n    const initial = {};\n    initial[fieldName] = initialValue;\n    const rxField = field(event(targetOrQuery, eventName, initial, options), fieldName, options);\n    return rxField;\n}\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options: EventOptions<V>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options?: Optional<EventOptions<V>, `transform`>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n// export function event(targetOrQuery: EventTarget | null | string, name: `pointermove` | `pointerover` | `pointerup` | `pointerdown` | `pointerenter` | `pointercancel` | `pointerout` | `pointerleave` | `gotpointercapture` | `lostpointer`, initialValue: Partial<PointerEvent> | undefined, options: Partial<EventSourceOptions>): ReactiveInitial<PointerEvent> & Reactive<PointerEvent>;\n/**\n * Subscribes to an event, emitting data\n *\n * @example Print x,y position of mouse as it moves\n * ```js\n * const r = Rx.From.event(document, `pointermove`);\n * r.onValue(event => {\n *  const { x, y } = event;\n * });\n * ```\n *\n * If `options.lazy` is _true_ (default: _false_), event will only be subscribed to when the stream\n * itself has a subscriber.\n *\n * `options.debugFiring` and `options.debugLifecycle` can be turned on to troubleshoot behaviour\n * of the stream if necessary.\n * @param targetOrQuery Event emitter, HTML element or string. If a string, it will be queryed as a selector.\n * @param name Event name\n * @param options Options\n * @returns\n */\nexport function event(targetOrQuery, name, initialValue, options = {}) {\n    let target;\n    if (typeof targetOrQuery === `string`) {\n        target = document.querySelector(targetOrQuery);\n        if (target === null)\n            throw new Error(`Target query did not resolve to an element. Query: '${targetOrQuery}'`);\n    }\n    else {\n        target = targetOrQuery;\n    }\n    if (target === null)\n        throw new Error(`Param 'targetOrQuery' is null`);\n    const debugLifecycle = options.debugLifecycle ?? false;\n    const debugFiring = options.debugFiring ?? false;\n    const diff = options.diff ?? false;\n    const lazy = options.lazy ?? false;\n    // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n    if (initialValue === undefined)\n        initialValue = {};\n    const rxObject = object(initialValue, { deepEntries: true });\n    let eventAdded = false;\n    let disposed = false;\n    const callback = (args) => {\n        if (debugFiring)\n            console.log(`Reactive.event '${name}' firing '${JSON.stringify(args)}`);\n        rxObject.set(args);\n    };\n    const remove = () => {\n        if (!eventAdded)\n            return;\n        eventAdded = false;\n        target.removeEventListener(name, callback);\n        if (debugLifecycle) {\n            console.log(`Rx.From.event remove '${name}'`);\n        }\n    };\n    const add = () => {\n        if (eventAdded)\n            return;\n        eventAdded = true;\n        target.addEventListener(name, callback);\n        if (debugLifecycle) {\n            console.log(`Rx.From.event add '${name}'`);\n        }\n    };\n    if (!lazy)\n        add();\n    return {\n        last: () => {\n            if (lazy)\n                add();\n            return rxObject.last();\n        },\n        dispose: (reason) => {\n            if (disposed)\n                return;\n            disposed = true;\n            remove();\n            rxObject.dispose(reason);\n        },\n        isDisposed() {\n            return disposed;\n        },\n        on: (handler) => {\n            if (lazy)\n                add();\n            return rxObject.on(handler);\n        },\n        onValue: (handler) => {\n            if (lazy)\n                add();\n            return rxObject.onValue(handler);\n        }\n    };\n}\n/**\n * Emits a value whenever event happens.\n * Data emitted is `{ sinceLast, total }`, where 'sinceLast'\n * is milliseconds since last event and 'total' is total number of\n * times event has been fired.\n * @param targetOrQuery\n * @param name\n * @param options\n * @returns\n */\nexport function eventTrigger(targetOrQuery, name, options = {}) {\n    let target;\n    if (typeof targetOrQuery === `string`) {\n        target = document.querySelector(targetOrQuery);\n        if (target === null)\n            throw new Error(`Target query did not resolve to an element. Query: '${targetOrQuery}'`);\n    }\n    else {\n        target = targetOrQuery;\n    }\n    if (target === null)\n        throw new Error(`Param 'targetOrQuery' is null`);\n    const debugLifecycle = options.debugLifecycle ?? false;\n    const debugFiring = options.debugFiring ?? false;\n    const fireInitial = options.fireInitial ?? false;\n    let count = 0;\n    const elapsed = elapsedInterval();\n    const stream = initLazyStream({\n        lazy: options.lazy ?? `very`,\n        onStart() {\n            target.addEventListener(name, callback);\n            if (debugLifecycle) {\n                console.log(`Rx.From.eventTrigger add '${name}'`);\n            }\n            if (fireInitial && count === 0) {\n                if (debugLifecycle || debugFiring)\n                    console.log(`Rx.From.eventTrigger: firing initial`);\n                callback();\n            }\n        },\n        onStop() {\n            target.removeEventListener(name, callback);\n            if (debugLifecycle) {\n                console.log(`Rx.From.eventTrigger remove '${name}'`);\n            }\n        },\n    });\n    const callback = (_args) => {\n        if (debugFiring)\n            console.log(`Rx.From.eventTrigger '${name}' triggered'`);\n        stream.set({\n            sinceLast: elapsed(),\n            total: ++count\n        });\n    };\n    return stream;\n}\n","import { initLazyStream } from \"../init-stream.js\";\n/**\n * Returns a stream that merges the output of a list of homogenous streams.\n * Use {@link mergedWithOptions} to specify additional options.\n * @param sources\n * @returns\n */\nexport function merged(...sources) {\n    return mergedWithOptions(sources);\n}\n/**\n * Returns a stream that merges the output of a list of homogenous streams.\n *\n * @param sources\n * @param options\n * @returns\n */\nexport function mergedWithOptions(sources, options = {}) {\n    let unsubs = [];\n    const stream = initLazyStream({\n        ...options,\n        onStart() {\n            for (const s of sources) {\n                unsubs.push(s.onValue(v => {\n                    stream.set(v);\n                }));\n            }\n        },\n        onStop() {\n            for (const un of unsubs) {\n                un();\n            }\n            unsubs = [];\n        },\n    });\n    return stream;\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nexport function number(initialValue) {\n    let value = initialValue;\n    const events = initStream();\n    const set = (v) => {\n        value = v;\n        events.set(v);\n    };\n    return {\n        dispose: events.dispose,\n        isDisposed: events.isDisposed,\n        last: () => value,\n        on: events.on,\n        onValue: events.onValue,\n        set\n    };\n}\n","import { Pathed } from '@ixfx/core';\nexport const symbol = Symbol(`Rx`);\n","import { object } from \"./object.js\";\nimport { symbol } from \"../types.js\";\nimport { array } from \"./array.js\";\nimport { arrayObject } from \"./array-object.js\";\n/**\n * Creates a proxy of `target` object (or array), so that regular property setting will be intercepted and output\n * on a {@link Reactive} object as well.\n *\n * ```js\n * const { proxy, rx } = Rx.From.objectProxy({ colour: `red`, x: 10, y: 20 });\n *\n * rx.onValue(v => {\n *  // Get notified when proxy is changed\n * });\n *\n * // Get and set properties as usual\n * console.log(proxy.x);\n * proxy.x = 20; // Triggers Reactive\n * ```\n *\n * Keep in mind that changing `target` directly won't affect the proxied object or Reactive. Thus,\n * only update the proxied object after calling `fromProxy`.\n *\n * The benefit of `objectProxy` instead of {@link From.object} is because the proxied object can be passed to other code that doesn't need\n * to know anything about Reactive objects.\n *\n * You can assign the return values to more meaningful names using\n * JS syntax.\n * ```js\n * const { proxy:colour, rx:colourRx } = Rx.From.objectProxy({ colour: `red` });\n * ```\n *\n * If `target` is an array, it's not possible to change the shape of the array by adding or removing\n * elements, only by updating existing ones. This follows the same behaviour of objects. Alternatively, use {@link arrayProxy}.\n *\n * See also:\n * * {@link objectProxySymbol}: Instead of {proxy,rx} return result, puts the `rx` under a symbol on the proxy.\n * * {@link arrayProxy}: Proxy an array, allowing inserts and deletes.\n * @param target\n * @returns\n */\nexport const objectProxy = (target) => {\n    const rx = object(target);\n    const proxy = new Proxy(target, {\n        set(target, p, newValue, _receiver) {\n            const isArray = Array.isArray(target);\n            //console.log(`Rx.Sources.object set. Target: ${ JSON.stringify(target) } (${ typeof target } array: ${ Array.isArray(target) }) p: ${ JSON.stringify(p) } (${ typeof p }) newValue: ${ JSON.stringify(newValue) } recv: ${ _receiver }`);\n            // Ignore length if target is array\n            if (isArray && p === `length`)\n                return true;\n            if (typeof p === `string`) {\n                rx.updateField(p, newValue);\n            }\n            // If target is array and field looks like an array index...\n            if (isArray && typeof p === `string`) {\n                const pAsNumber = Number.parseInt(p);\n                if (!Number.isNaN(pAsNumber)) {\n                    target[pAsNumber] = newValue;\n                    return true;\n                }\n            }\n            target[p] = newValue;\n            return true;\n        }\n    });\n    return { proxy, rx };\n};\nexport const arrayProxy = (target) => {\n    const rx = arrayObject(target);\n    const proxy = new Proxy(target, {\n        set(target, p, newValue, _receiver) {\n            //console.log(`Rx.Sources.arrayProxy set. Target: ${ JSON.stringify(target) } (${ typeof target } array: ${ Array.isArray(target) }) p: ${ JSON.stringify(p) } (${ typeof p }) newValue: ${ JSON.stringify(newValue) } recv: ${ _receiver }`);\n            // Ignore length if target is array\n            if (p === `length`)\n                return true;\n            if (typeof p !== `string`)\n                throw new Error(`Expected numeric index, got type: ${typeof p} value: ${JSON.stringify(p)}`);\n            const pAsNumber = Number.parseInt(p);\n            if (!Number.isNaN(pAsNumber)) {\n                rx.setAt(pAsNumber, newValue);\n                target[pAsNumber] = newValue;\n                return true;\n            }\n            else {\n                throw new Error(`Expected numeric index, got: '${p}'`);\n            }\n        }\n    });\n    return { proxy, rx };\n};\n/**\n * Same as {@link objectProxy}, but the return value is the proxied object along with\n * the Reactive wrapped as symbol property.\n *\n * ```js\n * const person = Rx.fromProxySymbol({name: `marie` });\n * person.name = `blah`;\n * person[Rx.symbol].on(msg => {\n *  // Value changed...\n * });\n * ```\n *\n * This means of access can be useful as the return result\n * is a bit neater, being a single object instead of two.\n * @param target\n * @returns\n */\nexport const objectProxySymbol = (target) => {\n    const { proxy, rx } = objectProxy(target);\n    const p = proxy;\n    p[symbol] = rx;\n    return p;\n};\n","import { messageHasValue } from \"../util.js\";\nimport { manual } from \"../index.js\";\n/**\n * Creates a RxJs style observable\n * ```js\n * const o = observable(stream => {\n *  // Code to run for initialisation when we go from idle to at least one subscriber\n *  // Won't run again for additional subscribers, but WILL run again if we lose\n *  // all subscribers and then get one\n *\n *  // To send a value:\n *  stream.set(someValue);\n *\n *   // Optional: return function to call when all subscribers are removed\n *   return () => {\n *     // Code to run when all subscribers are removed\n *   }\n * });\n * ```\n *\n * For example:\n * ```js\n * const xy = observable<(stream => {\n *  // Send x,y coords from PointerEvent\n *  const send = (event) => {\n *    stream.set({ x: event.x, y: event.y });\n *  }\n *  window.addEventListener(`pointermove`, send);\n *  return () => {\n *    // Unsubscribe\n *    window.removeEventListener(`pointermove`, send);\n *  }\n * });\n *\n * xy.onValue(value => {\n *  console.log(value);\n * });\n * ```\n * @param init\n * @returns\n */\nexport function observable(init) {\n    const ow = observableWritable(init);\n    return {\n        dispose: ow.dispose,\n        isDisposed: ow.isDisposed,\n        on: ow.on,\n        onValue: ow.onValue\n    };\n}\n/**\n * As {@link observable}, but returns a Reactive that allows writing\n * @param init\n * @returns\n */\nexport function observableWritable(init) {\n    let onCleanup = () => { };\n    const ow = manual({\n        onFirstSubscribe() {\n            onCleanup = init(ow);\n        },\n        onNoSubscribers() {\n            if (onCleanup)\n                onCleanup();\n        },\n    });\n    return {\n        ...ow,\n        onValue: (callback) => {\n            return ow.on(message => {\n                if (messageHasValue(message)) {\n                    callback(message.value);\n                }\n            });\n        }\n    };\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nexport function string(initialValue) {\n    let value = initialValue;\n    const events = initStream();\n    const set = (v) => {\n        value = v;\n        events.set(v);\n    };\n    return {\n        dispose: events.dispose,\n        isDisposed: events.isDisposed,\n        last: () => value,\n        on: events.on,\n        onValue: events.onValue,\n        set\n    };\n}\n","export * from './array.js';\nexport * from './array-object.js';\nexport * from './boolean.js';\nexport * from './count.js';\nexport * from './derived.js';\nexport * from './event.js';\nexport * from './function.js';\nexport * from './iterator.js';\nexport * from './merged.js';\nexport * from './number.js';\nexport * from './object.js';\nexport * from './object-proxy.js';\nexport * from './observable.js';\nexport * from './string.js';\nexport * from './types.js';\n","import { manual } from \"../index.js\";\n/**\n * Changes to `queue` are output as a responsive stream.\n * The stream emits the full data of the queue (first item being the head of the queue)\n * whenever there is an enqueue, remove or clear operation.\n *\n * ```js\n * const queue = new QueueMutable();\n * const r = asResponsive(queue);\n * r.onValue(v => {\n *  // v is an array of values\n * });\n *\n *\n * Calling `set()` on the stream enqueues data to the wrapped queue.\n * ```js\n * r.set([ `1, `2` ]); // Enqueues 1, 2\n * ```\n * @param queue\n * @returns\n */\nexport function asResponsive(queue) {\n    const events = manual({\n        onNoSubscribers() {\n            queue.removeEventListener(`removed`, onRemoved);\n            queue.removeEventListener(`enqueue`, onEnqueue);\n        },\n        onFirstSubscribe() {\n            queue.addEventListener(`removed`, onRemoved);\n            queue.addEventListener(`enqueue`, onEnqueue);\n            events.set(queue.toArray());\n        },\n    });\n    const onRemoved = (event) => {\n        events.set(event.finalData);\n    };\n    const onEnqueue = (event) => {\n        events.set(event.finalData);\n    };\n    const set = (data) => {\n        queue.enqueue(...data);\n    };\n    return {\n        ...events,\n        set\n    };\n}\n","export * from './responsive-queue.js';\n","import { Directed } from \"@ixfx/collections/graph\";\nimport { initStream } from \"./init-stream.js\";\nimport { isReactive } from \"./util.js\";\n// function isReactive(o: object): o is Reactive<any> {\n//   if (typeof o !== `object`) return false;\n//   if (`on` in o) {\n//     return (typeof o.on === `function`);\n//   }\n//   return false;\n// }\n/**\n * Build a graph of reactive dependencies for `rx`\n * @param _rx\n */\nexport function prepare(_rx) {\n    let g = Directed.graph();\n    const nodes = new Map();\n    const events = initStream();\n    const process = (o, path) => {\n        for (const [key, value] of Object.entries(o)) {\n            const subPath = path + `.` + key;\n            g = Directed.connect(g, {\n                from: path,\n                to: subPath\n            });\n            if (isReactive(value)) {\n                nodes.set(subPath, { value, type: `rx` });\n                value.on(v => {\n                    console.log(`Rx.prepare value: ${JSON.stringify(v)} path: ${subPath}`);\n                });\n            }\n            else {\n                const valueType = typeof value;\n                if (valueType === `bigint` || valueType === `boolean` || valueType === `number` || valueType === `string`) {\n                    nodes.set(subPath, { type: `primitive`, value });\n                }\n                else if (valueType === `object`) {\n                    process(value, subPath);\n                }\n                else if (valueType === `function`) {\n                    console.log(`Rx.process - not handling functions`);\n                }\n            }\n        }\n    };\n    // const produce = () => {\n    //   Object.fromEntries(entries);\n    // }\n    // process(rx, `_root`);\n    // console.log(DiGraph.dumpGraph(g));\n    // console.log(`--- Map ---`);\n    // for (const entries of nodes.entries()) {\n    //   console.log(entries[ 0 ]);\n    //   console.log(entries[ 1 ]);\n    //   console.log(``)\n    // }\n    const returnValue = {\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        dispose: events.dispose,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        isDisposed: events.isDisposed,\n        graph: g,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        on: events.on,\n        // eslint-disable-next-line @typescript-eslint/unbound-method\n        onValue: events.onValue\n    };\n    return returnValue;\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { resolveSource } from \"./resolve-source.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./util.js\";\n/**\n * Reads a set number of values from `source`, returning as an array. May contain\n * empty values if desired values is not reached.\n *\n * After the limit is reached (or `source` completes), `source` is unsubscribed from.\n *\n * If no limit is set, it will read until `source` completes or `maximumWait` is reached.\n * `maximumWait` is 10 seconds by default.\n *\n * Use {@link toArrayOrThrow} to throw if desired limit is not reached.\n *\n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArray()(source);\n * // Read 5 items from `source`\n * const data = await toArray({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArray({ maximumWait: 10_1000 })(source);\n * ```\n * @param source\n * @param options\n * @returns\n */\nexport async function toArray(source, options = {}) {\n    const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n    const maximumWait = intervalToMs(options.maximumWait, 10 * 1000);\n    const underThreshold = options.underThreshold ?? `partial`;\n    const read = [];\n    const rx = resolveSource(source);\n    const promise = new Promise((resolve, reject) => {\n        const done = () => {\n            clearTimeout(maxWait);\n            unsub();\n            if (read.length < limit && underThreshold === `throw`) {\n                reject(new Error(`Threshold not reached. Wanted: ${limit} got: ${read.length}. Maximum wait: ${maximumWait}`));\n                return;\n            }\n            if (read.length < limit && underThreshold === `fill`) {\n                for (let index = 0; index < limit; index++) {\n                    if (read[index] === undefined) {\n                        //console.log(`Rx.toArray filling at index: ${ index }`);\n                        read[index] = options.fillValue;\n                    }\n                }\n            }\n            resolve(read);\n        };\n        const maxWait = setTimeout(() => {\n            done();\n        }, maximumWait);\n        const unsub = rx.on(message => {\n            //console.log(`Rx.toArray: ${ JSON.stringify(message) }`);\n            if (messageIsDoneSignal(message)) {\n                done();\n            }\n            else if (messageHasValue(message)) {\n                read.push(message.value);\n                //console.log(`Rx.toArray read buffer: ${ JSON.stringify(read) }`);\n                if (read.length === limit) {\n                    done();\n                }\n            }\n        });\n    });\n    return promise;\n}\n/**\n * By default, reads all the values from `source`, or until 5 seconds has elapsed.\n *\n * If `limit` is provided as an option, it will exit early, or throw if that number of values was not acheived.\n *\n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArrayOrThrow()(source);\n * // Read 5 items from `source`\n * const data = await toArrayOrThrow({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArrayOrThrow({ maximumWait: 10_1000 })(source);\n * ```\n * @param source\n * @param options\n * @returns\n */\nexport async function toArrayOrThrow(source, options = {}) {\n    const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n    const maximumWait = options.maximumWait ?? 5 * 1000;\n    const v = await toArray(source, { limit, maximumWait, underThreshold: `partial` });\n    // There was a limit, but it wasn't reached\n    if (options.limit && v.length < options.limit)\n        throw new Error(`Threshold not reached. Wanted: ${options.limit}, got ${v.length}`);\n    // Otherwise, we may have been reading for a specified duration\n    return v;\n}\n","import { resolveSource } from \"./resolve-source.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./util.js\";\n/**\n * Returns an AsyncGenerator wrapper around Reactive.\n * This allows values to be iterated over using a `for await` loop,\n * like Chains.\n *\n * ```js\n * // Reactive numerical value\n * const number = Reactive.number(10);\n *\n * const g = Reactive.toGenerator(number);\n * for await (const v of g) {\n *  console.log(v); // Prints out whenever the reactive value changes\n * }\n * // Execution doesn't continue until Reactive finishes\n * ```\n *\n * When/if `source` closes, an exception is thrown.\n * To catch this, wrap the calling `for await` in a try-catch block\n * ```js\n * try {\n *  for await (const v of g) {\n *  }\n * } catch (error) {\n * }\n * // Completed\n * ```\n *\n * Use something like `setTimeout` to loop over the generator\n * without impeding the rest of your code flow. For example:\n * ```js\n * // Listen for every pointerup event\n * const ptr = Reactive.fromEvent(document.body, `pointerup`);\n * // Start iterating\n * setTimeout(async () => {\n *  const gen = Reactive.toGenerator(ptr);\n *  try {\n *    for await (const v of gen) {\n *      // Prints out whenever there is a click\n *      console.log(v);\n *    }\n *  } catch (e) { }\n *  console.log(`Iteration done`);\n * });\n *\n * // Execution continues here immediately\n * ```\n * @param source\n */\nexport async function* toGenerator(source) {\n    const s = resolveSource(source);\n    let promiseResolve = (_) => { };\n    let promiseReject = (_) => { };\n    const promiseInit = () => (new Promise((resolve, reject) => {\n        promiseResolve = resolve;\n        promiseReject = reject;\n    }));\n    let promise = promiseInit();\n    let keepRunning = true;\n    s.on(message => {\n        if (messageHasValue(message)) {\n            promiseResolve(message.value);\n            promise = promiseInit();\n        }\n        else if (messageIsDoneSignal(message)) {\n            keepRunning = false;\n            promiseReject(`Source has completed`);\n        }\n    });\n    while (keepRunning) {\n        yield await promise;\n    }\n}\n","import * as Ops from \"./ops/index.js\";\nimport * as Reactives from './reactives/index.js';\nimport { resolveSource } from \"./resolve-source.js\";\nimport { toArray, toArrayOrThrow } from \"./to-array.js\";\nimport { messageHasValue } from \"./util.js\";\nimport { mapObjectShallow } from '@ixfx/core/records';\nimport * as Enacts from './sinks/index.js';\n/**\n * Wrap a reactive source to allow for chained\n * function calls.\n *\n * Example:\n * For every `pointerup` event on the body, chunk the events over\n * periods of 200ms, get the number of events in that period,\n * and print it out.\n *\n * eg. detecting single or double-clicks\n * ```js\n * wrap(Rx.fromEvent<{ x: number, y: number }>(document.body, `pointerup`))\n *  .chunk({ elapsed: 200 })\n *  .transform(v => v.length)\n *  .onValue(v => { console.log(v) });\n * ```\n * @param source\n * @returns\n */\nexport function wrap(source) {\n    return {\n        source: resolveSource(source),\n        enacts: {\n            setHtmlText: (options) => {\n                return Enacts.setHtmlText(source, options);\n            },\n        },\n        annotate: (transformer) => {\n            const a = Ops.annotate(source, transformer);\n            return wrap(a);\n        },\n        annotateWithOp: (op) => {\n            const a = Ops.annotateWithOp(source, op);\n            return wrap(a);\n        },\n        chunk: (options) => {\n            const w = wrap(Ops.chunk(source, options));\n            return w;\n        },\n        // debounce: (options: Partial<DebounceOptions> = {}) => {\n        //   return wrap(Ops.debounce<TIn>(source, options));\n        // },\n        debounce: (options = {}) => {\n            return wrap(Reactives.debounce(source, options));\n        },\n        field: (fieldName, options = {}) => {\n            // Ops.field requires TIn extends object\n            // Would be good if `wrap` returns different versions depending on TIn, so .field\n            // would not be present at all if we had Reactive<number>, for example\n            // @ts-expect-error\n            const f = Ops.field(source, fieldName, options);\n            return wrap(f);\n        },\n        filter: (predicate, options) => {\n            return wrap(Ops.filter(source, predicate, options));\n        },\n        combineLatestToArray: (sources, options = {}) => {\n            const srcs = [source, ...sources];\n            return wrap(Ops.combineLatestToArray(srcs, options));\n        },\n        combineLatestToObject: (sources, options) => {\n            const name = options.name ?? `source`;\n            const o = { ...sources };\n            o[name] = source;\n            return wrap(Ops.combineLatestToObject(o, options));\n        },\n        min: (options = {}) => {\n            return wrap(Ops.min(source, options));\n        },\n        max: (options = {}) => {\n            return wrap(Ops.max(source, options));\n        },\n        average: (options = {}) => {\n            return wrap(Ops.average(source, options));\n        },\n        sum: (options = {}) => {\n            return wrap(Ops.sum(source, options));\n        },\n        tally: (options = {}) => {\n            return wrap(Ops.tally(source, options));\n        },\n        split: (options = {}) => {\n            const streams = Ops.split(source, options).map(v => wrap(v));\n            return streams;\n        },\n        splitLabelled: (...labels) => {\n            const l = Ops.splitLabelled(source, labels);\n            const m = mapObjectShallow(l, args => wrap(args.value));\n            return m;\n        },\n        switcher: (cases, options = {}) => {\n            const s = Ops.switcher(source, cases, options);\n            const m = mapObjectShallow(s, args => wrap(args.value));\n            return m;\n        },\n        syncToArray: (additionalSources, options = {}) => {\n            const unwrapped = [source, ...additionalSources].map(v => resolveSource(v));\n            const x = Ops.syncToArray(unwrapped, options);\n            return wrap(x); //synchronise<TIn>([ source, ...unwrapped ] as const));\n        },\n        syncToObject: (sources, options = {}) => {\n            const name = options.name ?? `source`;\n            const o = { ...sources };\n            o[name] = source;\n            return wrap(Ops.syncToObject(o, options));\n        },\n        tapProcess: (...processors) => {\n            Ops.tapProcess(source, ...processors);\n            return wrap(source);\n        },\n        tapStream: (divergedStream) => {\n            Ops.tapStream(source, divergedStream);\n            return wrap(source);\n        },\n        tapOps: (source, ...ops) => {\n            Ops.tapOps(source, ...ops);\n            return wrap(source);\n        },\n        throttle: (options = {}) => {\n            return wrap(Ops.throttle(source, options));\n        },\n        transform: (transformer, options = {}) => {\n            return wrap(Ops.transform(source, transformer, options));\n        },\n        timeoutValue: (options) => {\n            return wrap(Ops.timeoutValue(source, options));\n        },\n        timeoutPing: (options) => {\n            return wrap(Ops.timeoutPing(source, options));\n        },\n        toArray: (options) => {\n            return toArray(source, options);\n        },\n        toArrayOrThrow: (options) => {\n            return toArrayOrThrow(source, options);\n        },\n        onValue: (callback) => {\n            const s = resolveSource(source);\n            s.on(message => {\n                if (messageHasValue(message))\n                    callback(message.value);\n            });\n        }\n    };\n}\n","import { intervalToMs } from '@ixfx/core';\nimport { isWritable, messageHasValue, messageIsDoneSignal, opify } from \"./util.js\";\nimport { initStream } from \"./init-stream.js\";\nimport { resolveSource } from './resolve-source.js';\nimport * as SinkFns from './sinks/index.js';\nimport * as OpFns from './ops/index.js';\nexport * as From from './from/index.js';\nexport * as Collections from './collections/index.js';\nexport * from './ops/index.js';\nexport * from './sinks/index.js';\nexport * from './graph.js';\nexport * from './types.js';\nexport * from './to-array.js';\nexport * from './to-generator.js';\nexport * from './util.js';\nexport * from './wrap.js';\nexport * from './resolve-source.js';\nexport * from './cache.js';\nexport * from './init-stream.js';\nexport function run(source, ...ops) {\n    let s = resolveSource(source);\n    for (const op of ops) {\n        // @ts-ignore\n        s = op(s);\n    }\n    return s;\n}\nexport function writable(source, ...ops) {\n    let s = resolveSource(source);\n    const head = s;\n    for (const op of ops) {\n        // @ts-ignore\n        s = op(s);\n    }\n    const ss = s;\n    return {\n        ...ss,\n        set(value) {\n            if (isWritable(head)) {\n                head.set(value);\n            }\n            else\n                throw new Error(`Original source is not writable`);\n        }\n    };\n    //return s as Reactive<T2 | T3 | T4 | T5 | T6>;\n    //const raw = chainer<T1, T2, T3, T4, T5, T6>(...ops);\n    //return raw(source);\n}\n/**\n * Initialises a reactive that pipes values to listeners directly.\n * @returns\n */\nexport function manual(options = {}) {\n    const events = initStream(options);\n    return {\n        dispose: events.dispose,\n        isDisposed: events.isDisposed,\n        set(value) {\n            events.set(value);\n        },\n        on: events.on,\n        onValue: events.onValue\n    };\n}\nexport const Sinks = {\n    setHtmlText: (options) => {\n        return (source) => {\n            SinkFns.setHtmlText(source, options);\n        };\n    }\n};\nexport const Ops = {\n    /**\n   * Annotates values with the result of a function.\n   * The input value needs to be an object.\n   *\n   * For every value `input` emits, run it through `annotator`, which should\n   * return the original value with additional fields.\n   *\n   * Conceptually the same as `transform`, just with typing to enforce result\n   * values are V & TAnnotation\n   * @param annotator\n   * @returns\n   */\n    annotate: (annotator) => opify(OpFns.annotate, annotator),\n    /**\n     * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n     * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n     * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n     *\n     * ```js\n     * // Emit values from an array\n     * const r1 = Rx.run(\n     *  Rx.From.array([ 1, 2, 3 ]),\n     *  Rx.Ops.annotateWithOp(\n     *    // Add the 'max' operator to emit the largest-seen value\n     *    Rx.Ops.sum()\n     *  )\n     * );\n     * const data = await Rx.toArray(r1);\n     * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n     * ```\n     * @param annotatorOp\n     * @returns\n     */\n    annotateWithOp: (annotatorOp) => opify(OpFns.annotateWithOp, annotatorOp),\n    /**\n     * Takes a stream of values and chunks them up (by quantity or time elapsed),\n     * emitting them as an array.\n     * @param options\n     * @returns\n     */\n    chunk: (options) => {\n        return (source) => {\n            return OpFns.chunk(source, options);\n        };\n    },\n    cloneFromFields: () => {\n        return (source) => {\n            return OpFns.cloneFromFields(source);\n        };\n    },\n    /**\n   * Merges values from several sources into a single source that emits values as an array.\n   * @param options\n   * @returns\n   */\n    combineLatestToArray: (options = {}) => {\n        return (sources) => {\n            return OpFns.combineLatestToArray(sources, options);\n        };\n    },\n    /**\n     * Merges values from several sources into a single source that emits values as an object.\n     * @param options\n     * @returns\n     */\n    combineLatestToObject: (options = {}) => {\n        return (reactiveSources) => {\n            return OpFns.combineLatestToObject(reactiveSources, options);\n        };\n    },\n    /**\n   * Debounce values from the stream. It will wait until a certain time\n   * has elapsed before emitting latest value.\n   *\n   * Effect is that no values are emitted if input emits faster than the provided\n   * timeout.\n   *\n   * See also: throttle\n   * @param options\n   * @returns\n   */\n    // debounce: <V>(options: Partial<DebounceOptions>): ReactiveOp<V, V> => {\n    //   return (source: ReactiveOrSource<V>) => {\n    //     return OpFns.debounce(source, options);\n    //   }\n    // },\n    /**\n     * Drops values from the input stream that match `predicate`\n     * @param predicate If it returns _true_ value is ignored\n     * @returns\n     */\n    drop: (predicate) => opify(OpFns.drop, predicate),\n    /**\n     * Every upstream value is considered the target for interpolation.\n     * Output value interpolates by a given amount toward the target.\n     * @returns\n     */\n    elapsed: () => opify(OpFns.elapsed),\n    /**\n     * Yields the value of a field from an input stream of values.\n     * Eg if the source reactive emits `{ colour: string, size: number }`,\n     * we might use `field` to pluck out the `colour` field, thus returning\n     * a stream of string values.\n     * @param fieldName\n     * @param options\n     * @returns\n     */\n    field: (fieldName, options = {}) => {\n        return (source) => {\n            return OpFns.field(source, fieldName, options);\n        };\n    },\n    /**\n     * Filters the input stream, only re-emitting values that pass the predicate\n     * @param predicate If it returns _true_ value is allowed through\n     * @returns\n     */\n    filter: (predicate) => opify(OpFns.filter, predicate),\n    /**\n     * Every upstream value is considered the target for interpolation.\n     * Output value interpolates by a given amount toward the target.\n     * @param options\n     * @returns\n     */\n    interpolate: (options) => opify(OpFns.interpolate, options),\n    /**\n   * Outputs the minimum numerical value of the stream.\n   * A value is only emitted when minimum decreases.\n   * @returns\n   */\n    min: (options) => opify(OpFns.min, options),\n    /**\n     * Outputs the maxium numerical value of the stream.\n     * A value is only emitted when maximum increases.\n     * @returns\n     */\n    max: (options) => opify(OpFns.max, options),\n    sum: (options) => opify(OpFns.sum, options),\n    average: (options) => opify(OpFns.average, options),\n    tally: (options) => opify(OpFns.tally, options),\n    rank: (rank, options) => opify(OpFns.rank, rank, options),\n    pipe: (...streams) => {\n        return (source) => {\n            const resolved = resolveSource(source);\n            const s = [resolved, ...streams];\n            return OpFns.pipe(...s);\n        };\n    },\n    singleFromArray: (options = {}) => {\n        return (source) => {\n            return OpFns.singleFromArray(source, options);\n        };\n    },\n    split: (options = {}) => {\n        return (source) => {\n            return OpFns.split(source, options);\n        };\n    },\n    splitLabelled: (labels) => {\n        return (source) => {\n            return OpFns.splitLabelled(source, labels);\n        };\n    },\n    switcher: (cases, options = {}) => {\n        return (source) => {\n            return OpFns.switcher(source, cases, options);\n        };\n    },\n    syncToArray: (options = {}) => {\n        return (reactiveSources) => {\n            return OpFns.syncToArray(reactiveSources, options);\n        };\n    },\n    syncToObject: (options = {}) => {\n        return (reactiveSources) => {\n            return OpFns.syncToObject(reactiveSources, options);\n        };\n    },\n    tapProcess: (processor) => {\n        return (source) => {\n            return OpFns.tapProcess(source, processor);\n        };\n    },\n    tapStream: (divergedStream) => {\n        return (source) => {\n            return OpFns.tapStream(source, divergedStream);\n        };\n    },\n    tapOps: (...ops) => {\n        return (source) => {\n            return OpFns.tapOps(source, ...ops);\n        };\n    },\n    /**\n   * Throttle values from the stream.\n   * Only emits a value if some minimum time has elapsed.\n   * @param options\n   * @returns\n   */\n    throttle: (options) => opify(OpFns.throttle, options),\n    /**\n     * Trigger a value if 'source' does not emit a value within an interval.\n     * Trigger value can be a fixed value, result of function, or step through an iterator.\n     * @param options\n     * @returns\n     */\n    timeoutValue: (options) => {\n        return (source) => {\n            return OpFns.timeoutValue(source, options);\n        };\n    },\n    timeoutPing: (options) => {\n        return (source) => {\n            return OpFns.timeoutPing(source, options);\n        };\n    },\n    transform: (transformer, options = {}) => {\n        return (source) => {\n            return OpFns.transform(source, transformer, options);\n        };\n    },\n    /**\n    * Reactive where last (or a given initial) value is available to read\n    * @param opts\n    * @returns\n    */\n    withValue: (opts) => {\n        return opify(OpFns.withValue, opts);\n    },\n};\n// export const chain = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       // @ts-expect-error\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n// export const chainStream = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>): ReactiveStream<TIn, TOut> => {\n//   const stream = manual<TIn>();\n//   const c = chain(...ops);\n//   const x = c(stream);\n//   return x;\n// }\n// function chainx<TIn, TOut>(...ops: Array<ReactiveOp<any, any>>) {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n// export function runWithInitial<TIn, TOut>(initial: TOut, source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<any, any>>): ReactiveInitial<TOut> & ReactiveDisposable<TOut> {\n//   let lastValue = initial;\n//   const raw = prepareOps<TIn, TOut>(...ops);\n//   const r = raw(source);\n//   let disposed = false;\n//   r.onValue(value => {\n//     lastValue = value;\n//   });\n//   return {\n//     ...r,\n//     isDisposed() {\n//       return disposed\n//     },\n//     dispose(reason) {\n//       if (disposed) return;\n//       if (isDisposable(r)) {\n//         r.dispose(reason);\n//       }\n//       disposed = true;\n//     },\n//     last() {\n//       return lastValue;\n//     },\n//   }\n// }\n/**\n * Grabs the next value emitted from `source`.\n * By default waits up to a maximum of one second.\n * Handles subscribing and unsubscribing.\n *\n * ```js\n * const value = await Rx.takeNextValue(source);\n * ```\n *\n * Throws an error if the source closes without\n * a value or the timeout is reached.\n *\n * @param source\n * @param maximumWait\n * @returns\n */\nexport async function takeNextValue(source, maximumWait = 1000) {\n    const rx = resolveSource(source);\n    let off = () => { };\n    let watchdog;\n    const p = new Promise((resolve, reject) => {\n        off = rx.on(message => {\n            if (watchdog)\n                clearTimeout(watchdog);\n            if (messageHasValue(message)) {\n                off();\n                resolve(message.value);\n            }\n            else {\n                if (messageIsDoneSignal(message)) {\n                    reject(new Error(`Source closed. ${message.context ?? ``}`));\n                    off();\n                }\n            }\n        });\n        watchdog = setTimeout(() => {\n            watchdog = undefined;\n            off();\n            reject(new Error(`Timeout waiting for value (${JSON.stringify(maximumWait)})`));\n        }, intervalToMs(maximumWait));\n    });\n    return p;\n}\n/**\n * Connects reactive A to B, optionally transforming the value as it does so.\n *\n * Returns a function to unsubcribe A->B\n * @param a\n * @param b\n * @param transform\n */\nexport const to = (a, b, transform, closeBonA = false) => {\n    const unsub = a.on(message => {\n        if (messageHasValue(message)) {\n            const value = transform ? transform(message.value) : message.value;\n            b.set(value);\n        }\n        else if (messageIsDoneSignal(message)) {\n            unsub();\n            if (closeBonA) {\n                b.dispose(`Source closed (${message.context ?? ``})`);\n            }\n        }\n        else {\n            // eslint-disable-nex Unsupported message: ${ JSON.stringify(message) }`);\n        }\n    });\n    return unsub;\n};\n"],"mappings":"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"}