{"version":3,"sources":["../src/dom/CanvasHelper.ts"],"sourcesContent":["import type { Rect, RectPositioned } from '../geometry/rect/RectTypes.js';\nimport { scaler, type ScaleBy, type ScalerCombined } from \"../geometry/Scaler.js\";\nimport { resolveEl } from \"./ResolveEl.js\";\nimport { multiplyScalar as RectsMultiplyScalar } from \"../geometry/rect/Multiply.js\";\nimport { SimpleEventEmitter } from \"../Events.js\";\nimport { guard as RectsGuard } from '../geometry/rect/Guard.js';\nimport { Drawing, ImageDataGrid } from '../visual/index.js';\nimport { cloneFromFields } from '../data/CloneFromFields.js';\nimport { makeHelper, type DrawingHelper } from '../visual/Drawing.js';\nimport { Rects } from '../geometry/index.js';\nimport { ElementSizer, type ElementResizeLogic, type ElementSizerOptions } from './ElementSizing.js';\n\nexport type CanvasEvents = {\n  /**\n   * Fired when canvas is resized\n   */\n  resize: { size: Rect, helper: CanvasHelper, ctx: CanvasRenderingContext2D }\n\n  /**\n   * Pointerdown. \n   * \n   * Adds logicalX/Y to get logical pixel coordinate\n   */\n  pointerdown: PointerEvent & { physicalX: number, physicalY: number },\n  /**\n * Pointerup. \n * \n * Adds logicalX/Y to get logical pixel coordinate\n */\n  pointerup: PointerEvent & { physicalX: number, physicalY: number },\n  /**\n * Pointermove \n * \n * Adds logicalX/Y to get logical pixel coordinate\n */\n  pointermove: PointerEvent & { physicalX: number, physicalY: number },\n}\n\n\n/**\n * CanvasHelper options\n */\nexport type CanvasHelperOptions = Readonly<{\n  /**\n   * Automatic canvas resizing logic.\n   */\n  resizeLogic?: ElementResizeLogic\n  /**\n   * By default, the helper emits pointer events from the canvas.\n   * Set this to _true_ to disable.\n   */\n  disablePointerEvents: boolean\n  /**\n   * By default the display DPI is used for scaling.\n   * If this is set, this will override.\n   */\n  pixelZoom: number\n  /**\n   * If _true_ (default) canvas is cleared when a resize happens\n   */\n  clearOnResize: boolean\n  /**\n   * If true, it won't add any position CSS\n   */\n  skipCss: boolean;\n  coordinateScale: ScaleBy;\n  /**\n   * Callback when canvas is resized\n   * @param size \n   * @returns \n   */\n  onResize?: (ctx: CanvasRenderingContext2D, size: Rect, helper: CanvasHelper) => void\n  /**\n   * Logical width of canvas.\n   * This is used for establishing the desired aspect ratio.\n   */\n  width: number\n  /**\n   * Logical height of canvas.\n   * This is used for establishing the desired aspect ratio.\n   */\n  height: number\n  /**\n   * If set, the z-index for this canvas.\n   * By default, fullscreen canvas will be given -1\n   */\n  zIndex: number\n  /**\n   * Colour space to use. Defaults to sRGB.\n   */\n  colourSpace: PredefinedColorSpace;\n\n  /**\n   * If specified, this function be called in an animation loop.\n   * @param ctx Drawing context\n   * @param size Viewport size\n   * @param helper CanvasHelper instance\n   * @returns \n   */\n  draw?: (ctx: CanvasRenderingContext2D, size: Rect, helper: CanvasHelper) => void\n}>;\n\n\n/**\n * A wrapper for the CANVAS element that scales the canvas for high-DPI displays\n * and helps with resizing.\n * \n * ```js\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both` });\n * const { ctx, width, height } = canvas.ctx; // Get drawing context, width & height\n * ```\n * \n * Draw whenever it is resized using the 'resize' event\n * ```js\n * canvas.addEventListener(`resize`, ({ctx, size}) => {\n *  // Use ctx...  \n * });\n * ```\n * \n * Or provide a function when initialising:\n * ```js\n * const onResize = (ctx, size) => {\n *  // Do drawing\n * }\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both`, onResize });\n * ```\n * \n * Automatically draw at animation speeds:\n * ```js\n * const draw = () => {\n * }\n * const canvas = new CanvasHelper(`#my-canvas`, { resizeLogic: `both`, draw });\n * ```\n */\nexport class CanvasHelper extends SimpleEventEmitter<CanvasEvents> {\n  readonly el: HTMLCanvasElement;\n  readonly opts: CanvasHelperOptions\n\n  #scaler: ScalerCombined;\n  #scalerSize: ScalerCombined;\n  #viewport: RectPositioned = Rects.EmptyPositioned;\n  #logicalSize: Rect = Rects.Empty;\n  #ctx: CanvasRenderingContext2D | undefined;\n  #drawHelper: DrawingHelper | undefined;\n  #resizer: ElementSizer<HTMLCanvasElement> | undefined;\n  #disposed = false;\n\n  constructor(domQueryOrEl: Readonly<string | HTMLCanvasElement | undefined | null>, opts: Partial<CanvasHelperOptions> = {}) {\n    super();\n    if (!domQueryOrEl) throw new Error(`Param 'domQueryOrEl' is null or undefined`);\n    this.el = resolveEl<HTMLCanvasElement>(domQueryOrEl);\n    if (this.el.nodeName !== `CANVAS`) {\n      throw new Error(`Expected CANVAS HTML element. Got: ${ this.el.nodeName }`);\n    }\n\n    const size = this.el.getBoundingClientRect();\n    this.opts = {\n      resizeLogic: opts.resizeLogic ?? `none`,\n      disablePointerEvents: opts.disablePointerEvents ?? false,\n      pixelZoom: opts.pixelZoom ?? (window.devicePixelRatio || 1),\n      height: opts.height ?? size.height,\n      width: opts.width ?? size.width,\n      zIndex: opts.zIndex ?? -1,\n      coordinateScale: opts.coordinateScale ?? `both`,\n      onResize: opts.onResize,\n      clearOnResize: opts.clearOnResize ?? true,\n      draw: opts.draw,\n      skipCss: opts.skipCss ?? false,\n      colourSpace: `srgb`\n    }\n\n    this.#scaler = scaler(`both`);\n    this.#scalerSize = scaler(`both`, size);\n    this.#init();\n  }\n\n  getRectangle(): RectPositioned {\n    return {\n      x: 0, y: 0,\n      ...this.#logicalSize\n    }\n  }\n  dispose(reason?: string) {\n    if (this.#disposed) return;\n    this.#disposed = true;\n    if (this.#resizer) {\n      this.#resizer.dispose(`CanvasHelper disposing ${ reason }`.trim());\n      this.#resizer = undefined;\n    }\n  }\n\n  #getContext(reset = false) {\n    if (this.#ctx === undefined || reset) {\n      const ratio = this.ratio;\n      const c = this.el.getContext(`2d`);\n      if (c === null) throw new Error(`Could not create drawing context`);\n      this.#ctx = c;\n      // Reset scale\n      c.setTransform(1, 0, 0, 1, 0, 0);\n      c.scale(ratio, ratio);\n    }\n    return this.#ctx;\n  };\n\n  /**\n   * Gets the drawable area of the canvas.\n   * This accounts for scaling due to high-DPI displays etc.\n   * @returns \n   */\n  getPhysicalSize() {\n    return {\n      width: this.width * this.ratio,\n      height: this.height * this.ratio\n    }\n  }\n\n  /**\n   * Creates a drawing helper for the canvas.\n   * If one is already created it is reused.\n   */\n  getDrawHelper() {\n    if (!this.#drawHelper) {\n      this.#drawHelper = makeHelper(this.#getContext(), {\n        width: this.width, height: this.height\n      });\n    }\n  }\n\n  setLogicalSize(logicalSize: Rect) {\n    RectsGuard(logicalSize, `logicalSize`);\n    const logicalSizeInteger = Rects.applyFields(v => Math.floor(v), logicalSize);\n    const ratio = this.opts.pixelZoom;\n\n    // Scaler for going between relative and logical units\n    this.#scaler = scaler(this.opts.coordinateScale, logicalSize);\n    this.#scalerSize = scaler(`both`, logicalSize);\n\n    // Scaled logical size for DPI\n    const pixelScaled = RectsMultiplyScalar(logicalSize, ratio);\n\n    // Canvas will actually be much larger, based on DPI\n    this.el.width = pixelScaled.width;\n    this.el.height = pixelScaled.height;\n\n    // But scaled down on screen\n    this.el.style.width = logicalSizeInteger.width.toString() + `px`;\n    this.el.style.height = logicalSizeInteger.height.toString() + `px`;\n\n    // Since dimensions have change, reset context\n    this.#getContext(true);\n\n    if (this.opts.clearOnResize) {\n      this.ctx.clearRect(0, 0, this.width, this.height);\n    }\n\n    this.#logicalSize = logicalSizeInteger;\n\n    //console.log(`setting logical size to ${ this.#logicalSize.width }x${ this.#logicalSize.height }`);\n    // Notify listeners of resize\n    const r = this.opts.onResize;\n    if (r) {\n      setTimeout(() => { r(this.ctx, this.size, this) }, 100);\n    }\n    this.fireEvent(`resize`, { ctx: this.ctx, size: this.#logicalSize, helper: this });\n  }\n\n\n  #init() {\n    //console.log(`init`, this.opts);\n\n    // If there is a 'draw' callback, set up an animation loop\n    const d = this.opts.draw;\n    if (d) {\n      const sched = () => {\n        d(this.ctx, this.#logicalSize, this);\n        requestAnimationFrame(sched);\n      }\n      setTimeout(() => { sched() }, 100);\n    }\n\n    if (!this.opts.disablePointerEvents) {\n      this.#handleEvents();\n    }\n\n    const resizeLogic = this.opts.resizeLogic ?? `none`;\n    if (resizeLogic === `none`) {\n      this.setLogicalSize({ width: this.opts.width, height: this.opts.height });\n    } else {\n      const resizerOptions: ElementSizerOptions<HTMLCanvasElement> = {\n        onSetSize: (size) => {\n          if (Rects.isEqual(this.#logicalSize, size)) return;\n          this.setLogicalSize(size);\n        },\n        naturalSize: { width: this.opts.width, height: this.opts.height },\n        stretch: this.opts.resizeLogic ?? `none`\n      };\n      this.#resizer = new ElementSizer(this.el, resizerOptions);\n    }\n\n    this.#getContext();\n  }\n\n  #handleEvents() {\n    const handlePointerEvent = (event: PointerEvent) => {\n      const { offsetX, offsetY } = event;\n      const physicalX = offsetX * this.ratio;\n      const physicalY = offsetY * this.ratio;\n      event = cloneFromFields(event);\n      const eventData = {\n        physicalX, physicalY,\n        ...event\n      };\n\n      switch (event.type) {\n        case `pointerup`: {\n          {\n            this.fireEvent(`pointerup`, eventData);\n            break;\n          };\n        }\n        case `pointermove`: {\n          {\n            this.fireEvent(`pointermove`, eventData);\n            break;\n          };\n        }\n        case `pointerdown`: {\n          {\n            this.fireEvent(`pointerup`, eventData);\n            break;\n          };\n        }\n      };\n    }\n\n    this.el.addEventListener(`pointermove`, handlePointerEvent);\n    this.el.addEventListener(`pointerdown`, handlePointerEvent);\n    this.el.addEventListener(`pointerup`, handlePointerEvent);\n  }\n\n  /**\n   * Clears the canvas.\n   * \n   * Shortcut for:\n   * `ctx.clearRect(0, 0, this.width, this.height)`\n   */\n  clear() {\n    if (!this.#ctx) return;\n    this.#ctx.clearRect(0, 0, this.width, this.height);\n\n  }\n\n  /**\n   * Fills the canvas with a given colour.\n   * \n   * Shortcut for:\n   * ```js\n      * ctx.fillStyle = ``;\n   * ctx.fillRect(0, 0, this.width, this.height);\n   * ```\n   * @param colour Colour\n   */\n  fill(colour?: string) {\n    if (!this.#ctx) return;\n    if (colour) this.#ctx.fillStyle = colour;\n    this.#ctx.fillRect(0, 0, this.width, this.height);\n\n  }\n  /**\n   * Gets the drawing context\n   */\n  get ctx() {\n    if (this.#ctx === undefined) throw new Error(`Context not available`);\n    return this.#getContext();\n  }\n\n  get viewport() {\n    return this.#viewport;\n  }\n\n  /**\n   * Gets the logical width of the canvas\n   * See also: {@link height}, {@link size}\n   */\n  get width() {\n    return this.#logicalSize.width;\n  }\n\n  /**\n   * Gets the logical height of the canvas\n   * See also: {@link width}, {@link size}\n   */\n  get height() {\n    return this.#logicalSize.height;\n  }\n\n  /**\n   * Gets the logical size of the canvas\n   * See also: {@link width}, {@link height}\n   */\n  get size() {\n    return this.#logicalSize;\n  }\n\n  /**\n   * Gets the current scaling ratio being used\n   * to compensate for high-DPI display\n   */\n  get ratio() {\n    return window.devicePixelRatio || 1;\n  }\n\n  /**\n   * Returns the width or height, whichever is smallest\n   */\n  get dimensionMin() {\n    return Math.min(this.width, this.height);\n  }\n\n  /**\n   * Returns the width or height, whichever is largest\n   */\n  get dimensionMax() {\n    return Math.max(this.width, this.height);\n  }\n\n\n\n  drawBounds(strokeStyle = `green`) {\n    const ctx = this.#getContext();\n    Drawing.rect(ctx,\n      { x: 0, y: 0, width: this.width, height: this.height },\n      { crossed: true, strokeStyle, strokeWidth: 1 });\n\n    Drawing.rect(ctx, this.#viewport, { crossed: true, strokeStyle: `silver`, strokeWidth: 3 })\n  }\n\n  /**\n   * Returns a Scaler that converts from absolute\n   * to relative coordinates.\n   * This is based on the canvas size.\n   * \n   * ```js\n      * // Assuming a canvas of 800x500\n   * toRelative({ x: 800, y: 600 });  // { x: 1,   y: 1 }\n   * toRelative({ x: 0, y: 0 });   // { x: 0,   y: 0 }\n   * toRelative({ x: 400, y: 300 }); // { x: 0.5, y: 0.5 }\n   * ```\n   */\n  get toRelative() {\n    return this.#scaler.rel;\n  }\n\n  /**\n   * Returns a scaler for points based on width & height\n   */\n  get toAbsoluteFixed() {\n    return this.#scalerSize.abs\n  }\n\n  /**\n   * Returns a scaler for points based on width & height\n   */\n  get toRelativeFixed() {\n    return this.#scalerSize.rel;\n  }\n\n  get logicalCenter() {\n    return {\n      x: this.#logicalSize.width / 2,\n      y: this.#logicalSize.height / 2\n    }\n  }\n\n  /**\n * Returns a Scaler that converts from relative to absolute\n * coordinates.\n * This is based on the canvas size.\n * \n * ```js\n * // Assuming a canvas of 800x600\n * toAbsolute({ x: 1, y: 1 });      // { x: 800, y: 600}\n * toAbsolute({ x: 0, y: 0 });      // { x: 0, y: 0}\n * toAbsolute({ x: 0.5, y: 0.5 });  // { x: 400, y: 300}\n * ```\n */\n  get toAbsolute() {\n    return this.#scaler.abs;\n  }\n\n  /**\n   * Gets the center coordinate of the canvas\n   */\n  get center() {\n    return { x: this.width / 2, y: this.height / 2 }\n  }\n\n  /**\n   * Gets the image data for the canvas.\n   * Uses the 'physical' canvas size. Eg. A logical size of 400x400 might be\n   * 536x536 with a high-DPI display.\n   * @returns \n   */\n  getImageData(): ImageData {\n    const size = this.getPhysicalSize();\n    const data = this.ctx.getImageData(0, 0, size.width, size.height, { colorSpace: this.opts.colourSpace });\n    if (!data) throw new Error(`Could not get image data from context`);\n    return data;\n  }\n\n  /**\n   * Returns the canvas frame data as a writable grid.\n   * When editing, make as many edits as needed before calling\n   * `flip`, which writes buffer back to the canvas.\n   * ```js\n      * const g = helper.getWritableBuffer();\n   * // Get {r,g,b,opacity} of pixel 10,10\n   * const pixel = g.get({ x: 10, y: 10 });\n   * \n   * // Set a colour to pixel 10,10\n   * g.set({ r: 0.5, g: 1, b: 0, opacity: 0 }, { x: 10, y: 10 });\n   * \n   * // Write buffer to canvas\n   * g.flip();\n   * ```\n   * \n   * Uses 'physical' size of canvas. Eg with a high-DPI screen, this will\n   * mean a higher number of rows and columns compared to the logical size.\n   * @returns\n   */\n  getWritableBuffer() {\n    const ctx = this.ctx;\n    const data = this.getImageData();\n    const grid = ImageDataGrid.grid(data);\n    const get = ImageDataGrid.accessor(data);\n    const set = ImageDataGrid.setter(data);\n\n    const flip = () => {\n      ctx.putImageData(data, 0, 0);\n    }\n\n    return { grid, get, set, flip };\n  }\n}\n\n// export const imageDataAsGrid = (canvas: HTMLCanvasElement, colorSpace: PredefinedColorSpace = `srgb`) => {\n//   const ctx = canvas.getContext(`2d`);\n//   if (!ctx) throw new Error(`Could not create context`);\n\n//   const data = ctx.getImageData(0, 0, canvas.width, canvas.height, { colorSpace });\n//   if (!data) throw new Error(`Could not get image data from context`);\n\n//   const get = ImageDataGrid.accessor(data);\n//   const set = ImageDataGrid.setter(data);\n// }"],"mappings":"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","names":[]}