{"version":3,"file":"index-Bu_Q0Nu0.d.ts","names":["Point","Point3d","Placeholder","Readonly","Placeholder3d","Point","Point3d","abs","Point","angleRadian","angleRadianCircle","angleRadianThreePoint","Point","Point3d","PointApplyFn","Point3dApplyFn","apply","Point","PointAverager","PointAverageKinds","averager","Partial","Point","Point3d","RectArray","RectPositionedArray","Rect","Rect3d","RectPositioned","Rect3dPositioned","Rect3dPositioned","RectPositioned","Point","Point3d","bbox","ReadonlyArray","bbox3d","Point","centroid","Point","Point3d","clamp","Point","Point3d","compare","compareByX","compareByY","compareByZ","Point","convexHull","ReadonlyArray","Point","distance","distance2d","Point","Circle","CircleToSvg","CirclePositioned","CircleRandomPointOpts","Point","Line","PolyLine","ReadonlyArray","CirclePositioned","Line","PolyLine","Point","Point3d","RectPositioned","ShapePositioned","ContainsResult","Sphere","PointCalculableShape","Point","ArrowOpts","arrow","ReadonlyArray","Point","Triangle","BarycentricCoord","RandomSource","ShapePositioned","Point","Rect","Triangle","Circle","ShapeRandomPointOpts","randomPoint","Partial","center","Point","ShapePositioned","isIntersecting","Point","starburst","Point","PointCalculableShape","distanceToCenter","Point","PointCalculableShape","distanceToExterior","Point","Point3d","divide","divider","Point","dotProduct","Empty","Unit","Empty3d","Unit3d","Point","Point3d","findMinimum","ReadonlyArray","Point","Point3d","from","fromString","fromNumbers","Point","Point3d","getTwoPointParameters","getPointParameter","Array","ReadonlyArray","Point","Point3d","Result","isNull","isNaN","test","guard","guardNonZeroPoint","isPoint","isPoint3d","isEmpty","isPlaceholder","Point","interpolate","Point","Point3d","invert","Point","isEqual","ReadonlyArray","Point","clampMagnitude","Point","leftmost","ReadonlyArray","rightmost","Point","Point3d","multiply","multiplyScalar","Point","normalise","Rect","Point","normaliseByRect","Point","pipelineApply","pipeline","Point","PointRelation","PointRelationResult","Point","PolarToCartesian","Coord","PolarRay","Readonly","PolarRayWithOrigin","Coord","rotate","invert","isOpposite","isParallel","isAntiParallel","rotateDegrees","Point","Coord","PolarToCartesian","toLine","toCartesian","fromCartesian","toString","toPoint","Coord","isPolarCoord","guard","Coord","normalise","clampMagnitude","dotProduct","multiply","divide","Line","Point","PolarRay","toCartesian","toString","fromLine","Coord","spiral","IterableIterator","spiralRaw","Ray","TrackedValueMap","TrackedValueOpts","TrackOpts","TimestampedObject","ObjectTracker","Coord","PolarCoord","Line","PolyLine","Point","Point3d","PointRelation","TrimReason","PointRelationResult","PointTrack","PointTrackerResults","Readonly","PointTracker","TPoint","PointsTracker","UserPointerTracker","PointerEvent","MouseEvent","UserPointersTracker","Promise","Point3d","Point","progressBetween","Point","project","Point","Point3d","quantiseEvery","RandomSource","Point","Point3d","random","random3d","Point","reduce","ReadonlyArray","PointRelation","Point","relation","Point","rotate","rotatePointArray","ReadonlyArray","Array","Point","round","Point","Point3d","subtract","Point","Point3d","sum","Point","Point3d","toIntegerValues","to2d","to3d","toString","Point","toArray","ReadonlyArray","Point","withinRange","Point","wrap","Point","Point3d","Rect","area","RectPositioned","Rect","ApplyMergeOp","ApplyFieldOp","applyFields","applyMerge","applyScalar","applyDim","ISetMutable","GridVisual","Grid","GridCell","GridNeighbours","GridCardinalDirection","GridCardinalDirectionOptional","GridArray1d","T","GridReadable","GridWritable","GridBoundsLogic","GridNeighbourSelectionLogic","GridIdentifyNeighbours","GridNeighbourSelector","GridVisitorOpts","Readonly","GridCreateVisitor","Partial","Generator","GridCellAndValue","GridNeighbourMaybe","GridNeighbour","GridCellAccessor","TValue","GridCellSetter","GridBoundsLogic","GridCell","Grid","applyBounds","GridCellAccessor","GridCell","GridBoundsLogic","Grid","GridCellSetter","GridArray1d","access","V","setMutate","set","wrapMutable","T","wrap","createArray","createMutable","GridBoundsLogic","GridCell","GridCellAccessor","GridCellSetter","Grid","GridReadable","GridWritable","ArrayGrid","T","create","ReadonlyArray","Array","setMutate","V","access","wrapMutable","set","wrap","GridCell","Grid","rows","Generator","columns","GridBoundsLogic","GridCardinalDirection","GridCardinalDirectionOptional","GridCell","Grid","GridNeighbours","allDirections","crossDirections","offsetCardinals","getVectorFromCardinal","Grid","GridCell","GridCellAndValue","GridReadable","cells","Generator","cellValues","T","cellsAndValues","GridCell","getLine","ReadonlyArray","simpleLine","GridCell","Grid","isCell","guardCell","guardGrid","Grid","GridCell","GridBoundsLogic","indexFromCell","cellFromIndex","Grid","GridCell","inside","GridCell","Grid","GridVisual","isEqual","cellEquals","GridBoundsLogic","GridCardinalDirection","GridCell","Grid","GridNeighbour","GridNeighbours","randomNeighbour","neighbourList","neighbours","Grid","GridCell","GridBoundsLogic","offset","Grid","toArray2d","V","GridCell","cellKeyString","RectPositioned","GridCell","GridVisual","Point","asRectangles","IterableIterator","cellAtPoint","rectangleForCell","cellMiddle","GridReadable","GridCell","values","T","Iterable","Generator","GridNeighbourSelectionLogic","breadthLogic","GridNeighbourSelectionLogic","neighboursLogic","GridNeighbourSelectionLogic","GridVisitorOpts","columnLogic","Partial","GridNeighbourSelectionLogic","depthLogic","Grid","GridCell","GridCreateVisitor","stepper","GridNeighbourSelectionLogic","randomLogic","GridNeighbourSelectionLogic","randomContiguousLogic","GridNeighbourSelectionLogic","GridVisitorOpts","rowLogic","Partial","GridNeighbourSelectionLogic","Grid","GridCell","GridVisitorOpts","visitByNeighbours","Partial","Generator","GridCell","Grid","GridNeighbourSelectionLogic","GridVisitorOpts","VisitorTypes","create","Partial","Generator","withLogic","Array1d","Array2d","As","By","Visit","RectPositioned","GridCardinalDirection","Point","cardinal","Point","RectPositioned","centerOrigin","Point","Rect","RectPositioned","center","Point","Rect","RectPositioned","corners","RectPositioned","Point","distanceFromExterior","distanceFromCenter","RectPositioned","Rect","divide","divideScalar","divideDim","Rect","RectPositioned","Point","Line","edges","getEdgeX","getEdgeY","Empty","Readonly","EmptyPositioned","Point","RectPositioned","encompass","RectPositioned","Point","fromCenter","Rect","fromElement","HTMLElement","RectPositioned","Rect","fromNumbers","Point","RectPositioned","fromTopLeft","Point","Rect","RectPositioned","getRectPositionedParameter","RectPositioned","Rect","Point","guardDim","guard","getRectPositioned","guardPositioned","isEmpty","isPlaceholder","isPositioned","isRect","isRectPositioned","Rect","RectPositioned","Point","CirclePositioned","intersectsPoint","isIntersecting","Rect","RectPositioned","isEqualSize","isEqual","RectPositioned","lengths","Point","RectPositioned","maxFromCorners","RectPositioned","Rect","multiply","multiplyScalar","multiplyDim","Point","RectPositioned","nearestInternal","Placeholder","Readonly","PlaceholderPositioned","Rect","perimeter","Point","Rect","dividerByLargestDimension","Readonly","RandomSource","Point","Rect","RectPositioned","random","RectRandomPointOpts","randomPoint","Rect","RectPositioned","subtract","subtractSize","subtractOffset","Rect","RectPositioned","sum","sumOffset","Rect","RectArray","RectPositioned","RectPositionedArray","toArray","Point","RectPositioned","Path","ReadonlyArray","WithBeziers","CompoundPath","Dimensions","Point","Arc","ArcPositioned","ArcInterpolate","ArcToSvg","ArcSvgOpts","Point","Line","Path","Rect","RectPositioned","Arc","ArcInterpolate","ArcPositioned","ArcToSvg","CirclePositioned","isArc","isPositioned","fromDegrees","toLine","getStartEnd","point","guard","interpolate","angularSize","toPath","fromCircle","fromCircleAmount","length","bbox","toSvg","distanceCenter","isEqual","Path","Point","QuadraticBezier","QuadraticBezierPath","CubicBezier","CubicBezierPath","Path","QuadraticBezier","CubicBezier","isQuadraticBezier","isCubicBezier","Point","CubicBezier","CubicBezierPath","QuadraticBezier","QuadraticBezierPath","quadraticSimple","interpolator","quadraticToSvgString","ReadonlyArray","toPath","cubic","quadratic","Circle","area","CirclePositioned","Circle","RectPositioned","bbox","CirclePositioned","Circle","center","Readonly","Point","CompoundPath","Dimensions","Path","RectPositioned","setSegment","interpolate","distanceToPoint","relativePosition","computeDimensions","bbox","toString","guardContinuous","toSvgString","fromPaths","Point","Path","getStart","getEnd","Path","Circle","CircularPath","CirclePositioned","Point","distanceCenter","CirclePositioned","Point","distanceFromExterior","Point","CirclePositioned","exteriorIntegerPoints","IterableIterator","Point","Circle","CirclePositioned","guard","guardPositioned","isNaN","isPositioned","isCircle","isCirclePositioned","CirclePositioned","Point","interiorIntegerPoints","IterableIterator","Point","CirclePositioned","interpolate","CirclePositioned","Point","RectPositioned","isIntersecting","Point","CirclePositioned","Line","intersectionLine","intersections","CirclePositioned","Point","isContainedBy","Circle","CirclePositioned","isEqual","CirclePositioned","Circle","multiplyScalar","Point","Circle","CirclePositioned","nearest","pointOnPerimeter","circumference","length","Point","Circle","CirclePositioned","CircleRandomPointOpts","randomPoint","Partial","CircleToSvg","toSvg","CirclePositioned","CircularPath","toPath","Circle","CirclePositioned","Point","toPositioned","Line","parallel","perpendicularPoint","RectPositioned","Line","bbox","Point","Line","distanceSingleLine","Point","Line","divide","Line","fromFlatArray","Line","fromNumbers","Point","Line","fromPoints","Point","fromPivot","Readonly","Path","Point","Line","LinePath","ReadonlyArray","Point","LinePath","fromPointsToPath","Point","Line","getPointParameter","Line","PolyLine","isLine","isPolyLine","guard","Point","Line","interpolate","pointAtDistance","Line","isEqual","Point","PolyLine","joinPointsToLines","Point","Line","PolyLine","length","Point","Line","midpoint","Line","Point","multiply","Point","Line","nearest","Point","Line","relativePosition","Line","reverse","Point","Line","rotate","Point","Line","subtract","Point","Line","sum","LinePath","Line","toPath","Point","Line","toString","Point","Line","Empty","Readonly","Placeholder","isEmpty","isPlaceholder","apply","angleRadian","normaliseByRect","withinRange","slope","scaleFromMidpoint","pointAtX","extendFromA","pointsOf","Generator","distance","toFlatArray","asPoints","Iterable","toSvgString","CirclePositioned","Path","Point","Waypoint","WaypointOpts","fromPoints","Partial","Waypoints","WaypointResult","init","RandomSource","ShapePositioned","Circle","CirclePositioned","RandomOpts","random","CirclePacking","Point","Path","Ellipse","EllipsePositioned","fromDegrees","EllipticalPath","Point","degreeToRadian","radianInvert","degreeToGradian","gradianToDegree","radianToGradian","gradianToRadian","radianToDegree","radiansFromAxisX","radiansSum","degreesSum","radianArc","degreeArc","Angle","angleParse","angleConvert","turnToDegree","turnToRadian","degreeToTurn","radianToTurn","Point","rdpShortestDistance","Array","rdpPerpendicularDistance","TraversableTree","Point","ShapePositioned","RectPositioned","QuadTreeOpts","Direction","QuadTreeItem","quadTree","Partial","QuadTreeNode","IterableIterator","Point","Rect","Scaler","ScalerCombined","ScaleBy","scaler","Line","Point","Polar","Vector","Coord","fromRadians","Readonly","toRadians","fromPointPolar","fromLineCartesian","fromLinePolar","normalise","quadrantOffsetAngle","toPolar","toCartesian","toString","dotProduct","clampMagnitude","sum","subtract","multiply","divide","Point","Point3d","Circle","CirclePositioned","Sphere","VogelSpiralOpts","circleVogelSpiral","IterableIterator","CircleRingsOpts","circleRings","sphereFibonacci","Triangle","angles","ReadonlyArray","anglesDegrees","Triangle","area","Point","BarycentricCoord","Triangle","barycentricCoord","barycentricToCartestian","RectPositioned","Triangle","bbox","Point","Triangle","centroid","Point","Triangle","corners","ReadonlyArray","Point","Triangle","Empty","Readonly","Placeholder","equilateralFromVertex","Triangle","PolyLine","edges","Triangle","Point","fromRadius","fromFlatArray","fromPoints","CirclePositioned","Triangle","innerCircle","Point","Triangle","intersectsPoint","Triangle","isEquilateral","isIsosceles","isRightAngle","isOblique","isAcute","isObtuse","Triangle","lengths","ReadonlyArray","Point","Triangle","apply","Readonly","Triangle","CirclePositioned","outerCircle","Triangle","perimeter","Point","Triangle","rotate","rotateByVertex","Triangle","toFlatArray","Triangle","guard","isTriangle","isEmpty","isPlaceholder","isEqual","Circle","Point","Triangle","TriangleEquilateral","fromCenter","centerFromA","centerFromB","centerFromC","height","perimeter","area","circumcircle","incircle","Circle","Point","Triangle","Right","DefinedRight","fromA","fromB","fromC","resolveLengths","height","hypotenuseSegments","perimeter","area","angleAtPointA","angleAtPointB","medians","circumcircle","incircle","oppositeFromAdjacent","oppositeFromHypotenuse","adjacentFromHypotenuse","adjacentFromOpposite","hypotenuseFromOpposite","hypotenuseFromAdjacent","Circle","Point","Triangle","Isosceles","baseAngle","apexAngle","height","legHeights","perimeter","area","circumcircle","incircle","medians","fromCenter","fromA","fromB","fromC","Equilateral","Right","Isosceles","Arcs","Beziers","Circles","Grids","Lines","Paths","Points","Polar","Rects","Shapes","Waypoints","Layouts","Compound","Ellipses","CurveSimplification","QuadTree","Vectors","SurfacePoints","Triangles"],"sources":["../../geometry/dist/src/point/point-type.d.ts","../../geometry/dist/src/point/abs.d.ts","../../geometry/dist/src/point/angle.d.ts","../../geometry/dist/src/point/apply.d.ts","../../geometry/dist/src/point/averager.d.ts","../../geometry/dist/src/rect/rect-types.d.ts","../../geometry/dist/src/point/bbox.d.ts","../../geometry/dist/src/point/centroid.d.ts","../../geometry/dist/src/point/clamp.d.ts","../../geometry/dist/src/point/compare.d.ts","../../geometry/dist/src/point/convex-hull.d.ts","../../geometry/dist/src/point/distance.d.ts","../../geometry/dist/src/circle/circle-type.d.ts","../../geometry/dist/src/line/line-type.d.ts","../../geometry/dist/src/shape/shape-type.d.ts","../../geometry/dist/src/shape/arrow.d.ts","../../geometry/dist/src/triangle/triangle-type.d.ts","../../geometry/dist/src/shape/etc.d.ts","../../geometry/dist/src/shape/is-intersecting.d.ts","../../geometry/dist/src/shape/starburst.d.ts","../../geometry/dist/src/shape/index.d.ts","../../geometry/dist/src/point/distance-to-center.d.ts","../../geometry/dist/src/point/distance-to-exterior.d.ts","../../geometry/dist/src/point/divider.d.ts","../../geometry/dist/src/point/dot-product.d.ts","../../geometry/dist/src/point/empty.d.ts","../../geometry/dist/src/point/find-minimum.d.ts","../../geometry/dist/src/point/from.d.ts","../../geometry/dist/src/point/get-point-parameter.d.ts","../../geometry/dist/src/point/guard.d.ts","../../geometry/dist/src/point/interpolate.d.ts","../../geometry/dist/src/point/invert.d.ts","../../geometry/dist/src/point/is-equal.d.ts","../../geometry/dist/src/point/magnitude.d.ts","../../geometry/dist/src/point/most.d.ts","../../geometry/dist/src/point/multiply.d.ts","../../geometry/dist/src/point/normalise.d.ts","../../geometry/dist/src/point/normalise-by-rect.d.ts","../../geometry/dist/src/point/pipeline.d.ts","../../geometry/dist/src/point/point-relation-types.d.ts","../../geometry/dist/src/polar/types.d.ts","../../geometry/dist/src/polar/angles.d.ts","../../geometry/dist/src/polar/conversions.d.ts","../../geometry/dist/src/polar/guard.d.ts","../../geometry/dist/src/polar/math.d.ts","../../geometry/dist/src/polar/ray.d.ts","../../geometry/dist/src/polar/spiral.d.ts","../../geometry/dist/src/polar/index.d.ts","../../geometry/dist/src/point/point-tracker.d.ts","../../geometry/dist/src/point/progress-between.d.ts","../../geometry/dist/src/point/project.d.ts","../../geometry/dist/src/point/quantise.d.ts","../../geometry/dist/src/point/random.d.ts","../../geometry/dist/src/point/reduce.d.ts","../../geometry/dist/src/point/relation.d.ts","../../geometry/dist/src/point/rotate.d.ts","../../geometry/dist/src/point/rotate-point-array.d.ts","../../geometry/dist/src/point/round.d.ts","../../geometry/dist/src/point/subtract.d.ts","../../geometry/dist/src/point/sum.d.ts","../../geometry/dist/src/point/To.d.ts","../../geometry/dist/src/point/to-array.d.ts","../../geometry/dist/src/point/within-range.d.ts","../../geometry/dist/src/point/wrap.d.ts","../../geometry/dist/src/point/index.d.ts","../../geometry/dist/src/rect/area.d.ts","../../geometry/dist/src/rect/apply.d.ts","../../geometry/dist/src/grid/types.d.ts","../../geometry/dist/src/grid/apply-bounds.d.ts","../../geometry/dist/src/grid/array-1d.d.ts","../../geometry/dist/src/grid/array-2d.d.ts","../../geometry/dist/src/grid/as.d.ts","../../geometry/dist/src/grid/directions.d.ts","../../geometry/dist/src/grid/enumerators/cells.d.ts","../../geometry/dist/src/grid/enumerators/index.d.ts","../../geometry/dist/src/grid/geometry.d.ts","../../geometry/dist/src/grid/guards.d.ts","../../geometry/dist/src/grid/indexing.d.ts","../../geometry/dist/src/grid/inside.d.ts","../../geometry/dist/src/grid/is-equal.d.ts","../../geometry/dist/src/grid/neighbour.d.ts","../../geometry/dist/src/grid/offset.d.ts","../../geometry/dist/src/grid/to-array.d.ts","../../geometry/dist/src/grid/to-string.d.ts","../../geometry/dist/src/grid/visual.d.ts","../../geometry/dist/src/grid/values.d.ts","../../geometry/dist/src/grid/visitors/breadth.d.ts","../../geometry/dist/src/grid/visitors/cell-neighbours.d.ts","../../geometry/dist/src/grid/visitors/columns.d.ts","../../geometry/dist/src/grid/visitors/depth.d.ts","../../geometry/dist/src/grid/visitors/step.d.ts","../../geometry/dist/src/grid/visitors/random.d.ts","../../geometry/dist/src/grid/visitors/random-contiguous.d.ts","../../geometry/dist/src/grid/visitors/rows.d.ts","../../geometry/dist/src/grid/visitors/visitor.d.ts","../../geometry/dist/src/grid/visitors/index.d.ts","../../geometry/dist/src/grid/index.d.ts","../../geometry/dist/src/rect/cardinal.d.ts","../../geometry/dist/src/rect/center-origin.d.ts","../../geometry/dist/src/rect/center.d.ts","../../geometry/dist/src/rect/corners.d.ts","../../geometry/dist/src/rect/distance.d.ts","../../geometry/dist/src/rect/divide.d.ts","../../geometry/dist/src/rect/edges.d.ts","../../geometry/dist/src/rect/empty.d.ts","../../geometry/dist/src/rect/encompass.d.ts","../../geometry/dist/src/rect/from-center.d.ts","../../geometry/dist/src/rect/from-element.d.ts","../../geometry/dist/src/rect/from-numbers.d.ts","../../geometry/dist/src/rect/from-top-left.d.ts","../../geometry/dist/src/rect/get-rect-positionedparameter.d.ts","../../geometry/dist/src/rect/guard.d.ts","../../geometry/dist/src/rect/Intersects.d.ts","../../geometry/dist/src/rect/is-equal.d.ts","../../geometry/dist/src/rect/lengths.d.ts","../../geometry/dist/src/rect/max.d.ts","../../geometry/dist/src/rect/multiply.d.ts","../../geometry/dist/src/rect/nearest.d.ts","../../geometry/dist/src/rect/placeholder.d.ts","../../geometry/dist/src/rect/perimeter.d.ts","../../geometry/dist/src/rect/normalise-by-rect.d.ts","../../geometry/dist/src/rect/random.d.ts","../../geometry/dist/src/rect/subtract.d.ts","../../geometry/dist/src/rect/sum.d.ts","../../geometry/dist/src/rect/to-array.d.ts","../../geometry/dist/src/rect/index.d.ts","../../geometry/dist/src/path/path-type.d.ts","../../geometry/dist/src/arc/arc-type.d.ts","../../geometry/dist/src/arc/index.d.ts","../../geometry/dist/src/bezier/bezier-type.d.ts","../../geometry/dist/src/bezier/guard.d.ts","../../geometry/dist/src/bezier/index.d.ts","../../geometry/dist/src/circle/area.d.ts","../../geometry/dist/src/circle/bbox.d.ts","../../geometry/dist/src/circle/center.d.ts","../../geometry/dist/src/path/compound-path.d.ts","../../geometry/dist/src/path/start-end.d.ts","../../geometry/dist/src/path/index.d.ts","../../geometry/dist/src/circle/circular-path.d.ts","../../geometry/dist/src/circle/distance-center.d.ts","../../geometry/dist/src/circle/distance-from-exterior.d.ts","../../geometry/dist/src/circle/exterior-points.d.ts","../../geometry/dist/src/circle/guard.d.ts","../../geometry/dist/src/circle/interior-points.d.ts","../../geometry/dist/src/circle/interpolate.d.ts","../../geometry/dist/src/circle/intersecting.d.ts","../../geometry/dist/src/circle/intersections.d.ts","../../geometry/dist/src/circle/is-contained-by.d.ts","../../geometry/dist/src/circle/is-equal.d.ts","../../geometry/dist/src/circle/multiply.d.ts","../../geometry/dist/src/circle/perimeter.d.ts","../../geometry/dist/src/circle/random.d.ts","../../geometry/dist/src/circle/svg.d.ts","../../geometry/dist/src/circle/to-path.d.ts","../../geometry/dist/src/circle/to-positioned.d.ts","../../geometry/dist/src/circle/index.d.ts","../../geometry/dist/src/line/angles.d.ts","../../geometry/dist/src/line/bbox.d.ts","../../geometry/dist/src/line/distance-single-line.d.ts","../../geometry/dist/src/line/divide.d.ts","../../geometry/dist/src/line/from-flat-array.d.ts","../../geometry/dist/src/line/from-numbers.d.ts","../../geometry/dist/src/line/from-points.d.ts","../../geometry/dist/src/line/from-pivot.d.ts","../../geometry/dist/src/line/line-path-type.d.ts","../../geometry/dist/src/line/from-points-to-path.d.ts","../../geometry/dist/src/line/get-points-parameter.d.ts","../../geometry/dist/src/line/guard.d.ts","../../geometry/dist/src/line/interpolate.d.ts","../../geometry/dist/src/line/is-equal.d.ts","../../geometry/dist/src/line/join-points-to-lines.d.ts","../../geometry/dist/src/line/length.d.ts","../../geometry/dist/src/line/midpoint.d.ts","../../geometry/dist/src/line/multiply.d.ts","../../geometry/dist/src/line/nearest.d.ts","../../geometry/dist/src/line/relative-position.d.ts","../../geometry/dist/src/line/reverse.d.ts","../../geometry/dist/src/line/rotate.d.ts","../../geometry/dist/src/line/subtract.d.ts","../../geometry/dist/src/line/sum.d.ts","../../geometry/dist/src/line/to-path.d.ts","../../geometry/dist/src/line/to-string.d.ts","../../geometry/dist/src/line/index.d.ts","../../geometry/dist/src/waypoint.d.ts","../../geometry/dist/src/circle-packing.d.ts","../../geometry/dist/src/layout.d.ts","../../geometry/dist/src/ellipse.d.ts","../../geometry/dist/src/angles.d.ts","../../geometry/dist/src/curve-simplification.d.ts","../../geometry/dist/src/quad-tree.d.ts","../../geometry/dist/src/scaler.d.ts","../../geometry/dist/src/vector.d.ts","../../geometry/dist/src/surface-points.d.ts","../../geometry/dist/src/triangle/angles.d.ts","../../geometry/dist/src/triangle/area.d.ts","../../geometry/dist/src/triangle/barycentric.d.ts","../../geometry/dist/src/triangle/bbox.d.ts","../../geometry/dist/src/triangle/centroid.d.ts","../../geometry/dist/src/triangle/corners.d.ts","../../geometry/dist/src/triangle/create.d.ts","../../geometry/dist/src/triangle/edges.d.ts","../../geometry/dist/src/triangle/from.d.ts","../../geometry/dist/src/triangle/inner-circle.d.ts","../../geometry/dist/src/triangle/intersects.d.ts","../../geometry/dist/src/triangle/kinds.d.ts","../../geometry/dist/src/triangle/lengths.d.ts","../../geometry/dist/src/triangle/math.d.ts","../../geometry/dist/src/triangle/outer-circle.d.ts","../../geometry/dist/src/triangle/perimeter.d.ts","../../geometry/dist/src/triangle/rotate.d.ts","../../geometry/dist/src/triangle/to.d.ts","../../geometry/dist/src/triangle/guard.d.ts","../../geometry/dist/src/triangle/equilateral.d.ts","../../geometry/dist/src/triangle/right.d.ts","../../geometry/dist/src/triangle/isosceles.d.ts","../../geometry/dist/src/triangle/index.d.ts","../../geometry/dist/src/index.d.ts"],"sourcesContent":["/**\n * A point, consisting of x, y and maybe z fields.\n */\nexport type Point = {\n    readonly x: number;\n    readonly y: number;\n    readonly z?: number;\n};\nexport type Point3d = Point & {\n    readonly z: number;\n};\n/**\n * Placeholder point: `{ x: NaN, y: NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder3d` get a point with `z` property.\n */\nexport declare const Placeholder: Readonly<{\n    x: number;\n    y: number;\n}>;\n/**\n * Placeholder point: `{x: NaN, y:NaN, z:NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder` to get a point without `z` property.\n */\nexport declare const Placeholder3d: Readonly<{\n    x: number;\n    y: number;\n    z: number;\n}>;\n//# sourceMappingURL=point-type.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function abs(pt: Point3d): Point3d;\nexport declare function abs(pt: Point): Point;\n//# sourceMappingURL=abs.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns the angle in radians between `a` and `b`.\n *\n * Eg if `a` is the origin, and `b` is another point,\n * in degrees one would get 0 to -180 when `b` was above `a`.\n *  -180 would be `b` in line with `a`.\n * Same for under `a`.\n *\n * Providing a third point `c` gives the interior angle, where `b` is the middle point.\n *\n * See also {@link angleRadianCircle} which returns coordinates on 0..Math.Pi*2\n * range. This avoids negative numbers.\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport declare const angleRadian: (a: Point, b?: Point, c?: Point) => number;\n/**\n * Returns the angle between point(s) using a radian circle system.\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport declare const angleRadianCircle: (a: Point, b?: Point, c?: Point) => number;\n/**\n * Return the angle of a wedge, defined by a, b and C points, where 'b'\n * could be thought of as the origin or pivot.\n *\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport declare const angleRadianThreePoint: (a: Point, b: Point, c: Point) => number;\n//# sourceMappingURL=angle.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport type PointApplyFn = (v: number, field: `x` | `y`) => number;\nexport type Point3dApplyFn = (v: number, field: `x` | `y` | `z`) => number;\nexport declare function apply(pt: Point3d, fn: Point3dApplyFn): Point3d;\nexport declare function apply(pt: Point, fn: PointApplyFn): Point;\n//# sourceMappingURL=apply.d.ts.map","import type { Point } from \"./point-type.js\";\nexport type PointAverager = (point: Point) => Point;\nexport type PointAverageKinds = `moving-average-light`;\n/**\n * Keeps track of average x, y and z values.\n *\n * When calling, you have to specify the averaging technique. At the moment\n * only 'moving-average-light' is supported. This uses @ixfx/numbers.movingAverageLight\n * under-the-hood.\n *\n * ```js\n * // Create averager\n * const averager = Points.averager(`moving-average-light`);\n *\n * // Call function with a point to add it to average\n * // and return the current average.\n * averager(somePoint); // Yields current average {x,y,z?}\n * ```\n *\n * @param kind Averaging strategy\n * @param opts Scaling parameter. Higher means more smoothing, lower means less (minimum: 1). Default: 3\n * @returns\n */\nexport declare function averager(kind: `moving-average-light`, opts: Partial<{\n    scaling: number;\n}>): PointAverager;\n//# sourceMappingURL=averager.d.ts.map","import type { Point, Point3d } from \"../point/point-type.js\";\n/**\n * Rectangle as array: `[width, height]`\n */\nexport type RectArray = readonly [width: number, height: number];\n/**\n * Positioned rectangle as array: `[x, y, width, height]`\n */\nexport type RectPositionedArray = readonly [\n    x: number,\n    y: number,\n    width: number,\n    height: number\n];\nexport type Rect = {\n    readonly width: number;\n    readonly height: number;\n};\nexport type Rect3d = Rect & {\n    readonly depth: number;\n};\nexport type RectPositioned = Point & Rect;\nexport type Rect3dPositioned = Point3d & Rect3d;\n//# sourceMappingURL=rect-types.d.ts.map","import type { Rect3dPositioned, RectPositioned } from \"../rect/rect-types.js\";\nimport type { Point, Point3d } from \"./point-type.js\";\n/**\n * Returns the minimum rectangle that can enclose all provided points\n * @param points\n * @returns\n */\nexport declare const bbox: (...points: ReadonlyArray<Point>) => RectPositioned;\nexport declare const bbox3d: (...points: ReadonlyArray<Point3d>) => Rect3dPositioned;\n//# sourceMappingURL=bbox.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Calculates the [centroid](https://en.wikipedia.org/wiki/Centroid#Of_a_finite_set_of_points) of a set of points\n * Undefined values are skipped over. Calculation and return value is 2D.\n *\n * ```js\n * // Find centroid of a list of points\n * const c1 = centroid(p1, p2, p3, ...);\n *\n * // Find centroid of an array of points\n * const c2 = centroid(...pointsArray);\n * ```\n * @param points\n * @returns A single point\n */\nexport declare const centroid: (...points: readonly (Point | undefined)[]) => Point;\n//# sourceMappingURL=centroid.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function clamp(a: Point, min?: number, max?: number): Point;\nexport declare function clamp(a: Point3d, min?: number, max?: number): Point3d;\n//# sourceMappingURL=clamp.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\n/**\n * Returns -2 if both x & y of a is less than b\n * Returns -1 if either x/y of a is less than b\n *\n * Returns 2 if both x & y of a is greater than b\n * Returns 1 if either x/y of a is greater than b's x/y\n *\n * Returns 0 if x/y of a and b are equal\n * @param a\n * @param b\n * @returns\n */\nexport declare const compare: (a: Point, b: Point) => number;\n/**\n * Compares points based on x value. Y value is ignored.\n *\n * Return values:\n * * 0: If a.x === b.x\n * * 1: a is to the right of b (ie. a.x > b.x)\n * * -1: a is to the left of b (ie. a.x < b.x)\n *\n * @example Sorting by x\n * ```js\n * arrayOfPoints.sort(Points.compareByX);\n * ```\n *\n * @param a\n * @param b\n * @returns\n */\nexport declare const compareByX: (a: Point, b: Point) => number;\n/**\n * Compares points based on Y value. X value is ignored.\n *\n * Return values:\n * * 0: If a.y === b.y\n * * 1: A is below B (ie. a.y > b.y)\n * * -1: A is above B (ie. a.y < b.y)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByY);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const compareByY: (a: Point, b: Point) => number;\n/**\n * Compares points based on Z value. XY values are ignored.\n *\n * Return values:\n * * 0: If a.z === b.z\n * * 1: A is below B (ie. a.z > b.z)\n * * -1: A is above B (ie. a.z < b.z)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByZ);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const compareByZ: (a: Point3d, b: Point3d) => number;\n//# sourceMappingURL=compare.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Simple convex hull impementation. Returns a set of points which\n * enclose `pts`.\n *\n * For more power, see something like [Hull.js](https://github.com/AndriiHeonia/hull)\n * @param pts\n * @returns\n */\nexport declare const convexHull: (...pts: ReadonlyArray<Point>) => ReadonlyArray<Point>;\n//# sourceMappingURL=convex-hull.d.ts.map","import type { Point } from './point-type.js';\nexport declare function distance(a: Point, b?: Point): number;\nexport declare function distance(a: Point, x: number, y: number): number;\n/**\n * As {@distance} but always compares by x,y only.\n * @param a\n * @param xOrB\n * @param y\n * @param z\n * @returns\n */\nexport declare function distance2d(a: Point, xOrB?: Point | number, y?: number): number;\n//# sourceMappingURL=distance.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * A circle\n */\nexport type Circle = {\n    readonly radius: number;\n};\nexport type CircleToSvg = {\n    (circleOrRadius: Circle | number, sweep: boolean, origin: Point): readonly string[];\n    (circle: CirclePositioned, sweep: boolean): readonly string[];\n};\n/**\n * A {@link Circle} with position\n */\nexport type CirclePositioned = Point & Circle;\nexport type CircleRandomPointOpts = {\n    /**\n     * Algorithm to calculate random values.\n     * Default: 'uniform'\n     */\n    readonly strategy: `naive` | `uniform`;\n    /**\n     * Random number source.\n     * Default: Math.random\n     */\n    readonly randomSource: () => number;\n    /**\n     * Margin within shape to start generating random points\n     * Default: 0\n     */\n    readonly margin: number;\n};\n//# sourceMappingURL=circle-type.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * A line, which consists of an `a` and `b` {@link Point}.\n */\nexport type Line = {\n    readonly a: Point;\n    readonly b: Point;\n};\n/**\n * A PolyLine, consisting of more than one line.\n */\nexport type PolyLine = ReadonlyArray<Line>;\n//# sourceMappingURL=line-type.d.ts.map","import type { CirclePositioned } from \"../circle/circle-type.js\";\nimport type { Line, PolyLine } from \"../line/line-type.js\";\nimport type { Point, Point3d } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"../rect/rect-types.js\";\nexport type ShapePositioned = CirclePositioned | RectPositioned;\nexport type ContainsResult = `none` | `contained`;\nexport type Sphere = Point3d & {\n    readonly radius: number;\n};\nexport type PointCalculableShape = PolyLine | Line | RectPositioned | Point | CirclePositioned;\n//# sourceMappingURL=shape-type.d.ts.map","import type { Point } from \"../point/point-type.js\";\nexport type ArrowOpts = {\n    readonly arrowSize?: number;\n    readonly tailLength?: number;\n    readonly tailThickness?: number;\n    readonly angleRadian?: number;\n};\n/**\n * Returns the points forming an arrow.\n *\n * @example Create an arrow anchored by its tip at 100,100\n * ```js\n * const opts = {\n *  tailLength: 10,\n *  arrowSize: 20,\n *  tailThickness: 5,\n *  angleRadian: degreeToRadian(45)\n * }\n * const arrow = Shapes.arrow({x:100, y:100}, `tip`, opts); // Yields an array of points\n *\n * // Eg: draw points\n * Drawing.connectedPoints(ctx, arrow, {strokeStyle: `red`, loop: true});\n * ```\n *\n * @param origin Origin of arrow\n * @param from Does origin describe the tip, tail or middle?\n * @param opts Options for arrow\n * @returns\n */\nexport declare const arrow: (origin: Point, from: `tip` | `tail` | `middle`, opts?: ArrowOpts) => ReadonlyArray<Point>;\n//# sourceMappingURL=arrow.d.ts.map","import type { Point } from \"../point/point-type.js\";\nexport type Triangle = {\n    readonly a: Point;\n    readonly b: Point;\n    readonly c: Point;\n};\nexport type BarycentricCoord = {\n    readonly a: number;\n    readonly b: number;\n    readonly c: number;\n};\n//# sourceMappingURL=triangle-type.d.ts.map","import type { RandomSource } from \"@ixfx/random\";\nimport type { ShapePositioned } from \"./shape-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Rect } from \"../rect/rect-types.js\";\nimport type { Triangle } from \"../triangle/triangle-type.js\";\nimport type { Circle } from \"../circle/circle-type.js\";\nexport type ShapeRandomPointOpts = {\n    readonly randomSource: RandomSource;\n};\n/**\n * Returns a random point within a shape.\n * `shape` can be {@link Circles.CirclePositioned} or {@link Rects.RectPositioned}\n * @param shape\n * @param opts\n * @returns\n */\nexport declare const randomPoint: (shape: ShapePositioned, opts?: Partial<ShapeRandomPointOpts>) => Point;\n/**\n * Returns the center of a shape\n * Shape can be: rectangle, triangle, circle\n * @param shape\n * @returns\n */\nexport declare const center: (shape?: Rect | Triangle | Circle) => Point;\n//# sourceMappingURL=etc.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { ShapePositioned } from \"./shape-type.js\";\n/**\n * Returns the intersection result between a and b.\n * `a` can be a {@link Circles.CirclePositioned} or {@link Rects.RectPositioned}\n * `b` can be as above or a {@link Point}.\n * @param a\n * @param b\n */\nexport declare const isIntersecting: (a: ShapePositioned, b: ShapePositioned | Point) => boolean;\n//# sourceMappingURL=is-intersecting.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * Generates a starburst shape, returning an array of points. By default, initial point is top and horizontally-centred.\n *\n * ```\n * // Generate a starburst with four spikes\n * const pts = starburst(4, 100, 200);\n * ```\n *\n * `points` of two produces a lozenge shape.\n * `points` of three produces a triangle shape.\n * `points` of five is the familiar 'star' shape.\n *\n * Note that the path will need to be closed back to the first point to enclose the shape.\n *\n * @example Create starburst and draw it. Note use of 'loop' flag to close the path\n * ```\n * const points = starburst(4, 100, 200);\n * Drawing.connectedPoints(ctx, pts, {loop: true, fillStyle: `orange`, strokeStyle: `red`});\n * ```\n *\n * Options:\n * * initialAngleRadian: angle offset to begin from. This overrides the `-Math.PI/2` default.\n *\n * @param points Number of points in the starburst. Defaults to five, which produces a typical star\n * @param innerRadius Inner radius. A proportionally smaller inner radius makes for sharper spikes. If unspecified, 50% of the outer radius is used.\n * @param outerRadius Outer radius. Maximum radius of a spike to origin\n * @param opts Options\n * @param origin Origin, or `{ x:0, y:0 }` by default.\n */\nexport declare const starburst: (outerRadius: number, points?: number, innerRadius?: number, origin?: Point, opts?: {\n    readonly initialAngleRadian?: number;\n}) => readonly Point[];\n//# sourceMappingURL=starburst.d.ts.map","export type * from './shape-type.js';\nexport * from './arrow.js';\nexport * from './etc.js';\nexport * from './is-intersecting.js';\nexport * from './starburst.js';\n//# sourceMappingURL=index.d.ts.map","import type { Point } from \"./point-type.js\";\nimport type { PointCalculableShape } from \"../shape/index.js\";\n/**\n * Returns the distance from point `a` to the center of `shape`.\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport declare const distanceToCenter: (a: Point, shape: PointCalculableShape) => number;\n//# sourceMappingURL=distance-to-center.d.ts.map","import type { Point } from \"./point-type.js\";\nimport type { PointCalculableShape } from \"../shape/shape-type.js\";\n/**\n * Returns the distance from point `a` to the exterior of `shape`.\n *\n * @example Distance from point to rectangle\n * ```\n * const distance = distanceToExterior(\n *  {x: 50, y: 50},\n *  {x: 100, y: 100, width: 20, height: 20}\n * );\n * ```\n *\n * @example Find closest shape to point\n * ```\n * import {minIndex} from '../data/arrays.js';\n * const shapes = [ some shapes... ]; // Shapes to compare against\n * const pt = { x: 10, y: 10 };       // Comparison point\n * const distances = shapes.map(v => distanceToExterior(pt, v));\n * const closest = shapes[minIndex(...distances)];\n * ```\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport declare const distanceToExterior: (a: Point, shape: PointCalculableShape) => number;\n//# sourceMappingURL=distance-to-exterior.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function divide(a: Point, b: Point): Point;\nexport declare function divide(a: Point3d, b: Point3d): Point3d;\nexport declare function divide(a: Point, x: number, y: number): Point;\nexport declare function divide(a: Point3d, x: number, y: number, z: number): Point3d;\nexport declare function divide(ax: number, ay: number, bx: number, by: number): Point;\nexport declare function divide(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n/**\n * Returns a function that divides a point:\n * ```js\n * const f = divider(100, 200);\n * f(50,100); // Yields: { x: 0.5, y: 0.5 }\n * ```\n *\n * Input values can be Point, separate x,y and optional z values or an array:\n * ```js\n * const f = divider({ x: 100, y: 100 });\n * const f = divider( 100, 100 );\n * const f = divider([ 100, 100 ]);\n * ```\n *\n * Likewise the returned function an take these as inputs:\n * ```js\n * f({ x: 100, y: 100});\n * f( 100, 100 );\n * f([ 100, 100 ]);\n * ```\n *\n * Function throws if divisor has 0 for any coordinate (since we can't divide by 0)\n * @param a Divisor point, array of points or x\n * @param b Divisor y value\n * @param c Divisor z value\n * @returns\n */\nexport declare function divider(a: Point3d | Point | number | number[], b?: number, c?: number): (aa: Point3d | Point | number | number[], bb?: number, cc?: number) => Point;\n//# sourceMappingURL=divider.d.ts.map","import type { Point } from './point-type.js';\nexport declare const dotProduct: (...pts: readonly Point[]) => number;\n//# sourceMappingURL=dot-product.d.ts.map","/**\n * An empty point of `{ x: 0, y: 0 }`.\n *\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty3d` to get an empty point with `z`.\n */\nexport declare const Empty: {\n    readonly x: 0;\n    readonly y: 0;\n};\n/**\n * Returns { x:1, y:1 }\n */\nexport declare const Unit: {\n    readonly x: 1;\n    readonly y: 1;\n};\n/**\n * An empty Point of `{ x: 0, y: 0, z: 0}`\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty` to get an empty point without `z`.\n */\nexport declare const Empty3d: {\n    readonly x: 0;\n    readonly y: 0;\n    readonly z: 0;\n};\n/**\n * Returns { x:1,y:1,z:1 }\n */\nexport declare const Unit3d: {\n    readonly x: 1;\n    readonly y: 1;\n    readonly z: 1;\n};\n//# sourceMappingURL=empty.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function findMinimum(comparer: (a: Point, b: Point) => Point, ...points: ReadonlyArray<Point>): Point;\nexport declare function findMinimum(comparer: (a: Point3d, b: Point3d) => Point3d, ...points: ReadonlyArray<Point3d>): Point3d;\n//# sourceMappingURL=find-minimum.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function from(x: number, y: number, z: number): Point3d;\nexport declare function from(x: number, y: number): Point;\nexport declare function from(array: [x: number, y: number, z: number]): Point3d;\nexport declare function from(array: [x: number, y: number]): Point;\n/**\n * Parses a point as a string, in the form 'x,y' or 'x,y,z'.\n * eg '10,15' will be returned as `{ x: 10, y: 15 }`.\n *\n * Throws an error if `str` is not a string.\n *\n * ```js\n * Points.fromString(`10,15`);  // { x:10, y:15 }\n * Points.fromString(`a,10`);   // { x:NaN, y:10 }\n * ```\n *\n * Use {@link Points.isNaN} to check if returned point has NaN for either coordinate.\n * @param string_\n */\nexport declare const fromString: (string_: string) => Point;\n/**\n * Returns an array of points from an array of numbers.\n *\n * Array can be a continuous series of x, y values:\n * ```\n * [1,2,3,4] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n *\n * Or it can be an array of arrays:\n * ```\n * [[1,2], [3,4]] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n * @param coords\n * @returns\n */\nexport declare const fromNumbers: (...coords: readonly (readonly number[])[] | readonly number[]) => readonly Point[];\n//# sourceMappingURL=from.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function getTwoPointParameters(a: Point, b: Point): [a: Point, b: Point];\nexport declare function getTwoPointParameters(a: Point3d, b: Point3d): [a: Point3d, b: Point3d];\nexport declare function getTwoPointParameters(a: Point, x: number, y: number): [a: Point, b: Point];\nexport declare function getTwoPointParameters(a: Point3d, x: number, y: number, z: number): [a: Point3d, b: Point3d];\nexport declare function getTwoPointParameters(ax: number, ay: number, bx: number, by: number): [a: Point, b: Point];\nexport declare function getTwoPointParameters(ax: number, ay: number, az: number, bx: number, by: number, bz: number): [a: Point3d, b: Point3d];\n/**\n * Returns a Point form of either a point, x,y params or x,y,z params.\n * If parameters are undefined, an empty point is returned (0, 0)\n * @ignore\n * @param a\n * @param b\n * @returns\n */\nexport declare function getPointParameter(a?: Point3d | Point | number | Array<number> | ReadonlyArray<number>, b?: number | boolean, c?: number): Point | Point3d;\n//# sourceMappingURL=get-point-parameter.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nimport { type Result } from '@ixfx/guards';\n/**\n * Returns true if xy (and z, if present) are _null_.\n * @param p\n * @returns\n */\nexport declare const isNull: (p: Point) => boolean;\n/***\n * Returns true if either x, y, z isNaN.\n */\nexport declare const isNaN: (p: Point) => boolean;\nexport declare function test(p: Point, name?: string, extraInfo?: string): Result<Point, string>;\n/**\n * Throws an error if point is invalid\n * @param p\n * @param name\n */\nexport declare function guard(p: Point, name?: string, info?: string): void;\n/**\n * Throws if parameter is not a valid point, or either x or y is 0\n * @param pt\n * @returns\n */\nexport declare const guardNonZeroPoint: (pt: Point | Point3d, name?: string) => boolean;\n/**\n * Returns _true_ if `p` has x & y properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * Use {@link isPoint3d} to check further check for `z`.\n * @param p\n * @returns\n */\nexport declare function isPoint(p: number | unknown): p is Point;\n/**\n * Returns _true_ if `p` has x, y, & z properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * @param p\n * @returns\n */\nexport declare const isPoint3d: (p: Point | unknown) => p is Point3d;\n/**\n * Returns true if both xy (and z, if present) are 0.\n * Use `Points.Empty` to return an empty point.\n * @param p\n * @returns\n */\nexport declare const isEmpty: (p: Point) => boolean;\n/**\n * Returns true if point is a placeholder, where xy (and z, if present)\n * are `NaN`.\n *\n * Use Points.Placeholder to return a placeholder point.\n * @param p\n * @returns\n */\nexport declare const isPlaceholder: (p: Point) => boolean;\n//# sourceMappingURL=guard.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns a relative point between two points.\n *\n * ```js\n * interpolate(0.5, { x:0, y:0 }, { x:10, y:10 }); // Halfway { x, y }\n * ```\n *\n * Alias for Lines.interpolate(amount, a, b);\n *\n * @param amount Relative amount, 0-1\n * @param a\n * @param b\n * @param allowOverflow If true, length of line can be exceeded for `amount` of below 0 and above `1`.\n * @returns {@link Point}\n */\nexport declare const interpolate: (amount: number, a: Point, b: Point, allowOverflow?: boolean) => Point;\n//# sourceMappingURL=interpolate.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\n/**\n * Inverts one or more axis of a point\n * ```js\n * invert({x:10, y:10}); // Yields: {x:-10, y:-10}\n * invert({x:10, y:10}, `x`); // Yields: {x:-10, y:10}\n * ```\n * @param pt Point to invert\n * @param what Which axis. If unspecified, both axies are inverted\n * @returns\n */\nexport declare const invert: (pt: Point | Point3d, what?: `both` | `x` | `y` | `z`) => Point;\n//# sourceMappingURL=invert.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns _true_ if the points have identical values\n *\n * ```js\n * const a = {x: 10, y: 10};\n * const b = {x: 10, y: 10;};\n * a === b        // False, because a and be are different objects\n * isEqual(a, b)   // True, because a and b are same value\n * ```\n * @param p Points\n * @returns _True_ if points are equal\n */\nexport declare const isEqual: (...p: ReadonlyArray<Point>) => boolean;\n//# sourceMappingURL=is-equal.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Clamps the magnitude of a point.\n * This is useful when using a Point as a vector, to limit forces.\n * @param pt\n * @param max Maximum magnitude (1 by default)\n * @param min Minimum magnitude (0 by default)\n * @returns\n */\nexport declare const clampMagnitude: (pt: Point, max?: number, min?: number) => Point;\n//# sourceMappingURL=magnitude.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns the left-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x <= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport declare const leftmost: (...points: ReadonlyArray<Point>) => Point;\n/**\n * Returns the right-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x >= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport declare const rightmost: (...points: ReadonlyArray<Point>) => Point;\n//# sourceMappingURL=most.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function multiply(a: Point, b: Point): Point;\nexport declare function multiply(a: Point3d, b: Point3d): Point3d;\nexport declare function multiply(a: Point, x: number, y: number): Point;\nexport declare function multiply(a: Point3d, x: number, y: number, z: number): Point3d;\nexport declare function multiply(ax: number, ay: number, bx: number, by: number): Point;\nexport declare function multiply(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n/**\n * Multiplies all components by `v`.\n * Existing properties of `pt` are maintained.\n *\n * ```js\n * multiplyScalar({ x:2, y:4 }, 2);\n * // Yields: { x:4, y:8 }\n * ```\n * @param pt Point\n * @param v Value to multiply by\n * @returns\n */\nexport declare const multiplyScalar: (pt: Point | Point3d, v: number) => Point | Point3d;\n//# sourceMappingURL=multiply.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Normalise point as a unit vector.\n *\n * ```js\n * normalise({x:10, y:20});\n * normalise(10, 20);\n * ```\n * @param ptOrX Point, or x value\n * @param y y value if first param is x\n * @returns\n */\nexport declare const normalise: (ptOrX: Point | number, y?: number) => Point;\n//# sourceMappingURL=normalise.d.ts.map","import type { Rect } from \"../rect/rect-types.js\";\nimport type { Point } from \"./point-type.js\";\n/**\n * Normalises a point by a given width and height\n *\n * ```js\n * normaliseByRect({ x: 10, y: 10 }, 20, 40 }); // { x: 0.5, y: 0.2 }\n * ```\n * @param point Point\n * @param width Width\n * @param height Height\n */\nexport declare function normaliseByRect(point: Point, width: number, height: number): Point;\n/**\n * Normalises a point by a given rect's width and height\n *\n * ```js\n * normaliseByRect({ x: 10, y: 10, width: 20, height: 40 }); // { x: 0.5, y: 0.2 }\n * ```\n * @param pt\n * @param rect\n */\nexport declare function normaliseByRect(pt: Point, rect: Rect): Point;\n/**\n * Normalises x,y by width and height so it is on a 0..1 scale\n *\n * ```js\n * normaliseByRect(10, 10, 20, 40); // { x: 0.5, y: 0.2 }\n * ```\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport declare function normaliseByRect(x: number, y: number, width: number, height: number): Point;\n//# sourceMappingURL=normalise-by-rect.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Runs a sequential series of functions on `pt`. The output from one feeding into the next.\n *\n * ```js\n * const p = Points.pipelineApply(somePoint, Points.normalise, Points.invert);\n * ```\n *\n * If you want to make a reusable pipeline of functions, consider {@link pipeline} instead.\n * @param point\n * @param pipelineFns\n * @returns\n */\nexport declare const pipelineApply: (point: Point, ...pipelineFns: readonly ((pt: Point) => Point)[]) => Point;\n/**\n * Returns a pipeline function that takes a point to be transformed through a series of functions\n * ```js\n * // Create pipeline\n * const p = Points.pipeline(Points.normalise, Points.invert);\n *\n * // Now run it on `somePoint`.\n * // First we normalised, and then invert\n * const changedPoint = p(somePoint);\n * ```\n *\n * If you don't want to create a pipeline, use {@link pipelineApply}.\n * @param pipeline Pipeline of functions\n * @returns\n */\nexport declare const pipeline: (...pipeline: readonly ((pt: Point) => Point)[]) => (pt: Point) => Point;\n//# sourceMappingURL=pipeline.d.ts.map","import type { Point } from \"./point-type.js\";\nexport type PointRelation = (a: Point | number, b?: number) => PointRelationResult;\nexport type PointRelationResult = {\n    /**\n     * Angle from start\n     */\n    readonly angle: number;\n    /**\n     * Distance from start\n     */\n    readonly distanceFromStart: number;\n    /**\n     * Distance from last compared point\n     */\n    readonly distanceFromLast: number;\n    /**\n     * Center point from start\n     */\n    readonly centroid: Point;\n    /**\n     * Average of all points seen\n     * This is calculated by summing x,y and dividing by total points\n     */\n    readonly average: Point;\n    /**\n     * Speed. Distance/millisecond from one sample to the next.\n     */\n    readonly speed: number;\n};\n//# sourceMappingURL=point-relation-types.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * Converts to Cartesian coordiantes\n */\nexport type PolarToCartesian = {\n    (point: Coord, origin?: Point): Point;\n    (distance: number, angleRadians: number, origin?: Point): Point;\n};\n/**\n * A polar ray is allows you to express a line in polar coordinates\n *\n * It consists of an angle (in radians) with a given offset and length.\n *\n * * angleRadian: Angle of line\n * * Offset: distance from the polar origin (default: 0)\n * * Length: length of ray\n * * Origin: Start Cartesian coordinate of line\n */\nexport type PolarRay = Readonly<{\n    /**\n     * Angle of ray\n     */\n    angleRadian: number;\n    /**\n     * Starting point of a ray, defined as an\n     * offset from the polar origin.\n     */\n    offset: number;\n    /**\n     * Length of ray\n     */\n    length: number;\n    /**\n     * Optional origin point of ray (ie start)\n     */\n    origin?: Point;\n}>;\nexport type PolarRayWithOrigin = PolarRay & Readonly<{\n    origin: Point;\n}>;\n/**\n * Polar coordinate, made up of a distance and angle in radians.\n * Most computations involving PolarCoord require an `origin` as well.\n */\nexport type Coord = {\n    readonly distance: number;\n    readonly angleRadian: number;\n};\n//# sourceMappingURL=types.d.ts.map","import type { Coord } from \"./types.js\";\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountRadian Amount to rotate, in radians\n * @returns\n */\nexport declare const rotate: (c: Coord, amountRadian: number) => Coord;\n/**\n * Inverts the direction of coordinate. Ie if pointing north, will point south.\n * @param p\n * @returns\n */\nexport declare const invert: (p: Coord) => Coord;\n/**\n * Returns true if PolarCoords have same magnitude but opposite direction\n * @param a\n * @param b\n * @returns\n */\nexport declare const isOpposite: (a: Coord, b: Coord) => boolean;\n/**\n * Returns true if Coords have the same direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport declare const isParallel: (a: Coord, b: Coord) => boolean;\n/**\n * Returns true if coords are opposite direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport declare const isAntiParallel: (a: Coord, b: Coord) => boolean;\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountDeg Amount to rotate, in degrees\n * @returns\n */\nexport declare const rotateDegrees: (c: Coord, amountDeg: number) => Coord;\n//# sourceMappingURL=angles.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Coord, PolarToCartesian } from \"./types.js\";\n/**\n * Converts a polar coordinate to a Line.\n *\n * ```js\n * const line = toLine({ angleRadian: Math.Pi, distance: 0.5 }, { x: 0.2, y: 0.1 });\n * // Yields { a: { x, y}, b: { x, y } }\n * ```\n *\n * The 'start' parameter is taken to be the origin of the Polar coordinate.\n * @param c\n * @param start\n * @returns\n */\nexport declare const toLine: (c: Coord, start: Point) => {\n    a: Point;\n    b: Point;\n};\n/**\n * Converts to Cartesian coordinate from polar.\n *\n * ```js\n *\n * const origin = { x: 50, y: 50}; // Polar origin\n * // Yields: { x, y }\n * const polar = Polar.toCartesian({ distance: 10, angleRadian: 0 }, origin);\n * ```\n *\n * Distance and angle can be provided as numbers intead:\n *\n * ```\n * // Yields: { x, y }\n * const polar = Polar.toCartesian(10, 0, origin);\n * ```\n *\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport declare const toCartesian: PolarToCartesian;\n/**\n * Converts a Cartesian coordinate to polar\n *\n * ```js\n *\n * // Yields: { angleRadian, distance }\n * const polar = Polar.fromCartesian({x: 50, y: 50}, origin);\n * ```\n *\n * Any additional properties of `point` are copied to object.\n * @param point Point\n * @param origin Origin\n * @returns\n */\nexport declare const fromCartesian: (point: Point, origin: Point) => Coord;\n/**\n * Returns a human-friendly string representation `(distance, angleDeg)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport declare const toString: (p: Coord, digits?: number) => string;\nexport declare const toPoint: (v: Coord, origin?: {\n    readonly x: 0;\n    readonly y: 0;\n}) => Point;\n//# sourceMappingURL=conversions.d.ts.map","import type { Coord } from \"./types.js\";\n/**\n * Returns true if `p` seems to be a {@link Polar.Coord} (ie has both distance & angleRadian fields)\n * @param p\n * @returns True if `p` seems to be a PolarCoord\n */\nexport declare const isPolarCoord: (p: unknown) => p is Coord;\n/**\n * Throws an error if Coord is invalid\n * @param p\n * @param name\n */\nexport declare const guard: (p: Coord, name?: string) => void;\n//# sourceMappingURL=guard.d.ts.map","import type { Coord } from \"./types.js\";\nexport declare const normalise: (c: Coord) => Coord;\n/**\n * Clamps the magnitude of a vector\n * @param v\n * @param max\n * @param min\n * @returns\n */\nexport declare const clampMagnitude: (v: Coord, max?: number, min?: number) => Coord;\n/**\n * Calculate dot product of two PolarCoords.\n *\n * Eg, power is the dot product of force and velocity\n *\n * Dot products are also useful for comparing similarity of\n *  angle between two unit PolarCoords.\n * @param a\n * @param b\n * @returns\n */\nexport declare const dotProduct: (a: Coord, b: Coord) => number;\n/**\n * Multiplies the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport declare const multiply: (v: Coord, amt: number) => Coord;\n/**\n * Divides the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport declare const divide: (v: Coord, amt: number) => Coord;\n//# sourceMappingURL=math.d.ts.map","import { type Line } from \"../line/line-type.js\";\nimport { type Point } from '../point/point-type.js';\nimport { type PolarRay } from \"./types.js\";\n/**\n * Converts a ray to a Line in cartesian coordinates.\n *\n * By default, the ray's origin is taken to be 0,0.\n * Passing in an origin will override this default, or whatever\n * the ray's origin property is.\n * @param ray Ray\n * @param origin Override or provide origin point\n * @returns\n */\nexport declare const toCartesian: (ray: PolarRay, origin?: Point) => Line;\n/**\n * Returns a copy of `ray` ensuring it has an origin.\n * If the `origin` parameter is provided, it will override the existing origin.\n * If no origin information is available, 0,0 is used.\n * @param ray\n * @param origin\n * @returns\n */\n/**\n * Returns a string representation of the ray, useful for debugging.\n *\n * ```\n * \"PolarRay(angle: ... offset: ... len: ... origin: ...)\"\n * ```\n * @param ray\n * @returns\n */\nexport declare const toString: (ray: PolarRay) => string;\n/**\n * Returns a PolarRay based on a line and origin.\n *\n * If `origin` is omitted, the origin is taken to be the 'a' point of the line.\n * Otherwise, the origin value is used to determine the 'offset' of the ray.\n * @param line\n * @param origin\n * @returns\n */\nexport declare const fromLine: (line: Line, origin?: Point) => PolarRay;\n//# sourceMappingURL=ray.d.ts.map","/**\n * Produces an Archimedean spiral. It's a generator.\n *\n * ```js\n * const s = spiral(0.1, 1);\n * for (const coord of s) {\n *  // Use Polar coord...\n *  if (coord.step === 1000) break; // Stop after 1000 iterations\n * }\n * ```\n *\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n */\nimport type { Coord } from \"./types.js\";\nexport declare function spiral(smoothness: number, zoom: number): IterableIterator<Coord & {\n    readonly step: number;\n}>;\n/**\n * Produces an Archimedian spiral with manual stepping.\n * @param step Step number. Typically 0, 1, 2 ...\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n * @returns\n */\nexport declare const spiralRaw: (step: number, smoothness: number, zoom: number) => Coord;\n//# sourceMappingURL=spiral.d.ts.map","export type * from './types.js';\nexport * from './angles.js';\nexport * from './conversions.js';\nexport * from './guard.js';\nexport * from './math.js';\nexport * as Ray from './ray.js';\nexport * from './spiral.js';\n//# sourceMappingURL=index.d.ts.map","import { TrackedValueMap, type TrackedValueOpts as TrackOpts, type TimestampedObject } from '@ixfx/trackers';\nimport { ObjectTracker } from '@ixfx/trackers';\nimport type { Coord as PolarCoord } from '../polar/index.js';\nimport type { Line, PolyLine } from '../line/line-type.js';\nimport type { Point, Point3d } from './point-type.js';\nimport type { PointRelation } from './point-relation-types.js';\nimport type { TrimReason } from '@ixfx/trackers';\nimport type { PointRelationResult } from \"./point-relation-types.js\";\n/**\n * Information about seen points\n */\nexport type PointTrack = PointRelationResult & {};\n/**\n * Results of point tracking\n */\nexport type PointTrackerResults = Readonly<{\n    /**\n     * Relation of last point to previous point\n     */\n    fromLast: PointTrack;\n    /**\n     * Relation of last point to 'initial' point.\n     * This will be the oldest point in the buffer of the tracker.\n     */\n    fromInitial: PointTrack;\n    /**\n     * Relation of last point to a 'mark' point,\n     * which is manually set.\n     *\n     * Will give _undefined_ if `.mark()` has not been called on tracker.\n     */\n    fromMark: PointTrack | undefined;\n    values: readonly Point[];\n}>;\n/**\n * A tracked point. Mutable. Useful for monitoring how\n * it changes over time. Eg. when a pointerdown event happens, to record the start position and then\n * track the pointer as it moves until pointerup.\n *\n * See also\n * * [Playground](https://clinth.github.io/ixfx-play/data/point-tracker/index.html)\n * * {@link PointsTracker}: Track several points, useful for multi-touch.\n * * [ixfx Guide to Point Tracker](https://ixfx.fun/geometry/tracking/)\n *\n * ```js\n * // Create a tracker on a pointerdown\n * const t = new PointTracker();\n *\n * // ...and later, tell it when a point is seen (eg. pointermove)\n * const nfo = t.seen({x: evt.x, y:evt.y});\n * // nfo gives us some details on the relation between the seen point, the start, and points inbetween\n * // nfo.angle, nfo.centroid, nfo.speed etc.\n * ```\n *\n * Compute based on last seen point\n * ```js\n * t.angleFromStart();\n * t.distanceFromStart();\n * t.x / t.y\n * t.length; // Total length of accumulated points\n * t.elapsed; // Total duration since start\n * t.lastResult; // The PointSeenInfo for last seen point\n * ```\n *\n * Housekeeping\n * ```js\n * t.reset(); // Reset tracker\n * ```\n *\n * By default, the tracker only keeps track of the initial point and\n * does not store intermediate 'seen' points. To use the tracker as a buffer,\n * set `storeIntermediate` option to _true_.\n *\n * ```js\n * // Keep only the last 10 points\n * const t = new PointTracker({\n *  sampleLimit: 10\n * });\n *\n * // Store all 'seen' points\n * const t = new PointTracker({\n *  storeIntermediate: true\n * });\n *\n * // In this case, the whole tracker is automatically\n * // reset after 10 samples\n * const t = new PointTracker({\n *  resetAfterSamples: 10\n * })\n * ```\n *\n * When using a buffer limited by `sampleLimit`, the 'initial' point will be the oldest in the\n * buffer, not actually the very first point seen.\n */\nexport declare class PointTracker<TPoint extends Point = Point> extends ObjectTracker<TPoint, PointTrackerResults> {\n    initialRelation: PointRelation | undefined;\n    markRelation: PointRelation | undefined;\n    lastResult: PointTrackerResults | undefined;\n    constructor(opts?: TrackOpts);\n    /**\n     * Notification that buffer has been knocked down to `sampleLimit`.\n     *\n     * This will reset the `initialRelation`, which will use the new oldest value.\n     */\n    onTrimmed(_reason: TrimReason): void;\n    /**\n     * @ignore\n     */\n    onReset(): void;\n    /**\n     * Makes a 'mark' in the tracker, allowing you to compare values\n     * to this point.\n     */\n    mark(): void;\n    /**\n     * Tracks a point, returning data on its relation to the\n     * initial point and the last received point.\n     *\n     * Use {@link seenEvent} to track a raw `PointerEvent`.\n     *\n     * @param _p Point\n     */\n    computeResults(_p: TimestampedObject<Point>[]): PointTrackerResults;\n    /**\n     * Returns a polyline representation of stored points.\n     * Returns an empty array if points were not saved, or there's only one.\n     */\n    get line(): PolyLine;\n    /**\n     * Returns a vector of the initial/last points of the tracker.\n     * Returns as a polar coordinate\n     */\n    get vectorPolar(): PolarCoord;\n    /**\n     * Returns a vector of the initial/last points of the tracker.\n     * Returns as a Cartesian coordinate\n     */\n    get vectorCartesian(): Point;\n    /**\n     * Returns a line from initial point to last point.\n     *\n     * If there are less than two points, Lines.Empty is returned\n     */\n    get lineStartEnd(): Line;\n    /**\n     * Returns distance from latest point to initial point.\n     * If there are less than two points, zero is returned.\n     *\n     * This is the direct distance from initial to last,\n     * not the accumulated length. Use {@link lengthTotal} for that.\n     * @param force2d If _true_ distance is calculated only in 2d\n     * @returns Distance\n     */\n    distanceFromStart(force2d?: boolean): number;\n    /**\n     * Returns the speed (over milliseconds) based on accumulated travel distance.\n     *\n     * If there's no initial point, 0 is returned.\n     * @param force2d If _true_, speed is calculated with x,y only\n     * @returns\n     */\n    speedFromStart(force2d?: boolean): number;\n    speedFromLast(force2d?: boolean): number;\n    /**\n     * Difference between last point and the initial point, calculated\n     * as a simple subtraction of x,y & z.\n     *\n     * `Points.Placeholder` is returned if there's only one point so far.\n     */\n    difference(): Point | Point3d;\n    /**\n     * Returns angle (in radians) from latest point to the initial point\n     * If there are less than two points, undefined is return.\n     * @returns Angle in radians\n     */\n    angleFromStart(): number | undefined;\n    /**\n     * Returns the total distance from accumulated points.\n     * Returns 0 if points were not saved, or there's only one.\n     *\n     * Use {@link lengthAverage} to get the average length for all segments\n     * @param force2d If _true_ length is calculated using x&y only\n     */\n    lengthTotal(force2d?: boolean): number;\n    /**\n     * Adds up the accumulated length of all points (using {@link lengthTotal})\n     * dividing by the total number of points.\n     * @param force2d\n     * @returns\n     */\n    lengthAverage(force2d?: boolean): number;\n    /**\n   * Returns the last x coord\n   */\n    get x(): number;\n    /**\n     * Returns the last y coord\n     */\n    get y(): number;\n    /**\n     * Returns the last z coord (or _undefined_ if not available)\n     */\n    get z(): number | undefined;\n}\n/**\n * A {@link TrackedValueMap} for points. Uses {@link PointTracker} to\n * track added values.\n */\nexport declare class PointsTracker<TPoint extends Point = Point> extends TrackedValueMap<TPoint, PointTracker<TPoint>, PointTrackerResults> {\n    constructor(opts?: TrackOpts);\n    get(id: string): PointTracker<TPoint> | undefined;\n}\nexport declare class UserPointerTracker extends PointTracker {\n    /**\n     * Adds a PointerEvent along with its\n     * coalesced events, if available.\n     * @param p\n     * @returns\n     */\n    seenEvent(p: PointerEvent | MouseEvent): PointTrackerResults;\n}\nexport declare class UserPointersTracker extends TrackedValueMap<Point, PointTracker, PointTrackerResults> {\n    constructor(opts?: TrackOpts);\n    get(id: string): UserPointerTracker | undefined;\n    /**\n   * Track a PointerEvent\n   * @param event\n   */\n    seenEvent(event: PointerEvent): Promise<PointTrackerResults[]>;\n}\n//# sourceMappingURL=point-tracker.d.ts.map","import type { Point3d, Point } from \"./point-type.js\";\n/**\n * Computes the progress between two waypoints, given `position`.\n *\n * [Source](https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09)\n * @param position Current position\n * @param waypointA Start\n * @param waypointB End\n * @returns\n */\nexport declare const progressBetween: (position: Point | Point3d, waypointA: Point | Point3d, waypointB: Point | Point3d) => number;\n//# sourceMappingURL=progress-between.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Project `origin` by `distance` and `angle` (radians).\n *\n * To figure out rotation, imagine a horizontal line running through `origin`.\n * * Rotation = 0 deg puts the point on the right of origin, on same y-axis\n * * Rotation = 90 deg/3:00 puts the point below origin, on the same x-axis\n * * Rotation = 180 deg/6:00 puts the point on the left of origin on the same y-axis\n * * Rotation = 270 deg/12:00 puts the point above the origin, on the same x-axis\n *\n * ```js\n * // Yields a point 100 units away from 10,20 with 10 degrees rotation (ie slightly down)\n * const a = Points.project({x:10, y:20}, 100, degreeToRadian(10));\n * ```\n * @param origin\n * @param distance\n * @param angle\n * @returns\n */\nexport declare const project: (origin: Point, distance: number, angle: number) => {\n    x: number;\n    y: number;\n};\n//# sourceMappingURL=project.d.ts.map","import type { Point, Point3d } from './point-type.js';\nexport declare function quantiseEvery(pt: Point3d, snap: Point3d, middleRoundsUp?: boolean): Point3d;\nexport declare function quantiseEvery(pt: Point, snap: Point, middleRoundsUp?: boolean): Point;\n//# sourceMappingURL=quantise.d.ts.map","import { type RandomSource } from '@ixfx/random';\nimport type { Point, Point3d } from './point-type.js';\n/**\n * Returns a random 2D point on a 0..1 scale.\n * ```js\n * import { Points } from \"@ixfx/geometry.js\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"@ixfx/geometry.js\";\n * import { weightedSource } from \"@ixfx/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport declare const random: (rando?: RandomSource) => Point;\n/**\n * Returns a random 3D point on a 0..1 scale.\n * ```js\n * import { Points } from \"@ixfx/geometry\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"@ixfx/geometry\";\n * import { weightedSource } from \"@ixfx/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport declare const random3d: (rando?: RandomSource) => Point3d;\n//# sourceMappingURL=random.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Reduces over points, treating _x_ and _y_ separately.\n *\n * ```\n * // Sum x and y values\n * const total = Points.reduce(points, (p, acc) => {\n *  return {x: p.x + acc.x, y: p.y + acc.y}\n * });\n * ```\n * @param pts Points to reduce\n * @param fn Reducer\n * @param initial Initial value, uses `{ x:0, y:0 }` by default\n * @returns\n */\nexport declare const reduce: (pts: ReadonlyArray<Point>, fn: (p: Point, accumulated: Point) => Point, initial?: Point) => Point;\n//# sourceMappingURL=reduce.d.ts.map","import type { PointRelation } from \"./point-relation-types.js\";\nimport type { Point } from \"./point-type.js\";\n/**\n * Tracks the relation between two points.\n *\n * 1. Call `Points.relation` with the initial reference point\n * 2. You get back a function\n * 3. Call the function with a new point to compute relational information.\n *\n * It computes angle, average, centroid, distance and speed.\n *\n * ```js\n * // Reference point: 50,50\n * const t = Points.relation({x:50,y:50}); // t is a function\n *\n * // Invoke the returned function with a point\n * const relation = t({ x:0, y:0 }); // Juicy relational data\n * ```\n *\n * Or with destructuring:\n *\n * ```js\n * const { angle, distanceFromStart, distanceFromLast, average, centroid, speed } = t({ x:0,y:0 });\n * ```\n *\n * x & y coordinates can also be used as parameters:\n * ```js\n * const t = Points.relation(50, 50);\n * const result = t(0, 0);\n * // result.speed, result.angle ...\n * ```\n *\n * Note that intermediate values are not stored. It keeps the initial\n * and most-recent point. If you want to compute something over a set\n * of prior points, you may want to use {@link PointsTracker}\n * @param a Initial point, or x value\n * @param b y value, if first option is a number.\n * @returns\n */\nexport declare const relation: (a: Point | number, b?: number) => PointRelation;\n//# sourceMappingURL=relation.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Rotate a single point by a given amount in radians\n * @param pt\n * @param amountRadian\n * @param origin\n */\nexport declare function rotate(pt: Point, amountRadian: number, origin?: Point): Point;\n/**\n * Rotate several points by a given amount in radians\n * @param pt Points\n * @param amountRadian Amount to rotate in radians. If 0 is given, a copy of the input array is returned\n * @param origin Origin to rotate around. Defaults to 0,0\n */\nexport declare function rotate(pt: readonly Point[], amountRadian: number, origin?: Point): readonly Point[];\n//# sourceMappingURL=rotate.d.ts.map","export declare const rotatePointArray: (v: ReadonlyArray<ReadonlyArray<number>>, amountRadian: number) => Array<Array<number>>;\n//# sourceMappingURL=rotate-point-array.d.ts.map","import type { Point } from './point-type.js';\n/**\n * Round the point's _x_ and _y_ to given number of digits\n * @param ptOrX\n * @param yOrDigits\n * @param digits\n * @returns\n */\nexport declare const round: (ptOrX: Point | number, yOrDigits?: number, digits?: number) => Point;\n//# sourceMappingURL=round.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function subtract(a: Point, b: Point): Point;\nexport declare function subtract(a: Point3d, b: Point3d): Point3d;\nexport declare function subtract(a: Point, x: number, y: number): Point;\nexport declare function subtract(a: Point3d, x: number, y: number, z: number): Point3d;\nexport declare function subtract(ax: number, ay: number, bx: number, by: number): Point;\nexport declare function subtract(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n//# sourceMappingURL=subtract.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\nexport declare function sum(a: Point, b: Point): Point;\nexport declare function sum(a: Point3d, b: Point3d): Point3d;\nexport declare function sum(a: Point, x: number, y: number): Point;\nexport declare function sum(a: Point3d, x: number, y: number, z: number): Point3d;\nexport declare function sum(ax: number, ay: number, bx: number, by: number): Point;\nexport declare function sum(ax: number, ay: number, az: number, bx: number, by: number, bz: number): Point3d;\n//# sourceMappingURL=sum.d.ts.map","import type { Point, Point3d } from \"./point-type.js\";\n/**\n * Returns a point with rounded x,y coordinates. By default uses `Math.round` to round.\n * ```js\n * toIntegerValues({x:1.234, y:5.567}); // Yields: {x:1, y:6}\n * ```\n *\n * ```js\n * toIntegerValues(pt, Math.ceil); // Use Math.ceil to round x,y of `pt`.\n * ```\n * @param pt Point to round\n * @param rounder Rounding function, or Math.round by default\n * @returns\n */\nexport declare const toIntegerValues: (pt: Point, rounder?: (x: number) => number) => Point;\n/**\n * Returns a copy of `pt` with `z` field omitted.\n * If it didn't have one to begin within, a copy is still returned.\n * @param pt\n * @returns\n */\nexport declare const to2d: (pt: Point) => Point;\n/**\n * Returns a copy of `pt` with a `z` field set.\n * Defaults to a z value of 0.\n * @param pt Point\n * @param z Z-value, defaults to 0\n * @returns\n */\nexport declare const to3d: (pt: Point, z?: number) => Point3d;\n/**\n * Returns a human-friendly string representation `(x, y)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport declare function toString(p: Point, digits?: number): string;\n//# sourceMappingURL=To.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns point as an array in the form [x,y]. This can be useful for some libraries\n * that expect points in array form.\n *\n * ```\n * const p = {x: 10, y:5};\n * const p2 = toArray(p); // yields [10,5]\n * ```\n * @param p\n * @returns\n */\nexport declare const toArray: (p: Point) => ReadonlyArray<number>;\n//# sourceMappingURL=to-array.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Returns true if two points are within a specified range on both axes.\n *\n * Provide a point for the range to set different x/y range, or pass a number\n * to use the same range for both axis.\n *\n * Note this simply compares x,y values it does not calcuate distance.\n *\n * @example\n * ```js\n * withinRange({x:100,y:100}, {x:101, y:101}, 1); // True\n * withinRange({x:100,y:100}, {x:105, y:101}, {x:5, y:1}); // True\n * withinRange({x:100,y:100}, {x:105, y:105}, {x:5, y:1}); // False - y axis too far\n * ```\n * @param a\n * @param b\n * @param maxRange\n * @returns\n */\nexport declare const withinRange: (a: Point, b: Point, maxRange: Point | number) => boolean;\n//# sourceMappingURL=within-range.d.ts.map","import type { Point } from \"./point-type.js\";\n/**\n * Wraps a point to be within `ptMin` and `ptMax`.\n * Note that max values are _exclusive_, meaning the return value will always be one less.\n *\n * Eg, if a view port is 100x100 pixels, wrapping the point 150,100 yields 50,99.\n *\n * ```js\n * // Wraps 150,100 to on 0,0 -100,100 range\n * wrap({x:150,y:100}, {x:100,y:100});\n * ```\n *\n * Wrap normalised point:\n * ```js\n * wrap({x:1.2, y:1.5}); // Yields: {x:0.2, y:0.5}\n * ```\n * @param pt Point to wrap\n * @param ptMax Maximum value, or `{ x:1, y:1 }` by default\n * @param ptMin Minimum value, or `{ x:0, y:0 }` by default\n * @returns Wrapped point\n */\nexport declare const wrap: (pt: Point, ptMax?: Point, ptMin?: Point) => Point;\n//# sourceMappingURL=wrap.d.ts.map","export * from './abs.js';\nexport * from './angle.js';\nexport * from './apply.js';\nexport * from './averager.js';\nexport * from './bbox.js';\nexport * from './centroid.js';\nexport * from './clamp.js';\nexport * from './compare.js';\nexport * from './convex-hull.js';\nexport * from './distance.js';\nexport * from './distance-to-center.js';\nexport * from './distance-to-exterior.js';\nexport * from './divider.js';\nexport * from './dot-product.js';\nexport * from './empty.js';\nexport * from './find-minimum.js';\nexport * from './from.js';\nexport * from './get-point-parameter.js';\nexport * from './guard.js';\nexport * from './interpolate.js';\nexport * from './invert.js';\nexport * from './is-equal.js';\nexport * from './magnitude.js';\nexport * from './most.js';\nexport * from './multiply.js';\nexport * from './normalise.js';\nexport * from './normalise-by-rect.js';\nexport * from './pipeline.js';\nexport * from './point-relation-types.js';\nexport * from './point-tracker.js';\nexport * from './point-type.js';\nexport * from './progress-between.js';\nexport * from './project.js';\nexport * from './quantise.js';\nexport * from './random.js';\nexport * from './reduce.js';\nexport * from './relation.js';\nexport * from './rotate.js';\nexport * from './rotate-point-array.js';\nexport * from './round.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './To.js';\nexport * from './to-array.js';\nexport * from './within-range.js';\nexport * from './wrap.js';\nexport type { Point, Point3d } from './point-type.js';\n//# sourceMappingURL=index.d.ts.map","import type { Rect } from \"./rect-types.js\";\n/**\n * Returns the area of `rect`\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.area(rect);\n * ```\n * @param rect\n * @returns\n */\nexport declare const area: (rect: Rect) => number;\n//# sourceMappingURL=area.d.ts.map","import type { RectPositioned, Rect } from \"./rect-types.js\";\n/**\n * An operation between two fields of a rectangle.\n * Used in the context of {@link applyMerge}\n * ```\n * // Multiply fields\n * const op = (a, b) => a*b;\n * ```\n */\nexport type ApplyMergeOp = (a: number, b: number) => number;\nexport type ApplyFieldOp = (fieldValue: number, fieldName?: `x` | `y` | `width` | `height`) => number;\nexport declare function applyFields(op: ApplyFieldOp, rect: RectPositioned): RectPositioned;\nexport declare function applyFields(op: ApplyFieldOp, rect: Rect): Rect;\nexport declare function applyFields(op: ApplyFieldOp, width: number, height: number): Rect;\nexport declare function applyMerge(op: ApplyMergeOp, rect: RectPositioned, width: number, height?: number): RectPositioned;\nexport declare function applyMerge(op: ApplyMergeOp, rect: Rect, width: number, height: number): Rect;\nexport declare function applyMerge(op: ApplyMergeOp, a: RectPositioned, b: Rect): RectPositioned;\nexport declare function applyMerge(op: ApplyMergeOp, a: Rect, b: Rect): Rect;\n/**\n * Uses `op` with `param` to width and height.\n * @param op\n * @param rect\n * @param parameter\n */\nexport declare function applyScalar(op: ApplyMergeOp, rect: Rect, parameter: number): Rect;\n/**\n * Uses `op` to apply with `param` to width, height, x & y.\n * Use `applyDim` to apply just to dimensions.\n * @param op\n * @param rect\n * @param parameter\n */\nexport declare function applyScalar(op: ApplyMergeOp, rect: RectPositioned, parameter: number): RectPositioned;\n/**\n * Applies `op` with `param` to `rect`'s width and height.\n * @param op\n * @param rect\n * @param parameter\n * @returns\n */\nexport declare function applyDim(op: ApplyMergeOp, rect: Rect | RectPositioned, parameter: number): Rect | RectPositioned;\n//# sourceMappingURL=apply.d.ts.map","import type { ISetMutable } from \"@ixfx/collections\";\nexport type GridVisual = Grid & {\n    readonly size: number;\n};\nexport type Grid = {\n    readonly rows: number;\n    readonly cols: number;\n};\nexport type GridCell = {\n    readonly x: number;\n    readonly y: number;\n};\nexport type GridNeighbours = {\n    readonly n: GridCell | undefined;\n    readonly e: GridCell | undefined;\n    readonly s: GridCell | undefined;\n    readonly w: GridCell | undefined;\n    readonly ne: GridCell | undefined;\n    readonly nw: GridCell | undefined;\n    readonly se: GridCell | undefined;\n    readonly sw: GridCell | undefined;\n};\nexport type GridCardinalDirection = `n` | `ne` | `e` | `se` | `s` | `sw` | `w` | `nw`;\nexport type GridCardinalDirectionOptional = GridCardinalDirection | ``;\nexport type GridArray1d<T> = GridReadable<T> & GridWritable<T> & {\n    array: T[];\n};\n/**\n * Bounds logic\n * * Unbounded: attempts to read beyond limits\n * * Undefined: returns _undefined_ when reading beyond limits\n * * Stop: returns cell value at edge of limits\n * * Wrap: Wrap-around cell positions\n *\n */\nexport type GridBoundsLogic = \n/**\n * Unbounded: attempts to read beyond limits\n */\n`unbounded` | \n/**\n * Undefined: returns _undefined_ when reading beyond limits\n */\n`undefined` | \n/**\n * Stop: returns cell value at edge of limits\n */\n`stop` | \n/**\n * Wrap-around cell positions\n */\n`wrap`;\n/**\n * Logic to select the next cell based on a list of neighbours\n */\nexport type GridNeighbourSelectionLogic = {\n    /**\n     * Returns neighbours for a given cell in a grid\n     */\n    readonly getNeighbours?: GridIdentifyNeighbours;\n    /**\n     * Select a neighbour from given list\n     */\n    readonly select: GridNeighbourSelector;\n};\nexport type GridVisitorOpts = Readonly<{\n    start: GridCell;\n    visited: ISetMutable<GridCell>;\n    reversed: boolean;\n    debug: boolean;\n    boundsWrap: GridBoundsLogic;\n}>;\nexport type GridCreateVisitor = (grid: Grid, opts?: Partial<GridVisitorOpts>) => Generator<GridCell>;\nexport type GridCellAndValue<T> = {\n    cell: GridCell;\n    value: T | undefined;\n};\nexport type GridNeighbourMaybe = readonly [keyof GridNeighbours, GridCell | undefined];\nexport type GridNeighbour = readonly [keyof GridNeighbours, GridCell];\n/**\n * A function that returns a value (or _undefined_) based on a _cell_\n *\n * Implementations:\n * * {@link Grids.Array1d.access}: For accessing a single-dimension array as a grid\n * * {@link Grids.Array2d.access}: For accessing a two-dimension array as a grid\n *\n */\nexport type GridCellAccessor<TValue> = (cell: GridCell, wrap?: GridBoundsLogic) => TValue | undefined;\n/**\n * A function that sets the value of a cell.\n */\nexport type GridCellSetter<TValue> = (value: TValue, cell: GridCell, wrap?: GridBoundsLogic) => void;\n/**\n * Shape of a grid and a function to read values from it, based on\n * cell location.\n *\n * These functions create a GridReadable:\n * * {@link Grids.Array1d.wrap}: wrap an array and read as a grid\n * * {@link Grids.Array1d.wrapMutable}: wrap and modify an array as a grid\n * * {@link Grids.Array2d.wrap}: wrap a two-dimensional grid\n * * {@link Grids.Array2d.wrapMutable}\n */\nexport type GridReadable<T> = Grid & {\n    get: GridCellAccessor<T>;\n};\nexport type GridWritable<T> = Grid & {\n    set: GridCellSetter<T>;\n};\n/**\n * Neighbour selector logic. For a given set of `neighbours` pick one to visit next.\n */\nexport type GridNeighbourSelector = (neighbours: readonly GridNeighbour[]) => GridNeighbour | undefined;\n/**\n * Identify neighbours logic. For a given `grid` and `origin`, return a list of neighbours\n */\nexport type GridIdentifyNeighbours = (grid: Grid, origin: GridCell) => readonly GridNeighbour[];\n//# sourceMappingURL=types.d.ts.map","import type { GridBoundsLogic, GridCell, Grid } from \"./types.js\";\n/**\n * Calculates a legal position for a cell based on\n * `grid` size and `bounds` wrapping logic.\n * @param grid\n * @param cell\n * @param wrap\n * @returns\n */\nexport declare const applyBounds: (grid: Grid, cell: GridCell, wrap?: GridBoundsLogic) => GridCell | undefined;\n//# sourceMappingURL=apply-bounds.d.ts.map","import type { GridCellAccessor, GridCell, GridBoundsLogic, Grid, GridCellSetter, GridArray1d } from \"./types.js\";\n/**\n * Returns a {@link GridCellAccessor} to get values from `array`\n * based on cell (`{x,y}`) coordinates.\n *\n * ```js\n * const arr = [\n *  1,2,3,\n *  4,5,6\n * ]\n * const a = access(arr, 3);\n * a({x:0,y:0});  // 1\n * a({x:2, y:2}); // 6\n * ```\n * @param array\n * @param cols\n * @returns\n */\nexport declare const access: <V>(array: readonly V[], cols: number) => GridCellAccessor<V>;\n/**\n * Returns a {@link GridCellSetter} that can mutate\n * array values based on cell {x,y} positions.\n * ```js\n * const arr = [\n *  1,2,3,\n *  4,5,6\n * ]\n * const a = setMutate(arr, 3);\n * a(10, {x:0,y:0});\n * a(20, {x:2, y:2});\n *\n * // Arr is now:\n * // [\n * //  10, 2, 3,\n * //  4, 5, 20\n * // ]\n * ```\n * @param array\n * @param cols\n * @returns\n */\nexport declare const setMutate: <V>(array: V[], cols: number) => GridCellSetter<V>;\nexport declare const set: <V>(array: readonly V[], cols: number) => (value: V, cell: GridCell, wrap: GridBoundsLogic) => V[];\n/**\n * Wraps `array` for grid access.\n * Mutable, meaning that `array` gets modified if `set` function is used.\n *\n * ```js\n * const g = wrapMutable(myArray, 5); // 5 columns wide\n * g.get({x:1,y:2});     // Get value at cell position\n * g.set(10, {x:1,y:2}); // Set value at cell position\n * g.array;              // Get reference to original passed-in array\n * ```\n *\n * Use {@link wrap} for an immutable version.\n *\n * @param array Array to wrap\n * @param cols Width of grid\n * @returns\n */\nexport declare const wrapMutable: <T>(array: T[], cols: number) => GridArray1d<T>;\n/**\n * Wraps `array` for grid access.\n * Immutable, such that underlying array is not modified and a\n * call to `set` returns a new `GridArray1d`.\n *\n * ```js\n * const myArray = [\n *    `a`, `b`, `c`,\n *    `d`, `e`, `f`\n * ];\n * let g = wrap(myArray, 3);  // 3 columns wide\n * g.get({ x:1, y:2 });          // Get value at cell position\n *\n * // Note that `set` returns a new instance\n * g = g.set(10, { x:1, y:2 });  // Set value at cell position\n * g.array;                      // Get reference to current array\n * ```\n *\n * Use {@link wrapMutable} to modify an array in-place\n * @param array Array to wrap\n * @param cols Width of grid\n * @returns\n */\nexport declare const wrap: <T>(array: T[], cols: number) => GridArray1d<T>;\n/**\n * Creates a 1-dimensional array to fit a grid of rows x cols.\n * Use {@link createArray} if you want to create this array and wrap it for grid access.\n *\n * ```js\n * // Creates an array filled with 0, sized for a grid 10 rows by 20 columns\n * const arr = createArray(0, 10, 20);\n *\n * // Alternatively, pass in a grid\n * const arr = createArray(0, { rows: 10, cols: 20 });\n * ```\n * @param rowsOrGrid Number of rows, or a grid to use the settings of\n * @param columns Columns\n */\nexport declare const createArray: <T>(initialValue: T, rowsOrGrid: number | Grid, columns?: number) => T[];\n/**\n * Creates a {@link GridArray1d} instance given the dimensions of the grid.\n * Use {@link createArray} if you just want to create an array sized for a grid.\n *\n * Behind the scenes, it runs:\n * ```js\n * const arr = createArray(initialValue, rows, cols);\n * return wrapMutable(arr, cols);\n * ```\n * @param initialValue\n * @param rowsOrGrid\n * @param columns\n * @returns\n */\nexport declare const createMutable: <T>(initialValue: T, rowsOrGrid: number | Grid, columns?: number) => GridArray1d<T>;\n//# sourceMappingURL=array-1d.d.ts.map","import type { GridBoundsLogic, GridCell, GridCellAccessor, GridCellSetter, Grid, GridReadable, GridWritable } from \"./types.js\";\nexport type ArrayGrid<T> = GridReadable<T> & GridWritable<T> & {\n    array: T[][];\n};\n/**\n * Create a grid from a 2-dimensional array.\n * ```js\n * const data = [\n *  [1,2,3],\n *  [4,5,6]\n * ]\n * const g = create(data);\n * // { rows: 2, cols: 3 }\n * ```\n * @param array\n * @returns\n */\nexport declare const create: <T>(array: ReadonlyArray<T[]> | Array<T[]>) => Grid;\nexport declare const setMutate: <V>(array: V[][]) => GridCellSetter<V>;\nexport declare const access: <T>(array: ReadonlyArray<T[]>) => GridCellAccessor<T>;\nexport declare const wrapMutable: <T>(array: T[][]) => ArrayGrid<T>;\nexport declare const set: <V>(array: readonly V[][]) => (value: V, cell: GridCell, wrap: GridBoundsLogic) => V[][];\n/**\n * Wraps `array` with two dimensions for grid access.\n * Immutable, such that underlying array is not modified and a\n * call to `set` returns a new `GridArray1d`.\n *\n * ```js\n * // Grid of rows: 2, cols: 3\n * const myArray = [\n *  [ `a`, `b`, `c` ],\n *  [ `d`, `e`, `f` ]\n * ]\n * let g = wrap(myArray);\n * g.get({x:1,y:2});          // Get value at cell position\n * g = g.set(10, {x:1,y:2}); // Set value at cell position\n * g.array;                  // Get reference to current array\n * ```\n *\n * Use {@link wrapMutable} to modify an array in-place\n * @param array Array to wrap\n * @returns\n */\nexport declare const wrap: <T>(array: T[][]) => ArrayGrid<T>;\n//# sourceMappingURL=array-2d.d.ts.map","import type { GridCell, Grid } from \"./types.js\";\n/**\n * Enumerate rows of grid, returning all the cells in the row\n * as an array\n *\n * ```js\n * for (const row of Grid.As.rows(shape)) {\n *  // row is an array of Cells.\n *  // [ {x:0, y:0}, {x:1, y:0} ... ]\n * }\n * ```\n *\n * Use `Grid.values` to convert the returned iterator into values:\n * ```js\n * for (const v of Grid.values(Grid.rows(shape))) {\n * }\n * ```\n * @param grid\n * @param start\n */\nexport declare const rows: (grid: Grid, start?: GridCell) => Generator<GridCell[], void, unknown>;\n/**\n * Enumerate columns of grid, returning all the cells in the\n * same column as an array.\n *\n * ```js\n * for (const col of Grid.As.columns(grid)) {\n * }\n * ```\n *\n * Use `Grid.values` to convert into values\n * ```js\n * for (const value of Grid.values(Grid.As.columns(grid))) {\n * }\n * ```\n * @param grid\n * @param start\n */\nexport declare function columns(grid: Grid, start?: GridCell): Generator<GridCell[], void, unknown>;\n//# sourceMappingURL=as.d.ts.map","import type { GridBoundsLogic, GridCardinalDirection, GridCardinalDirectionOptional, GridCell, Grid, GridNeighbours } from \"./types.js\";\n/**\n * Returns a list of all cardinal directions: n, ne, nw, e, s, se, sw, w\n */\nexport declare const allDirections: readonly GridCardinalDirection[];\n/**\n * Returns a list of + shaped directions: n, e, s, w\n */\nexport declare const crossDirections: readonly GridCardinalDirection[];\n/**\n * Returns cells that correspond to the cardinal directions at a specified distance\n * i.e. it projects a line from `start` cell in all cardinal directions and returns the cells at `steps` distance.\n * @param grid Grid\n * @param steps Distance\n * @param start Start poiint\n * @param bounds Logic for if bounds of grid are exceeded\n * @returns Cells corresponding to cardinals\n */\nexport declare const offsetCardinals: (grid: Grid, start: GridCell, steps: number, bounds?: GridBoundsLogic) => GridNeighbours;\n/**\n * Returns an `{ x, y }` signed vector corresponding to the provided cardinal direction.\n * ```js\n * const n = getVectorFromCardinal(`n`); // {x: 0, y: -1}\n * ```\n *\n * Optional `multiplier` can be applied to vector\n * ```js\n * const n = getVectorFromCardinal(`n`, 10); // {x: 0, y: -10}\n * ```\n *\n * Blank direction returns `{ x: 0, y: 0 }`\n * @param cardinal Direction\n * @param multiplier Multipler\n * @returns Signed vector in the form of `{ x, y }`\n */\nexport declare const getVectorFromCardinal: (cardinal: GridCardinalDirectionOptional, multiplier?: number) => GridCell;\n//# sourceMappingURL=directions.d.ts.map","import type { Grid, GridCell, GridCellAndValue, GridReadable } from \"../types.js\";\n/**\n * Enumerate all cell coordinates in an efficient manner.\n * Runs left-to-right, top-to-bottom.\n *\n * If end of grid is reached, behaviour depends on `wrap`:\n * * _true_ (default): iterator will wrap to ensure all are visited.\n * * _false_: iterator stops at end of grid\n *\n * ```js\n * import { Grids } from 'ixfx/geometry.js';\n *\n * // Enumerate each cell position, left-to-right, top-to-bottom\n * for (const cell of Grids.By.cells(grid)) {\n *  // cell will be { x, y }\n * }\n * ```\n *\n * See also:\n * * {@link cellValues}: Iterate over cell values\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid Grid to iterate over\n * @param start Starting cell position (default: {x:0,y:0})\n * @param wrap If true (default), iteration will wrap around through (0,0) when end of grid is reached.\n */\nexport declare function cells(grid: Grid, start?: GridCell, wrap?: boolean): Generator<{\n    x: number;\n    y: number;\n}, void, unknown>;\n/**\n * Yield all the values of a grid, left-to-right, top-to-bottom.\n *\n * This is just a wrapper around Grids.values:\n * ```js\n * yield* values(grid, cells(grid, start, wrap));\n * ```\n *\n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid\n * @param start\n * @param wrap\n */\nexport declare function cellValues<T>(grid: GridReadable<T>, start?: GridCell, wrap?: boolean): Generator<T, void, any>;\n/**\n * Yield all cell coordinates and values of a grid, left-to-right, top-to-bottom\n *\n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellValues}: Iterate over cell values\n * @param grid\n * @param start\n * @param wrap\n */\nexport declare function cellsAndValues<T>(grid: GridReadable<T>, start?: GridCell, wrap?: boolean): Generator<GridCellAndValue<T>>;\n//# sourceMappingURL=cells.d.ts.map","export * from './cells.js';\n//# sourceMappingURL=index.d.ts.map","import type { GridCell } from \"./types.js\";\n/**\n * Returns the cells on the line of `start` and `end`, inclusive\n *\n * ```js\n * // Get cells that connect 0,0 and 10,10\n * const cells = Grids.getLine({x:0,y:0}, {x:10,y:10});\n * ```\n *\n * This function does not handle wrapped coordinates.\n * @param start Starting cell\n * @param end End cell\n * @returns\n */\nexport declare const getLine: (start: GridCell, end: GridCell) => ReadonlyArray<GridCell>;\n/**\n * Returns a list of cells from `start` to `end`.\n *\n * Throws an error if start and end are not on same row or column.\n *\n * @param start Start cell\n * @param end end clel\n * @param endInclusive\n * @return Array of cells\n */\nexport declare const simpleLine: (start: GridCell, end: GridCell, endInclusive?: boolean) => ReadonlyArray<GridCell>;\n//# sourceMappingURL=geometry.d.ts.map","import type { GridCell, Grid } from \"./types.js\";\n/**\n * Returns true if `cell` parameter is a cell with x,y fields.\n * Does not check validity of fields.\n *\n * @param cell\n * @return True if parameter is a cell\n */\nexport declare const isCell: (cell: GridCell | undefined) => cell is GridCell;\n/**\n * Throws an exception if any of the cell's parameters are invalid\n * @private\n * @param cell\n * @param parameterName\n * @param grid\n */\nexport declare const guardCell: (cell: GridCell, parameterName?: string, grid?: Grid) => void;\n/**\n * Throws an exception if any of the grid's parameters are invalid\n * @param grid\n * @param parameterName\n */\nexport declare const guardGrid: (grid: Grid, parameterName?: string) => void;\n//# sourceMappingURL=guards.d.ts.map","import type { Grid, GridCell, GridBoundsLogic } from \"./types.js\";\n/**\n * Returns the index for a given cell.\n * This is useful if a grid is stored in an array.\n *\n * ```js\n * const data = [\n *  1, 2,\n *  3, 4,\n *  5, 6 ];\n * const cols = 2; // Grid of 2 columns wide\n * const index = indexFromCell(cols, {x: 1, y: 1});\n * // Yields an index of 3\n * console.log(data[index]); // Yields 4\n * ```\n *\n * Bounds logic is applied to cell.x/y separately. Wrapping\n * only ever happens in same col/row.\n * @see cellFromIndex\n * @param grid Grid\n * @param cell Cell to get index for\n * @param wrap Logic for if we hit bounds of grid\n * @returns\n */\nexport declare const indexFromCell: (grid: Grid, cell: GridCell, wrap: GridBoundsLogic) => number | undefined;\n/**\n * Returns x,y from an array index.\n *\n * ```js\n *  const data = [\n *   1, 2,\n *   3, 4,\n *   5, 6 ];\n *\n * // Cols of 2, index 2 (ie. data[2] == 3)\n * const cell = cellFromIndex(2, 2);\n * // Yields: {x: 0, y: 1}\n * ```\n * @see indexFromCell\n * @param colsOrGrid\n * @param index\n * @returns\n */\nexport declare const cellFromIndex: (colsOrGrid: number | Grid, index: number) => GridCell;\n//# sourceMappingURL=indexing.d.ts.map","import type { Grid, GridCell } from \"./types.js\";\n/**\n * Returns _true_ if cell coordinates are above zero and within bounds of grid\n *\n * @param grid\n * @param cell\n * @return\n */\nexport declare const inside: (grid: Grid, cell: GridCell) => boolean;\n//# sourceMappingURL=inside.d.ts.map","import type { GridCell, Grid, GridVisual } from \"./types.js\";\n/**\n * Returns _true_ if grids `a` and `b` are equal in value.\n * Returns _false_ if either parameter is undefined.\n *\n * @param a\n * @param b\n * @return\n */\nexport declare const isEqual: (a: Grid | GridVisual, b: Grid | GridVisual) => boolean;\n/**\n * Returns _true_ if two cells equal.\n * Returns _false_ if either cell are undefined\n *\n * @param a\n * @param b\n * @returns\n */\nexport declare const cellEquals: (a: GridCell | undefined, b: GridCell | undefined) => boolean;\n//# sourceMappingURL=is-equal.d.ts.map","import type { GridBoundsLogic, GridCardinalDirection, GridCell, Grid, GridNeighbour, GridNeighbours } from \"./types.js\";\nexport declare const randomNeighbour: (nbos: readonly GridNeighbour[]) => GridNeighbour;\n/**\n * Gets a list of neighbours for `cell` (using {@link neighbours}), filtering\n * results to only those that are valid neighbours (using {@link isNeighbour})\n *\n * ```js\n * // Get all eight surrounding cells\n * const n = Grids.neighbourList(grid, cell, Grids.allDirections);\n *\n * // Get north, east, south, west cells\n * const n = Grids.neighbourList(grid, cell, Grids.crossDirections);\n * ```\n * @param grid Grid\n * @param cell Cell\n * @param directions Directions\n * @param bounds Bounds\n * @returns\n */\nexport declare const neighbourList: (grid: Grid, cell: GridCell, directions: readonly GridCardinalDirection[], bounds: GridBoundsLogic) => readonly GridNeighbour[];\n/**\n * Returns neighbours for a cell. If no `directions` are provided, it defaults to {@link allDirections}.\n *\n * ```js\n * const grid = { rows: 5, cols: 5 };\n * const cell = { x:2, y:2 };\n *\n * // Get n,ne,nw,e,s,se,sw and w neighbours\n * const n = Grids.neighbours(grid, cell, `wrap`);\n *\n * Yields:\n * {\n *  n: {x: 2, y: 1}\n *  s: {x: 2, y: 3}\n *  ....\n * }\n * ```\n *\n * Returns neighbours without diagonals (ie: n, e, s, w):\n * ```js\n * const n = Grids.neighbours(grid, cell, `stop`, Grids.crossDirections);\n * ```\n * @returns Returns a map of cells, keyed by cardinal direction\n * @param grid Grid\n * @param cell Cell\n * @param bounds How to handle edges of grid\n * @param directions Directions to return\n */\nexport declare const neighbours: (grid: Grid, cell: GridCell, bounds?: GridBoundsLogic, directions?: readonly GridCardinalDirection[]) => GridNeighbours;\n//# sourceMappingURL=neighbour.d.ts.map","import type { Grid, GridCell, GridBoundsLogic } from './types.js';\n/**\n * Returns a coordinate offset from `start` by `vector` amount.\n *\n * Different behaviour can be specified for how to handle when coordinates exceed the bounds of the grid\n *\n * Note: x and y wrapping are calculated independently. A large wrapping of x, for example won't shift up/down a line.\n *\n * Use {@link Grids.applyBounds} if you need to calculate a wrapped coordinate without adding two together.\n * @param grid Grid to traverse\n * @param vector Offset in x/y\n * @param start Start point\n * @param bounds\n * @returns Cell\n */\nexport declare const offset: (grid: Grid, start: GridCell, vector: GridCell, bounds?: GridBoundsLogic) => GridCell | undefined;\n//# sourceMappingURL=offset.d.ts.map","/**\n * Returns a two-dimensional array according to `grid`\n * size.\n *\n * ```js\n * const a = Grids.toArray({ rows: 3, cols: 2 });\n * Yields:\n * [ [_,_] ]\n * [ [_,_] ]\n * [ [_,_] ]\n * ```\n *\n * `initialValue` can be provided to set the value\n * for all cells.\n * @param grid Grid\n * @param initialValue Initial value\n * @returns\n */\nimport type { Grid } from \"./types.js\";\nexport declare const toArray2d: <V>(grid: Grid, initialValue?: V) => V[][];\n//# sourceMappingURL=to-array.d.ts.map","import type { GridCell } from \"./types.js\";\n/**\n * Returns a key string for a cell instance\n * A key string allows comparison of instances by value rather than reference\n *\n * ```js\n * cellKeyString({x:10,y:20});\n * // Yields: \"Cell{10,20}\";\n * ```\n * @param v\n * @returns\n */\nexport declare const cellKeyString: (v: GridCell) => string;\n//# sourceMappingURL=to-string.d.ts.map","import type { RectPositioned } from \"../rect/rect-types.js\";\nimport type { GridCell, GridVisual } from \"./types.js\";\nimport type { Point } from \"../point/point-type.js\";\n/**\n * Generator that returns rectangles for each cell in a grid\n *\n * @example Draw rectangles\n * ```js\n * import { Drawing } from 'visuals.js'\n * const rects = [...Grids.asRectangles(grid)];\n * Drawing.rect(ctx, rects, { strokeStyle: `silver`});\n * ```\n * @param grid\n */\nexport declare function asRectangles(grid: GridVisual): IterableIterator<RectPositioned>;\n/**\n * Returns the cell at a specified visual coordinate\n * or _undefined_ if the position is outside of the grid.\n *\n * `position` must be in same coordinate/scale as the grid.\n *\n * @param position Position, eg in pixels\n * @param grid Grid\n * @return Cell at position or undefined if outside of the grid\n */\nexport declare const cellAtPoint: (grid: GridVisual, position: Point) => GridCell | undefined;\n/**\n * Returns a visual rectangle of the cell, positioned from the top-left corner\n *\n * ```js\n * const cell = { x: 1, y: 0 };\n *\n * // 5x5 grid, each cell 5px in size\n * const grid = { rows: 5, cols: 5, size: 5 }\n *\n * const r = rectangleForCell(grid, cell,);\n *\n * // Yields: { x: 5, y: 0, width: 5, height: 5 }\n * ```\n * @param cell\n * @param grid\n * @return\n */\nexport declare const rectangleForCell: (grid: GridVisual, cell: GridCell) => RectPositioned;\n/**\n * Returns the visual midpoint of a cell (eg. pixel coordinate)\n *\n * @param cell\n * @param grid\n * @return\n */\nexport declare const cellMiddle: (grid: GridVisual, cell: GridCell) => Point;\n//# sourceMappingURL=visual.d.ts.map","import type { GridReadable, GridCell } from \"./types.js\";\nexport declare function values<T>(grid: GridReadable<T>, iter: Iterable<GridCell>): Generator<T>;\nexport declare function values<T>(grid: GridReadable<T>, iter: Iterable<GridCell[]>): Generator<T[]>;\n//# sourceMappingURL=values.d.ts.map","import type { GridNeighbourSelectionLogic } from \"../types.js\";\nexport declare const breadthLogic: () => GridNeighbourSelectionLogic;\n//# sourceMappingURL=breadth.d.ts.map","import type { GridNeighbourSelectionLogic } from \"../types.js\";\nexport declare const neighboursLogic: () => GridNeighbourSelectionLogic;\n//# sourceMappingURL=cell-neighbours.d.ts.map","import type { GridNeighbourSelectionLogic, GridVisitorOpts } from \"../types.js\";\n/**\n * Visits cells running down columns, left-to-right.\n * @param opts Options\n * @returns Visitor generator\n */\nexport declare const columnLogic: (opts?: Partial<GridVisitorOpts>) => GridNeighbourSelectionLogic;\n//# sourceMappingURL=columns.d.ts.map","import type { GridNeighbourSelectionLogic } from \"../types.js\";\nexport declare const depthLogic: () => GridNeighbourSelectionLogic;\n//# sourceMappingURL=depth.d.ts.map","import type { Grid, GridCell, GridCreateVisitor } from \"../types.js\";\n/**\n * Runs the provided `visitor` for `steps`, returning the cell we end at\n * ```js\n * // Create visitor & stepper\n * const visitor = Grids.Visit.create(`row`);\n * const stepper = Grids.Visit.stepper(grid, visitor);\n *\n * // Step by 10\n * stepper(10); // GridCell {x,y}\n *\n * // Step by another 2\n * stepper(2);\n * ```\n * @param grid Grid to traverse\n * @param start Start point\n * @param createVisitor Visitor function\n * @returns\n */\nexport declare const stepper: (grid: Grid, createVisitor: GridCreateVisitor, start?: GridCell, resolution?: number) => (step: number, fromStart?: boolean) => GridCell | undefined;\n//# sourceMappingURL=step.d.ts.map","import type { GridNeighbourSelectionLogic } from \"../types.js\";\nexport declare const randomLogic: () => GridNeighbourSelectionLogic;\n//# sourceMappingURL=random.d.ts.map","import type { GridNeighbourSelectionLogic } from \"../types.js\";\nexport declare const randomContiguousLogic: () => GridNeighbourSelectionLogic;\n//# sourceMappingURL=random-contiguous.d.ts.map","import type { GridNeighbourSelectionLogic, GridVisitorOpts } from \"../types.js\";\n/**\n* Visit by following rows. Normal order is left-to-right, top-to-bottom.\n* @param opts Options\n* @returns\n*/\nexport declare const rowLogic: (opts?: Partial<GridVisitorOpts>) => GridNeighbourSelectionLogic;\n//# sourceMappingURL=rows.d.ts.map","import type { GridNeighbourSelectionLogic, Grid, GridCell, GridVisitorOpts } from \"../types.js\";\n/**\n * Visits every cell in grid using supplied selection function\n * In-built functions to use: visitorDepth, visitorBreadth, visitorRandom,\n * visitorColumn, visitorRow.\n *\n * Usage example:\n * ```js\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell);\n *  for (let cell of visitor) {\n *   // do something with cell\n *  }\n * ```\n *\n * If you want to keep tabs on the visitor, pass in a @ixfx/collections.Sets.ISetMutable instance. This gets\n * updated as cells are visited to make sure we don't visit the same one twice. If a set is not passed\n * in, one will be created internally.\n * ```js\n * let visited = new SetStringMutable<Grids.Cell>(c => Grids.cellKeyString(c));\n * let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell, visited);\n * ```\n *\n * To visit with some delay, try this pattern\n * ```js\n *  const delayMs = 100;\n *  const run = () => {\n *   let cell = visitor.next().value;\n *   if (cell === undefined) return;\n *   // Do something with cell\n *   setTimeout(run, delayMs);\n *  }\n *  setTimeout(run, delayMs);\n * ```\n * @param logic Logic for selecting next cell\n * @param grid Grid to visitl\n * @param opts Options\n * @returns Cells\n */\nexport declare function visitByNeighbours(logic: GridNeighbourSelectionLogic, grid: Grid, opts?: Partial<GridVisitorOpts>): Generator<GridCell>;\n//# sourceMappingURL=visitor.d.ts.map","import type { GridCell, Grid, GridNeighbourSelectionLogic, GridVisitorOpts } from '../types.js';\nexport * from './breadth.js';\nexport * from './cell-neighbours.js';\nexport * from './columns.js';\nexport * from './depth.js';\nexport * from './step.js';\nexport * from './random.js';\nexport * from './random-contiguous.js';\nexport * from './rows.js';\nexport * from './visitor.js';\nexport type VisitorTypes = `row` | `column` | `neighbours` | `breadth` | `depth` | `random` | `random-contiguous`;\n/**\n * Logic types:\n * * 'row': left-to-right, top-to-bottom\n * * 'column': top-to-bottom, left-to-right\n * * 'neighbours': neighbours surrounding cell (eight)\n * * 'breadth`: breadth-first\n * * 'depth': depth-first\n * * 'random': any random cell in grid\n * * 'random-contiguous': any random cell neighbouring an already visited cell\n * @param type\n * @param opts\n * @returns\n */\nexport declare const create: (type: VisitorTypes, opts?: Partial<GridVisitorOpts>) => (grid: Grid, optionsOverride?: Partial<GridVisitorOpts>) => Generator<GridCell, any, any>;\nexport declare const withLogic: (logic: GridNeighbourSelectionLogic, options?: Partial<GridVisitorOpts>) => (grid: Grid, optionsOverride?: Partial<GridVisitorOpts>) => Generator<GridCell, any, any>;\n//# sourceMappingURL=index.d.ts.map","export * from './apply-bounds.js';\nexport * as Array1d from './array-1d.js';\nexport * as Array2d from './array-2d.js';\n/**\n * Iterates over slices of the grid (eg a whole row, a whole column)\n */\nexport * as As from './as.js';\nexport * from './directions.js';\nexport * as By from './enumerators/index.js';\nexport * from './geometry.js';\nexport * from './guards.js';\nexport * from './indexing.js';\nexport * from './inside.js';\nexport * from './is-equal.js';\nexport * from './neighbour.js';\nexport * from './offset.js';\nexport * from './to-array.js';\nexport * from './to-string.js';\nexport type * from './types.js';\nexport * from './visual.js';\nexport * from './values.js';\nexport * as Visit from './visitors/index.js';\n//# sourceMappingURL=index.d.ts.map","import type { RectPositioned } from \"./rect-types.js\";\nimport type { GridCardinalDirection } from '../grid/index.js';\nimport type { Point } from \"../point/point-type.js\";\n/**\n * Returns a point on cardinal direction, or 'center' for the middle.\n *\n * ```js\n * cardinal({x: 10, y:10, width:100, height: 20}, 'center');\n * ```\n * @param rect Rectangle\n * @param card Cardinal direction or 'center'\n * @returns Point\n */\nexport declare const cardinal: (rect: RectPositioned, card: GridCardinalDirection | `center`) => Point;\n//# sourceMappingURL=cardinal.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n/**\n * Perform basic point translation using a rectangle where its center is the origin.\n *\n * Thus the relative coordinate { x: 0, y: 0} corresponds to the absolute middle of the\n * rectangle.\n *\n * The relative coordinate { x: -1, y: -1 } corresponds to the rectangle's {x,y} properties, and so on.\n * @param rectAbsolute\n * @returns\n */\nexport declare const centerOrigin: (rectAbsolute: RectPositioned) => {\n    relativeToAbsolute: (point: Point) => {\n        x: number;\n        y: number;\n        z?: number;\n    };\n    absoluteToRelative: (point: Point) => {\n        x: number;\n        y: number;\n        z?: number;\n    };\n};\n//# sourceMappingURL=center-origin.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Returns the center of a rectangle as a {@link Point}.\n *  If the rectangle lacks a position and `origin` parameter is not provided, 0,0 is used instead.\n *\n * ```js\n * const p = Rects.center({x:10, y:20, width:100, height:50});\n * const p2 = Rects.center({width: 100, height: 50}); // Assumes 0,0 for rect x,y\n * ```\n * @param rect Rectangle\n * @param origin Optional origin. Overrides `rect` position if available. If no position is available 0,0 is used by default.\n * @returns\n */\nexport declare const center: (rect: RectPositioned | Rect, origin?: Point) => Point;\n//# sourceMappingURL=center.d.ts.map","import { type Point } from \"../point/point-type.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Returns the four corners of a rectangle as an array of Points.\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 0, y: 0};\n * const pts = Rects.corners(rect);\n * ```\n *\n * If the rectangle is not positioned, is origin can be provided.\n * Order of corners: ne, nw, sw, se\n * @param rect\n * @param origin\n * @returns\n */\nexport declare const corners: (rect: RectPositioned | Rect, origin?: Point) => readonly Point[];\n//# sourceMappingURL=corners.d.ts.map","import type { RectPositioned } from \"./rect-types.js\";\nimport { type Point } from '../point/point-type.js';\n/**\n * Returns the distance from the perimeter of `rect` to `pt`.\n * If the point is within the rectangle, 0 is returned.\n *\n * If `rect` does not have an x,y it's assumed to be 0,0\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromExterior(rect, { x: 20, y: 20 });\n * ```\n * @param rect Rectangle\n * @param pt Point\n * @returns Distance\n */\nexport declare const distanceFromExterior: (rect: RectPositioned, pt: Point) => number;\n/**\n * Return the distance of `pt` to the center of `rect`.\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromCenter(rect, { x: 20, y: 20 });\n * ```\n * @param rect\n * @param pt\n * @returns\n */\nexport declare const distanceFromCenter: (rect: RectPositioned, pt: Point) => number;\n//# sourceMappingURL=distance.d.ts.map","import type { RectPositioned, Rect } from \"./rect-types.js\";\n/**\n * Divides positioned `rect` by width/height. Useful for normalising a value.\n * x & y value of second parameter are ignored\n * ```js\n * // Normalise based on window size\n * const r = { x: 10, y: 200, width: 100, height: 30 };\n * const rr = Rects.divide(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Division applies to the first parameter's x/y fields. X is affected by `width`, Y is affected by `height`.\n */\nexport declare function divide(rect: RectPositioned, width: number, height?: number): RectPositioned;\n/**\n * Divides `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * // Normalise based on window size\n * const r = { width: 100, height: 30 };\n * const rr = Rects.divide(r, window.innerWidth, window.innerHeight);\n * ```\n *\n */\nexport declare function divide(rect: Rect, width: number, height: number): Rect;\n/**\n * Divides positioned rect `a` by width and height of rect `b`.\n * ```js\n * // Returns { ...a, width: a.width / b.width, height: a.height/b.height, x: a.x / b.width, y: a.y / b.height }\n * Rects.divide(a, b);\n * ```\n *\n * @param a\n * @param b\n */\nexport declare function divide(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n/**\n * Divides rect `a` by width and height of rect `b`.\n *\n * ```js\n * // Returns {...a, width: a.width / b.width, height: a.height/b.height }\n * Rects.divide(a, b);\n * ```\n *\n * @param a\n * @param b\n */\nexport declare function divide(a: Rect, b: Rect): Rect;\n/**\n * Divides all components of `rect` by `amount`.\n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport declare function divideScalar(rect: Rect, amount: number): Rect;\n/**\n * Divides all components of `rect` by `amount`.\n * This includes x,y if present.\n *\n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * divideScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 0.5, y: 1, width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport declare function divideScalar(rect: RectPositioned, amount: number): RectPositioned;\nexport declare function divideDim(rect: Rect | RectPositioned, amount: number): Rect | RectPositioned;\n//# sourceMappingURL=divide.d.ts.map","import type { Rect, RectPositioned } from \"./rect-types.js\";\nimport type { Point } from '../point/point-type.js';\nimport type { Line } from \"../line/line-type.js\";\n/**\n * Returns four lines based on each corner.\n * Lines are given in order: top, right, bottom, left\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lines = Rects.lines(rect);\n * ```\n *\n * @param {(RectPositioned|Rect)} rect\n * @param {Points.Point} [origin]\n * @returns {Lines.Line[]}\n */\nexport declare const edges: (rect: RectPositioned | Rect, origin?: Point) => readonly Line[];\n/**\n * Returns a point on the edge of rectangle\n * ```js\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeX(r1, `right`);  // Yields: 110\n * Rects.getEdgeX(r1, `bottom`); // Yields: 10\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeX(r2, `right`);  // Yields: 100\n * Rects.getEdgeX(r2, `bottom`); // Yields: 0\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport declare const getEdgeX: (rect: RectPositioned | Rect, edge: `right` | `bottom` | `left` | `top`) => number;\n/**\n * Returns a point on the edge of rectangle\n *\n * ```js\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeY(r1, `right`);  // Yields: 10\n * Rects.getEdgeY(r1, `bottom`); // Yields: 60\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeY(r2, `right`);  // Yields: 0\n * Rects.getEdgeY(r2, `bottom`); // Yields: 50\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport declare const getEdgeY: (rect: RectPositioned | Rect, edge: `right` | `bottom` | `left` | `top`) => number;\n//# sourceMappingURL=edges.d.ts.map","export declare const Empty: Readonly<{\n    width: 0;\n    height: 0;\n}>;\nexport declare const EmptyPositioned: Readonly<{\n    x: 0;\n    y: 0;\n    width: 0;\n    height: 0;\n}>;\n//# sourceMappingURL=empty.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n/**\n * Returns a copy of `rect` with `rect` resized so it also encompasses `points`.\n * If provided point(s) are within bounds of `rect`, a copy of `rect` is returned.\n * @param rect\n * @param points\n * @returns\n */\nexport declare const encompass: (rect: RectPositioned, ...points: Point[]) => RectPositioned;\n//# sourceMappingURL=encompass.d.ts.map","import { type RectPositioned } from \"./rect-types.js\";\nimport type { Point } from \"../point/point-type.js\";\n/**\n * Initialises a rectangle based on its center, a width and height\n *\n * ```js\n * // Rectangle with center at 50,50, width 100 height 200\n * Rects.fromCenter({x: 50, y:50}, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport declare const fromCenter: (origin: Point, width: number, height: number) => RectPositioned;\n//# sourceMappingURL=from-center.d.ts.map","import type { Rect } from \"./rect-types.js\";\n/**\n * Initialise a rectangle based on the width and height of a HTML element.\n *\n * ```js\n * Rects.fromElement(document.querySelector(`body`));\n * ```\n * @param el\n * @returns\n */\nexport declare const fromElement: (el: HTMLElement) => Rect;\n//# sourceMappingURL=from-element.d.ts.map","import type { RectPositioned, Rect } from \"./rect-types.js\";\n/**\n * Returns a rectangle from width, height\n * ```js\n * const r = Rects.fromNumbers(100, 200);\n * // {width: 100, height: 200}\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @param width\n * @param height\n */\nexport declare function fromNumbers(width: number, height: number): Rect;\n/**\n * Returns a rectangle from x,y,width,height\n *\n * ```js\n * const r = Rects.fromNumbers(10, 20, 100, 200);\n * // {x: 10, y: 20, width: 100, height: 200}\n * ```\n *\n * Use the spread operator (...) if the source is an array:\n * ```js\n * const r3 = Rects.fromNumbers(...[10, 20, 100, 200]);\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @param x\n * @param y\n * @param width\n * @param height\n */\nexport declare function fromNumbers(x: number, y: number, width: number, height: number): RectPositioned;\n//# sourceMappingURL=from-numbers.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n/**\n * Creates a rectangle from its top-left coordinate, a width and height.\n *\n * ```js\n * // Rectangle at 50,50 with width of 100, height of 200.\n * const rect = Rects.fromTopLeft({ x: 50, y:50 }, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport declare const fromTopLeft: (origin: Point, width: number, height: number) => RectPositioned;\n//# sourceMappingURL=from-top-left.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Accepts:\n * * x,y,w,h\n * * x,y,rect\n * * point,rect\n * * RectPositioned\n * * Rect, x,y\n * * Rect, Point\n * @param a\n * @param b\n * @param c\n * @param d\n * @returns\n */\nexport declare function getRectPositionedParameter(a: number | Point | Rect | RectPositioned, b?: Rect | number | Point, c?: number | Rect, d?: number): RectPositioned;\n//# sourceMappingURL=get-rect-positionedparameter.d.ts.map","import type { RectPositioned, Rect } from \"./rect-types.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Throws an error if the dimensions of the rectangle are undefined, NaN or negative.\n * @param d\n * @param name\n */\nexport declare const guardDim: (d: number, name?: string) => void;\n/**\n * Throws an error if rectangle is missing fields or they\n * are not valid.\n *\n * Checks:\n * * `width` and `height` must be defined on `rect`\n * * dimensions (w & h) must not be NaN\n * * dimensions (w & h) must not be negative\n *\n * If `rect` has x,y, this value is checked as well.\n * @param rect\n * @param name\n */\nexport declare const guard: (rect: Rect, name?: string) => void;\n/**\n * Returns a positioned rect or if it's not possible, throws an error.\n *\n * If `rect` does not have a position, `origin` is used.\n * If `rect` is positioned and `origin` is provided, returned result uses `origin` as x,y instead.\n * ```js\n * // Returns input because it's positioned\n * getRectPositioned({ x:1, y:2, width:10, height:20 });\n *\n * // Returns { x:1, y:2, width:10, height:20 }\n * getRectPositioned({ width:10, height:20 }, { x:1, y:2 });\n *\n * // Throws, because we have no point\n * getRectPositioned({width:10,height:20})\n * ```\n * @param rect\n * @param origin\n * @returns\n */\nexport declare const getRectPositioned: (rect: Rect | RectPositioned, origin?: Point) => RectPositioned;\n/**\n * Throws an error if `rect` is does not have a position, or\n * is an invalid rectangle\n * @param rect\n * @param name\n */\nexport declare const guardPositioned: (rect: RectPositioned, name?: string) => void;\n/**\n * Returns _true_ if `rect` has width and height values of 0.\n * Use Rects.Empty or Rects.EmptyPositioned to generate an empty rectangle.\n * @param rect\n * @returns\n */\nexport declare const isEmpty: (rect: Rect) => boolean;\n/**\n * Returns _true_ if `rect` is a placeholder, with both width and height values of NaN.\n * Use Rects.Placeholder or Rects.PlaceholderPositioned to generate a placeholder.\n * @param rect\n * @returns\n */\nexport declare const isPlaceholder: (rect: Rect) => boolean;\n/**\n * Returns _true_ if `rect` has position (x,y) fields.\n * @param rect Point, Rect or RectPositiond\n * @returns\n */\nexport declare const isPositioned: (rect: Point | Rect | RectPositioned) => rect is Point;\n/**\n * Returns _true_ if `rect` has width and height fields.\n * @param rect\n * @returns\n */\nexport declare const isRect: (rect: unknown) => rect is Rect;\n/**\n * Returns _true_ if `rect` is a positioned rectangle\n * Having width, height, x and y properties.\n * @param rect\n * @returns\n */\nexport declare const isRectPositioned: (rect: any) => rect is RectPositioned;\n//# sourceMappingURL=guard.d.ts.map","import type { Rect, RectPositioned } from \"./rect-types.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { CirclePositioned } from \"../circle/circle-type.js\";\n/**\n * Returns _true_ if `point` is within, or on boundary of `rect`.\n *\n * ```js\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * ```\n * @param rect\n * @param point\n */\nexport declare function intersectsPoint(rect: Rect | RectPositioned, point: Point): boolean;\n/**\n * Returns true if x,y coordinate is within, or on boundary of `rect`.\n * ```js\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param x\n * @param y\n */\nexport declare function intersectsPoint(rect: Rect | RectPositioned, x: number, y: number): boolean;\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A rectangle can be checked for intersections with another RectPositioned, CirclePositioned or Point.\n *\n */\nexport declare const isIntersecting: (a: RectPositioned, b: CirclePositioned | Point) => boolean;\n//# sourceMappingURL=Intersects.d.ts.map","import type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Returns _true_ if the width & height of the two rectangles is the same.\n *\n * ```js\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const isEqualSize: (a: Rect, b: Rect) => boolean;\n/**\n * Returns _true_ if two rectangles have identical values.\n * Both rectangles must be positioned or not.\n *\n * ```js\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const isEqual: (a: Rect | RectPositioned, b: Rect | RectPositioned) => boolean;\n//# sourceMappingURL=is-equal.d.ts.map","import type { RectPositioned } from './rect-types.js';\n/**\n * Returns the length of each side of the rectangle (top, right, bottom, left)\n *\n * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lengths = Rects.lengths(rect);\n * ```\n * @param rect\n * @returns\n */\nexport declare const lengths: (rect: RectPositioned) => readonly number[];\n//# sourceMappingURL=lengths.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n/**\n * Returns a rectangle based on provided four corners.\n *\n * To create a rectangle that contains an arbitary set of points, use {@link Points.bbox}.\n *\n * Does some sanity checking such as:\n *  - x will be smallest of topLeft/bottomLeft\n *  - y will be smallest of topRight/topLeft\n *  - width will be largest between top/bottom left and right\n *  - height will be largest between left and right top/bottom\n *\n */\nexport declare const maxFromCorners: (topLeft: Point, topRight: Point, bottomRight: Point, bottomLeft: Point) => RectPositioned;\n//# sourceMappingURL=max.d.ts.map","import type { RectPositioned, Rect } from \"./rect-types.js\";\n/**\n * Multiplies positioned `rect` by width/height. Useful for denormalising a value.\n * x/y value of second parameter are ignored.\n * ```js\n * // Normalised rectangle\n * const r = { x:0.5, y:0.5, width: 0.5, height: 0.5};\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields.\n */\nexport declare function multiply(rect: RectPositioned, width: number, height?: number): RectPositioned;\n/**\n * Multiplies `rect` by width/height. Useful for denormalising a value.\n *\n * ```js\n * // Normalised rectangle of width 50%, height 50%\n * const r = { width: 0.5, height: 0.5 };\n *\n * // Map to window:\n * const rr = Rects.multiply(r, window.innerWidth, window.innerHeight);\n * ```\n *\n * Multiplication applies to the first parameter's x/y fields, if present.\n */\nexport declare function multiply(rect: Rect, width: number, height: number): Rect;\n/**\n * Multiplies positioned rect `a` by width and height of rect `b`.\n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n * ```\n *\n * @param a\n * @param b\n */\nexport declare function multiply(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n/**\n * Multiplies rect `a` by width and height of rect `b`.\n *\n * ```js\n * // Returns {width: someRect.width * someOtherRect.width ...}\n * Rects.multiply(someRect, someOtherRect);\n * ```\n *\n * @param a\n * @param b\n */\nexport declare function multiply(a: Rect, b: Rect): Rect;\n/**\n * Multiplies all components of `rect` by `amount`.\n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * ```\n * @param rect\n * @param amount\n */\nexport declare function multiplyScalar(rect: Rect, amount: number): Rect;\n/**\n * Multiplies all components of `rect` by `amount`.\n * This includes x,y if present.\n *\n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * multiplyScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 2, y: 4, width:20, height: 40 }\n * ```\n * @param rect\n * @param amount\n */\nexport declare function multiplyScalar(rect: RectPositioned, amount: number): RectPositioned;\n/**\n * Multiplies only the width/height of `rect`, leaving `x` and `y` as they are.\n * ```js\n * multiplyDim({ x:1,y:2,width:3,height:4 }, 2);\n * // Yields: { x:1, y:2, width:6, height: 8 }\n * ```\n *\n * In comparison, {@link multiply} will also include x & y.\n * @param rect Rectangle\n * @param amount Amount to multiply by\n * @returns\n */\nexport declare function multiplyDim(rect: Rect | RectPositioned, amount: number): Rect | RectPositioned;\n//# sourceMappingURL=multiply.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"./rect-types.js\";\n/**\n * If `p` is inside of `rect`, a copy of `p` is returned.\n * If `p` is outside of `rect`, a point is returned closest to `p` on the edge\n * of the rectangle.\n * @param rect\n * @param p\n * @returns\n */\nexport declare const nearestInternal: (rect: RectPositioned, p: Point) => Point;\n//# sourceMappingURL=nearest.d.ts.map","export declare const Placeholder: Readonly<{\n    width: number;\n    height: number;\n}>;\nexport declare const PlaceholderPositioned: Readonly<{\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n}>;\n//# sourceMappingURL=placeholder.d.ts.map","import type { Rect } from \"./rect-types.js\";\n/**\n * Returns the perimeter of `rect` (ie. sum of all edges)\n *  * ```js\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.perimeter(rect);\n * ```\n * @param rect\n * @returns\n */\nexport declare const perimeter: (rect: Rect) => number;\n//# sourceMappingURL=perimeter.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Rect } from \"./rect-types.js\";\n/**\n * Returns a function that divides numbers or points by the largest dimension of `rect`.\n *\n * ```js\n * const d = dividerByLargestDimension({width:100,height:50});\n * d(50);                // 0.5 (50/100)\n * d({ x: 10, y: 20 }); // { x: 0.1, y: 0.2 }\n * ```\n * @param rect\n * @returns\n */\nexport declare const dividerByLargestDimension: (rect: Rect) => (value: number | Point) => number | Readonly<{\n    x: number;\n    y: number;\n    z?: number;\n}>;\n//# sourceMappingURL=normalise-by-rect.d.ts.map","import { type RandomSource } from '@ixfx/random';\nimport type { Point } from '../point/point-type.js';\nimport type { Rect, RectPositioned } from './rect-types.js';\n/**\n * Returns a random positioned Rect on a 0..1 scale.\n * ```js\n * const r = Rects.random(); // eg {x: 0.2549012, y:0.859301, width: 0.5212, height: 0.1423 }\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Rects } from \"@ixfx/geometry.js\";\n * import { weightedSource } from \"@ixfx/random.js\"\n * const r = Rects.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport declare const random: (rando?: RandomSource) => RectPositioned;\nexport type RectRandomPointOpts = {\n    readonly strategy?: `naive`;\n    readonly randomSource?: RandomSource;\n    readonly margin?: {\n        readonly x: number;\n        readonly y: number;\n    };\n};\n/**\n * Returns a random point within a rectangle.\n *\n * By default creates a uniform distribution.\n *\n * ```js\n * const pt = randomPoint({width: 5, height: 10});\n * ```'\n * @param within Rectangle to generate a point within\n * @param options Options\n * @returns\n */\nexport declare const randomPoint: (within: Rect | RectPositioned, options?: RectRandomPointOpts) => Point;\n//# sourceMappingURL=random.d.ts.map","import type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Subtracts width/height of `b` from `a` (ie: a - b), returning result.\n * x,y of second parameter is ignored.\n * ```js\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rectA, rectB);\n * ```\n * @param a\n * @param b\n */\nexport declare function subtract(a: Rect, b: Rect | RectPositioned): Rect;\nexport declare function subtract(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n/**\n * Subtracts a width/height from `a`, returning result.\n * ```js\n * const rect = { width: 100, height: 100 };\n * Rects.subtract(rect, 200, 200);\n * // Yields: { width: -100, height: -100 }\n * ```\n * @param a\n * @param width\n * @param height\n */\nexport declare function subtract(a: Rect, width: number, height: number): Rect;\nexport declare function subtract(a: RectPositioned, width: number, height: number): RectPositioned;\n/**\n * Subtracts a width & height from `a`. Leaves x & y as-is.\n * ```js\n * const rect = { x: 10, y: 20, width: 100, height: 200 };\n * subtractSize(rect, { width: 50, height: 100 });\n * subtractSize(rec, 50, 100);\n * // Both yields: { x:10, y: 20, width: 50, height: 100 }\n * ```\n * @param a Rectangle\n * @param b Rectangle to subtract by, or width\n * @param c Height, if second parameter is width\n */\nexport declare function subtractSize(a: RectPositioned, b: Rect | number, c?: number): RectPositioned;\n/**\n * Subtracts a width & height from `a`.\n * ```js\n * const rect = { width: 100, height: 200 };\n * subtractSize(rect, { width: 50, height: 100 });\n * subtractSize(rec, 50, 100);\n * // Both yields: { width: 50, height: 100 }\n * ```\n * @param a Rectangle\n * @param b Rectangle to subtract by, or width\n * @param c Height, if second parameter is width\n */\nexport declare function subtractSize(a: Rect, b: Rect | number, c?: number): Rect;\n/**\n * Subtracts A-B. Applies to x, y, width & height\n * ```js\n * subtractOffset(\n *  { x:100, y:100, width:100, height:100 },\n *  { x:10, y:20,   width: 30, height: 40 }\n * );\n * // Yields: {x: 90, y: 80, width: 70, height: 60 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used.\n * @param a\n * @param b\n * @returns\n */\nexport declare function subtractOffset(a: RectPositioned | Rect, b: RectPositioned | Rect): RectPositioned;\n//# sourceMappingURL=subtract.d.ts.map","import type { Rect, RectPositioned } from \"./rect-types.js\";\n/**\n * Sums width/height of `b` with `a` (ie: a + b), returning result.\n * x/y of second parameter are ignored\n * ```js\n * import { Rects } from \"@ixfx/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.sum(rectA, rectB);\n * ```\n * @param a\n * @param b\n */\nexport declare function sum(a: Rect, b: Rect | RectPositioned): Rect;\n/**\n * Sums width/height of `b` with `a`, returning result.\n *\n * Note that width/height of `b` is also added to `a`'s x & y properties\n * ```js\n * // Yields: { x:101, y:202, width: 110, height: 220 }\n * sum({x:1, y:2, width:10, height:20}, {width:100, height: 200});\n * ```\n *\n * x & y values of `b` are ignored. If you want to sum with those, use `sumOffset`\n * @param a\n * @param b\n */\nexport declare function sum(a: RectPositioned, b: Rect | RectPositioned): RectPositioned;\n/**\n * Sums width/height of `rect` with given `width` and `height`\n * ```js\n * import { Rects } from \"@ixfx/geometry.js\";\n * const rect = { width: 100, height: 100 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.subtract(rect, 200, 200);\n * ```\n * @param rect\n * @param width\n * @param height\n */\nexport declare function sum(rect: Rect, width: number, height: number): Rect;\n/**\n * Sums width/height of `rect` with `width` and `height`\n *\n * `width` and `height` is added to `rect`'s `x` and `y` values.\n * ```js\n * // Yields: { x:101, y:202, width: 110, height: 220 }\n * sum({x:1, y:2, width:10, height:20}, 100, 200);\n * ```\n * @param rect\n * @param width\n * @param height\n */\nexport declare function sum(rect: RectPositioned, width: number, height: number): RectPositioned;\n/**\n * Sums x,y,width,height of a+b.\n * ```js\n * sumOffset({x:100,y:100,width:100,height:100}, {x:10, y:20, width: 30, height: 40});\n * // Yields: {x: 110, y: 120, width: 130, height: 140 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used\n * @param a\n * @param b\n * @returns\n */\nexport declare function sumOffset(a: RectPositioned | Rect, b: RectPositioned | Rect): RectPositioned;\n//# sourceMappingURL=sum.d.ts.map","import type { Rect, RectArray, RectPositioned, RectPositionedArray } from \"./rect-types.js\";\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n *\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\nexport declare function toArray(rect: Rect): RectArray;\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n *\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\nexport declare function toArray(rect: RectPositioned): RectPositionedArray;\n//# sourceMappingURL=to-array.d.ts.map","export * from './area.js';\nexport * from './apply.js';\nexport * from './cardinal.js';\nexport * from './center-origin.js';\nexport * from './center.js';\nexport * from './corners.js';\nexport * from './distance.js';\nexport * from './divide.js';\nexport * from './edges.js';\nexport * from './empty.js';\nexport * from './encompass.js';\nexport * from './from-center.js';\nexport * from './from-element.js';\nexport * from './from-numbers.js';\nexport * from './from-top-left.js';\nexport * from './get-rect-positionedparameter.js';\nexport * from './guard.js';\nexport * from './Intersects.js';\nexport * from './is-equal.js';\nexport * from './lengths.js';\nexport * from './max.js';\nexport * from './multiply.js';\nexport * from './nearest.js';\nexport * from './placeholder.js';\nexport * from './perimeter.js';\nexport * from './normalise-by-rect.js';\nexport * from './random.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './to-array.js';\nexport type * from './rect-types.js';\n//# sourceMappingURL=index.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { RectPositioned } from \"../rect/rect-types.js\";\nexport type Path = {\n    /**\n     * Length of path\n     */\n    length(): number;\n    /**\n     * Returns a point at a relative (0.0-1.0) position along the path\n     *\n     * Inverse of {@link relativePosition}.\n     * @param {number} t Relative position (0.0-1.0)\n     * @returns {Point} Point\n     */\n    interpolate(t: number): Point;\n    /**\n     * Returns relative position of `point` along path.\n     * If `pt` is same as start, result will be 0, if it's the same as end, it will be 1.\n     *\n     * Inverse of {@link interpolate}.\n     * @param point\n     * @param intersectionThreshold\n     */\n    relativePosition(point: Point, intersectionThreshold: number): number;\n    /**\n     * Gets smallest box that encloses path\n     */\n    bbox(): RectPositioned;\n    /**\n     * Returns the nearest point on path to `point`\n     * @param point\n     */\n    nearest(point: Point): Point;\n    /**\n     * Distance from start of path to this point.\n     * If path is closed (eg. a circle) it may have some arbitary 'start' point\n     * @param point\n     */\n    distanceToPoint(point: Point): number;\n    /**\n     * Returns a string representation of pth values\n     */\n    toString(): string;\n    /**\n     * Returns an array of SVG segments that can render path\n     */\n    toSvgString(): ReadonlyArray<string>;\n    /**\n     * Well-known path kind\n     */\n    readonly kind: `compound` | `elliptical` | `circular` | `arc` | `bezier/cubic` | `bezier/quadratic` | `line`;\n};\nexport type WithBeziers = {\n    getBeziers(): ReadonlyArray<Path>;\n};\nexport type CompoundPath = Path & {\n    readonly segments: ReadonlyArray<Path>;\n    readonly kind: `compound`;\n};\nexport type Dimensions = {\n    /**\n     * Width of each path (based on bounding box)\n     */\n    readonly widths: ReadonlyArray<number>;\n    /**\n     * Length of each path\n     */\n    readonly lengths: ReadonlyArray<number>;\n    /**\n     * Total length of all paths\n     */\n    readonly totalLength: number;\n    /**\n     * Total width of all paths\n     */\n    readonly totalWidth: number;\n};\n//# sourceMappingURL=path-type.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * Arc, defined by radius, start and end point in radians and direction\n */\nexport type Arc = {\n    /**\n     * Radius of arc\n     */\n    readonly radius: number;\n    /**\n     * Start radian\n     */\n    readonly startRadian: number;\n    /**\n     * End radian\n     */\n    readonly endRadian: number;\n    /**\n     * If true, arc runs in clockwise direction\n     */\n    readonly clockwise: boolean;\n};\n/**\n * An {@link Arc} that also has a center position, given in x, y\n */\nexport type ArcPositioned = Point & Arc;\n/**\n * Function which can interpolate along an {@link Arc} or {@link ArcPositioned}.\n */\nexport type ArcInterpolate = {\n    (amount: number, arc: Arc, allowOverflow: boolean, origin: Point): Point;\n    (amount: number, arc: ArcPositioned, allowOverflow?: boolean): Point;\n};\n/**\n * Function to convert an arc to SVG segments\n */\nexport type ArcToSvg = {\n    /**\n     * SVG path for arc description\n     * @param origin Origin of arc\n     * @param radius Radius\n     * @param startRadian Start\n     * @param endRadian End\n     */\n    (origin: Point, radius: number, startRadian: number, endRadian: number, opts?: ArcSvgOpts): readonly string[];\n    /**\n     * SVG path for non-positioned arc.\n     * If `arc` does have a position, `origin` will override it.\n     */\n    (arc: Arc, origin: Point, opts?: ArcSvgOpts): readonly string[];\n    /**\n     * SVG path for positioned arc\n     */\n    (arc: ArcPositioned, opts?: ArcSvgOpts): readonly string[];\n};\nexport type ArcSvgOpts = {\n    /**\n     * \"If the arc should be greater or less than 180 degrees\"\n     * ie. tries to maximise arc length\n     */\n    readonly largeArc?: boolean;\n    /**\n     * \"If the arc should begin moving at positive angles\"\n     * ie. the kind of bend it makes to reach end point\n     */\n    readonly sweep?: boolean;\n};\n//# sourceMappingURL=arc-type.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { Line } from '../line/line-type.js';\nimport type { Path } from '../path/path-type.js';\nimport type { Rect, RectPositioned } from '../rect/rect-types.js';\nimport type { Arc, ArcInterpolate, ArcPositioned, ArcToSvg } from './arc-type.js';\nimport type { CirclePositioned } from '../circle/circle-type.js';\nexport type * from './arc-type.js';\n/**\n * Returns true if parameter is an arc\n * @param p Arc or number\n * @returns\n */\nexport declare const isArc: (p: unknown) => p is Arc;\n/**\n * Returns true if parameter has a positioned (x,y)\n * @param p Point, Arc or ArcPositiond\n * @returns\n */\nexport declare const isPositioned: (p: Point | Arc | ArcPositioned) => p is Point;\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @returns Arc\n */\nexport declare function fromDegrees(radius: number, startDegrees: number, endDegrees: number, clockwise: boolean): Arc;\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @param origin Optional center of arc\n * @param clockwise Whether arc moves in clockwise direction\n * @returns Arc\n */ export declare function fromDegrees(radius: number, startDegrees: number, endDegrees: number, clockwise: boolean, origin: Point): ArcPositioned;\n/**\n * Returns a {@link Line} linking the start and end points of an {@link ArcPositioned}.\n *\n * @param arc\n * @returns Line from start to end of arc\n */\nexport declare const toLine: (arc: ArcPositioned) => Line;\n/**\n * Return start and end points of `arc`.\n * `origin` will override arc's origin, if defined.\n *\n * See also:\n * * {@link point} - get point on arc by angle\n * * {@link interpolate} - get point on arc by interpolation percentage\n * @param arc\n * @param origin\n * @returns\n */\nexport declare const getStartEnd: (arc: ArcPositioned | Arc, origin?: Point) => [start: Point, end: Point];\n/**\n * Calculates a coordinate on an arc, based on an angle.\n * `origin` will override arc's origin, if defined.\n *\n * See also:\n * * {@link getStartEnd} - get start and end of arc\n * * {@link interpolate} - get point on arc by interpolation percentage\n * @param arc Arc\n * @param angleRadian Angle of desired coordinate\n * @param origin Origin of arc (0,0 used by default)\n * @returns Coordinate\n */\nexport declare const point: (arc: Arc | ArcPositioned, angleRadian: number, origin?: Point) => Point;\n/**\n * Throws an error if arc instance is invalid\n * @param arc\n */\nexport declare const guard: (arc: Arc | ArcPositioned) => void;\n/**\n * Compute relative position on arc.\n *\n * See also:\n * * {@link getStartEnd} - get start and end of arc\n * * {@link point} - get point on arc by angle\n * @param arc Arc\n * @param amount Relative position 0-1\n * @param origin If arc is not positioned, pass in an origin\n * @param allowOverflow If _true_ allows point to overflow arc dimensions (default: _false_)\n * @returns\n */\nexport declare const interpolate: ArcInterpolate;\n/**\n * Returns the angular size of arc.\n * Eg if arc runs from 45-315deg in clockwise direction, size will be 90deg.\n * @param arc\n */\nexport declare const angularSize: (arc: Arc) => number;\n/**\n * Creates a {@link Path} instance from the arc. This wraps up some functions for convienence.\n * @param arc\n * @returns Path\n */\nexport declare const toPath: (arc: ArcPositioned) => Path;\n/**\n * Returns an arc based on a circle using start and end angles.\n * If you don't have the end angle, but rather the size of the arc, use {@link fromCircleAmount}\n * @param circle Circle\n * @param startRadian Start radian\n * @param endRadian End radian\n * @param clockwise Whether arc goes in a clockwise direction (default: true)\n * @returns\n */\nexport declare const fromCircle: (circle: CirclePositioned, startRadian: number, endRadian: number, clockwise?: boolean) => ArcPositioned;\n/**\n * Returns an arc based on a circle, a start angle, and the size of the arc.\n * See {@link fromCircle} if you already have start and end angles.\n * @param circle Circle to base off\n * @param startRadian Starting angle\n * @param sizeRadian Size of arc\n * @param clockwise Whether arc moves in clockwise direction (default: true)\n * @returns\n */\nexport declare const fromCircleAmount: (circle: CirclePositioned, startRadian: number, sizeRadian: number, clockwise?: boolean) => ArcPositioned;\n/**\n * Calculates the length of the arc\n * @param arc\n * @returns Length\n */\nexport declare const length: (arc: Arc) => number;\n/**\n * Calculates a {@link Rect} bounding box for arc.\n * @param arc\n * @returns Rectangle encompassing arc.\n */\nexport declare const bbox: (arc: ArcPositioned | Arc) => RectPositioned | Rect;\n/**\n * Creates an SV path snippet for arc\n * @returns\n */\nexport declare const toSvg: ArcToSvg;\n/**\n * Calculates the distance between the centers of two arcs\n * @param a\n * @param b\n * @returns Distance\n */\nexport declare const distanceCenter: (a: ArcPositioned, b: ArcPositioned) => number;\n/**\n * Returns true if the two arcs have the same values\n *\n * ```js\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * arcA === arcB; // false, because object identities are different\n * Arcs.isEqual(arcA, arcB); // true, because values are identical\n * ```\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport declare const isEqual: (a: Arc | ArcPositioned, b: Arc | ArcPositioned) => boolean;\n//# sourceMappingURL=index.d.ts.map","import type { Path } from \"../path/path-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nexport type QuadraticBezier = {\n    readonly a: Point;\n    readonly b: Point;\n    readonly quadratic: Point;\n};\nexport type QuadraticBezierPath = Path & QuadraticBezier;\nexport type CubicBezier = {\n    readonly a: Point;\n    readonly b: Point;\n    readonly cubic1: Point;\n    readonly cubic2: Point;\n};\nexport type CubicBezierPath = Path & CubicBezier;\n//# sourceMappingURL=bezier-type.d.ts.map","import type { Path } from \"../path/path-type.js\";\nimport type { QuadraticBezier, CubicBezier } from \"./bezier-type.js\";\nexport declare const isQuadraticBezier: (path: Path | QuadraticBezier | CubicBezier) => path is QuadraticBezier;\nexport declare const isCubicBezier: (path: Path | CubicBezier | QuadraticBezier) => path is CubicBezier;\n//# sourceMappingURL=guard.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { CubicBezier, CubicBezierPath, QuadraticBezier, QuadraticBezierPath } from './bezier-type.js';\nexport * from './bezier-type.js';\nexport * from './guard.js';\n/**\n * Returns a new quadratic bezier with specified bend amount\n *\n * @param {QuadraticBezier} b Curve\n * @param {number} [bend=0] Bend amount, from -1 to 1\n * @returns {QuadraticBezier}\n */\n/**\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve.\n *\n * Use {@link interpolator} to calculate a point along the curve.\n * @param {Point} start Start of curve\n * @param {Point} end End of curve\n * @param {number} [bend=0] Bend amount, -1 to 1\n * @returns {QuadraticBezier}\n */\nexport declare const quadraticSimple: (start: Point, end: Point, bend?: number) => QuadraticBezier;\n/**\n * Returns a relative point on a simple quadratic\n * @param start Start\n * @param end  End\n * @param bend Bend (-1 to 1)\n * @param amt Amount\n * @returns Point\n */\n/**\n * Interpolate cubic or quadratic bezier\n * ```js\n * const i = interpolator(myBezier);\n *\n * // Get point at 50%\n * i(0.5); // { x, y }\n * ```\n * @param q\n * @returns\n */\nexport declare const interpolator: (q: QuadraticBezier | CubicBezier) => (amount: number) => Point;\nexport declare const quadraticToSvgString: (start: Point, end: Point, handle: Point) => ReadonlyArray<string>;\nexport declare const toPath: (cubicOrQuadratic: CubicBezier | QuadraticBezier) => CubicBezierPath | QuadraticBezierPath;\nexport declare const cubic: (start: Point, end: Point, cubic1: Point, cubic2: Point) => CubicBezier;\nexport declare const quadratic: (start: Point, end: Point, handle: Point) => QuadraticBezier;\n//# sourceMappingURL=index.d.ts.map","import type { Circle } from \"./circle-type.js\";\n/**\n * Returns the area of `circle`.\n * @param circle\n * @returns\n */\nexport declare const area: (circle: Circle) => number;\n//# sourceMappingURL=area.d.ts.map","import type { CirclePositioned, Circle } from \"./circle-type.js\";\nimport type { RectPositioned } from \"../rect/rect-types.js\";\n/**\n * Computes a bounding box that encloses circle\n * @param circle\n * @returns\n */\nexport declare const bbox: (circle: CirclePositioned | Circle) => RectPositioned;\n//# sourceMappingURL=bbox.d.ts.map","import type { CirclePositioned, Circle } from \"./circle-type.js\";\n/**\n * Returns the center of a circle\n *\n * If the circle has an x,y, that is the center.\n * If not, `radius` is used as the x and y.\n *\n * ```js\n * const circle = { radius: 5, x: 10, y: 10};\n *\n * // Yields: { x: 5, y: 10 }\n * Circles.center(circle);\n * ```\n *\n * It's a trivial function, but can make for more understandable code\n * @param circle\n * @returns Center of circle\n */\nexport declare const center: (circle: CirclePositioned | Circle) => Readonly<{\n    x: number;\n    y: number;\n}>;\n//# sourceMappingURL=center.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { CompoundPath, Dimensions, Path } from './path-type.js';\nimport type { RectPositioned } from '../rect/rect-types.js';\n/**\n * Returns a new compoundpath, replacing a path at a given index\n *\n * @param compoundPath Existing compoundpath\n * @param index Index to replace at\n * @param path Path to substitute in\n * @returns New compoundpath\n */\nexport declare const setSegment: (compoundPath: CompoundPath, index: number, path: Path) => CompoundPath;\n/**\n * Computes x,y point at a relative position along compoundpath\n *\n * @param paths Combined paths (assumes contiguous)\n * @param t Position (given as a percentage from 0 to 1)\n * @param useWidth If true, widths are used for calulcating. If false, lengths are used\n * @param dimensions Precalculated dimensions of paths, will be computed if omitted\n * @returns\n */\nexport declare const interpolate: (paths: readonly Path[], t: number, useWidth?: boolean, dimensions?: Dimensions) => Point;\n/**\n * Returns the shortest distance of `point` to any point on `paths`.\n * @param paths\n * @param point\n * @returns\n */\nexport declare const distanceToPoint: (paths: readonly Path[], point: Point) => number;\n/**\n * Relative position\n * @param paths Paths\n * @param point Point\n * @param intersectionThreshold Threshold\n * @param dimensions Pre-computed dimensions\n * @returns\n */\nexport declare const relativePosition: (paths: readonly Path[], point: Point, intersectionThreshold: number, dimensions?: Dimensions) => number;\n/**\n * Computes the widths and lengths of all paths, adding them up as well\n *\n * @param paths\n * @returns\n */\nexport declare const computeDimensions: (paths: readonly Path[]) => Dimensions;\n/**\n * Computes the bounding box that encloses entire compoundpath\n *\n * @param paths\n * @returns\n */\nexport declare const bbox: (paths: readonly Path[]) => RectPositioned;\n/**\n * Produce a human-friendly representation of paths\n *\n * @param paths\n * @returns\n */\nexport declare const toString: (paths: readonly Path[]) => string;\n/**\n * Throws an error if paths are not connected together, in order\n *\n * @param paths\n */\nexport declare const guardContinuous: (paths: readonly Path[]) => void;\nexport declare const toSvgString: (paths: readonly Path[]) => readonly string[];\n/**\n * Create a compoundpath from an array of paths.\n * All this does is verify they are connected, and precomputes dimensions\n *\n * @param paths\n * @returns\n */\nexport declare const fromPaths: (...paths: readonly Path[]) => CompoundPath;\n//# sourceMappingURL=compound-path.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Path } from \"./path-type.js\";\n/**\n * Return the start point of a path\n *\n * @param path\n * @return Point\n */\nexport declare const getStart: (path: Path) => Point;\n/**\n * Return the end point of a path\n *\n * @param path\n * @return Point\n */\nexport declare const getEnd: (path: Path) => Point;\n//# sourceMappingURL=start-end.d.ts.map","export * from './compound-path.js';\nexport type * from './path-type.js';\nexport * from './start-end.js';\n//# sourceMappingURL=index.d.ts.map","import type { Path } from \"../path/index.js\";\nimport type { Circle } from \"./circle-type.js\";\nexport type CircularPath = Circle & Path & {\n    readonly kind: `circular`;\n};\n//# sourceMappingURL=circular-path.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Returns the distance between two circle centers.\n *\n * ```js\n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * Throws an error if either is lacking position.\n * @param a\n * @param b\n * @returns Distance\n */\nexport declare const distanceCenter: (a: CirclePositioned, b: CirclePositioned | Point) => number;\n//# sourceMappingURL=distance-center.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Returns the distance between the exterior of two circles, or between the exterior of a circle and point.\n * If `b` overlaps or is enclosed by `a`, distance is 0.\n *\n * ```js\n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * @param a\n * @param b\n */\nexport declare const distanceFromExterior: (a: CirclePositioned, b: CirclePositioned | Point) => number;\n//# sourceMappingURL=distance-from-exterior.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { CirclePositioned } from \"./circle-type.js\";\n/**\n * Yields the points making up the exterior (ie. circumference) of the circle.\n * Uses [Midpoint Circle Algorithm](http://en.wikipedia.org/wiki/Midpoint_circle_algorithm)\n *\n * @example Draw outline of circle\n * ```js\n * const circle = { x: 100, y: 100, radius: 50 }\n * for (const pt of Circles.exteriorIntegerPoints(circle)) {\n *  // Fill 1x1 pixel\n *  ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle\n */\nexport declare function exteriorIntegerPoints(circle: CirclePositioned): IterableIterator<Point>;\n//# sourceMappingURL=exterior-points.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { Circle, CirclePositioned } from './circle-type.js';\n/**\n * Throws if radius is out of range. If x,y is present, these will be validated too.\n * @param circle\n * @param parameterName\n */\nexport declare const guard: (circle: CirclePositioned | Circle, parameterName?: string) => void;\n/**\n * Throws if `circle` is not positioned or has dodgy fields\n * @param circle\n * @param parameterName\n * @returns\n */\nexport declare const guardPositioned: (circle: CirclePositioned, parameterName?: string) => void;\n/***\n * Returns true if radius, x or y are NaN\n */\nexport declare const isNaN: (a: Circle | CirclePositioned) => boolean;\n/**\n * Returns true if parameter has x,y. Does not verify if parameter is a circle or not\n *\n * ```js\n * const circleA = { radius: 5 };\n * Circles.isPositioned(circle); // false\n *\n * const circleB = { radius: 5, x: 10, y: 10 }\n * Circles.isPositioned(circle); // true\n * ```\n * @param p Circle\n * @returns\n */\nexport declare const isPositioned: (p: Circle | Point) => p is Point;\nexport declare const isCircle: (p: any) => p is Circle;\nexport declare const isCirclePositioned: (p: any) => p is CirclePositioned;\n//# sourceMappingURL=guard.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Returns all integer points contained within `circle`.\n *\n * ```js\n * const c = { x:100, y:100, radius:100 };\n * for (const pt of Circles.interiorIntegerPoints(c)) {\n *   ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle\n */\nexport declare function interiorIntegerPoints(circle: CirclePositioned): IterableIterator<Point>;\n//# sourceMappingURL=interior-points.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { CirclePositioned } from \"./circle-type.js\";\n/**\n * Computes relative position along circle perimeter\n *\n * ```js\n * const circle = { radius: 100, x: 100, y: 100 };\n *\n * // Get a point halfway around circle\n * // Yields { x, y }\n * const pt = Circles.interpolate(circle, 0.5);\n * ```\n * @param circle\n * @param t Position, 0-1\n * @returns\n */\nexport declare const interpolate: (circle: CirclePositioned, t: number) => Point;\n//# sourceMappingURL=interpolate.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\nimport type { RectPositioned } from \"../rect/index.js\";\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A circle can be checked for intersections with another CirclePositioned, Point or RectPositioned.\n *\n * Use `intersections` to find the points of intersection.\n *\n * @param a Circle\n * @param b Circle or point to test\n * @returns True if circle overlap\n */\nexport declare const isIntersecting: (a: CirclePositioned, b: CirclePositioned | Point | RectPositioned, c?: number) => boolean;\n//# sourceMappingURL=intersecting.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { CirclePositioned } from \"./circle-type.js\";\nimport type { Line } from \"../line/line-type.js\";\n/**\n * Returns the point(s) of intersection between a circle and line.\n *\n * ```js\n * const circle = { radius: 5, x: 5, y: 5 };\n * const line = { a: { x: 0, y: 0 }, b: { x: 10, y: 10 } };\n * const pts = Circles.intersectionLine(circle, line);\n * ```\n * @param circle\n * @param line\n * @returns Point(s) of intersection, or empty array\n */\nexport declare const intersectionLine: (circle: CirclePositioned, line: Line) => readonly Point[];\n/**\n *\n * Returns the points of intersection betweeen `a` and `b`.\n *\n * Returns an empty array if circles are equal, one contains the other or if they don't touch at all.\n *\n * @param a Circle\n * @param b Circle\n * @returns Points of intersection, or an empty list if there are none\n */\nexport declare const intersections: (a: CirclePositioned, b: CirclePositioned) => readonly Point[];\n//# sourceMappingURL=intersections.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Returns true if `b` is completely contained by `a`\n *\n * ```js\n * // Compare two points\n * isContainedBy(circleA, circleB);\n *\n * // Compare a circle with a point\n * isContainedBy(circleA, {x: 10, y: 20});\n *\n * // Define radius as third parameter\n * isContainedBy(circleA, {x: 10, y: 20}, 20);\n * ```\n * @param a Circle\n * @param b Circle or point to compare to\n * @param c Radius to accompany parameter b if it's a point\n * @returns\n */\nexport declare const isContainedBy: (a: CirclePositioned, b: CirclePositioned | Point, c?: number) => boolean;\n//# sourceMappingURL=is-contained-by.d.ts.map","import type { Circle, CirclePositioned } from \"./circle-type.js\";\n/**\n * Returns true if the two objects have the same values\n *\n * ```js\n * const circleA = { radius: 10, x: 5, y: 5 };\n * const circleB = { radius: 10, x: 5, y: 5 };\n *\n * circleA === circleB; // false, because identity of objects is different\n * Circles.isEqual(circleA, circleB); // true, because values are the same\n * ```\n *\n * Circles must both be positioned or not.\n * @param a\n * @param b\n * @returns\n */\nexport declare const isEqual: (a: CirclePositioned | Circle, b: CirclePositioned | Circle) => boolean;\n//# sourceMappingURL=is-equal.d.ts.map","import type { CirclePositioned, Circle } from \"./circle-type.js\";\nexport declare function multiplyScalar(a: CirclePositioned, value: number): CirclePositioned;\nexport declare function multiplyScalar(a: Circle, value: number): Circle;\n//# sourceMappingURL=multiply.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Circle, CirclePositioned } from \"./circle-type.js\";\n/**\n * Returns the nearest point on `circle`'s perimeter closest to `point`.\n *\n * ```js\n * const pt = Circles.nearest(circle, {x:10,y:10});\n * ```\n *\n * If an array of circles is provided, it will be the closest point amongst all the circles\n * @param circle Circle or array of circles\n * @param point\n * @returns Point `{ x, y }`\n */\nexport declare const nearest: (circle: CirclePositioned | readonly CirclePositioned[], point: Point) => Point;\n/**\n * Returns a point on a circle's perimeter at a specified angle in radians\n *\n * ```js\n * // Circle without position\n * const circleA = { radius: 5 };\n *\n * // Get point at angle Math.PI, passing in a origin coordinate\n * const ptA = Circles.pointOnPerimeter(circleA, Math.PI, {x: 10, y: 10 });\n *\n * // Point on circle with position\n * const circleB = { radius: 5, x: 10, y: 10};\n * const ptB = Circles.pointOnPerimeter(circleB, Math.PI);\n * ```\n * @param circle\n * @param angleRadian Angle in radians\n * @param origin or offset of calculated point. By default uses center of circle or 0,0 if undefined\n * @returns Point oo circle\n */\nexport declare const pointOnPerimeter: (circle: Circle | CirclePositioned, angleRadian: number, origin?: Point) => Point;\n/**\n * Returns circumference of `circle` (alias of {@link length})\n * @param circle\n * @returns\n */\nexport declare const circumference: (circle: Circle) => number;\n/**\n * Returns circumference of `circle` (alias of {@link circumference})\n * @param circle\n * @returns\n */\nexport declare const length: (circle: Circle) => number;\n//# sourceMappingURL=perimeter.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Circle, CirclePositioned, CircleRandomPointOpts } from \"./circle-type.js\";\n/**\n * Returns a random point within a circle.\n *\n * By default creates a uniform distribution.\n *\n * ```js\n * const pt = randomPoint({radius: 5});\n * const pt = randomPoint({radius: 5, x: 10, y: 20});\n * ```'\n *\n * Generate points with a gaussian distribution\n * ```js\n * const pt = randomPoint(circle, {\n *  randomSource: Random.gaussian\n * })\n * ```\n * @param within Circle to generate a point within\n * @param opts Options\n * @returns\n */\nexport declare const randomPoint: (within: Circle | CirclePositioned, opts?: Partial<CircleRandomPointOpts>) => Point;\n//# sourceMappingURL=random.d.ts.map","import type { CircleToSvg } from \"./circle-type.js\";\n/**\n * Creates a SVG path segment.\n * @param a Circle or radius\n * @param sweep If true, path is 'outward'\n * @param origin Origin of path. Required if first parameter is just a radius or circle is non-positioned\n * @returns\n */\nexport declare const toSvg: CircleToSvg;\n//# sourceMappingURL=svg.d.ts.map","import type { CirclePositioned } from \"./circle-type.js\";\nimport type { CircularPath } from \"./circular-path.js\";\n/**\n * Returns a `CircularPath` representation of a circle\n *\n * @param {CirclePositioned} circle\n * @returns {CircularPath}\n */\nexport declare const toPath: (circle: CirclePositioned) => CircularPath;\n//# sourceMappingURL=to-path.d.ts.map","import type { Circle, CirclePositioned } from \"./circle-type.js\";\nimport type { Point } from '../point/point-type.js';\n/**\n * Returns a positioned version of a circle.\n * If circle is already positioned, it is returned.\n * If no default position is supplied, 0,0 is used.\n * @param circle\n * @param defaultPositionOrX\n * @param y\n * @returns\n */\nexport declare const toPositioned: (circle: Circle | CirclePositioned, defaultPositionOrX?: Point | number, y?: number) => CirclePositioned;\n//# sourceMappingURL=to-positioned.d.ts.map","export * from './area.js';\nexport * from './bbox.js';\nexport * from './center.js';\nexport type * from './circle-type.js';\nexport * from './circular-path.js';\nexport * from './distance-center.js';\nexport * from './distance-from-exterior.js';\nexport * from './exterior-points.js';\nexport * from './guard.js';\nexport * from './interior-points.js';\nexport * from './interpolate.js';\nexport * from './intersecting.js';\nexport * from './intersections.js';\nexport * from './is-contained-by.js';\nexport * from './is-equal.js';\nexport * from './multiply.js';\nexport * from './perimeter.js';\nexport * from './random.js';\nexport * from './svg.js';\nexport * from './to-path.js';\nexport * from './to-positioned.js';\n//# sourceMappingURL=index.d.ts.map","import type { Line } from \"./line-type.js\";\n/**\n * Returns a parallel line to `line` at `distance`.\n *\n * ```js\n * const l = Lines.parallel(line, 10);\n * ```\n * @param line\n * @param distance\n */\nexport declare const parallel: (line: Line, distance: number) => Line;\n/**\n * Returns a point perpendicular to `line` at a specified `distance`. Use negative\n * distances for the other side of line.\n * ```\n * // Project a point 100 units away from line, at its midpoint.\n * const pt = Lines.perpendicularPoint(line, 100, 0.5);\n * ```\n * @param line Line\n * @param distance Distance from line. Use negatives to flip side\n * @param amount Relative place on line to project point from. 0 projects from A, 0.5 from the middle, 1 from B.\n */\nexport declare const perpendicularPoint: (line: Line, distance: number, amount?: number) => {\n    x: number;\n    y: number;\n};\n//# sourceMappingURL=angles.d.ts.map","import type { RectPositioned } from \"../rect/rect-types.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns a rectangle that encompasses dimension of line\n *\n * ```js\n * const rect = Lines.bbox(line);\n * ```\n */\nexport declare const bbox: (line: Line) => RectPositioned;\n//# sourceMappingURL=bbox.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns the distance of `point` to the nearest point on `line`\n *\n * ```js\n * const distance = Lines.distanceSingleLine(line, pt);\n * ```\n * @param line Line\n * @param point Target point\n * @returns\n */\nexport declare const distanceSingleLine: (line: Line, point: Point) => number;\n//# sourceMappingURL=distance-single-line.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Divides both start and end points by given x,y\n * ```js\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.divide(l, {x:2, y:4});\n * // Yields: 0.5,0.25 -> 5,2.5\n * ```\n *\n * Dividing by zero will give Infinity for that dimension.\n * @param line\n * @param point\n * @returns\n */\nexport declare const divide: (line: Line, point: Point) => Line;\n//# sourceMappingURL=divide.d.ts.map","import type { Line } from \"./line-type.js\";\n/**\n * Returns a line from four numbers [x1,y1,x2,y2].\n *\n * See {@link toFlatArray} to create an array from a line.\n *\n * ```js\n * const line = Lines.fromFlatArray(...[0, 0, 100, 100]);\n * // line is {a: { x:0, y:0 }, b: { x: 100, y: 100 } }\n * ```\n * @param array Array in the form [x1,y1,x2,y2]\n * @returns Line\n */\nexport declare const fromFlatArray: (array: readonly number[]) => Line;\n//# sourceMappingURL=from-flat-array.d.ts.map","import type { Line } from \"./line-type.js\";\n/**\n * Returns a line from a basis of coordinates (x1, y1, x2, y2)\n *\n * ```js\n * // Line from 0,1 -> 10,15\n * Lines.fromNumbers(0, 1, 10, 15);\n * ```\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @returns\n */\nexport declare const fromNumbers: (x1: number, y1: number, x2: number, y2: number) => Line;\n//# sourceMappingURL=from-numbers.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns a line from two points\n *\n * ```js\n * // Line from 0,1 to 10,15\n * const line = Lines.fromPoints( { x:0, y:1 }, { x:10, y:15 });\n * // line is: { a: { x: 0, y: 1}, b: { x: 10, y: 15 } };\n * ```\n * @param a Start point\n * @param b End point\n * @returns\n */\nexport declare const fromPoints: (a: Point, b: Point) => Line;\n//# sourceMappingURL=from-points.d.ts.map","import type { Point } from \"../point/point-type.js\";\n/**\n * Creates a line from an origin point.\n * ```js\n * // Line of length 0.2 with middle at 0.5,0.5\n * fromPivot({ x:0.5, y:0.5 }, 0.2);\n * // Same line, but on an angle\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45));\n *\n * // ...now with pivot point at 20%, rather than center\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45), 0.2);\n * ```\n *\n * Examples:\n * * Angle of 0 (deg/rad) results in a horizontal line,\n * * Angle of 90deg in a vertical line.\n * * Angle of 45deg will be angled downwards.\n *\n * @param origin Origin to pivot around\n * @param length Total length of line\n * @param angleRadian Angle of line, in radians\n * @param balance Percentage of where origin ought to be on line. Default: 0.5, meaning the middle of line\n */\nexport declare const fromPivot: (origin?: Point, length?: number, angleRadian?: number, balance?: number) => Readonly<{\n    a: Point;\n    b: Point;\n}>;\n//# sourceMappingURL=from-pivot.d.ts.map","import type { Path } from \"../path/path-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\nexport type LinePath = Line & Path & {\n    toFlatArray(): ReadonlyArray<number>;\n    toPoints(): ReadonlyArray<Point>;\n    rotate(amountRadian: number, origin: Point): LinePath;\n    sum(point: Point): LinePath;\n    divide(point: Point): LinePath;\n    multiply(point: Point): LinePath;\n    subtract(point: Point): LinePath;\n    apply(fn: (point: Point) => Point): LinePath;\n    midpoint(): Point;\n    parallel(distance: number): Line;\n    perpendicularPoint(distance: number, amount?: number): Point;\n    slope(): number;\n    withinRange(point: Point, maxRange: number): boolean;\n    isEqual(otherLine: Line): boolean;\n};\n//# sourceMappingURL=line-path-type.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { LinePath } from \"./line-path-type.js\";\n/**\n * Returns a {@link LinePath} from two points\n *\n * ```js\n * const path = Lines.fromPointsToPath(ptA, ptB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const fromPointsToPath: (a: Point, b: Point) => LinePath;\n//# sourceMappingURL=from-points-to-path.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns [a,b] points from either a line parameter, or two points.\n * It additionally applies the guardPoint function to ensure validity.\n * This supports function overloading.\n * @ignore\n * @param aOrLine\n * @param b\n * @returns\n */\nexport declare const getPointParameter: (aOrLine: Point | Line, b?: Point) => readonly [Point, Point];\n//# sourceMappingURL=get-points-parameter.d.ts.map","import type { Line, PolyLine } from \"./line-type.js\";\n/**\n * Returns true if `p` is a valid line, containing `a` and `b` Points.\n * ```js\n * Lines.isLine(l);\n * ```\n * @param p Value to check\n * @returns True if a valid line.\n */\nexport declare const isLine: (p: any) => p is Line;\n/**\n * Returns true if `p` is a {@link PolyLine}, ie. an array of {@link Line}s.\n * Validates all items in array.\n * @param p\n * @returns\n */\nexport declare const isPolyLine: (p: any) => p is PolyLine;\n/**\n * Throws an exception if:\n * * line is undefined\n * * a or b parameters are missing\n *\n * Does not validate points\n * @param line\n * @param name\n */\nexport declare const guard: (line: Line, name?: string) => void;\n//# sourceMappingURL=guard.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Calculates a point in-between `a` and `b`.\n *\n * If an interpolation amount below 0 or above 1 is given, _and_\n * `allowOverflow_ is true, a point will be returned that is extended\n * past `line`. This is useful for easing functions which might\n * briefly go past the limits.\n *\n * ```js\n * // Get {x,y} at 50% along line\n * Lines.interpolate(0.5, line);\n *\n * // Get {x,y} at 80% between point A and B\n * Lines.interpolate(0.8, ptA, ptB);\n * ```\n * @param amount Relative position, 0 being at a, 0.5 being halfway, 1 being at b\n * @param a Start\n * @param pointB End\n * @returns Point between a and b\n */\nexport declare function interpolate(amount: number, a: Point, pointB: Point, allowOverflow?: boolean): Point;\n/**\n * Calculates a point in-between `line`'s start and end points.\n *\n * ```js\n * // Get {x, y } at 50% along line\n * Lines.interpolate(0.5, line);\n * ```\n *\n * Any additional properties from `b`  are returned on the result as well.\n * @param amount 0..1\n * @param line Line\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line\n */\nexport declare function interpolate(amount: number, line: Line, allowOverflow?: boolean): Point;\n/**\n * Returns the point along a line from its start (A)\n * @param line Line\n * @param distance Distance\n * @param fromA If _true_ (default) returns from A. Use _false_ to calculate from end\n * @returns\n */\nexport declare function pointAtDistance(line: Line, distance: number, fromA?: boolean): Point;\n//# sourceMappingURL=interpolate.d.ts.map","import type { Line } from \"./line-type.js\";\n/**\n * Returns true if the lines have the same value. Note that only\n * the line start and end points are compared. So the lines might\n * be different in other properties, and `isEqual` will still return\n * true.\n *\n * ```js\n * const a = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * const b = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * a === b; // false, because they are different objects\n * Lines.isEqual(a, b); // true, because they have the same value\n * ```\n * @param {Line} a\n * @param {Line} b\n * @returns {boolean}\n */\nexport declare const isEqual: (a: Line, b: Line) => boolean;\n//# sourceMappingURL=is-equal.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { PolyLine } from \"./line-type.js\";\n/**\n * Returns an array of lines that connects provided points. Note that line is not closed.\n *\n * Eg, if points a,b,c are provided, two lines are provided: a->b and b->c.\n *\n * ```js\n * const lines = Lines.joinPointsToLines(ptA, ptB, ptC);\n * // lines is an array of, well, lines\n * ```\n * @param points\n * @returns\n */\nexport declare const joinPointsToLines: (...points: readonly Point[]) => PolyLine;\n//# sourceMappingURL=join-points-to-lines.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line, PolyLine } from \"./line-type.js\";\n/**\n * Returns the length between two points\n * ```js\n * Lines.length(ptA, ptB);\n * ```\n * @param a First point\n * @param b Second point\n * @returns\n */\nexport declare function length(a: Point, b: Point, force2d?: boolean): number;\n/**\n * Returns length of line. If a polyline (array of lines) is provided,\n * it is the sum total that is returned.\n *\n * ```js\n * Lines.length(a: {x:0, y:0}, b: {x: 100, y:100});\n * Lines.length(lines);\n * ```\n * @param line Line\n */\nexport declare function length(line: Line | PolyLine, force2d?: boolean): number;\n//# sourceMappingURL=length.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns the mid-point of a line (same as `interpolate` with an amount of 0.5)\n *\n * ```js\n * Lines.midpoint(line); // Returns {x, y}\n * ```\n * @param aOrLine\n * @param pointB\n * @returns\n */\nexport declare const midpoint: (aOrLine: Point | Line, pointB?: Point) => Point;\n//# sourceMappingURL=midpoint.d.ts.map","import type { Line } from \"./line-type.js\";\nimport { type Point } from \"../point/index.js\";\n/**\n * Multiplies start and end of line by point.x, point.y.\n *\n * ```js\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1, 1, 10, 10);\n * const ll = Lines.multiply(l, {x:2, y:3});\n * // Yields: 2,20 -> 3,30\n * ```\n * @param line\n * @param point\n * @returns\n */\nexport declare const multiply: (line: Line, point: Point) => Line;\n//# sourceMappingURL=multiply.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns the nearest point on `line` closest to `point`.\n *\n * ```js\n * const pt = Lines.nearest(line, {x:10,y:10});\n * ```\n *\n * If an array of lines is provided, it will be the closest point amongst all the lines\n * @param line Line or array of lines\n * @param point\n * @returns Point `{ x, y }`\n */\nexport declare const nearest: (line: Line | readonly Line[], point: Point) => Point;\n//# sourceMappingURL=nearest.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns the relative position of `pt` along `line`.\n * Warning: assumes `pt` is actually on `line`. Results may be bogus if not.\n * @param line\n * @param pt\n */\nexport declare const relativePosition: (line: Line, pt: Point) => number;\n//# sourceMappingURL=relative-position.d.ts.map","import type { Line } from \"./line-type.js\";\n/**\n * Reverses a line.\n * ````js\n * const a = { x: 10, y: 20 };\n * const b = { x: 100, y: 200 };\n * const line = reverse({ a, b });\n * // { a: { x: 100, y: 200 }, b: { x: 10, y: 20 } }\n * ```\n * @param line\n * @returns\n */\nexport declare function reverse(line: Line): Line;\n//# sourceMappingURL=reverse.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns a line that is rotated by `angleRad`. By default it rotates\n * around its center, but an arbitrary `origin` point can be provided.\n * If `origin` is a number, it's presumed to be a 0..1 percentage of the line.\n *\n * ```js\n * // Rotates line by 0.1 radians around point 10,10\n * const r = Lines.rotate(line, 0.1, {x:10,y:10});\n *\n * // Rotate line by 5 degrees around its center\n * const r = Lines.rotate(line, degreeToRadian(5));\n *\n * // Rotate line by 5 degres around its end point\n * const r = Lines.rotate(line, degreeToRadian(5), line.b);\n *\n * // Rotate by 90 degrees at the 80% position\n * const r = Lines.rotated = rotate(line, Math.PI / 2, 0.8);\n * ```\n * @param line Line to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of line will be used\n * @returns\n */\nexport declare const rotate: (line: Line, amountRadian?: number, origin?: Point | number) => Line;\n//# sourceMappingURL=rotate.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Subtracts both start and end points by given x,y\n * ```js\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.subtract(l, {x:2, y:4});\n * // Yields: -1,-3 -> 8,6\n * ```\n * @param line\n * @param point\n * @returns\n */\nexport declare const subtract: (line: Line, point: Point) => Line;\n//# sourceMappingURL=subtract.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Adds both start and end points by given x,y\n * ```js\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.sum(l, {x:2, y:4});\n * // Yields: 3,5 -> 12,14\n * ```\n * @param line\n * @param point\n * @returns\n */\nexport declare const sum: (line: Line, point: Point) => Line;\n//# sourceMappingURL=sum.d.ts.map","import type { LinePath } from \"./line-path-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns a path wrapper around a line instance. This is useful if there are a series\n * of operations you want to do with the same line because you don't have to pass it\n * in as an argument to each function.\n *\n * Note that the line is immutable, so a function like `sum` returns a new LinePath,\n * wrapping the result of `sum`.\n *\n * ```js\n * // Create a path\n * const l = Lines.toPath(fromNumbers(0,0,10,10));\n *\n * // Now we can use it...\n * l.length();\n *\n * // Mutate functions return a new path\n * const ll = l.sum({x:10,y:10});\n * ll.length();\n * ```\n * @param line\n * @returns\n */\nexport declare const toPath: (line: Line) => LinePath;\n//# sourceMappingURL=to-path.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Line } from \"./line-type.js\";\n/**\n * Returns a string representation of two points\n * ```js\n * console.log(Lines.toString(a, b)));\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare function toString(a: Point, b: Point): string;\n/**\n * Returns a string representation of a line\n * ```js\n * Lines.toString(line);\n * ```\n * @param line\n */\nexport declare function toString(line: Line): string;\n//# sourceMappingURL=to-string.d.ts.map","import type { Point } from '../point/point-type.js';\nimport type { Line } from './line-type.js';\nexport * from './angles.js';\nexport * from './bbox.js';\nexport * from './distance-single-line.js';\nexport * from './divide.js';\nexport * from './from-flat-array.js';\nexport * from './from-numbers.js';\nexport * from './from-points.js';\nexport * from './from-pivot.js';\nexport * from './from-points-to-path.js';\nexport * from './get-points-parameter.js';\nexport * from './guard.js';\nexport * from './interpolate.js';\nexport * from './is-equal.js';\nexport * from './join-points-to-lines.js';\nexport * from './length.js';\nexport type * from './line-path-type.js';\nexport type * from './line-type.js';\nexport * from './midpoint.js';\nexport * from './multiply.js';\nexport * from './nearest.js';\nexport * from './relative-position.js';\nexport * from './reverse.js';\nexport * from './rotate.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './to-path.js';\nexport * from './to-string.js';\nexport declare const Empty: Readonly<{\n    a: Readonly<{\n        x: 0;\n        y: 0;\n    }>;\n    b: Readonly<{\n        x: 0;\n        y: 0;\n    }>;\n}>;\nexport declare const Placeholder: Readonly<{\n    a: Readonly<{\n        x: number;\n        y: number;\n    }>;\n    b: Readonly<{\n        x: number;\n        y: number;\n    }>;\n}>;\n/**\n * Returns true if `l` is the same as Line.Empty, that is\n * the `a` and `b` points are Points.Empty.\n * @param l\n * @returns\n */\nexport declare const isEmpty: (l: Line) => boolean;\nexport declare const isPlaceholder: (l: Line) => boolean;\n/**\n * Applies `fn` to both start and end points.\n *\n * ```js\n * // Line 10,10 -> 20,20\n * const line = Lines.fromNumbers(10,10, 20,20);\n *\n * // Applies randomisation to both x and y.\n * const rand = (p) => ({\n *  x: p.x * Math.random(),\n *  y: p.y * Math.random()\n * });\n *\n * // Applies our randomisation function\n * const line2 = apply(line, rand);\n * ```\n * @param line Line\n * @param fn Function that takes a point and returns a point\n * @returns\n */\nexport declare const apply: (line: Line, fn: (p: Point) => Point) => Readonly<Line>;\n/**\n * Returns the angle in radians of a line, or two points\n * ```js\n * Lines.angleRadian(line);\n * Lines.angleRadian(ptA, ptB);\n * ```\n * @param lineOrPoint\n * @param b\n * @returns\n */\nexport declare const angleRadian: (lineOrPoint: Line | Point, b?: Point) => number;\n/**\n * Normalises start and end points by given width and height. Useful\n * for converting an absolutely-defined line to a relative one.\n *\n * ```js\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.normaliseByRect(l, 10, 10);\n * // Yields: 0.1,0.1 -> 1,1\n * ```\n * @param line\n * @param width\n * @param height\n * @returns\n */\nexport declare const normaliseByRect: (line: Line, width: number, height: number) => Line;\n/**\n * Returns true if `point` is within `maxRange` of `line`.\n *\n * ```js\n * const line = Lines.fromNumbers(0,20,20,20);\n * Lines.withinRange(line, {x:0,y:21}, 1); // True\n * ```\n * @param line\n * @param point\n * @param maxRange\n * @returns True if point is within range\n */\nexport declare const withinRange: (line: Line, point: Point, maxRange: number) => boolean;\n/**\n * Calculates [slope](https://en.wikipedia.org/wiki/Slope) of line.\n *\n * @example\n * ```js\n * Lines.slope(line);\n * Lines.slope(ptA, ptB)\n * ```\n * @param lineOrPoint Line or point. If point is provided, second point must be given too\n * @param b Second point if needed\n * @returns\n */\nexport declare const slope: (lineOrPoint: Line | Point, b?: Point) => number;\n/**\n * Scales a line from its midpoint\n *\n * @example Shorten by 50%, anchored at the midpoint\n * ```js\n * const l = {\n *  a: {x:50, y:50}, b: {x: 100, y: 90}\n * }\n * const l2 = Lines.scaleFromMidpoint(l, 0.5);\n * ```\n * @param line\n * @param factor\n */\nexport declare const scaleFromMidpoint: (line: Line, factor: number) => Line;\n/**\n * Calculates `y` where `line` intersects `x`.\n * @param line Line to extend\n * @param x Intersection of x-axis.\n */\nexport declare const pointAtX: (line: Line, x: number) => Point;\n/**\n * Returns a line extended from its `a` point by a specified distance\n *\n * ```js\n * const line = {a: {x: 0, y:0}, b: {x:10, y:10} }\n * const extended = Lines.extendFromA(line, 2);\n * ```\n * @param line\n * @param distance\n * @return Newly extended line\n */\nexport declare const extendFromA: (line: Line, distance: number) => Line;\n/**\n * Yields every integer point along `line`.\n *\n * @example Basic usage\n * ```js\n * const l = { a: {x: 0, y: 0}, b: {x: 100, y: 100} };\n * for (const p of Lines.pointsOf(l)) {\n *  // Do something with point `p`...\n * }\n * ```\n *\n * Some precision is lost as start and end\n * point is also returned as an integer.\n *\n * Uses [Bresenham's line algorithm](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)\n * @param line Line\n */\nexport declare function pointsOf(line: Line): Generator<Point>;\n/**\n * Returns the distance of `point` to the\n * nearest point on `line`.\n *\n * ```js\n * const d = Lines.distance(line, {x:10,y:10});\n * ```\n *\n * If an array of lines is provided, the shortest distance is returned.\n * @param line Line (or array of lines)\n * @param point Point to check against\n * @returns Distance\n */\nexport declare const distance: (line: Line | readonly Line[], point: Point) => number;\n/**\n * Returns an array representation of line: [a.x, a.y, b.x, b.y]\n *\n * See {@link fromFlatArray} to create a line _from_ this representation.\n *\n * ```js\n * Lines.toFlatArray(line);\n * Lines.toFlatArray(pointA, pointB);\n * ```\n * @param {Point} a\n * @param {Point} b\n * @returns {number[]}\n */\nexport declare const toFlatArray: (a: Point | Line, b: Point) => readonly number[];\n/**\n * Yields all the points of all the lines.\n *\n * ```js\n * const lines = [ ..some array of lines.. ];\n * for (const pt of Lines.asPoints(lines)) {\n *  // Yields a and then b of each point sequentially\n * }\n * ```\n * @param lines\n */\nexport declare function asPoints(lines: Iterable<Line>): Generator<Point, void, unknown>;\n/**\n * Returns an SVG description of line\n * ```\n * Lines.toSvgString(ptA, ptB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport declare const toSvgString: (a: Point, b: Point) => readonly string[];\n//# sourceMappingURL=index.d.ts.map","import type { CirclePositioned } from \"./circle/circle-type.js\";\nimport type { Path } from \"./path/path-type.js\";\nimport type { Point } from \"./point/point-type.js\";\nexport type Waypoint = CirclePositioned;\nexport type WaypointOpts = {\n    readonly maxDistanceFromLine: number;\n    readonly enforceOrder: boolean;\n};\n/**\n * Create from set of points, connected in order starting at array position 0.\n * @param waypoints\n * @param opts\n * @returns\n */\nexport declare const fromPoints: (waypoints: readonly Point[], opts?: Partial<WaypointOpts>) => Waypoints;\n/**\n * Result\n */\nexport type WaypointResult = {\n    /**\n     * Path being compared against\n     */\n    path: Path;\n    /**\n     * Index of this path in original `paths` array\n     */\n    index: number;\n    /**\n     * Nearest point on path. See also {@link distance}\n     */\n    nearest: Point;\n    /**\n     * Closest distance to path. See also {@link nearest}\n     */\n    distance: number;\n    /**\n     * Rank of this result, 0 being highest.\n     */\n    rank: number;\n    /**\n     * Relative position on this path segment\n     * 0 being start, 0.5 middle and so on.\n     */\n    positionRelative: number;\n};\n/**\n * Given point `pt`, returns a list of {@link WaypointResult}, comparing\n * this point to a set of paths.\n * ```js\n * // Init once with a set of paths\n * const w = init(paths);\n * // Now call with a point to get results\n * const results = w({ x: 10, y: 20 });\n * ```\n */\nexport type Waypoints = (pt: Point) => WaypointResult[];\n/**\n * Initialise\n *\n * Options:\n * * maxDistanceFromLine: Distances greater than this are not matched. Default 0.1\n * @param paths\n * @param opts\n * @returns\n */\nexport declare const init: (paths: readonly Path[], opts?: Partial<WaypointOpts>) => Waypoints;\n//# sourceMappingURL=waypoint.d.ts.map","import type { RandomSource } from \"@ixfx/random\";\nimport { type ShapePositioned } from \"./shape/index.js\";\nimport type { Circle, CirclePositioned } from \"./circle/circle-type.js\";\nexport type RandomOpts = {\n    readonly attempts?: number;\n    readonly randomSource?: RandomSource;\n};\n/**\n * Naive randomised circle packing.\n * [Algorithm by Taylor Hobbs](https://tylerxhobbs.com/essays/2016/a-randomized-approach-to-cicle-packing)\n */\nexport declare const random: (circles: readonly Circle[], container: ShapePositioned, opts?: RandomOpts) => CirclePositioned[];\n//# sourceMappingURL=circle-packing.d.ts.map","export * as CirclePacking from './circle-packing.js';\n//# sourceMappingURL=layout.d.ts.map","import type { Point } from './point/point-type.js';\nimport type { Path } from './path/index.js';\n/**\n * An ellipse\n */\nexport type Ellipse = {\n    readonly radiusX: number;\n    readonly radiusY: number;\n    /**\n     * Rotation, in radians\n     */\n    readonly rotation?: number;\n    readonly startAngle?: number;\n    readonly endAngle?: number;\n};\n/**\n * A {@link Ellipse} with position\n */\nexport type EllipsePositioned = Point & Ellipse;\nexport declare const fromDegrees: (radiusX: number, radiusY: number, rotationDeg?: number, startAngleDeg?: number, endAngleDeg?: number) => Ellipse;\nexport type EllipticalPath = Ellipse & Path & {\n    readonly kind: `elliptical`;\n};\n//# sourceMappingURL=ellipse.d.ts.map","import type { Point } from './point/point-type.js';\n/**\n * Convert angle in degrees to angle in radians.\n * @param angleInDegrees\n * @returns\n */\nexport declare function degreeToRadian(angleInDegrees: number): number;\n/**\n * Convert angles in degrees to angles in radians\n * @param angleInDegrees\n */\nexport declare function degreeToRadian(angleInDegrees: readonly number[]): readonly number[];\n/**\n * Inverts the angle so it points in the opposite direction of a unit circle\n * @param angleInRadians\n * @returns\n */\nexport declare function radianInvert(angleInRadians: number): number;\nexport declare function degreeToGradian(angleInDegrees: number): number;\n/**\n * Returns the gradian value converted to degrees.\n * By default it wraps, so any value 360 or greater wraps around.\n * @param angleInGradians\n * @param wrap\n * @returns\n */\nexport declare function gradianToDegree(angleInGradians: number, wrap?: boolean): number;\nexport declare function radianToGradian(angleInRadians: number): number;\nexport declare function gradianToRadian(angleInGradian: number): number;\n/**\n * Convert angle in radians to angle in degrees\n * @param angleInRadians\n * @returns\n */\nexport declare function radianToDegree(angleInRadians: number): number;\n/**\n * Convert angles in radians to angles in degrees\n * @param angleInRadians\n */\nexport declare function radianToDegree(angleInRadians: readonly number[]): readonly number[];\n/**\n * Angle from x-axis to point (ie. `Math.atan2`)\n * @param point\n * @returns\n */\nexport declare const radiansFromAxisX: (point: Point) => number;\n/**\n * Sum angles together, accounting for the 'wrap around'.\n *\n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n *\n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(Math.PI, Math.PI/2, true);\n * ```\n *\n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * {@link degreesSum} is the same, but uses degrees (0..360)\n * @param start Starting angle, in radian\n * @param amount Angle to add, in radian\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in radians\n */\nexport declare const radiansSum: (start: number, amount: number, clockwise?: boolean) => number;\n/**\n * Sum angles together, accounting for the 'wrap around'.\n *\n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n *\n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(180, 90, true);\n * ```\n *\n * {@link radiansSum} is the same, but uses radians (0..2 Pi)\n *\n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Starting angle, in degrees\n * @param amount Angle to add, in degrees\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in degrees\n */\nexport declare const degreesSum: (start: number, amount: number, clockwise?: boolean) => number;\n/**\n * Computes the angle arc between a start and end angle,\n * given in radians. It properly accounts for the wrap-around\n * values.\n *\n * ```js\n * // Between 0-90deg in clockwise direction\n * radianArc(0, Math.PI/2, true); // Yields: 3Pi/2 (270 deg)\n *\n * // In counter-clockwise direction\n * radianArc(0, Math.PI/2, false); // Yields: Math.PI/2 (90deg)\n * ```\n *\n * See {@link degreeArc} to operate in degrees.\n *\n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param start Start angle, in radians\n * @param end End angle, in radians\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in radians.\n */\nexport declare const radianArc: (start: number, end: number, clockwise?: boolean) => number;\n/**\n * Computes the angle arc between a start and end angle,\n * given in degrees. It properly accounts for the wrap-around\n * values.\n *\n * ```js\n * // Between 0-90 in clockwise direction\n * degreeArc(0, 90, true); // Yields: 270\n *\n * // In counter-clockwise direction\n * degreeArc(0, 90, false); // Yields: 90\n * ```\n *\n * See {@link radianArc} to operate in radians.\n *\n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Start angle, in degrees\n * @param end End angle, in degrees\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in degrees.\n */\nexport declare const degreeArc: (start: number, end: number, clockwise?: boolean) => number;\nexport type Angle = {\n    value: number;\n    unit: `deg` | `rad` | `turn` | `grad`;\n};\n/**\n * Parses CSS-style angle strings. By default assumes degrees.\n *\n * ```js\n * angleParse(`100`);     // { value: 100, unit: `deg` }\n * angleParse(100);       // { value: 100, unit: `deg` }\n * angleParse(`100deg`);   // { value: 100, unit: `deg` }\n *\n * // More exotic units:\n * angleParse(`100rad`);  // { value: 100, unit: `rad` }\n * angleParse(`100turn`); // { value: 100, unit: `turn` }\n * angleParse(`100grad`); // { value: 100, unit: `grad` }\n * ```\n *\n * Once parsed in this format, use {@link angleConvert} to convert to\n * a different unit.\n * @param value\n * @returns\n */\nexport declare const angleParse: (value: string | number | Angle) => Angle;\n/**\n * Converts an angle to another representation.\n * Input value is assumed degrees unless it's an {@link Angle} type of has the unit.\n *\n * These are all identical inputs: 100, `100`, `100deg`\n * ```js\n * angleConvert(100, `rad`); // Converts 100deg to radians\n * ```\n *\n * Other units can be used for string input: `2turn`, `1grad`, `2rad`.\n * ```js\n * angleConvert(`2rad`, `deg`); // Converts 2radians to degrees\n * ```\n *\n * Can also use an object input:\n * ```js\n * angleConvert({ value: 10, unit: `deg`}, `rad`);\n * ```\n * @param angleOrDegrees\n * @param destination\n * @returns\n */\nexport declare const angleConvert: (angleOrDegrees: Angle | number | string, destination: Angle[`unit`]) => Angle;\n/**\n * Converts 'turns' to degrees. By defaults wraps the value, so\n * turn value of 1 or 2 equal 0deg instead of 360 or 720deg.\n * @param turns\n * @param wrap\n * @returns\n */\nexport declare const turnToDegree: (turns: number, wrap?: boolean) => number;\nexport declare const turnToRadian: (turns: number) => number;\nexport declare const degreeToTurn: (degrees: number) => number;\nexport declare const radianToTurn: (radians: number) => number;\n//# sourceMappingURL=angles.d.ts.map","import type { Point } from \"./point/point-type.js\";\n/**\n * Simplifies a curve by dropping points based on shortest distance.\n *\n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n *\n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n *\n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n *\n * @param points\n * @param epsilon\n * @returns\n */\nexport declare const rdpShortestDistance: (points: Array<Point>, epsilon?: number) => Array<Point>;\n/**\n * Simplifies a curve by dropping points based on perpendicular distance\n *\n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n *\n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n *\n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n *\n * @param points\n * @param epsilon\n * @returns\n */\nexport declare const rdpPerpendicularDistance: (points: Array<Point>, epsilon?: number) => Array<Point>;\n//# sourceMappingURL=curve-simplification.d.ts.map","import { type TraversableTree } from '@ixfx/collections';\nimport type { Point } from './point/point-type.js';\nimport type { ShapePositioned } from './shape/index.js';\nimport type { RectPositioned } from './rect/rect-types.js';\n/**\n * Options for quad tree\n */\nexport type QuadTreeOpts = {\n    /**\n     * Maximum items per node\n     */\n    readonly maxItems: number;\n    /**\n     * Maximum level of sub-division\n     */\n    readonly maxLevels: number;\n};\n/**\n * Direction\n */\nexport declare enum Direction {\n    Nw = 0,\n    Ne = 1,\n    Sw = 2,\n    Se = 3\n}\n/**\n * A Point or ShapePositioned\n */\nexport type QuadTreeItem = Point | ShapePositioned;\n/**\n * Creates a QuadTreeNode\n * @param bounds Bounds of region\n * @param initialData Initial items to place in quad tree\n * @param opts Options\n * @returns New quad tree\n */\nexport declare const quadTree: (bounds: RectPositioned, initialData?: readonly QuadTreeItem[], opts?: Partial<QuadTreeOpts>) => QuadTreeNode;\n/**\n * QuadTreeNode. The values of the node is an array of {@link QuadTreeItem}.\n *\n * To create, you probably want the {@link quadTree} function.\n *\n */\nexport declare class QuadTreeNode implements TraversableTree<QuadTreeItem[]> {\n    #private;\n    readonly boundary: RectPositioned;\n    readonly level: number;\n    readonly opts: QuadTreeOpts;\n    /**\n     * Constructor\n     * @param boundary\n     * @param level\n     * @param opts\n     */\n    constructor(parent: QuadTreeNode | undefined, boundary: RectPositioned, level: number, opts: QuadTreeOpts);\n    getLengthChildren(): number;\n    parents(): IterableIterator<QuadTreeNode>;\n    getParent(): QuadTreeNode | undefined;\n    /**\n     * Iterates over immediate children\n     */\n    children(): IterableIterator<QuadTreeNode>;\n    /**\n     * Array of QuadTreeItem\n     * @returns\n     */\n    getValue(): QuadTreeItem[];\n    getIdentity(): this;\n    /**\n     * Get a descendant node in a given direction\n     * @param d\n     * @returns\n     */\n    direction(d: Direction): QuadTreeNode | undefined;\n    /**\n     * Add an item to the quadtree\n     * @param p\n     * @returns False if item is outside of boundary, True if item was added\n     */\n    add(p: QuadTreeItem): boolean;\n    /**\n     * Returns true if point is inside node's boundary\n     * @param p\n     * @returns\n     */\n    couldHold(p: Point): boolean;\n}\n//# sourceMappingURL=quad-tree.d.ts.map","import type { Point } from './point/point-type.js';\nimport type { Rect } from './rect/index.js';\n/**\n * A scale function that takes an input value to scale.\n * Input can be in the form of `{ x, y }` or two number parameters.\n *\n * ```js\n * scale(10, 20);\n * scale({ x:10, y:20 });\n * ```\n *\n * Output range can be specified as a `{ width, height }` or two number parameters.\n * If omitted, the default range\n * is used.\n *\n * ```js\n * // Scale 10,20 with range w:800 h:600\n * scale(10, 20, 800, 600);\n * scale({x:10, y:20}, 800, 600);\n * scale({x:10, y:20}, {width: 800, height: 600});\n * ```\n */\nexport type Scaler = (a: number | Point, b?: number | Rect, c?: number | Rect, d?: number) => Point;\n/**\n * A scaler than can convert to a from an output range\n */\nexport type ScalerCombined = {\n    /**\n     * Relative to absolute coordinates\n     */\n    readonly abs: Scaler;\n    /**\n     * Absolute to relative coordintes\n     */\n    readonly rel: Scaler;\n    readonly width: number;\n    readonly height: number;\n    computeScale(): Point;\n};\nexport type ScaleBy = `both` | `min` | `max` | `width` | `height`;\n/**\n * Returns a set of scaler functions, to convert to and from ranges.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`, {width:window.innerWidth, height:window.innerHeight});\n * // Assuming screen of 800x400...\n * scaler.abs(400,200);          // Yields { x:0.5, y:0.5 }\n * scaler.abs({ x:400, y:200 }); // Yields { x:0.5, y:0.5 }\n *\n * scaler.rel(0.5, 0.5);         // Yields: { x:400, y:200 }\n * scaler.rel({ x:0.5, y:0.5 }); // Yields: { x:400, y:200 }\n * ```\n *\n * If no default range is provided, it must be given each time the scale function is used.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`);\n *\n * scaler.abs(400, 200, 800, 400);\n * scaler.abs(400, 200, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, 800, 400);\n * // All are the same, yielding { x:0.5, y:0.5 }\n *\n * scaler.abs(400, 200); // Throws an exception because there is no scale\n * ```\n * @param scaleBy Dimension to scale by\n * @param defaultRect Default range\n * @returns\n */\nexport declare const scaler: (scaleBy?: ScaleBy, defaultRect?: Rect) => ScalerCombined;\n//# sourceMappingURL=scaler.d.ts.map","import type { Line } from './line/line-type.js';\nimport type { Point } from './point/point-type.js';\nimport * as Polar from './polar/index.js';\nexport type Vector = Point | Polar.Coord;\nexport declare const fromRadians: (radians: number) => Readonly<{\n    x: number;\n    y: number;\n}>;\nexport declare const toRadians: (point: Point) => number;\n/**\n * Create a vector from a point\n *\n * If `unipolar` normalisation is used, direction will be fixed to 0..2\n * if `bipolar` normalisation is used, direction will be fixed to -...\n * @param pt Point\n * @param angleNormalisation Technique to normalise angle\n * @param origin Origin to calculate vector from or 0,0 if left empty\n * @returns\n */\nexport declare const fromPointPolar: (pt: Point, angleNormalisation?: `` | `unipolar` | `bipolar`, origin?: Point) => Polar.Coord;\n/**\n * Returns a Cartesian-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport declare const fromLineCartesian: (line: Line) => Point;\n/**\n * Returns a polar-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport declare const fromLinePolar: (line: Line) => Polar.Coord;\n/**\n * Returns the normalised vector (aka unit vector). This is where\n * direction is kept, but magnitude set to 1. This then just\n * suggests direction.\n * @param v\n * @returns\n */\nexport declare const normalise: (v: Vector) => Vector;\nexport declare const quadrantOffsetAngle: (p: Point) => number;\n/**\n * Converts a vector to a polar coordinate. If the provided\n * value is already Polar, it is returned.\n * @param v\n * @param origin\n * @returns Polar vector\n */\nexport declare const toPolar: (v: Vector, origin?: {\n    readonly x: 0;\n    readonly y: 0;\n}) => Polar.Coord;\n/**\n * Converts a Vector to a Cartesian coordinate. If the provided\n * value is already Cartesian, it is returned.\n * @param v\n * @returns Cartestian vector\n */\nexport declare const toCartesian: (v: Vector) => Point;\n/**\n * Return a human-friendly representation of vector\n * @param v\n * @param digits\n * @returns\n */\nexport declare const toString: (v: Vector, digits?: number) => string;\n/**\n * Calculate dot product of a vector\n * @param a\n * @param b\n * @returns\n */\nexport declare const dotProduct: (a: Vector, b: Vector) => number;\n/**\n * Clamps the magnitude of a vector\n * @param v Vector to clamp\n * @param max Maximum magnitude\n * @param min Minium magnitude\n * @returns\n */\nexport declare const clampMagnitude: (v: Vector, max?: number, min?: number) => Point | Polar.Coord;\n/**\n * Returns `a + b`.\n *\n * Vector is returned in the same type as `a`.\n * @param a\n * @param b\n * @returns\n */\nexport declare const sum: (a: Vector, b: Vector) => Point | Polar.Coord;\n/**\n * Returns `a - b`.\n *\n * Vector is returned in the same type as `a`\n * @param a\n * @param b\n */\nexport declare const subtract: (a: Vector, b: Vector) => Point | Polar.Coord;\n/**\n * Returns `a * b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport declare const multiply: (a: Vector, b: Vector) => Point | Polar.Coord;\n/**\n * Returns `a / b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport declare const divide: (a: Vector, b: Vector) => Point | Polar.Coord;\n//# sourceMappingURL=vector.d.ts.map","import type { Point, Point3d } from './point/point-type.js';\nimport type { Circle, CirclePositioned } from './circle/circle-type.js';\nimport type { Sphere } from './shape/index.js';\n/**\n * Options for a Vogel spiral\n */\nexport type VogelSpiralOpts = {\n    /**\n     * Upper limit of points to produce.\n     * By default, 5000.\n     */\n    readonly maxPoints?: number;\n    /**\n     * Density value (0..1) which determines spacing of points.\n     * This is useful because it scales with whatever circle radius is given\n     * Use this parameter OR the `spacing` parameter.\n     */\n    readonly density?: number;\n    /**\n     * Spacing between points.\n     * Use this option OR the density value.\n     */\n    readonly spacing?: number;\n    /**\n     * Rotation offset to apply, in radians. 0 by default\n     */\n    readonly rotation?: number;\n};\n/**\n * Generates points on a Vogel spiral - a sunflower-like arrangement of points.\n *\n * @example With no arguments, assumes a unit circle\n * ```js\n * for (const pt of circleVogelSpiral()) {\n *  // Generate points on a unit circle, with 95% density\n * }\n * ```\n *\n *\n * @example Specifying a circle and options\n * ```js\n * const circle = { radius: 100, x: 100, y: 100 };\n * const opts = {\n *  maxPoints: 50,\n *  density: 0.99\n * };\n * for (const pt of circleVogelSpiral(circle, opts)) {\n *  // Do something with point...\n * }\n * ```\n *\n * @example Array format\n * ```js\n * const ptsArray = [...circleVogelSpiral(circle, opts)];\n * ```\n * @param circle\n * @param opts\n */\nexport declare function circleVogelSpiral(circle?: Circle, opts?: VogelSpiralOpts): IterableIterator<Point>;\nexport type CircleRingsOpts = {\n    readonly rings?: number;\n    /**\n     * Rotation offset, in radians\n     */\n    readonly rotation?: number;\n};\n/**\n * Generates points spaced out on the given number of rings.\n *\n * Get points as array\n * ```js\n * const circle = { radius: 5, x: 100, y: 100 };\n * const opts = { rings: 5 };\n * const points = [...circleRings(circle, rings)];\n * ```\n *\n * Or iterate over them\n * ```js\n * for (const point of circleRings(circle, opts)) {\n * }\n * ```\n * Source: http://www.holoborodko.com/pavel/2015/07/23/generating-equidistant-points-on-unit-disk/#more-3453\n * @param circle\n */\nexport declare function circleRings(circle?: Circle | CirclePositioned, opts?: CircleRingsOpts): IterableIterator<Point>;\n/**\n * Fibonacci sphere algorithm. Generates points\n * distributed on a sphere.\n *\n * @example Generate points of a unit sphere\n * ```js\n * for (const pt of sphereFibonacci(100)) {\n *  // pt.x, pt.y, pt.z\n * }\n * ```\n *\n * @example Generate points into an array\n * ```js\n * const sphere = { radius: 10, x: 10, y: 200 }\n * const pts = [...sphereFibonacci(100, 0, sphere)];\n * ```\n *\n * Source: https://codepen.io/elchininet/pen/vXeRyL\n *\n * @param samples\n * @returns\n */\nexport declare function sphereFibonacci(samples?: number, rotationRadians?: number, sphere?: Sphere): IterableIterator<Point3d>;\n//# sourceMappingURL=surface-points.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Return the three interior angles of the triangle, in radians.\n * @param t\n * @returns\n */\nexport declare const angles: (t: Triangle) => ReadonlyArray<number>;\n/**\n * Returns the three interior angles of the triangle, in degrees\n * @param t\n * @returns\n */\nexport declare const anglesDegrees: (t: Triangle) => ReadonlyArray<number>;\n//# sourceMappingURL=angles.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Calculates the area of a triangle\n * @param t\n * @returns\n */\nexport declare const area: (t: Triangle) => number;\n//# sourceMappingURL=area.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { BarycentricCoord, Triangle } from \"./triangle-type.js\";\n/**\n * Returns the [Barycentric coordinate](https://en.wikipedia.org/wiki/Barycentric_coordinate_system) of a point within a triangle\n *\n * @param t\n * @param a\n * @param b\n * @returns\n */\nexport declare const barycentricCoord: (t: Triangle, a: Point | number, b?: number) => BarycentricCoord;\n/**\n * Convert Barycentric coordinate to Cartesian\n * @param t\n * @param bc\n * @returns\n */\nexport declare const barycentricToCartestian: (t: Triangle, bc: BarycentricCoord) => Point;\n//# sourceMappingURL=barycentric.d.ts.map","import type { RectPositioned } from \"../rect/rect-types.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns the bounding box that encloses the triangle.\n * @param t\n * @param inflation If specified, box will be inflated by this much. Default: 0.\n * @returns\n */\nexport declare const bbox: (t: Triangle, inflation?: number) => RectPositioned;\n//# sourceMappingURL=bbox.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns simple centroid of triangle\n * @param t\n * @returns\n */\nexport declare const centroid: (t: Triangle) => Point;\n//# sourceMappingURL=centroid.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns the corners (vertices) of the triangle as an array of points\n * @param t\n * @returns Array of length three\n */\nexport declare const corners: (t: Triangle) => ReadonlyArray<Point>;\n//# sourceMappingURL=corners.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * A triangle consisting of three empty points (Points.Empty)\n */\nexport declare const Empty: Readonly<{\n    a: {\n        x: number;\n        y: number;\n    };\n    b: {\n        x: number;\n        y: number;\n    };\n    c: {\n        x: number;\n        y: number;\n    };\n}>;\n/**\n * A triangle consisting of three placeholder points (Points.Placeholder)\n */\nexport declare const Placeholder: Readonly<{\n    a: {\n        x: number;\n        y: number;\n    };\n    b: {\n        x: number;\n        y: number;\n    };\n    c: {\n        x: number;\n        y: number;\n    };\n}>;\n/**\n * Returns a triangle anchored at `origin` with a given `length` and `angleRadian`.\n * The origin will be point `b` of the triangle, and the angle will be the angle for b.\n * @param origin Origin\n * @param length Length\n * @param angleRadian Angle\n * @returns\n */\nexport declare const equilateralFromVertex: (origin?: Point, length?: number, angleRadian?: number) => Triangle;\n//# sourceMappingURL=create.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\nimport type { PolyLine } from \"../line/line-type.js\";\n/**\n * Returns the edges (ie sides) of the triangle as an array of lines\n * @param t\n * @returns Array of length three\n */\nexport declare const edges: (t: Triangle) => PolyLine;\n//# sourceMappingURL=edges.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\n/**\n * Returns an equilateral triangle centered at the origin.\n *\n * ```js\n * // Create a triangle at 100,100 with radius of 60\n * const tri = fromRadius({x:100,y:100}, 60);\n *\n * // Triangle with point A upwards, B to the right, C to the left\n * constr tri2 = fromRadius({x:100,y:100}, 60, {initialAngleRadian: -Math.PI / 2});\n * ```\n *\n *\n * @param origin Origin\n * @param radius Radius of triangle\n * @param opts Options\n */\nexport declare const fromRadius: (origin: Point, radius: number, opts?: {\n    readonly initialAngleRadian?: number;\n}) => Triangle;\n/**\n * Returns a triangle from a set of coordinates in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param coords\n * @returns\n */\nexport declare const fromFlatArray: (coords: readonly number[]) => Triangle;\n/**\n * Returns a triangle from an array of three points\n * @param points\n * @returns\n */\nexport declare const fromPoints: (points: readonly Point[]) => Triangle;\n//# sourceMappingURL=from.d.ts.map","import type { CirclePositioned } from \"../circle/circle-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns the largest circle enclosed by triangle `t`.\n * @param t\n */\nexport declare const innerCircle: (t: Triangle) => CirclePositioned;\n//# sourceMappingURL=inner-circle.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns true if point is within or on the boundary of triangle\n * @param t\n * @param a\n * @param b\n */\nexport declare const intersectsPoint: (t: Triangle, a: Point | number, b?: number) => boolean;\n//# sourceMappingURL=intersects.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns true if it is an equilateral triangle\n * @param t\n * @returns\n */\nexport declare const isEquilateral: (t: Triangle) => boolean;\n/**\n * Returns true if it is an isosceles triangle\n * @param t\n * @returns\n */\nexport declare const isIsosceles: (t: Triangle) => boolean;\n/**\n * Returns true if at least one interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport declare const isRightAngle: (t: Triangle) => boolean;\n/**\n * Returns true if triangle is oblique: No interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport declare const isOblique: (t: Triangle) => boolean;\n/**\n * Returns true if triangle is actue: all interior angles less than 90 degrees\n * @param t\n * @returns\n */\nexport declare const isAcute: (t: Triangle) => boolean;\n/**\n * Returns true if triangle is obtuse: at least one interior angle is greater than 90 degrees\n * @param t\n * @returns\n */\nexport declare const isObtuse: (t: Triangle) => boolean;\n//# sourceMappingURL=kinds.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns the lengths of the triangle sides\n * @param t\n * @returns Array of length three\n */\nexport declare const lengths: (t: Triangle) => ReadonlyArray<number>;\n//# sourceMappingURL=lengths.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Applies `fn` to each of a triangle's corner points, returning the result.\n *\n * @example Add some random to the x of each corner\n * ```\n * const t = apply(tri, p => {\n *  const r = 10;\n *  return {\n *    x: p.x + (Math.random()*r*2) - r,\n *    y: p.y\n *  }\n * });\n * ```\n * @param t\n * @param fn\n * @returns\n */\nexport declare const apply: (t: Triangle, fn: (p: Point, label?: string) => Point) => Readonly<Triangle>;\n//# sourceMappingURL=math.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\nimport type { CirclePositioned } from '../circle/circle-type.js';\n/**\n * Returns the largest circle touching the corners of triangle `t`.\n * @param t\n * @returns\n */\nexport declare const outerCircle: (t: Triangle) => CirclePositioned;\n//# sourceMappingURL=outer-circle.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Calculates perimeter of a triangle\n * @param t\n * @returns\n */\nexport declare const perimeter: (t: Triangle) => number;\n//# sourceMappingURL=perimeter.d.ts.map","import type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns a triangle that is rotated by `angleRad`. By default it rotates\n * around its center but an arbitrary `origin` point can be provided.\n *\n * ```js\n * let triangle = Triangles.fromPoints([a, b, c]);\n *\n * // Rotate triangle by 5 degrees\n * triangle = Triangles.rotate(triangle, degreeToRadian(5));\n *\n * // Rotate by 90 degrees\n * triangle = Triangles.rotate(triangle, Math.PI / 2);\n * ```\n * @param triangle Triangle to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of triangle will be used\n * @returns A new triangle\n */\nexport declare const rotate: (triangle: Triangle, amountRadian?: number, origin?: Point) => Triangle;\n/**\n * Rotates the vertices of the triangle around one point (by default, `b`), returning\n * as a new object.\n *\n * ```js\n * let triangle = Triangles.fromPoints([a, b, c]);\n * triangle = Triangles.rotateByVertex(triangle, Math.Pi, `a`);\n * ```\n * @param triangle Triangle\n * @param amountRadian Angle to rotate by\n * @param vertex Name of vertex: a, b or c.\n * @returns A new triangle\n */\nexport declare const rotateByVertex: (triangle: Triangle, amountRadian: number, vertex?: `a` | `b` | `c`) => Triangle;\n//# sourceMappingURL=rotate.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Returns the coordinates of triangle in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param t\n * @returns\n */\nexport declare const toFlatArray: (t: Triangle) => readonly number[];\n//# sourceMappingURL=to.d.ts.map","import type { Triangle } from \"./triangle-type.js\";\n/**\n * Throws an exception if the triangle is invalid\n * @param t\n * @param name\n */\nexport declare const guard: (t: Triangle, name?: string) => void;\n/**\n * Returns true if the parameter appears to be a valid triangle\n * @param p\n * @returns\n */\nexport declare const isTriangle: (p: unknown) => p is Triangle;\n/**\n * Returns true if triangle is empty\n * @param t\n * @returns\n */\nexport declare const isEmpty: (t: Triangle) => boolean;\n/**\n * Returns true if triangle is a placeholder\n * @param t\n * @returns\n */\nexport declare const isPlaceholder: (t: Triangle) => boolean;\n/**\n * Returns true if the two parameters have equal values\n * @param a\n * @param b\n * @returns\n */\nexport declare const isEqual: (a: Triangle, b: Triangle) => boolean;\n//# sourceMappingURL=guard.d.ts.map","import type { Circle } from \"../circle/circle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nexport type TriangleEquilateral = {\n    readonly length: number;\n} | number;\n/**\n * Returns a positioned `Triangle` from an equilateral triangle definition.\n * By default the rotation is such that point `a` and `c` are lying on the horizontal,\n * and `b` is the upward-facing tip.\n *\n * Default is a triangle pointing upwards with b at the top, c to the left and b to right on the baseline.\n *\n * Example rotation values in radians:\n * *  0: a and c on vertical, b at the tip\n * *  Math.PI: `c`and `a` are on vertical, with `b` at the tip.\n * *  Math.PI/2: `c` and `a` are on horizontal, `c` to the left. `b` at the bottom.\n * *  Math.PI*1.5: `c` and `a` are on horizontal, `c` to the right. `b` at the top. (default)\n * @param t\n * @param origin\n * @param rotationRad\n * @returns\n */\nexport declare const fromCenter: (t: TriangleEquilateral, origin?: Point, rotationRad?: number) => Triangle;\n/**\n * Calculate center from the given point A\n * @param t\n * @param ptA\n * @returns\n */\nexport declare const centerFromA: (t: TriangleEquilateral, ptA?: Point) => Point;\n/**\n * Calculate center from the given point B\n * @param t\n * @param ptB\n * @returns\n */\nexport declare const centerFromB: (t: TriangleEquilateral, ptB?: Point) => Point;\n/**\n * Calculate center from the given point C\n * @param t\n * @param ptC\n * @returns\n */\nexport declare const centerFromC: (t: TriangleEquilateral, ptC?: Point) => Point;\n/**\n * Returns the height (or rise) of an equilateral triangle.\n * Ie. from one vertex to the perpendicular edge.\n * (line marked x in the diagram below)\n *\n * ```\n *      .\n *     .x .\n *    . x  .\n *   .  x   .\n *  ..........\n * ```\n * @param t\n */\nexport declare const height: (t: TriangleEquilateral) => number;\nexport declare const perimeter: (t: TriangleEquilateral) => number;\nexport declare const area: (t: TriangleEquilateral) => number;\n/**\n * Circle that encompasses all points of triangle\n * @param t\n */\nexport declare const circumcircle: (t: TriangleEquilateral) => Circle;\n/**\n * Circle that is inside the edges of the triangle\n * @param t\n * @returns\n */\nexport declare const incircle: (t: TriangleEquilateral) => Circle;\n//# sourceMappingURL=equilateral.d.ts.map","import type { Circle } from \"../circle/circle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nexport type Right = {\n    readonly adjacent?: number;\n    readonly hypotenuse?: number;\n    readonly opposite?: number;\n};\nexport type DefinedRight = {\n    readonly adjacent: number;\n    readonly hypotenuse: number;\n    readonly opposite: number;\n};\n/**\n * Returns a positioned triangle from a point for A.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport declare const fromA: (t: Right, origin?: Point) => Triangle;\n/**\n * Returns a positioned triangle from a point for B.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport declare const fromB: (t: Right, origin?: Point) => Triangle;\n/**\n * Returns a positioned triangle from a point for C.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n *\n *\n * ```js\n * // Triangle pointing up to 0,0 with sides of 15\n * Triangles.Right.fromC({ adjacent: 15, opposite:15 }, { x: 0, y: 0 });\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport declare const fromC: (t: Right, origin?: Point) => Triangle;\n/**\n * Returns a right triangle with all lengths defined.\n * At least two lengths must already exist\n * @param t\n * @returns\n */\nexport declare const resolveLengths: (t: Right) => DefinedRight;\n/**\n * Height of right-triangle\n * @param t\n * @returns\n */\nexport declare const height: (t: Right) => number;\n/**\n * Returns the lengths of the hypotenuse split into p and q segments.\n * In other words, if one makes a line from the right-angle vertex down to hypotenuse.\n *\n * [See here](https://rechneronline.de/pi/right-triangle.php)\n * @param t\n * @returns\n */\nexport declare const hypotenuseSegments: (t: Right) => readonly [p: number, q: number];\nexport declare const perimeter: (t: Right) => number;\nexport declare const area: (t: Right) => number;\n/**\n * Angle (in radians) between hypotenuse and adjacent edge\n * @param t\n * @returns\n */\nexport declare const angleAtPointA: (t: Right) => number;\n/**\n * Angle (in radians) between opposite edge and hypotenuse\n * @param t\n * @returns\n */\nexport declare const angleAtPointB: (t: Right) => number;\n/**\n * Returns the median line lengths a, b and c in an array.\n *\n * The median lines are the lines from each vertex to the center.\n *\n * @param t\n * @returns\n */\nexport declare const medians: (t: Right) => readonly [a: number, b: number, c: number];\n/**\n * The circle which passes through the points of the triangle\n * @param t\n * @returns\n */\nexport declare const circumcircle: (t: Right) => Circle;\n/**\n * Circle enclosed by triangle\n * @param t\n * @returns\n */\nexport declare const incircle: (t: Right) => Circle;\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param adjacent\n * @returns\n */\nexport declare const oppositeFromAdjacent: (angleRad: number, adjacent: number) => number;\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param hypotenuse\n * @returns\n */\nexport declare const oppositeFromHypotenuse: (angleRad: number, hypotenuse: number) => number;\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param hypotenuse\n * @returns\n */\nexport declare const adjacentFromHypotenuse: (angleRadian: number, hypotenuse: number) => number;\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport declare const adjacentFromOpposite: (angleRadian: number, opposite: number) => number;\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport declare const hypotenuseFromOpposite: (angleRadian: number, opposite: number) => number;\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param adjacent\n * @returns\n */\nexport declare const hypotenuseFromAdjacent: (angleRadian: number, adjacent: number) => number;\n//# sourceMappingURL=right.d.ts.map","import type { Circle } from \"../circle/circle-type.js\";\nimport type { Point } from \"../point/point-type.js\";\nimport type { Triangle } from \"./triangle-type.js\";\nexport type Isosceles = {\n    readonly legs: number;\n    readonly base: number;\n};\nexport declare const baseAngle: (t: Isosceles) => number;\nexport declare const apexAngle: (t: Isosceles) => number;\nexport declare const height: (t: Isosceles) => number;\nexport declare const legHeights: (t: Isosceles) => number;\nexport declare const perimeter: (t: Isosceles) => number;\nexport declare const area: (t: Isosceles) => number;\nexport declare const circumcircle: (t: Isosceles) => Circle;\nexport declare const incircle: (t: Isosceles) => Circle;\nexport declare const medians: (t: Isosceles) => readonly [a: number, b: number, c: number];\n/**\n * Returns a positioned `Triangle` based on a center origin.\n * Center is determined by the intesecting of the medians.\n *\n * See: https://rechneronline.de/pi/isosceles-triangle.php\n * @param t\n * @param origin\n * @returns\n */\nexport declare const fromCenter: (t: Isosceles, origin?: Point) => Triangle;\nexport declare const fromA: (t: Isosceles, origin?: Point) => Triangle;\nexport declare const fromB: (t: Isosceles, origin?: Point) => Triangle;\nexport declare const fromC: (t: Isosceles, origin?: Point) => Triangle;\n//# sourceMappingURL=isosceles.d.ts.map","export type * from './triangle-type.js';\nexport * from './angles.js';\nexport * from './area.js';\nexport * from './barycentric.js';\nexport * from './bbox.js';\nexport * from './centroid.js';\nexport * from './corners.js';\nexport * from './create.js';\nexport * from './edges.js';\nexport * from './from.js';\nexport * from './inner-circle.js';\nexport * from './intersects.js';\nexport * from './kinds.js';\nexport * from './lengths.js';\nexport * from './math.js';\nexport * from './outer-circle.js';\nexport * from './perimeter.js';\nexport * from './rotate.js';\nexport * from './to.js';\nexport * from './guard.js';\n/**\n * Functions for working with equilateral triangles, defined by length\n */\nexport * as Equilateral from './equilateral.js';\n/**\n * Functions for working with right-angled triangles, defined by two of three edges\n */\nexport * as Right from './right.js';\nexport * as Isosceles from './isosceles.js';\n/**\n* Triangle.\n*\n* Helpers for creating:\n*  - {@link Triangles.fromFlatArray}: Create from [x1, y1, x2, y2, x3, y3]\n*  - {@link Triangles.fromPoints}: Create from three `{x,y}` sets\n*  - {@link Triangles.fromRadius}: Equilateral triangle of a given radius and center\n*/\n//# sourceMappingURL=index.d.ts.map","/**\n * Arcs are a angle-limited circle. Essentially describing a wedge.\n */\nexport * as Arcs from './arc/index.js';\nexport type * from './arc/arc-type.js';\nexport * as Beziers from './bezier/index.js';\nexport type * from './bezier/bezier-type.js';\n/**\n * A circle is defined as having a radius\n */\nexport * as Circles from './circle/index.js';\nexport type * from './circle/circle-type.js';\nexport * as Grids from './grid/index.js';\nexport type * from './grid/types.js';\nexport * as Lines from './line/index.js';\nexport type * from './line/line-path-type.js';\nexport type * from './line/line-type.js';\nexport * as Paths from './path/index.js';\nexport type * from './path/path-type.js';\nexport * as Points from './point/index.js';\nexport type * from './point/point-type.js';\nexport type * from './point/point-relation-types.js';\n/**\n * Work with Polar coordinates.\n * A {@link Polar.Coord} is just `{ angleRadians:number, distance: number }`.\n *\n * Conversion: {@link toCartesian}, {@link fromCartesian}, {@link toString}\n *\n * Math: {@link divide}, {@link invert}, {@link multiply}, {@link dotProduct}\n *\n * Geometric manipulations: {@link rotate}, {@link rotateDegrees}\n *\n * Cleaning: {@link clampMagnitude}, {@link normalise}\n *\n * Debugging: {@link toString}\n *\n * Comparisons: {@link isAntiParallel}, {@link isOpposite}, {@link isParallel}, {@link isPolarCoord}\n */\nexport * as Polar from './polar/index.js';\nexport type * from './polar/types.js';\nexport * as Rects from './rect/index.js';\nexport type * from './rect/rect-types.js';\n/**\n * Generate a few basic geometric shapes\n * Overview:\n * * {@link arrow}\n * * {@link starburst}\n */\nexport * as Shapes from './shape/index.js';\nexport type * from './shape/shape-type.js';\nexport * as Waypoints from './waypoint.js';\nexport * as Layouts from './layout.js';\nexport * from './point/point-tracker.js';\nexport * as Compound from './path/compound-path.js';\nexport * as Ellipses from './ellipse.js';\nexport * from './angles.js';\nexport * as CurveSimplification from './curve-simplification.js';\n/**\n * Quad tree is a datastructure for efficiently determining whether\n * a point/shape is at a location\n * - {@link quadTree}: Create a quad tree\n */\nexport * as QuadTree from './quad-tree.js';\nexport * from './scaler.js';\n/**\n * Helper functions for working with vectors, which can either be a {@link Points.Point} or Polar {@link Polar.Coord}.\n * While most of the functionality is provided in either of those modules, the Vector module lets you cleanly\n * interoperate between these two coordinates.\n */\nexport * as Vectors from './vector.js';\n/**\n * Functions for producing points within a shape.\n * Useful for creating patterns.\n *\n * Overview:\n * * {@link sphereFibonacci}: Generate points on a sphere\n * * {@link circleVogelSpiral}: Generate a sunflower-esque pattern of points in a circle\n */\nexport * as SurfacePoints from './surface-points.js';\n/**\n * Triangle processing.\n *\n * Helpers for creating:\n * - {@link Triangles.fromFlatArray}: Create from `[ aX, aY, bX, bY, cX, cY ]`\n * - {@link Triangles.fromPoints}: Create from an array of three Points.\n * - {@link Triangles.fromRadius}: Equilateral triangle of a given radius and center\n *\n * There are sub-modules for dealing with particular triangles:\n * - {@link Triangles.Equilateral}: Equilateral triangls\n * - {@link Triangles.Right}: Right-angled triangles\n * - {@link Triangles.Isosceles}: Iscosceles triangles\n *\n * Calculations\n * - {@link angles}: Internal angles in radians. {@link anglesDegrees} for degrees.\n * - {@link area}: Area of triangle\n * - {@link bbox}: Bounding box\n * - {@link centroid}: Centroid of triangle\n * - {@link perimeter}: Calculate perimeter\n * - {@link lengths}: Return array lengths of triangle's edges\n * - {@link rotate}, {@link rotateByVertex}\n *\n * Conversions\n * - {@link edges}: Edges of triangle as {@link Lines.Line}\n * - {@link corners}: Corner positions\n * - {@link innerCircle}: Largest circle to fit within triangle\n * - {@link outerCircle}: Largest circle to enclose triangle\n * - {@link toFlatArray}: Returns an array of coordinates: `[aX, aY, bX, bY, cX, cY]`\n *\n * Comparisons\n * - {@link intersectsPoint}: Whether a point intersects triangle\n * - {@link isEqual}: Check whether two triangles have equal values\n * - {@link isAcute}, {@link isEquilateral}, {@link isIsosceles}, {@link isRightAngle}\n * - {@link isTriangle}: Returns true if object has expected properties of a triangle\n */\nexport * as Triangles from './triangle/index.js';\nexport type * from './triangle/triangle-type.js';\n//# sourceMappingURL=index.d.ts.map"],"mappings":"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"}