{"version":3,"sources":["../src/numbers/index.ts","../src/numbers/ApplyToValues.ts","../src/numbers/Guard.ts","../src/numbers/Filter.ts","../src/numbers/Flip.ts","../src/numbers/Generate.ts","../src/numbers/IsApprox.ts","../src/numbers/Normalise.ts","../src/numbers/Proportion.ts","../src/numbers/Difference.ts","../src/numbers/Softmax.ts"],"sourcesContent":["/**\n * * {@link average}, {@link max}, {@link min}, {@link total}: Calculate average/max/min/total\n * * {@link averageWeighted}: Calculate average, but applies a weighting function, eg to favour items at beginning of array\n * * {@link minMaxAvg}: Find smallest, largest and average\n * * {@link maxIndex}, {@link minIndex}: Return index of largest/smallest value\n * * {@link dotProduct}: Returns the dot-product between two arrays\n * * {@link weight}: Applies a weighting function to all values based on their index\n * * See also {@link Numbers} module for working with numbers in general.\n * @module\n */\n\n\nexport * from './ApplyToValues.js';\nexport * from './AverageWeighted.js'\n/**\n * Work with bipolar values (-1...1)\n * \n * Import:\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * ```\n * \n * Overview:\n * * {@link clamp}: Clamp on -1..1 scale\n * * {@link fromScalar}: Convert from 0..1 to -1..1\n * * {@link immutable}: Immutable wrapper around a value\n * * {@link random}: Create a random bipolar value\n * * {@link scale}: Scale a value to -1..1 (clamped)\n * * {@link scaleUnclamped} As {@link scale} but allowed to go outside of -1...1 range\n * * {@link toScalar}: Convert -1..1 to 0..1\n * * {@link towardZero}: Nudge a bipolar value towards zero\n */\nexport * as Bipolar from './Bipolar.js';\n\nexport * from './Clamp.js';\nexport * from './Count.js';\nexport * from './Filter.js';\nexport * from './Flip.js';\nexport * from './Generate.js';\nexport * from './Guard.js';\nexport * from './Interpolate.js';\nexport * from './IsApprox.js';\nexport * from './LinearSpace.js';\nexport * from './MinMaxAvg.js';\nexport * from './MovingAverage.js';\n\n/**\n * Normalise module\n * * {@link array}: Normalises the contents of an array of known values.\n * * {@link stream}: Normalises a stream of unknown values.\n */\nexport * as Normalise from './Normalise.js';\nexport * from './NumericArrays.js';\nexport * from './Proportion.js';\nexport * from './Quantise.js';\nexport * from './Difference.js';\nexport * from './Round.js';\nexport * from './Scale.js';\nexport * from './Softmax.js';\nexport type * from './Types.js';\nexport * from './Wrap.js';\n","/**\n * Apples `fn` to every key of `obj` which is numeric.\n * ```js\n * const o = {\n *  name: 'john',\n *  x: 10,\n *  y: 20\n * };\n * const o2 = applyToValues(o, (v) => v * 2);\n * \n * // Yields: { name: 'john', x: 20, y: 40 }\n * ```\n * @param object \n * @param apply \n * @returns \n */\nexport const applyToValues = <T extends Record<string, any>>(object: T, apply: (v: number) => number): T => {\n  const o: T = { ...object };\n  for (const [ key, value ] of Object.entries(object)) {\n    if (typeof value === `number`) {\n      // Run number through function\n      //eslint-disable-next-line functional/immutable-data\n      (o as any)[ key ] = apply(value);\n    } else {\n      // Copy value\n      //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-unsafe-assignment\n      (o as any)[ key ] = value;\n    }\n  }\n  return o;\n}","/**\n * Returns true if `possibleNumber` is a number and not NaN\n * @param possibleNumber\n * @returns\n */\nexport const isValid = (possibleNumber: unknown) => {\n  if (typeof possibleNumber !== `number`) return false;\n  if (Number.isNaN(possibleNumber)) return false;\n  return true;\n};","import { isValid } from './Guard.js';\n/**\n * Filters an iterator of values, only yielding\n * those that are valid numbers\n *\n * ```js\n * import * as Numbers from 'https://unpkg.com/ixfx/dist/numbers.js';\n *\n * const data = [true, 10, '5', { x: 5 }];\n * for (const n of Numbers.filter(data)) {\n *  // 5\n * }\n * ```\n * @param it\n */\n//eslint-disable-next-line func-style\nexport function* filter(it: Iterable<unknown>) {\n  for (const v of it) {\n    if (isValid(v)) yield v;\n  }\n}\n","import { throwNumberTest } from \"../util/GuardNumbers.js\";\nimport type { NumberFunction } from '../data/Types.js';\n\n/**\n * Flips a percentage-scale number: `1 - v`.\n *\n * The utility of this function is that it sanity-checks\n * that `v` is in 0..1 scale.\n *\n * ```js\n * flip(1);   // 0\n * flip(0.5); // 0.5\n * flip(0);   // 1\n * ```\n * @param v\n * @returns\n */\nexport const flip = (v: number | NumberFunction) => {\n  if (typeof v === `function`) v = v();\n  throwNumberTest(v, `percentage`, `v`);\n  return 1 - v;\n};\n","import { throwNumberTest } from \"../util/GuardNumbers.js\";\n\n\n/**\n * Generates a range of numbers, starting from `start` and counting by `interval`.\n * If `end` is provided, generator stops when reached.\n *\n * Unlike {@link numericRange}, numbers might contain rounding errors\n *\n * ```js\n * for (const c of numericRangeRaw(10, 100)) {\n *  // 100, 110, 120 ...\n * }\n * ```\n * @param interval Interval between numbers\n * @param start Start\n * @param end End (if undefined, range never ends)\n */\nexport const numericRangeRaw = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false\n) {\n  if (interval <= 0) throw new Error(`Interval is expected to be above zero`);\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  let v = start;\n  do {\n    while (v < end) {\n      yield v;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n/**\n * Generates a range of numbers, with a given interval.\n *\n * @example For-loop\n * ```\n * let loopForever = numericRange(0.1); // By default starts at 0 and counts upwards forever\n * for (v of loopForever) {\n *  console.log(v);\n * }\n * ```\n *\n * @example If you want more control over when/where incrementing happens...\n * ```js\n * let percent = numericRange(0.1, 0, 1);\n *\n * let percentResult = percent.next().value;\n * ```\n *\n * Note that computations are internally rounded to avoid floating point math issues. So if the `interval` is very small (eg thousandths), specify a higher rounding\n * number.\n *\n * @param interval Interval between numbers\n * @param start Start. Defaults to 0\n * @param end End (if undefined, range never ends)\n * @param repeating Range loops from start indefinately. Default _false_\n * @param rounding A rounding that matches the interval avoids floating-point math hikinks. Eg if the interval is 0.1, use a rounding of 10\n */\nexport const numericRange = function* (\n  interval: number,\n  start = 0,\n  end?: number,\n  repeating = false,\n  rounding?: number\n) {\n  throwNumberTest(interval, `nonZero`);\n\n  const negativeInterval = interval < 0;\n  if (end === undefined) {\n    /* no op */\n  } else {\n    if (negativeInterval && start < end) {\n      throw new Error(\n        `Interval of ${ interval } will never go from ${ start } to ${ end }`\n      );\n    }\n    if (!negativeInterval && start > end) {\n      throw new Error(\n        `Interval of ${ interval } will never go from ${ start } to ${ end }`\n      );\n    }\n  }\n\n  rounding = rounding ?? 1000;\n  if (end === undefined) end = Number.MAX_SAFE_INTEGER;\n  else end *= rounding;\n  interval = interval * rounding;\n\n  do {\n    let v = start * rounding;\n    while ((!negativeInterval && v <= end) || (negativeInterval && v >= end)) {\n      yield v / rounding;\n      v += interval;\n    }\n  } while (repeating);\n};\n\n\n\n/**\n * Yields numeric range between 0.0-1.0.\n *\n * ```\n * // Yields: [0, 0.2, 0.4, 0.6, 0.8, 1]\n * const a = [...numericPercent(0.2)];\n *\n * // Repeating flag set to true:\n * for (const v of numericPercent(0.2, true)) {\n *  // Infinite loop. V loops back to 0 after hitting 1\n * }\n * ```\n *\n * If `repeating` is true, it loops back to 0 after reaching 1\n * @param interval Interval (default: 0.01, ie. 1%)\n * @param repeating Whether generator should loop (default: false)\n * @param start Start (default: 0)\n * @param end End (default: 1)\n * @returns\n */\nexport const numericPercent = function (\n  interval = 0.01,\n  repeating = false,\n  start = 0,\n  end = 1\n) {\n  throwNumberTest(interval, `percentage`, `interval`);\n  throwNumberTest(start, `percentage`, `start`);\n  throwNumberTest(end, `percentage`, `end`);\n  return numericRange(interval, start, end, repeating);\n};","import { numberTest, throwNumberTest } from \"../util/GuardNumbers.js\";\nimport { round } from \"./Round.js\";\n\n/**\n * Returns a function that checks if a value is within range of a base value\n * ```js\n * const tenPercent = isApprox(0.1);\n * // Check if 101 is within 10% range of 100\n * tenPercent(100, 101); \n * ```\n * @param rangePercent \n */\nexport function isApprox(\n  rangePercent: number\n): (baseValue: number, value: number) => boolean;\n\n/**\n * Returns a function to check if a value is within range of a base value\n * ```js\n * const close = isApprox(0.1, 100);\n * // Check if 101 is within 10% range of 100\n * close(101);\n * ```\n * @param rangePercent \n * @param baseValue \n */\nexport function isApprox(\n  rangePercent: number,\n  baseValue: number,\n): (value: number) => boolean;\n\n/**\n * Returns _true/false_ if `value` is within `rangePercent` of `baseValue`.\n * \n * ```js\n * isApprox(0.1, 100, 101);\n * ```\n * @param rangePercent \n * @param baseValue \n * @param value \n */\nexport function isApprox(\n  rangePercent: number,\n  baseValue: number,\n  value: number\n): boolean;\n\n\n/**\n * Checks if a value is within range of a base value\n * \n * ```js\n * // Check if 101 is within 10% of 100\n * isApprox(0.1, 100, 101);\n * \n * // Gets a function to compare some value of 10% range to 100\n * const c = isApprox(0.1,100);\n * c(101);\n * \n * // Gets a function to compare some base value and value to 10% range\n * const c = isApprox(0.1);\n * c(100, 101);\n * ```\n * \n * Throws an error if range or base values are NaN.\n * If value being checked is NaN or infinity, _false_ is returned.\n * @param rangePercent \n * @param baseValue \n * @param v \n * @returns \n */\nexport function isApprox(\n  rangePercent: number,\n  baseValue?: number,\n  v?: number\n) {\n  throwNumberTest(rangePercent, `percentage`, `rangePercent`);\n\n  // Round percentages to avoid floating point nonsense\n  const range = Math.floor(rangePercent * 100);\n  const test = (base: number, value: number): boolean => {\n    try {\n      if (typeof value !== `number`) return false;\n      if (Number.isNaN(value)) return false;\n      if (!Number.isFinite(value)) return false;\n\n      // Round value\n      const diff = Math.abs(value - base)\n      const relative = base === 0 ? Math.floor(diff * 100) : Math.floor((diff / base) * 100);\n      //console.log(`v: ${ value } base: ${ base } rel: ${ relative } range: ${ range } diff: ${ diff }`);\n      return relative <= range;\n    } catch {\n      return false;\n    }\n  };\n\n  if (baseValue === undefined) return test;\n  throwNumberTest(baseValue, ``, `baseValue`);\n  if (v === undefined) {\n    return (value: number) => test(baseValue, value);\n  } else {\n    return test(baseValue, v);\n  }\n}\n","\nimport { scale } from './Scale.js';\nimport { throwNumberTest } from \"../util/GuardNumbers.js\";\nimport { clamp } from './Clamp.js';\nimport { minMaxAvg } from './MinMaxAvg.js';\n/**\n * Normalises numbers, adjusting min/max as new values are processed.\n * Normalised return values will be in the range of 0-1 (inclusive).\n *\n * [ixfx Guide on Normalising](https://ixfx.fun/cleaning/normal/)\n *\n * @example\n * ```js\n * import {Normalise} from 'https://unpkg.com/ixfx/dist/numbers.js'\n * const s = Normalise.stream();\n * s(2);    // 1 (because 2 is highest seen)\n * s(1);    // 0 (because 1 is the lowest so far)\n * s(1.5);  // 0.5 (50% of range 1-2)\n * s(0.5);  // 0 (because it's the new lowest)\n * ```\n *\n * Since normalisation is being adjusted as new min/max are encountered, it might\n * be that value normalised to 1 at one time is different to what normalises to 1\n * at a later time.\n *\n * If you already know what to expect of the number range, passing in `minDefault`\n * and `maxDefault` primes the normalisation.\n * ```js\n * const s = Normalise.stream();\n * s(5); // 1, because it's the highest seen\n *\n * // With priming:\n * const s = Normalise.stream(0, 10);\n * s(5); // 0.5, because we're expecting range 0-10\n * ```\n *\n * If a value exceeds the default range, normalisation adjusts.\n * Errors are thrown if min/max defaults are NaN or if one attempts to\n * normalise NaN.\n * @returns\n */\nexport const stream = (minDefault?: number, maxDefault?: number) => {\n  let min = minDefault ?? Number.MAX_SAFE_INTEGER;\n  let max = maxDefault ?? Number.MIN_SAFE_INTEGER;\n\n  throwNumberTest(min);\n  throwNumberTest(max);\n\n  return (v: number): number => {\n    throwNumberTest(v);\n    min = Math.min(min, v);\n    max = Math.max(max, v);\n    return scale(v, min, max);\n  };\n};\n\n/**\n * Normalises an array. By default uses the actual min/max of the array\n * as the normalisation range. [ixfx Guide on Normalising](https://ixfx.fun/cleaning/normal/)\n *\n * ```js\n * import {Normalise} from 'https://unpkg.com/ixfx/dist/numbers.js'\n * // Yields: [0.5, 0.1, 0.0, 0.9, 1]\n * Normalise.array([5,1,0,9,10]);\n * ```\n *\n * `minForced` and/or `maxForced` can\n * be provided to use an arbitrary range.\n * ```js\n * // Forced range 0-100\n * // Yields: [0.05, 0.01, 0.0, 0.09, 0.10]\n * Normalise.array([5,1,0,9,10], 0, 100);\n * ```\n *\n * Return values are clamped to always be 0-1, inclusive.\n *\n * @param values Values\n * @param minForced If provided, this will be min value used\n * @param maxForced If provided, this will be the max value used\n */\nexport const array = (values: ReadonlyArray<number>,\n  minForced?: number,\n  maxForced?: number\n) => {\n  if (!Array.isArray(values)) {\n    throw new TypeError(`Param 'values' should be an array. Got: ${ typeof values }`);\n  }\n  const mma = minMaxAvg(values);\n\n  const min = minForced ?? mma.min;\n  const max = maxForced ?? mma.max;\n\n  return values.map((v) => clamp(scale(v, min, max)));\n};\n","import { throwNumberTest } from \"../util/GuardNumbers.js\";\nimport { type NumberFunction } from '../data/Types.js';\n\n/**\n * Scales a percentage-scale number, ie: `v * t`.\n * The utility of this function is that it sanity-checks that\n *  both parameters are in the 0..1 scale.\n * @param v Value\n * @param t Scale amount\n * @returns Scaled value\n */\nexport const proportion = (\n  v: number | NumberFunction,\n  t: number | NumberFunction\n) => {\n  if (typeof v === `function`) v = v();\n  if (typeof t === `function`) t = t();\n\n  throwNumberTest(v, `percentage`, `v`);\n  throwNumberTest(t, `percentage`, `t`);\n  return v * t;\n};\n","export type DifferenceKind = `numerical` | `relative` | `relativeSigned` | `absolute`\n\n/**\n * Returns the difference from the `initial` value. Defaults to absolute difference.\n * ```js\n * const rel = differenceFromFixed(100);\n * rel(100); // 0\n * rel(150); // 50\n * rel(50);  // 50\n * ```\n *\n * 'numerical' gives sign:\n * ```js\n * const rel = differenceFromFixed(100, `numerical`);\n * rel(100); // 0\n * rel(150); // 50\n * rel(50); // -50\n * ```\n * \n * 'relative' gives proportion to initial\n * ```js\n * const rel = differenceFromFixed(100, `relative`);\n * rel(100); // 0\n * rel(150); // 0.5\n * rel(10);  // 0.90\n * ```\n * \n * Using 'relativeSigned', we get negative relative result\n * when value is below the initial value.\n * \n * Use {@link differenceFromLast} to compare against the last value,\n * rather than the same fixed value.\n * @param {number} initial Value to compare against\n * @returns Difference from initial value\n */\nexport const differenceFromFixed = (initial: number, kind: DifferenceKind = `absolute`) => (value: number) => differenceFrom(kind, value, initial);\n\n\n/**\n * Returns a function which yields difference compared to last value.\n * \n * If no initial value is provided, the first difference will be returned as 0.\n * \n * Difference can be returned in various formats:\n * * 'absolute': numerical difference, without sign\n * * 'numerical': numerical difference, with sign, so you can see if difference is higher or lower\n * * 'relative': difference divided by last value, giving a proportional difference. Unsigned.\n * * 'relativeSigned': as above, but with sign\n * \n * Use {@link differenceFromFixed} to compare against a fixed value instead of the last value.\n * \n * ```js\n * let d = differenceFromLast(`absolute`);\n * d(10); // 0\n * d(11); // 1\n * d(10); // 1\n * ```\n * \n * ```js\n * let d = differenceFromLast(`numerical`);\n * d(10); // 0\n * d(11); // 1\n * d(10); // -1\n * ```\n * \n * ```js\n * let d = differenceFromLast(`relative`);\n * d(10); // 0\n * d(11); // 0.1\n * d(10); // 0.1\n * ```\n * ```js\n * let d = differenceFromLast(`relativeSigned`);\n * d(10); // 0\n * d(11); // 0.1\n * d(10); // -0.1\n * ```\n * \n * An initial value can be provided, eg:\n * ```js\n * let d = differenceFromLast(`absolute`, 10);\n * d(11); // 1\n * ```\n * @param kind Kind of output value\n * @param initialValue Optional initial value \n * @returns \n */\nexport const differenceFromLast = (kind: DifferenceKind = `absolute`, initialValue = Number.NaN): (v: number) => number => {\n  let lastValue = initialValue;\n  return (value: number) => {\n    const x = differenceFrom(kind, value, lastValue);\n    lastValue = value;\n    return x;\n  }\n}\n//   const compute = (v: number) => {\n//     if (Number.isNaN(lastValue)) {\n//       lastValue = v;\n//       return 0;\n//     }\n//     const d = v - lastValue;\n//     let r = 0;\n//     if (kind === `absolute`) {\n//       r = Math.abs(d);\n//     } else if (kind === `numerical`) {\n//       r = d;\n//     } else if (kind === `relative`) {\n//       r = Math.abs(d / lastValue);\n//     } else if (kind === `relativeSigned`) {\n//       r = d / lastValue;\n//     } else throw new TypeError(`Unknown kind: '${ kind }' Expected: 'absolute', 'relative', 'relativeSigned' or 'numerical'`);\n//     lastValue = v;\n//     return r;\n//   }\n//   return compute;\n// }\n\nconst differenceFrom = (kind: DifferenceKind = `absolute`, value: number, from: number) => {\n  if (Number.isNaN(from)) {\n    return 0;\n  }\n  const d = value - from;\n  let r = 0;\n  if (kind === `absolute`) {\n    r = Math.abs(d);\n  } else if (kind === `numerical`) {\n    r = d;\n  } else if (kind === `relative`) {\n    r = Math.abs(d / from);\n  } else if (kind === `relativeSigned`) {\n    r = d / from;\n  } else throw new TypeError(`Unknown kind: '${ kind }' Expected: 'absolute', 'relative', 'relativeSigned' or 'numerical'`);\n  return r;\n}","/**\n * Via: https://gist.github.com/cyphunk/6c255fa05dd30e69f438a930faeb53fe\n * @param logits \n * @returns \n */\nexport const softmax = (logits: Array<number>) => {\n  // eslint-disable-next-line unicorn/no-array-reduce\n  const maxLogit = logits.reduce((a, b) => Math.max(a, b), Number.NEGATIVE_INFINITY);\n  const scores = logits.map((l) => Math.exp(l - maxLogit));\n  const denom = scores.reduce((a, b) => a + b);\n  return scores.map((s) => s / denom);\n}"],"mappings":"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","names":["min","max"]}