{"version":3,"file":"rx.js","names":["message: Passed<V> | PassedSignal","v: Passed<V> | PassedSignal","rx: Reactive<V> | ReactiveDiff<V> | object","rx: object","rx: Reactive<V> | ReactiveWritable<V>","v: any","fn: (source: ReactiveOrSource<TIn>, ...args: any[]) => TRxOut","source: ReactiveOrSource<TIn>","t: Trigger<V>","t: any","callback: FunctionFunction<V>","options: Partial<FunctionOptions>","manual","reason: string","run","source: IterableIterator<V> | V[] | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V>","options: Partial<GeneratorOptions>","message: string","_: string","iterator: IterableIterator<V> | AsyncIterableIterator<V> | undefined","ourAc: AbortController | undefined","iterator","reason: string","source: ReactiveOrSource<V>","options: Partial<ResolveSourceOptions>","r: RT","initialValue: TValue | undefined","lastValue: TValue | undefined","upstreamSource: ReactiveOrSource<In>","options: Partial<UpstreamOptions<In>>","_v: In","unsub: undefined | (() => void)","options: InitLazyStreamInitedOptions<V>","options: InitLazyStreamOptions","options: Partial<InitStreamOptions>","dispatcher: DispatchList<Passed<V>> | undefined","handler: Dispatch<Passed<V>>","reason: string","v: V","signal: SignalKinds","context?: string","handler: (value: V) => void","rxOrSource: ReactiveOrSource<any>","optionsOrElementOrQuery: SetHtmlOptions | string | HTMLElement","el: HTMLElement | null | undefined","options: SetHtmlOptions | undefined","stream: ReactiveStream<V>","input: ReactiveOrSource<In>","annotator: (value: In) => TAnnotation","options: Partial<TransformOpts>","annotatorOp: ReactiveOp<In, TAnnotation>","source: ReactiveOrSource<V>","options: Partial<ChunkOptions>","value: V","input: ReactiveOrSource<In>","transformer: (value: In) => Out","options: Partial<TransformOpts>","source: ReactiveOrSource<In>","entries: [ key: string, value: any ][]","field","reactiveSources: T","options: Partial<CombineLatestOptions>","event","data: (RxValueTypes<T> | undefined)[]","initialValue?: V","options: Partial<ObjectOptions<V>>","fieldChangeEvents: [ matcher: (value: string) => boolean, pattern: string, DispatchList<ObjectFieldHandler> ][]","value: V | undefined","v: V","field: string","value: any","field","updateCompareOptions: Partial<Pathed.CompareDataOptions<V>>","toMerge: Partial<V>","path: string","valueForField: any","reason: string","fieldPattern: string","handler: (result: ObjectFieldHandler) => void","reactiveSources: T","options: Partial<CombineLatestOptions>","event","s: State<any>","state: State<any>","field: string","field","reason: string","input: ReactiveOrSource<TIn>","fn: (previous: TIn, current: TIn) => TIn","previousValue: TIn | undefined","currentValue: TIn | undefined","debounce","source: ReactiveOrSource<V>","options: Partial<DebounceOptions>","elapsed","lastValue: V | undefined","options: Partial<DebounceOptions>","source: ReactiveOrSource<V>","debounceReactive","input: ReactiveOrSource<In>","elapsed","fieldSource: ReactiveOrSource<TIn>","fieldName: keyof TIn","options: Partial<FieldOptions<TIn, TFieldType>>","v: TFieldType | undefined","input: ReactiveOrSource<In>","predicate: FilterPredicate<In>","options: Partial<InitStreamOptions>","interpolate","input: ReactiveOrSource<number>","options: Partial<OpInterpolateOptions>","interpolateFunction","max","input: ReactiveOrSource<any>","options: OpMathOptions","min","average","sum","tally","input: ReactiveOrSource<TIn>","options: Partial<TallyOptions>","rank","rank: RankFunction<TIn>","options: Partial<RankOptions & OpMathOptions>","processor: Proc.Process<any, any>","annotationField: string","annotate","previous: number | undefined","ret: any","event","unsubs: (() => void)[]","reason: string","message: Passed<unknown>","source: ReactiveOrSource<V[]>","options: Partial<SingleFromArrayOptions<V>>","values: V[]","rxOrSource: ReactiveOrSource<T>","options: Partial<SplitOptions>","outputs: ReactiveStream<T>[]","labels: K[]","t: Partial<Record<K, Reactive<T>>>","reactiveOrSource: ReactiveOrSource<TValue>","cases: TRec","options: Partial<SwitcherOptions>","t: Partial<Record<TLabel, ReactiveStream<TValue>>>","reactiveSources: T","options: Partial<SyncOptions>","watchdog: ReturnType<typeof globalThis.setTimeout> | undefined","data: (RxValueTypes<T> | undefined)[]","states: State<any>[]","reason: string","event","init","reactiveSources: T","options: Partial<SyncOptions>","input: ReactiveOrSource<In>","diverged: ReactiveWritable<In>","input: ReactiveOrSource<TIn>","throttleSource: ReactiveOrSource<V>","options: Partial<ThrottleOptions>","elapsed","lastValue: V | undefined","source: ReactiveOrSource<TSource>","options: TimeoutValueOptions<TTriggerValue>","timer: ReturnType<typeof setTimeout> | undefined","source: ReactiveOrSource<TSource>","options: TimeoutPingOptions","timer: ReturnType<typeof setTimeout> | undefined","source: ReactiveOrSource<TSource>","target: ReactivePingable<TTarget>","options: Partial<ValueToPingOptions<TSource>>","value: TSource","upstreamOff: Unsubscriber | undefined","downstreamOff: Unsubscriber | undefined","reason: string","input: ReactiveOrSource<In>","options: WithValueOptions<In>","lastValue: In | undefined","source: V[] | Iterable<V>","options: Partial<ArrayOptions>","sourceArray: V[]","array","initialValue: readonly V[]","options: Partial<ArrayObjectOptions<V>>","value: readonly V[]","replacement: V[] | readonly V[]","index: number","v: V","cr: ChangeRecord<number>","ArraysRemove","filter: (value: V) => boolean","filter","count","insertAt","ArraysInsertAt","reason: string","initialValue?: boolean","v: boolean","options: Partial<CountOptions>","reason: string","fn: (combined: RxValueTypeObject<T>) => TResult | undefined","reactiveSources: T","options: Partial<DerivedOptions<TResult, CombineLatestToObject<T>>>","v: RxValueTypeObject<T>","targetOrQuery: EventTarget | string | null","eventName: string","fieldName: string","initialValue: TFieldValue","options: Partial<EventSourceOptions & FieldOptions<any, TFieldValue>>","initial: Record<string, any>","targetOrQuery: EventTarget | null | string","name: string","initialValue: TEventArgs | undefined","options: Partial<EventSourceOptions>","target: EventTarget | null","args: any","remove","reason: string","handler: (v: Passed<TEventArgs>) => void","handler: (v: TEventArgs) => void","options: Partial<EventSourceTriggerOptions>","count","elapsed","_args?: any","sources: Reactive<T>[]","options: Partial<InitLazyStreamOptions>","unsubs: Unsubscriber[]","initialValue?: number","v: number","target: V","target","target: T","init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined","init","onCleanup: (() => void) | undefined","callback: (value: V) => void","initialValue?: string","v: string","queue: IQueueMutableWithEvents<T>","event: QueueMutableEvents<T>[ `removed` ]","event","event: QueueMutableEvents<T>[ `enqueue` ]","data: T[]","_rx: V","process","o: object","path: string","source: ReactiveOrSource<V>","options: Partial<ToArrayOptions<V>>","read: (V | undefined)[]","source: ReactiveOrSource<V>","promiseResolve: ((value: V | PromiseLike<V>) => void)","promiseReject: ((reason: string) => void)","source: ReactiveOrSource<TIn>","transformer: (value: TIn) => TAnnotation","op: ReactiveOp<TIn, TOut>","options: Partial<ChunkOptions>","options: Partial<DebounceOptions>","fieldName: keyof TIn","options: Partial<FieldOptions<TSource, TFieldType>>","predicate: FilterPredicate<TIn>","options: Partial<InitStreamOptions>","sources: T","options: Partial<CombineLatestOptions>","options: { name?: string } & Partial<CombineLatestOptions>","options: Partial<Ops.OpMathOptions>","options: Partial<Ops.TallyOptions>","options: Partial<SplitOptions>","cases: TRec","options: Partial<SwitcherOptions>","additionalSources: T","options: Partial<SyncOptions>","options: { name?: string } & Partial<SyncOptions>","source","options: Partial<ThrottleOptions>","transformer: (value: TIn) => TOut","options: Partial<TransformOpts>","options: TimeoutValueOptions<TTrigger>","options: TimeoutPingOptions","options: Partial<ToArrayOptions<TIn>>","callback: ((value: TIn) => void)","source: ReactiveOrSource<any>","source: ReactiveOrSource<TIn>","value: TIn","options: Partial<InitStreamOptions>","value: V","options: SinkFns.SetHtmlOptions","source: ReactiveOrSource<string>","annotator: (input: V) => V & TAnnotation","annotatorOp: ReactiveOp<TIn, TAnnotation>","options: Partial<ChunkOptions>","source: ReactiveOrSource<V>","options: Partial<CombineLatestOptions>","sources: T","reactiveSources: T","predicate: (value: V) => boolean","fieldName: keyof TSource","options: FieldOptions<TSource, TFieldType>","source: ReactiveOrSource<TSource>","options?: Partial<OpFns.OpInterpolateOptions>","options?: OpFns.OpMathOptions","options?: OpFns.TallyOptions","rank: RankFunction<TIn>","options?: RankOptions & OpFns.OpMathOptions","rank","source: ReactiveOrSource<TInput>","options: Partial<SingleFromArrayOptions<V>>","source: ReactiveOrSource<V[]>","options: Partial<SplitOptions>","labels: string[]","cases: TRec","options: Partial<SwitcherOptions>","source: ReactiveOrSource<TValue>","options: Partial<SyncOptions>","processor: ((value: In) => any)","source: ReactiveOrSource<In>","divergedStream: ReactiveWritable<In>","options: Partial<ThrottleOptions>","options: TimeoutValueOptions<TTriggerValue>","options: TimeoutPingOptions","transformer: ((value: In) => Out)","options: Partial<OpFns.TransformOpts>","opts: Partial<WithValueOptions<V>>","maximumWait: Interval","watchdog: ReturnType<typeof globalThis.setTimeout> | undefined","to","a: Reactive<TA>","b: ReactiveWritable<TB>","transform?: (valueA: TA) => TB","transform"],"sources":["../packages/rx/src/util.ts","../packages/rx/src/from/function.ts","../packages/rx/src/from/iterator.ts","../packages/rx/src/resolve-source.ts","../packages/rx/src/cache.ts","../packages/rx/src/init-stream.ts","../packages/rx/src/sinks/dom.ts","../packages/rx/src/to-readable.ts","../packages/rx/src/ops/annotate.ts","../packages/rx/src/ops/chunk.ts","../packages/rx/src/ops/transform.ts","../packages/rx/src/ops/clone-from-fields.ts","../packages/rx/src/ops/combine-latest-to-array.ts","../packages/rx/src/from/object.ts","../packages/rx/src/ops/combine-latest-to-object.ts","../packages/rx/src/ops/compute-with-previous.ts","../packages/rx/src/reactives/debounce.ts","../packages/rx/src/ops/debounce.ts","../packages/rx/src/ops/elapsed.ts","../packages/rx/src/ops/field.ts","../packages/rx/src/ops/filter.ts","../packages/rx/src/ops/interpolate.ts","../packages/rx/src/ops/math.ts","../packages/rx/src/ops/pipe.ts","../packages/rx/src/ops/single-from-array.ts","../packages/rx/src/ops/split.ts","../packages/rx/src/ops/switcher.ts","../packages/rx/src/ops/sync-to-array.ts","../packages/rx/src/ops/sync-to-object.ts","../packages/rx/src/ops/tap.ts","../packages/rx/src/ops/throttle.ts","../packages/rx/src/ops/timeout-value.ts","../packages/rx/src/ops/timeout-ping.ts","../packages/rx/src/ops/value-to-ping.ts","../packages/rx/src/ops/with-value.ts","../packages/rx/src/from/array.ts","../packages/rx/src/from/array-object.ts","../packages/rx/src/from/boolean.ts","../packages/rx/src/from/count.ts","../packages/rx/src/from/derived.ts","../packages/rx/src/from/event.ts","../packages/rx/src/from/merged.ts","../packages/rx/src/from/number.ts","../packages/rx/src/types.ts","../packages/rx/src/from/object-proxy.ts","../packages/rx/src/from/observable.ts","../packages/rx/src/from/string.ts","../packages/rx/src/from/index.ts","../packages/rx/src/collections/responsive-queue.ts","../packages/rx/src/collections/index.ts","../packages/rx/src/graph.ts","../packages/rx/src/to-array.ts","../packages/rx/src/to-generator.ts","../packages/rx/src/wrap.ts","../packages/rx/src/index.ts"],"sourcesContent":["import { isIterable } from \"@ixfx/iterables\";\nimport type { Passed, PassedSignal, PassedValue, Reactive, ReactiveDiff, ReactiveInitial, ReactiveOrSource, ReactivePingable, ReactiveWritable, Wrapped } from \"./types.js\";\nimport type { Trigger, TriggerValue, TriggerFunction, TriggerGenerator } from \"./from/types.js\";\n\nexport function messageIsSignal<V>(message: Passed<V> | PassedSignal): message is PassedSignal {\n  if (message.value !== undefined) return false;\n  if (`signal` in message && message.signal !== undefined) return true;\n  return false;\n}\n\nexport function messageIsDoneSignal<V>(message: Passed<V> | PassedSignal): boolean {\n  if (message.value !== undefined) return false;\n  if (`signal` in message && message.signal === `done`) return true;\n  return false;\n}\n\n/**\n * Returns _true_ if `v` has a non-undefined value. Note that sometimes\n * _undefined_ is a legal value to pass\n * @param v \n * @returns \n */\nexport function messageHasValue<V>(v: Passed<V> | PassedSignal): v is PassedValue<V> {\n  if (v.value !== undefined) return true;\n  return false;\n}\n\nexport const isPingable = <V>(rx: Reactive<V> | ReactiveDiff<V> | object): rx is ReactivePingable<V> => {\n  if (!isReactive(rx)) return false;\n  if (`ping` in rx) {\n    return true;\n  }\n  return false;\n}\n\nexport const hasLast = <V>(rx: Reactive<V> | ReactiveDiff<V> | object): rx is ReactiveInitial<V> => {\n  if (!isReactive(rx)) return false;\n  if (`last` in rx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const v = (rx as any).last();\n    if (v !== undefined) return true;\n  }\n  return false;\n}\n\n/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx \n * @returns \n */\nexport const isReactive = <V>(rx: object): rx is Reactive<V> => {\n  if (typeof rx !== `object`) return false;\n  if (rx === null) return false;\n  return (`on` in rx && `onValue` in rx)\n}\n\n/**\n * Returns true if `rx` is a disposable reactive.\n * @param rx \n * @returns \n */\n// export const isDisposable = <V>(rx: Reactive<V> | ReactiveWritable<V>): rx is ReactiveDisposable<V> => {\n//   if (!isReactive(rx)) return false;\n//   return (`isDisposed` in rx && `dispose` in rx);\n// }\n\n/**\n * Returns _true_ if `rx` is a writable Reactive\n * @param rx \n * @returns \n */\nexport const isWritable = <V>(rx: Reactive<V> | ReactiveWritable<V>): rx is ReactiveWritable<V> => {\n  if (!isReactive(rx)) return false;\n  if (`set` in rx) return true;\n  return false;\n}\n\nexport const isWrapped = <T>(v: any): v is Wrapped<T> => {\n  if (typeof v !== `object`) return false;\n  if (!(`source` in v)) return false;\n  if (!(`annotate` in v)) return false;\n  return true;\n}\n\n// export const opify = <TIn, TOut = TIn,>(fn: (source: ReactiveOrSource<TIn>, ...args: Array<any>) => Reactive<TOut>, ...args: Array<any>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     return fn(source, ...args);\n//   }\n// }\n\nexport const opify = <TIn, TRxOut = Reactive<TIn>>(fn: (source: ReactiveOrSource<TIn>, ...args: any[]) => TRxOut, ...args: any[]) => {\n  return (source: ReactiveOrSource<TIn>) => {\n    return fn(source, ...args);\n  }\n}\n\n\nexport const isTriggerValue = <V>(t: Trigger<V>): t is TriggerValue<V> => (`value` in t);\nexport const isTriggerFunction = <V>(t: Trigger<V>): t is TriggerFunction<V> => (`fn` in t);\nexport const isTriggerGenerator = <V>(t: Trigger<V>): t is TriggerGenerator<V> => isIterable(t);\nexport const isTrigger = <V>(t: any): t is Trigger<V> => {\n  if (typeof t !== `object`) return false;\n  if (isTriggerValue(t)) return true;\n  if (isTriggerFunction(t)) return true;\n  if (isTriggerGenerator(t)) return true;\n  return false;\n}\n\nexport type ResolveTriggerValue<V> = [ value: V, false ];\nexport type ResolveTriggerDone = [ undefined, true ];\n\n/**\n * Resolves a trigger value.\n * \n * A trigger can be a value, a function or generator. Value triggers never complete.\n * A trigger function is considered complete if it returns undefined.\n * A trigger generator is considered complete if it returns done.\n * \n * Returns `[value, _false_]` if we have a value and trigger is not completed.\n * Returns `[value, _true_]` trigger is completed\n * @param t \n * @returns \n */\nexport function resolveTriggerValue<V>(t: Trigger<V>): ResolveTriggerDone | ResolveTriggerValue<V> {\n  if (isTriggerValue(t)) return [ t.value, false ];\n  if (isTriggerFunction(t)) {\n    const v = t.fn();\n    if (v === undefined) return [ undefined, true ];\n    return [ v, false ];\n  }\n  if (isTriggerGenerator(t)) {\n    const v = t.gen.next();\n    if (v.done) return [ undefined, true ];\n    return [ v.value, false ];\n  }\n  throw new Error(`Invalid trigger. Missing 'value' or 'fn' fields`);\n}","import { continuously, intervalToMs } from \"@ixfx/core\";\nimport { getErrorMessage } from \"@ixfx/debug\";\n\nimport { sleep } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\nimport type { ReactivePingable } from \"../types.js\";\nimport type { FunctionFunction, FunctionOptions } from \"./types.js\";\n\n\n/**\n * Produces a reactive from the basis of a function. `callback` is executed, with its result emitted via the returned reactive.\n * \n * ```js\n * // Produce a random number every second\n * const r = Rx.From.func(Math.random, { interval: 1000 });\n * ```\n * \n * `callback` can be called repeatedly by providing the `interval` option to set the rate of repeat.\n * Looping can be limited with `options.maximumRepeats`, or passing a signal `options.signal`\n * and then activating it. \n * ```js\n * // Reactive that emits a random number every second, five times\n * const r1 = Rx.From.func(Math.random, { interval: 1000, maximumRepeats: 5 }\n * ```\n * \n * ```js\n * // Generate a random number every second until ac.abort() is called\n * const ac = new AbortController();\n * const r2 = Rx.From.func(Math.random, { interval: 1000, signal: ac.signal });\n * ```\n * \n * The third option is for `callback` to fire the provided abort function.\n * ```js\n * Rx.From.func((abort) => {\n *  if (Math.random() > 0.5) abort('Random exit');\n *  return 1;\n * });\n * ```\n *\n * By default has a laziness of 'very' meaning that `callback` is run only when there's a subscriber \n * By default stream closes if `callback` throws an error. Use `options.closeOnError:'ignore'` to change.\n * @param callback \n * @param options \n * @returns \n */\n\nexport function func<V>(callback: FunctionFunction<V>, options: Partial<FunctionOptions> = {}): ReactivePingable<V> {\n  const maximumRepeats = options.maximumRepeats ?? Number.MAX_SAFE_INTEGER;\n  const closeOnError = options.closeOnError ?? true;\n  const intervalMs = options.interval ? intervalToMs(options.interval) : -1;\n  let manual = options.manual ?? false;\n\n  // If niether interval or manual is set, assume manual\n  if (options.interval === undefined && options.manual === undefined) manual = true;\n\n  if (manual && options.interval) throw new Error(`If option 'manual' is set, option 'interval' cannot be used`);\n  const predelay = intervalToMs(options.predelay, 0);\n  const lazy = options.lazy ?? `very`;\n  const signal = options.signal;\n\n  const internalAbort = new AbortController();\n  const internalAbortCallback = (reason: string) => { internalAbort.abort(reason) };\n  let sentResults = 0;\n  let enabled = false;\n\n  const done = (reason: string) => {\n    events.dispose(reason);\n    enabled = false;\n    if (run) run.cancel();\n  }\n\n  const ping = async () => {\n    if (!enabled) return false;\n    if (predelay) await sleep(predelay);\n    if (sentResults >= maximumRepeats) {\n      done(`Maximum repeats reached ${ maximumRepeats.toString() }`);\n      return false;\n    }\n    //console.log(`sent: ${ sentResults } max: ${ maximumRepeats }`);\n    try {\n      if (signal?.aborted) {\n        done(`Signal (${ signal.aborted })`);\n        return false;\n      }\n      const value = await callback(internalAbortCallback);\n      sentResults++;\n      events.set(value);\n      return true;\n    } catch (error) {\n      if (closeOnError) {\n        done(`Function error: ${ getErrorMessage(error) }`);\n        return false;\n      } else {\n        events.signal(`warn`, getErrorMessage(error));\n        return true;\n      }\n    }\n  }\n\n  const run = manual ? undefined : continuously(async () => {\n    const pingResult = await ping();\n    if (!pingResult) return false;\n\n    // if (!loop) {\n    //   done(`fromFunction done`);\n    //   return false; // Stop loop\n    // }\n    if (internalAbort.signal.aborted) {\n      done(`callback function aborted (${ internalAbort.signal.reason })`);\n      return false\n    }\n\n  }, intervalMs);\n\n  const events = initLazyStream<V>({\n    lazy,\n    onStart() {\n      enabled = true;\n      if (run) run.start();\n    },\n    onStop() {\n\n      enabled = false;\n      if (run) run.cancel();\n    },\n  });\n\n  if (lazy === `never` && run) run.start();\n  return { ...events, ping };\n}\n\n","\nimport { nextWithTimeout } from \"@ixfx/iterables/async\";\nimport { intervalToMs } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\nimport { isAsyncIterable } from \"@ixfx/iterables\";\nimport type { Reactive } from \"../types.js\";\nimport type { GeneratorOptions } from \"./types.js\";\nimport * as StateMachine from \"@ixfx/flow/state-machine\";\n\n/**\n * Creates a Reactive from an AsyncGenerator or Generator\n * @param gen \n * @returns \n */\n// export function readFromGenerator<V>(gen: AsyncGenerator<V> | Generator<V>) {\n//   const rx = initStream<V>();\n//   // eslint-disable-next-line @typescript-eslint/no-misused-promises\n//   setTimeout(async () => {\n//     try {\n//       for await (const value of gen) {\n//         rx.set(value);\n//       }\n//       rx.dispose(`Source generator complete`);\n//     } catch (error) {\n//       console.error(error);\n//       rx.dispose(`Error while iterating`);\n//     }\n//   }, 1);\n//   return rx;\n// }\n\n/**\n * Creates a readable reactive based on a (async)generator or iterator\n * ```js\n * // Generator a random value every 5 seconds\n * const valuesOverTime = Flow.interval(() => Math.random(), 5000);\n * // Wrap the generator\n * const r = Rx.From.iterator(time);\n * // Get notified when there is a new value\n * r.onValue(v => {\n *   console.log(v);\n * });\n * ```\n * \n * Awaiting values could potentially hang code. Thus there is a `readTimeout`, the maximum time to wait for a value from the generator. Default: 5 minutes.\n * If `signal` is given, this will also cancel waiting for the value.\n * @param source \n */\nexport function iterator<V>(source: IterableIterator<V> | V[] | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V>, options: Partial<GeneratorOptions> = {}): Reactive<V> {\n  const lazy = options.lazy ?? `very`;\n  const log = options.traceLifecycle ? (message: string) => { console.log(`Rx.From.iterator ${ message }`); } : (_: string) => {/* no-up */ }\n\n  const readIntervalMs = intervalToMs(options.readInterval, 5);\n  const readTimeoutMs = intervalToMs(options.readTimeout, 5 * 60 * 1000);\n  const whenStopped = options.whenStopped ?? `continue`;\n\n  let iterator: IterableIterator<V> | AsyncIterableIterator<V> | undefined;\n  //let reading = false;\n  let ourAc: AbortController | undefined;\n  let sm = StateMachine.init({\n    idle: [ `wait_for_next` ],\n    wait_for_next: [ `processing_result`, `stopping`, `disposed` ],\n    processing_result: [ `queued`, `disposed`, `stopping` ],\n    queued: [ `wait_for_next`, `disposed`, `stopping` ],\n    stopping: `idle`,\n\n    disposed: null\n  }, `idle`);\n\n  const onExternalSignal = () => {\n    log(`onExternalSignal`);\n    ourAc?.abort(options.signal?.reason);\n  }\n  if (options.signal) {\n    options.signal.addEventListener(`abort`, onExternalSignal, { once: true });\n  };\n\n  const read = async () => {\n    log(`read. State: ${ sm.value }`);\n    ourAc = new AbortController();\n    try {\n      sm = StateMachine.to(sm, `wait_for_next`);\n      const v = await nextWithTimeout(iterator!, { signal: ourAc.signal, millis: readTimeoutMs });\n      sm = StateMachine.to(sm, `processing_result`);\n      ourAc.abort(`nextWithTimeout completed`);\n\n      if (v.done) {\n        log(`read v.done true`);\n        events.dispose(`Generator complete`);\n        //reading = false;\n        sm = StateMachine.to(sm, `disposed`);\n      }\n      //if (!reading) return;\n      if (sm.value === `stopping`) {\n        log(`read. sm.value = stopping`)\n        sm = StateMachine.to(sm, `idle`);\n        return;\n      }\n      if (sm.value === `disposed`) {\n        log(`read. sm.value = disposed`);\n        return;\n      }\n      events.set(v.value);\n\n    } catch (error) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      events.dispose(`Generator error: ${ (error as any).toString() }`);\n      return;\n    }\n    //if (events.isDisposed()) return;\n    //if (!reading) return;\n\n    if (sm.value === `processing_result`) {\n      sm = StateMachine.to(sm, `queued`);\n      log(`scheduling read. State: ${ sm.value }`);\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      setTimeout(read, readIntervalMs);\n    } else {\n      sm = StateMachine.to(sm, `idle`);\n    }\n  }\n\n  const events = initLazyStream<V>({\n    ...options,\n    lazy,\n    onStart() {\n      log(`onStart state: ${ sm.value } whenStopped: ${ whenStopped }`);\n      if (sm.value !== `idle`) return;\n      if ((sm.value === `idle` && whenStopped === `reset`) || iterator === undefined) {\n        iterator = isAsyncIterable(source) ? source[ Symbol.asyncIterator ]() : source[ Symbol.iterator ]();\n      }\n      //reading = true;\n      void read();\n    },\n    onStop() {\n      log(`onStop state: ${ sm.value } whenStopped: ${ whenStopped }`);\n      //reading = false;\n      sm = StateMachine.to(sm, `stopping`);\n      if (whenStopped === `reset`) {\n        log(`onStop reiniting iterator`);\n        iterator = isAsyncIterable(source) ? source[ Symbol.asyncIterator ]() : source[ Symbol.iterator ]();\n      }\n    },\n    onDispose(reason: string) {\n      log(`onDispose (${ reason })`);\n      ourAc?.abort(`Rx.From.iterator disposed (${ reason })`);\n      if (options.signal) options.signal.removeEventListener(`abort`, onExternalSignal);\n    },\n  });\n\n  // const readingStart = () => {\n\n  // }\n  //if (!lazy) readingStart();\n\n  // return {\n  //   on: events.on,\n  //   value: events.value,\n  //   dispose: events.dispose,\n  //   isDisposed: events.isDisposed\n  // }\n  return events;\n}\n","import { isAsyncIterable, isIterable } from \"@ixfx/iterables\";\nimport { func } from \"./from/function.js\";\nimport { iterator } from \"./from/iterator.js\";\nimport type { GeneratorOptions, FunctionOptions } from \"./from/types.js\";\nimport type { Reactive, ReactiveOrSource } from \"./types.js\";\nimport { isReactive, isWrapped } from \"./util.js\";\n\nexport type ResolveSourceOptions = {\n  /**\n   * Options when creating a reactive from a generator\n   * Default:  `{ lazy: true, interval: 5 }`\n   */\n  generator: GeneratorOptions\n  /**\n   * Options when creating a reactive from a function.\n   */\n  function: FunctionOptions\n}\n\n/**\n * Resolves various kinds of sources into a Reactive.\n * If `source` is an iterable/generator, it gets wrapped via `generator()`.\n * \n * Default options:\n * * generator: `{ lazy: true, interval: 5 }`\n * @param source \n * @returns \n */\nexport const resolveSource = <V>(source: ReactiveOrSource<V>, options: Partial<ResolveSourceOptions> = {}): Reactive<V> => {\n  if (isReactive(source)) return source;\n  const generatorOptions = options.generator ?? { lazy: `initial`, interval: 5 }\n  const functionOptions = options.function ?? { lazy: `very` }\n\n  if (Array.isArray(source)) {\n    return iterator(source.values(), generatorOptions);\n  } else if (typeof source === `function`) {\n    return func<V>(source, functionOptions)\n  } else if (typeof source === `object`) {\n    //console.log(`resolveSource is object`);\n    if (isWrapped<V>(source)) {\n      //console.log(`resolveSource is object - wrapped`);\n      return source.source;\n    }\n    if (isIterable(source) || isAsyncIterable(source)) {\n      //console.log(`resolveSource is object - iterable`);\n      return iterator(source, generatorOptions);\n    }\n  }\n  throw new TypeError(`Unable to resolve source. Supports: array, Reactive, Async/Iterable. Got type: ${ typeof source }`);\n}","import type { Reactive } from \"./types.js\";\n\n/**\n * A stream that caches its last value\n */\nexport type CacheStream<T> = {\n  /**\n   * Clears the last cached value\n   * @returns \n   */\n  resetCachedValue: () => void\n  /**\n   * Gets the cached value, if available\n   * @returns \n   */\n  last: () => T | undefined\n}\n\n/**\n * A {@link CacheStream} with an initial value\n */\nexport type CacheStreamInitial<T> = CacheStream<T> & {\n  last: () => T\n}\n\n/**\n * Wraps an input stream to cache values, and provide an initial value\n * @param r Input stream\n * @param initialValue Initial value\n */\nexport function cache<TValue, RT extends Reactive<TValue>>(r: RT, initialValue: TValue): CacheStreamInitial<TValue> & RT;\n\n/**\n * Wrapes an input stream to cache values, optionally providing an initial value\n * @param r \n * @param initialValue \n * @returns \n */\nexport function cache<TValue, RT extends Reactive<TValue>>(r: RT, initialValue: TValue | undefined): CacheStream<TValue> & RT {\n  let lastValue: TValue | undefined = initialValue;\n  r.onValue(value => {\n    lastValue = value;\n  });\n  return {\n    ...r,\n    last() {\n      return lastValue\n    },\n    resetCachedValue() {\n      lastValue = undefined;\n    }\n  }\n}","import { type Dispatch, DispatchList } from \"@ixfx/flow\";\nimport { resolveSource } from \"./resolve-source.js\";\nimport type { InitLazyStreamInitedOptions, InitLazyStreamOptions, InitStreamOptions, Passed, ReactiveInitialStream, ReactiveOrSource, ReactiveStream, SignalKinds, UpstreamOptions } from \"./types.js\";\nimport { messageHasValue, messageIsSignal } from \"./util.js\";\nimport { cache } from \"./cache.js\";\n\n\n/**\n * Initialise a stream based on an upstream source.\n * Calls initLazyStream under the hood.\n * \n * Options:\n * * onValue: called when upstream emits a value (default: does nothing with upstream value)\n * * lazy: laziness of stream (default: 'initial')\n * * disposeIfSourceDone: disposes stream if upstream disposes (default: true)\n * @ignore\n * @param upstreamSource \n * @param options \n * @returns \n */\nexport function initUpstream<In, Out>(upstreamSource: ReactiveOrSource<In>, options: Partial<UpstreamOptions<In>>): ReactiveStream<Out> {\n  const lazy = options.lazy ?? `initial`;\n  const disposeIfSourceDone = options.disposeIfSourceDone ?? true;\n  const onValue = options.onValue ?? ((_v: In) => {/** no-op */ })\n  const source = resolveSource(upstreamSource);\n  let unsub: undefined | (() => void);\n  const debugLabel = options.debugLabel ? `[${ options.debugLabel }]` : ``;\n  //console.log(`initUpstream${ debugLabel } creating`);\n\n  const onStop = () => {\n    //console.log(`Rx.initStream${ debugLabel } stop`);\n    if (unsub === undefined) return;\n    unsub();\n    unsub = undefined;\n    if (options.onStop) options.onStop();\n  }\n\n  const onStart = () => {\n    //console.log(`Rx.initStream${ debugLabel } start unsub ${ unsub !== undefined }`);\n    if (unsub !== undefined) return;\n    if (options.onStart) options.onStart();\n\n    unsub = source.on(value => {\n      //console.log(`Rx.initStream${ debugLabel } onValue`, value);\n      if (messageIsSignal(value)) {\n        if (value.signal === `done`) {\n          onStop();\n          events.signal(value.signal, value.context);\n          if (disposeIfSourceDone) events.dispose(`Upstream source ${ debugLabel } has completed (${ value.context ?? `` })`);\n        } else {\n          //events.through_(value);\n          events.signal(value.signal, value.context);\n        }\n      } else if (messageHasValue(value)) {\n        //lastValue = value.value;\n        onValue(value.value);\n      }\n    });\n  }\n\n\n\n  //const initOpts = \n  // const events:ReactiveInitialStream<Out>|ReactiveStream<Out> = ((`initialValue` in options) && options.initialValue !== undefined) ?\n  //   initLazyStreamWithInitial<Out>({ ...initOpts, initialValue: options.initialValue }) :\n  //   initLazyStream<Out>(initOpts);\n  //console.log(`initUpstream${ debugLabel } creating initLazyStream`);\n\n  const events = initLazyStream<Out>({\n    ...options,\n    lazy,\n    onStart,\n    onStop\n  });\n  return events;\n}\n\n/**\n * Initialises a lazy stream with an initial value.\n * Uses {@link initLazyStream} and {@link cache} together.\n * @param options \n * @returns \n */\nexport function initLazyStreamWithInitial<V>(options: InitLazyStreamInitedOptions<V>): ReactiveInitialStream<V> {\n  const r = initLazyStream<V>(options);\n  const c = cache<V, typeof r>(r, options.initialValue);\n  return c;\n}\n\n/**\n * Initialises a lazy stream\n * Consider also: {@link initLazyStreamWithInitial}\n * \n * @param options \n * @returns \n */\nexport function initLazyStream<V>(options: InitLazyStreamOptions): ReactiveStream<V> {\n  const lazy = options.lazy ?? `initial`;\n  const onStop = options.onStop ?? (() => { /* no-op*/ })\n  const onStart = options.onStart ?? (() => {/* no-op*/ })\n  const debugLabel = options.debugLabel ? `[${ options.debugLabel }]` : ``;\n  const events = initStream<V>({\n    ...options,\n    onFirstSubscribe() {\n      if (lazy !== `never`) {\n        //console.log(`initLazyStream${ debugLabel } onFirstSubscribe, lazy: ${ lazy }. Calling onStart`);\n        onStart();\n      }\n    },\n    onNoSubscribers() {\n      if (lazy === `very`) {\n        //console.log(`initLazyStream${ debugLabel } onNoSubscribers, lazy: ${ lazy }. Calling onStop`);\n        onStop();\n      }\n    },\n  });\n  if (lazy === `never`) onStart();\n  return events;\n}\n\n/**\n * Initialises a new stream.\n * \n * Options:\n * * onFirstSubscribe: Called when there is a subscriber after there have been no subscribers.\n * * onNoSubscribers: Called when there are no more subscribers. 'onFirstSubscriber' will be called next time a subscriber is added.\n * \n * Alternatives:\n * * {@link initLazyStream} - a stream with callbacks for when there is some/none subscribers\n * @ignore\n * @param options \n * @returns \n */\nexport function initStream<V>(options: Partial<InitStreamOptions> = {}): ReactiveStream<V> {\n  let dispatcher: DispatchList<Passed<V>> | undefined;\n  let disposed = false;\n  let firstSubscribe = false;\n  let emptySubscriptions = true;\n  const onFirstSubscribe = options.onFirstSubscribe ?? undefined;\n  const onNoSubscribers = options.onNoSubscribers ?? undefined;\n  const debugLabel = options.debugLabel ? `[${ options.debugLabel }]` : ``;\n\n  const isEmpty = () => {\n    if (dispatcher === undefined) return;\n    if (!dispatcher.isEmpty) return;\n    if (!emptySubscriptions) {\n      emptySubscriptions = true;\n      firstSubscribe = false;\n      if (onNoSubscribers) onNoSubscribers();\n    }\n  }\n\n  const subscribe = (handler: Dispatch<Passed<V>>) => {\n    if (disposed) throw new Error(`Disposed, cannot subscribe ${ debugLabel }`);\n    if (dispatcher === undefined) dispatcher = new DispatchList();\n    //console.log(`initStream${ debugLabel } subscribe handler:`, handler);\n    const id = dispatcher.add(handler);\n    emptySubscriptions = false;\n    if (!firstSubscribe) {\n      firstSubscribe = true;\n      //if (onFirstSubscribe) setTimeout(() => { onFirstSubscribe() }, 10);\n      if (onFirstSubscribe) onFirstSubscribe();\n    }\n    return () => {\n      dispatcher?.remove(id);\n      isEmpty();\n    }\n  }\n\n  return {\n    dispose: (reason: string) => {\n      if (disposed) return;\n      dispatcher?.notify({ value: undefined, signal: `done`, context: `Disposed: ${ reason }` });\n      disposed = true;\n      if (options.onDispose) options.onDispose(reason);\n    },\n    isDisposed: () => {\n      return disposed\n    },\n    removeAllSubscribers: () => {\n      dispatcher?.clear();\n      isEmpty();\n    },\n    set: (v: V) => {\n      if (disposed) throw new Error(`${ debugLabel } Disposed, cannot set`);\n      dispatcher?.notify({ value: v });\n    },\n    // through: (pass: Passed<V>) => {\n    //   if (disposed) throw new Error(`Disposed, cannot through`);\n    //   dispatcher?.notify(pass)\n    // },\n    signal: (signal: SignalKinds, context?: string) => {\n      if (disposed) throw new Error(`${ debugLabel } Disposed, cannot signal`);\n      dispatcher?.notify({ signal, value: undefined, context });\n    },\n    on: (handler: Dispatch<Passed<V>>) => subscribe(handler),\n    onValue: (handler: (value: V) => void) => {\n      const unsub = subscribe(message => {\n        //console.log(`initStream${ debugLabel } onValue wrapper`, message);\n        if (messageHasValue(message)) {\n          handler(message.value);\n        }\n      });\n      return unsub;\n    }\n  }\n}\n","import { setProperty } from \"@ixfx/dom\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport type { ReactiveOrSource } from \"../types.js\";\n\nexport type SetHtmlOptionsQuery = {\n  query: string\n}\n\nexport type SetHtmlOptionsElement = {\n  el: HTMLElement\n}\n\nexport type SetHtmlOptions = (SetHtmlOptionsQuery | SetHtmlOptionsElement) & {\n  /**\n   * If _true_ .innerHTML is used\n   * If _false_ (default) .textContent is used\n   */\n  asHtml?: boolean;\n};\n\n/**\n * Values from `input` are set to the textContent/innerHTML of an element.\n * ```js\n * const rxSource = Rx.From.string('hello');\n * const rxSet = Rx.Sinks.setHtmlText(rxSource, { query: })\n * ```\n * @param rxOrSource \n * @param optionsOrElementOrQuery \n */\nexport const setHtmlText = (rxOrSource: ReactiveOrSource<any>, optionsOrElementOrQuery: SetHtmlOptions | string | HTMLElement) => {\n  let el: HTMLElement | null | undefined;\n  let options: SetHtmlOptions | undefined;\n  if (typeof optionsOrElementOrQuery === `string`) {\n    options = { query: optionsOrElementOrQuery };\n  }\n  if (typeof optionsOrElementOrQuery === `object`) {\n\n    if (`nodeName` in optionsOrElementOrQuery) {\n      options = { el: optionsOrElementOrQuery };\n    } else {\n      options = optionsOrElementOrQuery;\n    }\n  }\n  if (options === undefined) throw new TypeError(`Missing element as second parameter or option`);\n  if (`el` in options) {\n    el = options.el;\n  } else if (`query` in options) {\n    el = document.querySelector<HTMLElement>(options.query);\n  } else {\n    throw new TypeError(`Options does not include 'el' or 'query' fields`);\n  }\n  if (el === null || el === undefined) throw new Error(`Element could not be resolved.`);\n\n  const stream = resolveSource(rxOrSource);\n  const setter = setProperty(options.asHtml ? `innerHTML` : `textContent`, el);\n  const off = stream.onValue(value => {\n    setter(value)\n  });\n  return off;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport type { Reactive, ReactiveStream } from \"./types.js\";\n\n/***\n * Returns a read-only version of `stream`\n */\nexport const toReadable = <V>(stream: ReactiveStream<V>): Reactive<V> => ({\n  on: stream.on,\n  dispose: stream.dispose,\n  isDisposed: stream.isDisposed,\n  onValue: stream.onValue\n});\n","import { initUpstream } from \"../init-stream.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveOp } from \"../types.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport type { TransformOpts } from \"./types.js\";\nimport { resolveSource, syncToObject } from \"../index.js\";\n\n/**\n * Annotates values from `source`. Output values will be\n * in the form `{ value: TIn, annotation: TAnnotation }`.\n * Where `TIn` is the type of the input, and `TAnnotation` is\n * the return type of the annotator function.\n * \n * Example calculating area from width & height:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const annotated = Rx.Ops.annotate(data, v => {\n *  return { area: v.w * v.h }\n * });\n * const data = await Rx.toArray(annotated);\n * // Data =  [ { value: { w:1, h:3 }, annotation: { area:3 } } ...]\n * ```\n * \n * If you would rather annotate and have values merge with the input,\n * use `transform`:\n * ```js\n * const data = Rx.From.array(\n *  { w: 1, h: 3 }, { w: 1, h: 1 }, { w: 2, h: 2 }\n * );\n * const withArea = Rx.Ops.transform(data, v => {\n *  return { ...v, area: v.w * v.h }\n * });\n * const data = await Rx.toArray(withArea);\n * // Data =  [ { w:1, h:3, area:3 }, ...]\n * ```\n */\nexport function annotate<In, TAnnotation>(input: ReactiveOrSource<In>, annotator: (value: In) => TAnnotation, options: Partial<TransformOpts> = {}): Reactive<{ value: In, annotation: TAnnotation }> {\n  const upstream = initUpstream<In, { value: In, annotation: TAnnotation }>(input, {\n    ...options,\n    onValue(value) {\n      const annotation = annotator(value);\n      upstream.set({ value, annotation });\n    },\n  })\n  return toReadable(upstream);\n}\n\n/**\n * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n * \n * ```js\n * const data = Rx.From.array([ 1, 2, 3 ]);\n * const annotated = Rx.Ops.annotateWithOp(data, Rx.Ops.sum());\n * const data = await annotated.toArray(annotated);\n * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n * ```\n * @param annotatorOp Operator to generate annotations\n * @param input Input stream\n * @returns \n */\nexport function annotateWithOp<In, TAnnotation>(input: ReactiveOrSource<In>, annotatorOp: ReactiveOp<In, TAnnotation>): Reactive<{ value: In, annotation: TAnnotation }> {\n\n  const inputStream = resolveSource(input);\n\n  // Create annotations from input\n  const stream = annotatorOp(inputStream);\n\n  const synced = syncToObject({\n    value: inputStream,\n    annotation: stream\n  })\n  return synced as Reactive<{ value: In, annotation: TAnnotation }>;\n}\n\n","import { QueueMutable } from \"@ixfx/collections\";\nimport { timeout } from \"@ixfx/flow\";\nimport { initUpstream } from \"../init-stream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../types.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport type { ChunkOptions } from \"./types.js\";\n\n/**\n * Queue from `source`, emitting when thresholds are reached. \n * The resulting Reactive produces arrays.\n * \n * Can use a combination of elapsed time or number of data items.\n * \n * By default options are OR'ed together.\n *\n * ```js\n * // Emit data in chunks of 5 items\n * chunk(source, { quantity: 5 });\n * // Emit a chunk of data every second\n * chunk(source, { elapsed: 1000 });\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport function chunk<V>(source: ReactiveOrSource<V>, options: Partial<ChunkOptions> = {}): Reactive<V[]> {\n  const queue = new QueueMutable<V>();\n  const quantity = options.quantity ?? 0;\n  const returnRemainder = options.returnRemainder ?? true;\n\n  const upstreamOpts = {\n    ...options,\n    onStop() {\n      if (returnRemainder && !queue.isEmpty) {\n        const data = queue.toArray();\n        queue.clear();\n        upstream.set(data);\n      }\n    },\n    onValue(value: V) {\n      queue.enqueue(value);\n      if (quantity > 0 && queue.length >= quantity) {\n        // Reached quantity limit\n        send();\n      }\n      // Start timer\n      if (timer !== undefined && timer.runState === `idle`) {\n        timer.start();\n      }\n    },\n  }\n  const upstream = initUpstream<V, V[]>(source, upstreamOpts);\n\n  //let testElapsed = performance.now();\n  const send = () => {\n    //console.log(`Elapsed: ${ performance.now() - testElapsed }`);\n    //testElapsed = performance.now();\n    if (queue.isEmpty) return;\n\n    // Reset timer\n    if (timer !== undefined) timer.start();\n\n    // Fire queued data\n    const data = queue.toArray();\n    queue.clear();\n    setTimeout(() => { upstream.set(data); });\n  }\n\n  const timer = options.elapsed ? timeout(send, options.elapsed) : undefined\n\n  // const trigger = () => {\n  //   const now = performance.now();\n  //   let byElapsed = false;\n  //   let byLimit = false;\n  //   if (elapsed > 0 && (now - lastFire > elapsed)) {\n  //     lastFire = now;\n  //     byElapsed = true;\n  //   }\n  //   if (limit > 0 && queue.length >= limit) {\n  //     byLimit = true;\n  //   }\n  //   if (logic === `or` && (!byElapsed && !byLimit)) return;\n  //   if (logic === `and` && (!byElapsed || !byLimit)) return;\n\n  //   send();\n  // }\n\n  return toReadable(upstream);\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport type { Reactive, ReactiveOrSource } from \"../types.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport type { TransformOpts } from \"./types.js\";\n\n/**\n * Transforms values from `source` using the `transformer` function.\n * @param transformer \n * @returns \n */\nexport function transform<In, Out>(input: ReactiveOrSource<In>, transformer: (value: In) => Out, options: Partial<TransformOpts> = {}): Reactive<Out> {\n  const traceInput = options.traceInput ?? false;\n  const traceOutput = options.traceOutput ?? false;\n\n  const upstream = initUpstream<In, Out>(input, {\n    lazy: `initial`,\n    ...options,\n    onValue(value) {\n      const t = transformer(value);\n      if (traceInput && traceOutput) {\n        console.log(`Rx.Ops.transform input: ${ JSON.stringify(value) } output: ${ JSON.stringify(t) }`);\n      } else if (traceInput) {\n        console.log(`Rx.Ops.transform input: ${ JSON.stringify(value) }`);\n      } else if (traceOutput) {\n        console.log(`Rx.Ops.transform output: ${ JSON.stringify(t) }`);\n      }\n\n      upstream.set(t);\n    },\n  })\n  return toReadable(upstream);\n}\n\n","\nimport { testPlainObjectOrPrimitive } from \"@ixfx/guards\";\nimport type { ReactiveOrSource } from \"../types.js\";\nimport { transform } from \"./transform.js\";\n\n/**\n * Create a new object from input, based on cloning fields rather than a destructured copy.\n * This is useful for event args.\n * @param source \n * @returns \n */\nexport const cloneFromFields = <In>(source: ReactiveOrSource<In>) => {\n  return transform<In, In>(source, (v): In => {\n    const entries: [ key: string, value: any ][] = [];\n    for (const field in v) {\n      const value = (v)[ field ];\n      if (testPlainObjectOrPrimitive(value as unknown)) {\n        entries.push([ field, value ]);\n      }\n    }\n    return Object.fromEntries(entries) as In;\n  })\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport type { ReactiveOrSource, CombineLatestOptions, Reactive, RxValueTypes } from \"../types.js\";\nimport { messageIsDoneSignal, messageHasValue } from \"../util.js\";\n\n/**\n * Monitors input reactive values, storing values as they happen to an array.\n * Whenever a new value is emitted, the whole array is sent out, containing current\n * values from each source, or _undefined_ if not yet emitted.\n * \n * See {@link combineLatestToObject} to combine streams by name into an object, rather than array.\n * \n * ```\n * const sources = [\n *  Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToArray(sources);\n * r.onValue(value => {\n *  // Value will be an array of last value from each source:\n *  // [number,number]  \n * });\n * ```\n * \n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToArray} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n * \n * Set `onSourceDone` to choose behaviour if a source stops. By default it\n * is 'break', meaning the whole merged stream stops.\n * \n * Note: unlike RxJS's `combineLatest`, does not wait for each source to emit once\n * before emitting first value.\n * @param reactiveSources Sources to merge\n * @param options Options for merging \n * @returns \n */\nexport function combineLatestToArray<const T extends readonly ReactiveOrSource<any>[]>(reactiveSources: T, options: Partial<CombineLatestOptions> = {}): Reactive<RxValueTypes<T>> {\n  const event = initStream<RxValueTypes<T>>();\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const data: (RxValueTypes<T> | undefined)[] = [];\n  const sources = reactiveSources.map(source => resolveSource(source));\n  const noop = () => {/** no-op */ };\n  const sourceOff = sources.map(_ => noop);\n  const doneSources = sources.map(_ => false);\n\n  const unsub = () => {\n    for (const v of sourceOff) { v() }\n  }\n\n  for (const [ index, v ] of sources.entries()) {\n    data[ index ] = undefined;\n    sourceOff[ index ] = v.on(message => {\n      if (messageIsDoneSignal(message)) {\n        doneSources[ index ] = true;\n        sourceOff[ index ]();\n        sourceOff[ index ] = noop;\n        if (onSourceDone === `break`) {\n          unsub();\n          event.dispose(`Source has completed and 'break' is set`);\n          return;\n        }\n        if (!doneSources.includes(false)) {\n          // All sources are done\n          unsub();\n          event.dispose(`All sources completed`);\n        }\n      } else if (messageHasValue(message)) {\n        data[ index ] = message.value;\n        event.set([ ...data ] as RxValueTypes<T>);\n      }\n    });\n  }\n\n  return {\n    dispose: event.dispose,\n    isDisposed: event.isDisposed,\n    on: event.on,\n    onValue: event.onValue\n  }\n}\n","\nimport { DispatchList } from \"@ixfx/flow\";\nimport * as Pathed from \"@ixfx/core/records\";\nimport { initStream } from \"../init-stream.js\";\nimport type { ObjectFieldHandler, ReactiveDiff, ReactiveInitial, ReactiveNonInitial } from \"../types.js\";\nimport type { ObjectOptions } from \"./types.js\";\nimport { isEqualContextString } from \"@ixfx/core\";\nimport { wildcard } from \"@ixfx/core/text\";\nimport { resultIsError, resultThrow, resultThrowSingle, resultToError } from \"@ixfx/guards\";\n\nexport function object<V extends Record<string, any>>(initialValue: V, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveInitial<V>;\nexport function object<V extends Record<string, any>>(initialValue: undefined, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveNonInitial<V>;\n\n\n/**\n * Creates a Reactive wrapper with the shape of the input object.\n * \n * Changing the wrapped object directly does not update the Reactive. \n * Instead, to update values use:\n * * `set()`, 'resets' the whole object\n * * `update()` changes a particular field\n * \n * Consider using {@link From.objectProxy} to return a object with properties that can be\n * set in the usual way yet is also Reactive.\n * \n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onValue(changed => {\n * });\n * o.set({ name: `mary`, level: 3 });\n * \n * // `onValue` will get called, with `changed` having a value of:\n * // { name: `mary`, level: 3 }\n * ```\n * \n * Use `last()` to get the most recently set value.\n * \n * `onDiff` subscribes to a rough diff of the object.\n * \n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onDiff(diffValue => {\n *  const diff = diffValue.value;\n * })\n * o.set({ name: `mary`, level: 3 });\n * \n * // onDiff would fire with `diff` of:\n * [\n *  { path: `name`, previous: `bob`, value: `mary` },\n *  { path: `level`, previous: 2, value: 3 }\n * ]\n * ```\n * \n * You can also listen to updates on a field via `onField`.\n * ```js\n * o.onField(`name`, value => {\n *  // Called whenever the 'name' field is updated\n * });\n * ```\n * @param initialValue  Initial value\n * @param options Options\n * @returns \n */\nexport function object<V extends Record<string, any>>(initialValue?: V, options: Partial<ObjectOptions<V>> = {}): ReactiveDiff<V> & (ReactiveInitial<V> | ReactiveNonInitial<V>) {\n  const eq = options.eq ?? isEqualContextString;\n  const setEvent = initStream<V>();\n  const diffEvent = initStream<Pathed.PathDataChange<any>[]>();\n\n  //const fieldChangeEvents = new Map<string, DispatchList<ObjectFieldHandler>>;\n  const fieldChangeEvents: [ matcher: (value: string) => boolean, pattern: string, DispatchList<ObjectFieldHandler> ][] = [];\n\n  let value: V | undefined = initialValue;\n  let disposed = false;\n\n  const set = (v: V) => {\n    const diff = [ ...Pathed.compareData(value ?? {} as V, v, { ...options, includeMissingFromA: true }) ];\n    if (diff.length === 0) return;\n    value = v;\n    setEvent.set(v);\n    diffEvent.set(diff);\n  }\n\n  const fireFieldUpdate = (field: string, value: any) => {\n    for (const [ matcher, pattern, list ] of fieldChangeEvents) {\n      if (matcher(field)) {\n        list.notify({ fieldName: field, pattern, value });\n      }\n    }\n    //const l = fieldChangeEvents.get(field.toLowerCase());\n    //if (l === undefined) return;\n    //l.notify(value);\n  }\n\n  const updateCompareOptions: Partial<Pathed.CompareDataOptions<V>> = {\n    asPartial: true,\n    includeParents: true\n  }\n\n  const update = (toMerge: Partial<V>) => {\n    //console.log(`Rx.From.object update: toMerge: ${ JSON.stringify(toMerge) } value: ${ JSON.stringify(value) }`);\n\n    if (value === undefined) {\n      value = toMerge as V;\n      setEvent.set(value);\n      for (const [ k, v ] of Object.entries(toMerge as V)) {\n        fireFieldUpdate(k, v);\n      }\n      return value;\n    } else {\n      const diff = [ ...Pathed.compareData(value, toMerge, updateCompareOptions) ];\n      //const diffWithoutRemoved = diff.filter(d => d.state !== `removed`);\n      if (diff.length === 0) return value; // No changes\n      value = {\n        ...value,\n        ...toMerge\n      }\n      setEvent.set(value);\n      diffEvent.set(diff);\n      //console.log(`diff`, diff);\n      for (const d of diff) {\n        fireFieldUpdate(d.path, d.value);\n      }\n      return value;\n    }\n  }\n\n  const updateField = (path: string, valueForField: any) => {\n    if (value === undefined) throw new Error(`Cannot update value when it has not already been set`);\n    //console.log(`Rx.Sources.Object.updateField path: ${ path } value: ${ JSON.stringify(valueForField) }`);\n\n    const existing = Pathed.getField<any>(value, path);\n    //resultThrowSingle(existing);\n    if (resultIsError(existing)) {\n      throw resultToError(existing);\n    }\n\n    //console.log(`Rx.fromObject.updateField path: ${ path } existing: ${ JSON.stringify(existing) }`);\n    if (eq(existing.value, valueForField, path)) {\n      //console.log(`Rx.object.updateField identical existing: ${ existing } value: ${ valueForField } path: ${ path }`);\n      return;\n    }\n    let diff = [ ...Pathed.compareData(existing.value, valueForField, { ...options, includeMissingFromA: true }) ];\n    diff = diff.map(d => {\n      if (d.path.length > 0) return { ...d, path: path + `.` + d.path };\n      return { ...d, path };\n    })\n\n    //console.log(`Rx.fromObject.updateField diff path: ${ path }`, diff);\n    const o = Pathed.updateByPath(value, path, valueForField, true);\n    value = o;\n    //diffEvent.set([ { path, value: valueForField, previous: existing } ]);\n\n    setEvent.set(o);\n    diffEvent.set(diff);\n    fireFieldUpdate(path, valueForField);\n    //console.log(`Rx.fromObject.updateField: path: '${ path }' value: '${ JSON.stringify(valueForField) }' o: ${ JSON.stringify(o) }`);\n  }\n\n  const dispose = (reason: string) => {\n    if (disposed) return;\n    diffEvent.dispose(reason);\n    setEvent.dispose(reason);\n    disposed = true;\n  }\n\n  return {\n    dispose,\n    isDisposed() {\n      return disposed\n    },\n    /**\n     * Update a field.\n     * Exception is thrown if field does not exist\n     */\n    updateField,\n    last: () => value,\n    on: setEvent.on,\n    onValue: setEvent.onValue,\n    onDiff: diffEvent.onValue,\n    onField(fieldPattern: string, handler: (result: ObjectFieldHandler) => void) {\n      const matcher = wildcard(fieldPattern);\n      const listeners = new DispatchList<ObjectFieldHandler>();\n      fieldChangeEvents.push([ matcher, fieldPattern, listeners ]);\n      const id = listeners.add(handler);\n      return () => listeners.remove(id);\n      // let listeners = fieldChangeEvents.get(fieldName.toLowerCase());\n      // if (listeners === undefined) {\n      //   listeners = new DispatchList();\n      //   fieldChangeEvents.set(fieldName.toLowerCase(), listeners);\n      // }\n      // const id = listeners.add((value) => {\n      //   setTimeout(() => { handler(value, fieldName) }, 1);\n      // });\n      // return () => listeners.remove(id);\n    },\n    /**\n     * Set the whole object\n     */\n    set,\n    /**\n     * Update the object with a partial set of fields and values\n     */\n    update\n  }\n}\n","\nimport * as MapFns from \"@ixfx/core/maps\"\nimport { resolveSource } from \"../resolve-source.js\"\nimport type { ReactiveOrSource, CombineLatestOptions, Reactive, RxValueTypeObject, ReactiveInitial, RxValueTypeRx, ReactiveDiff } from \"../types.js\"\nimport { messageIsDoneSignal, messageHasValue, isWritable } from \"../util.js\"\nimport { object } from \"../from/object.js\"\n\nexport type CombineLatestToObject<T extends Record<string, ReactiveOrSource<any>>> = {\n  hasSource: (field: string) => boolean,\n  replaceSource: (field: Extract<keyof T, string>, source: ReactiveOrSource<any>) => void\n  /**\n   * Reactive sources being combined\n   */\n  sources: RxValueTypeRx<T>\n  /**\n   * Updates writable sources with values.\n   * @param data \n   * @returns Keys and values set to writable source(s)\n   */\n  setWith: (data: Partial<RxValueTypeObject<T>>) => Partial<RxValueTypeObject<T>>\n} & ReactiveDiff<RxValueTypeObject<T>> & ReactiveInitial<RxValueTypeObject<T>>;\n\n/**\n * Monitors input reactive values, storing values as they happen to an object.\n * Whenever a new value is emitted, the whole object is sent out, containing current\n * values from each source (or _undefined_ if not yet emitted)\n * \n * See {@link combineLatestToArray} to combine streams by name into an array instead.\n * \n * ```\n * const sources = {\n *  fast: Rx.fromFunction(Math.random, { loop: true, interval: 100 }),\n *  slow: Rx.fromFunction(Math.random, { loop: true, interval: 200 })\n * ];\n * const r = Rx.combineLatestToObject(sources);\n * r.onValue(value => {\n *  // 'value' will be an object containing the labelled latest\n *  // values from each source.\n *  // { fast: number, slow: number }\n * });\n * ```\n * \n * The tempo of this stream will be set by the fastest source stream.\n * See {@link syncToObject} to have pace determined by slowest source, and only\n * send when each source has produce a new value compared to last time.\n * \n * This source ends if all source streams end.\n * @param reactiveSources Sources to merge\n * @param options Options for merging \n * @returns \n */\nexport function combineLatestToObject<const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<CombineLatestOptions> = {}): CombineLatestToObject<T> {// { sources: RxValueTypeRx<T> } & Reactive<RxValueTypeObject<T>> & ReactiveInitial<RxValueTypeObject<T>> {\n  type State<V> = {\n    source: Reactive<V>\n    done: boolean\n    data: V | undefined\n    off: () => void\n  }\n  const disposeSources = options.disposeSources ?? true;\n  const event = object<RxValueTypeObject<T>>(undefined);\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const emitInitial = options.emitInitial ?? true;\n  let emitInitialDone = false;\n\n  const states = new Map<string, State<any>>();\n  for (const [ key, source ] of Object.entries(reactiveSources)) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const initialData = (`last` in source) ? (source as any).last() : undefined;\n    //console.log(`initialData: ${ initialData } src: ${ (source as any).last() }`);\n    const s: State<any> = {\n      source: resolveSource(source),\n      done: false,\n      data: initialData,\n      off: () => { /** no-op */ }\n    }\n    states.set(key, s);\n  }\n  const sources = Object.fromEntries(Object.entries(states).map(entry => [ entry[ 0 ], entry[ 1 ].source ])) as RxValueTypeRx<T>;\n\n  const someUnfinished = () => MapFns.some(states, v => !v.done);\n\n  const unsub = () => {\n    //console.log(`Rx.MergeToObject.unsub states: ${ [ ...states.keys() ].join(`,`) }`);\n    for (const state of states.values()) state.off();\n  }\n\n  const getData = () => {\n    const r = {};\n    for (const [ key, state ] of states) {\n      const d = state.data;\n      if (d !== undefined) {\n        (r as any)[ key ] = state.data;\n      }\n    }\n    //console.log(`Rx.Ops.CombineLatestToObject getData`, r);\n\n    return r as RxValueTypeObject<T>;\n  }\n\n  const trigger = () => {\n    emitInitialDone = true;\n    const d = getData();\n    //console.log(`Rx.Ops.combineLatestToObject trigger`, d);\n    event.set(d);\n  }\n\n  const wireUpState = (state: State<any>) => {\n    state.off = state.source.on(message => {\n      if (messageIsDoneSignal(message)) {\n        state.done = true;\n        state.off();\n        state.off = () => {/**no-op */ }\n        if (onSourceDone === `break`) {\n          unsub();\n          event.dispose(`Source has completed and 'break' is behaviour`);\n          return;\n        }\n        if (!someUnfinished()) {\n          // All sources are done\n          unsub();\n          event.dispose(`All sources completed`);\n        }\n      } else if (messageHasValue(message)) {\n        state.data = message.value;\n        trigger();\n      }\n    });\n  }\n\n  for (const state of states.values()) {\n    wireUpState(state);\n  }\n\n  if (!emitInitialDone && emitInitial) {\n    //console.log(`Rx.Ops.CombineLatestToObject emitting initial`);\n    trigger();\n  }\n  return {\n    ...event,\n    hasSource(field: string) {\n      return states.has(field)\n    },\n    replaceSource(field, source) {\n      const state = states.get(field);\n      if (state === undefined) throw new Error(`Field does not exist: '${ field }'`);\n      state.off();\n      const s = resolveSource(source);\n      state.source = s;\n      wireUpState(state);\n    },\n    setWith(data) {\n      const written = {};\n      for (const [ key, value ] of Object.entries(data)) {\n        const state = states.get(key);\n        if (state !== undefined) {\n          if (isWritable(state.source)) {\n            state.source.set(value);\n            (written as any)[ key ] = value;\n          }\n          state.data = value;\n        }\n      }\n      return written;\n    },\n    sources,\n    last() {\n      return getData()\n    },\n    dispose(reason: string) {\n      unsub();\n      event.dispose(reason);\n      if (disposeSources) {\n        for (const v of states.values()) {\n          v.source.dispose(`Part of disposed mergeToObject`)\n        }\n      }\n    }\n  }\n}","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport type { ReactiveOrSource, Reactive, ReactivePingable } from \"../types.js\";\nimport { hasLast } from \"../util.js\";\n\n/**\n * When there is a value from `input`, or the reactive is pinged,\n * this reactive emits the result of `fn`.\n * \n * `fn` is provided the previous value as well as the most recent value.\n * \n * If no previous value is available, the current value is emitted and `fn` is not called.\n * @param input \n * @param fn \n * @returns \n */\nexport function computeWithPrevious<TIn>(input: ReactiveOrSource<TIn>, fn: (previous: TIn, current: TIn) => TIn): ReactivePingable<TIn> {\n  let previousValue: TIn | undefined;\n  let currentValue: TIn | undefined;\n  if (hasLast(input)) {\n    currentValue = previousValue = input.last();\n  }\n\n  const trigger = () => {\n    if (previousValue === undefined && currentValue !== undefined) {\n      previousValue = currentValue;\n      upstream.set(previousValue);\n    } else if (previousValue !== undefined && currentValue !== undefined) {\n      const vv = fn(previousValue, currentValue);\n      //console.log(`vv: ${ vv } prev: ${ previousValue } target: ${ target }`)\n      previousValue = vv;\n      upstream.set(vv);\n    }\n  }\n\n  const upstream = initUpstream<TIn, TIn>(input, {\n    lazy: \"very\",\n    debugLabel: `computeWithPrevious`,\n    onValue(value) {\n      //console.log(`onValue ${ value }`);\n      currentValue = value;\n      trigger();\n    },\n  })\n  if (currentValue) trigger();\n\n  return {\n    ...toReadable(upstream),\n    ping: () => {\n      if (currentValue !== undefined) trigger()\n    }\n  }\n}","import { type Reactive, intervalToMs } from \"@ixfx/core\";\nimport { timeout } from \"@ixfx/flow\";\nimport { initUpstream } from \"../init-stream.js\";\nimport type { DebounceOptions } from \"../ops/types.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport type { ReactiveOrSource } from \"../types.js\";\n\n/**\n * Debounce waits for `elapsed` time after the last received value before emitting it.\n * \n * If a flurry of values are received that are within the interval, it won't emit anything. But then\n * as soon as there is a gap in the messages that meets the interval, the last received value is sent out.\n * \n * `debounce` always emits with at least `elapsed` as a delay after a value received. While {@link throttle} potentially\n * sends immediately, if it's outside of the elapsed period.\n * \n * This is a subtly different logic to {@link throttle}. `throttle` more eagerly sends the first value, potentially\n * not sending later values. `debouce` however will send later values, potentially ignoring earlier ones.\n * @param source \n * @param options \n * @returns \n */\nexport function debounce<V>(source: ReactiveOrSource<V>, options: Partial<DebounceOptions> = {}): Reactive<V> {\n  const elapsed = intervalToMs(options.elapsed, 50);\n  let lastValue: V | undefined;\n\n  const timer = timeout(() => {\n    const v = lastValue;\n    if (v) {\n      upstream.set(v);\n      lastValue = undefined;\n    }\n  }, elapsed);\n\n  const upstream = initUpstream<V, V>(source, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      timer.start();\n    }\n  });\n  return toReadable(upstream);\n}\n","import type { ReactiveOp, ReactiveOrSource } from \"../types.js\";\nimport type { DebounceOptions } from \"./types.js\";\nimport { debounce as  debounceReactive  } from \"../reactives/debounce.js\";\n\nexport function debounce<V>(options: Partial<DebounceOptions>): ReactiveOp<V, V>  {\n  return (source: ReactiveOrSource<V>) => {\n    return debounceReactive<V>(source, options);\n  }\n}\n","import type { ReactiveOrSource } from \"../types.js\";\nimport { transform } from \"./transform.js\";\n\n/**\n * Emits time in milliseconds since last message.\n * If it is the first value, 0 is used.\n * @param input \n * @returns \n */\nexport const elapsed = <In>(input: ReactiveOrSource<In>) => {\n  let last = 0;\n  return transform<In, number>(input, (_ignored) => {\n    const elapsed = last === 0 ? 0 : Date.now() - last;\n    last = Date.now();\n    return elapsed;\n  });\n}"," \nimport { initUpstream } from \"../init-stream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../types.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport type { FieldOptions } from \"./types.js\";\n\n/**\n * From a source value, yields a field from it. Only works\n * if stream values are objects.\n * \n * If a source value doesn't have that field, it is skipped.\n *\n * @returns \n */\nexport function field<TIn extends object, TFieldType>(fieldSource: ReactiveOrSource<TIn>, fieldName: keyof TIn, options: Partial<FieldOptions<TIn, TFieldType>> = {}): Reactive<TFieldType> {\n  const fallbackFieldValue = options.fallbackFieldValue;\n  const fallbackObject = options.fallbackObject;\n\n  const upstream = initUpstream<TIn, TFieldType>(fieldSource, {\n    disposeIfSourceDone: true,\n    ...options,\n    onValue(value) {\n      let v: TFieldType | undefined;\n      // 1. Try to read from value\n      if (fieldName in value) {\n        v = value[ fieldName ] as TFieldType;\n      } else if (fallbackObject && fieldName in fallbackObject) {\n        // 2. Read from fallback object\n        v = fallbackObject[ fieldName ] as TFieldType;\n      }\n      // 3. Use fallback value\n      if (v === undefined) {\n        v = fallbackFieldValue;\n      }\n      if (v !== undefined) {\n        upstream.set(v);\n      }\n    },\n  })\n  return toReadable(upstream);\n}","import { initUpstream } from \"../init-stream.js\";\nimport type { ReactiveOrSource, InitStreamOptions, Reactive } from \"../types.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport type { FilterPredicate } from \"./types.js\";\n\n/**\n * Passes all values where `predicate` function returns _true_.\n */\nexport function filter<In>(input: ReactiveOrSource<In>, predicate: FilterPredicate<In>, options: Partial<InitStreamOptions>): Reactive<In> {\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      if (predicate(value)) {\n        upstream.set(value);\n      }\n    },\n  })\n  return toReadable(upstream);\n}\n\n\n/**\n * Drops all values where `predicate` function returns _true_.\n */\nexport function drop<In>(input: ReactiveOrSource<In>, predicate: FilterPredicate<In>, options: Partial<InitStreamOptions>): Reactive<In> {\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      if (!predicate(value)) {\n        upstream.set(value);\n      }\n    },\n  })\n  return toReadable(upstream);\n}\n","import type { ReactiveOrSource, ReactivePingable } from \"../types.js\";\nimport { interpolate as interpolateFunction, type InterpolateOptions } from \"@ixfx/modulation\";\nimport { computeWithPrevious } from \"./compute-with-previous.js\";\n\nexport type OpInterpolateOptions = InterpolateOptions & {\n  amount: number\n  /**\n   * Percentage of value that we consider 'done'.\n   * Since interpolation can never converge to target exactly, this allows us to snap to completion.\n   * Default: 0.99, meaning if value gets to within 99%, return the target.\n   */\n  snapAt: number\n}\n\n/**\n * Interpolates to the source value.\n * \n * Outputs one value for every input value. Thus, to interpolation\n * over time, it's necessary to get the source to emit values at the desired rate.\n * \n * Options can specify an easing name or custom transform of easing progress.\n * @param input \n * @param options \n * @returns \n */\nexport function interpolate(input: ReactiveOrSource<number>, options: Partial<OpInterpolateOptions> = {}): ReactivePingable<number> {\n  const amount = options.amount ?? 0.1;\n  const snapAt = options.snapAt ?? 0.99;\n\n  const index = interpolateFunction(amount, options);\n\n  return computeWithPrevious<number>(input, (previous, target) => {\n    const v = index(previous, target);\n    if (target > previous) {\n      if (v / target >= snapAt) return target;\n    }\n    return v;\n  });\n}\n\n\n/**\n * From the basis of an input stream of values, run a function over\n * each value. The function takes in the last value from the stream as well as the current.\n * @param input\n * @param fn\n * @returns\n */\n// export function interpolateToTarget<TIn>(input: ReactiveOrSource<TIn>, fn: (previous: TIn, target: TIn) => TIn): ReactivePingable<TIn> {\n//   let previousValue: TIn | undefined;\n//   let target: TIn | undefined;\n//   if (hasLast(input)) {\n//     target = previousValue = input.last();\n//   }\n\n//   const ping = () => {\n//     if (previousValue === undefined && target !== undefined) {\n//       previousValue = target;\n//     } else if (previousValue !== undefined && target !== undefined) {\n//       previousValue = fn(previousValue, target);\n//     }\n//     upstream.set(previousValue!);\n//   }\n\n//   const upstream = initUpstream<TIn, TIn>(input, {\n//     lazy: \"very\",\n//     debugLabel: `computeWithPrevious`,\n//     onValue(value) {\n//       target = value;\n//       ping();\n//     },\n//   })\n//   if (target) ping();\n\n//   return {\n//     ...toReadable(upstream),\n//     ping: () => {\n//       if (target !== undefined) ping()\n//     }\n//   }\n// }","import { initUpstream } from \"../init-stream.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport type { Reactive, ReactiveOrSource } from \"../types.js\";\nimport * as Proc from '@ixfx/process';\nimport type { OpAsAnnotation, OpMathOptions } from \"./types.js\";\nimport type { RankFunction, RankOptions } from \"@ixfx/core\";\n\nexport function max(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function max(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, max: number }>;\nexport function max(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, max: number }> {\n  const p = Proc.max();\n  return process(p, `max`, input, options);\n}\n\nexport function min(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function min(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, min: number }>;\nexport function min(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, min: number }> {\n  const p = Proc.min();\n  return process(p, `min`, input, options);\n}\n\nexport function average(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function average(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, average: number }>;\nexport function average(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, average: number }> {\n  const p = Proc.average();\n  return process(p, `average`, input, options);\n}\n\nexport function sum(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number>;\nexport function sum(input: ReactiveOrSource<any>, options: OpAsAnnotation & OpMathOptions): Reactive<{ value: number, sum: number }>;\nexport function sum(input: ReactiveOrSource<any>, options: OpMathOptions): Reactive<number> | Reactive<{ value: number, sum: number }> {\n  const p = Proc.sum();\n  return process(p, `sum`, input, options);\n}\n\nexport type TallyOptions = OpMathOptions & {\n  countArrayItems: boolean\n}\n\nexport function tally(input: ReactiveOrSource<any>, options: Partial<TallyOptions>): Reactive<number>;\nexport function tally<TIn>(input: ReactiveOrSource<TIn>, options: OpAsAnnotation & Partial<TallyOptions>): Reactive<{ value: TIn, tally: number }>;\nexport function tally<TIn>(input: ReactiveOrSource<TIn>, options: Partial<TallyOptions> = {}): Reactive<number> | Reactive<{ value: TIn, tally: number }> {\n  const countArrayItems = options.countArrayItems ?? true;\n  const p = Proc.tally(countArrayItems);\n  return process(p, `tally`, input, options);\n}\n\nexport function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: Partial<RankOptions & OpMathOptions>): Reactive<TIn>;\nexport function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: OpAsAnnotation & Partial<RankOptions & OpMathOptions>): Reactive<{ value: TIn, rank: TIn }>;\nexport function rank<TIn>(input: ReactiveOrSource<any>, rank: RankFunction<TIn>, options: Partial<RankOptions & OpMathOptions>): Reactive<TIn> | Reactive<{ value: TIn, rank: TIn }> {\n  const p = Proc.rank(rank, options);\n  return process(p, `rank`, input, options);\n}\n\nfunction process(processor: Proc.Process<any, any>, annotationField: string, input: ReactiveOrSource<any>, options: OpMathOptions = {}) {\n  const annotate = options.annotate;\n  let previous: number | undefined;\n  const skipUndefined = options.skipUndefined ?? true;\n  const skipIdentical = options.skipIdentical ?? true;\n  const upstream = initUpstream<any, any>(input, {\n    ...options,\n    onValue(value) {\n      const x = processor(value);\n      if (x === undefined && skipUndefined) return;\n      if (skipIdentical && x === previous) return;\n      previous = x;\n      if (annotate) {\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        const ret: any = { value };\n        ret[ annotationField ] = x;\n        upstream.set(ret);\n      } else {\n        upstream.set(x);\n      }\n    },\n  })\n  return toReadable(upstream);\n}\n\n//todo testing for annotation and non - annotated\n\n\n// rankArray\n\n// chunk, reduce\n\n// debounce, delay\n\n// duration, take","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nimport type { PipeSet, Reactive, Passed } from \"../types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../util.js\";\n\n/**\n * Pipes the output of one stream into another, in order.\n * The stream returned is a new stream which captures the final output.\n * \n * If any stream in the pipe closes the whole pipe is closed.\n * @param streams \n * @returns \n */\nexport const pipe = <TInput, TOutput>(...streams: PipeSet<TInput, TOutput>): Reactive<TOutput> => {\n  const event = initStream<TOutput>();\n  const unsubs: (() => void)[] = [];\n  const performDispose = (reason: string) => {\n    for (const s of streams) {\n      if (!s.isDisposed) s.dispose(reason);\n    }\n    for (const s of unsubs) {\n      s();\n    }\n    event.dispose(reason);\n  }\n\n  for (let index = 0; index < streams.length; index++) {\n     \n    unsubs.push(streams[ index ].on((message: Passed<unknown>) => {\n      const isLast = index === streams.length - 1;\n      if (messageHasValue(message)) {\n        if (isLast) {\n          // Last stream, send to output\n          event.set(message.value as TOutput);\n        } else {\n          // @ts-expect-error\n           \n          streams[ index + 1 ].set(message.value);\n        }\n      } else if (messageIsDoneSignal(message)) {\n        performDispose(`Upstream disposed`);\n      }\n    }));\n  }\n  return {\n    on: event.on,\n    onValue: event.onValue,\n    dispose(reason) {\n      performDispose(reason);\n    },\n    isDisposed() {\n      return event.isDisposed();\n    },\n  };\n}","import { shuffle } from \"@ixfx/arrays\";\nimport { initUpstream } from \"../init-stream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../types.js\";\nimport type { SingleFromArrayOptions } from \"./types.js\";\n\n/**\n * For a stream that emits arrays of values, this op will select a single value.\n * \n * Can select based on:\n * * predicate: a function that returns _true_ for a value\n * * at: selection based on array index (can be combined with random ordering to select a random value)\n * \n * ```js\n * // If source is Reactive<Array<number>>, picks the first even number\n * singleFromArray(source, { \n *  predicate: v => v % 2 === 0\n * });\n * \n * // Selects a random value from source\n * singleFromArray(source, { \n *  order: `random`,\n *  at: 0\n * });\n * ```\n * \n * If neither `predicate` or `at` options are given, exception is thrown.\n * @param source Source to read from\n * @param options Options for selection\n * @returns \n */\nexport function singleFromArray<V>(source: ReactiveOrSource<V[]>, options: Partial<SingleFromArrayOptions<V>> = {}): Reactive<V> {\n  const order = options.order ?? `default`;\n  if (!options.at && !options.predicate) throw new Error(`Options must have 'predicate' or 'at' fields`);\n\n  let preprocess = (values: V[]) => values;\n  if (order === `random`) preprocess = shuffle;\n  else if (typeof order === `function`) preprocess = (values) => values.toSorted(order);\n\n  const upstream = initUpstream<V[], V>(source, {\n    onValue(values) {\n      values = preprocess(values);\n      if (options.predicate) {\n        for (const v of values) {\n          if (options.predicate(v)) {\n            upstream.set(v);\n          }\n        }\n      } else if (options.at) {\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        upstream.set(values.at(options.at)!);\n      }\n    },\n  });\n  return upstream;\n}\n","import { initUpstream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport type { ReactiveOrSource, ReactiveStream, Reactive } from \"../types.js\";\nimport type { SplitOptions } from \"./types.js\";\n\n/**\n * Creates a set of streams each of which receives data from `source`.\n * By default these are lazy and dispose if the upstream source closes.\n * \n * See also {@link splitLabelled} to split into named streams.\n * @param rxOrSource \n * @param options \n * @returns \n */\nexport const split = <T>(rxOrSource: ReactiveOrSource<T>, options: Partial<SplitOptions> = {}) => {\n  const quantity = options.quantity ?? 2;\n  const outputs: ReactiveStream<T>[] = [];\n  const source = resolveSource(rxOrSource);\n  for (let index = 0; index < quantity; index++) {\n    outputs.push(initUpstream(source, { disposeIfSourceDone: true, lazy: `initial` }));\n  }\n  return outputs;\n}\n\n/**\n * Splits `source` into several duplicated streams. \n * Returns an object with keys according to `labels`.\n * Each value is a stream which echos the values from `source`.\n * ```js\n * const { a, b, c} = splitLabelled(source, `a`, `b`, `c`);\n * // a, b, c are Reactive types\n * ```\n * \n * See also {@link split} to get an unlabelled split\n * @param rxOrSource \n * @param labels \n * @returns \n */\nexport const splitLabelled = <T, K extends PropertyKey>(rxOrSource: ReactiveOrSource<T>, labels: K[]): Record<K, Reactive<T>> => {\n  const source = resolveSource(rxOrSource);\n  const t: Partial<Record<K, Reactive<T>>> = {}\n  for (const label of labels) {\n    t[ label ] = initUpstream(source, { lazy: `initial`, disposeIfSourceDone: true });\n  }\n  return t as Record<K, Reactive<T>>;\n}","import { initStream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveStream } from \"../types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"../util.js\";\nimport type { FilterPredicate, SwitcherOptions } from \"./types.js\";\n\n/**\n * Switcher generates several output streams, labelled according to the values of `cases`.\n * Values from `source` are fed to the output streams if their associated predicate function returns _true_.\n * \n * In this way, we can split one input stream into several output streams, each potentially getting a different\n * subset of the input.\n * \n * With `options`, you can specify whether to send to multiple outputs if several match, or just the first (default behaviour).\n * \n * The below example shows setting up a switcher and consuming the output streams.\n * @example\n * ```js\n * // Initialise a reactive number, starting at 0\n * const switcherSource = Reactive.number(0);\n * // Set up the switcher\n * const x = Reactive.switcher(switcherSource, {\n *  even: v => v % 2 === 0,\n *  odd: v => v % 2 !== 0\n * });\n * // Listen for outputs from each of the resulting streams\n * x.even.on(msg => {\n *   log(`even: ${msg.value}`);\n * });\n * x.odd.on(msg => {\n *   log(`odd: ${msg.value}`);\n * })\n * // Set new values to the number source, counting upwards\n * // ...this will in turn trigger the outputs above\n * setInterval(() => {\n *   switcherSource.set(switcherSource.last() + 1);\n * }, 1000);\n * ```\n * \n * If `source` closes, all the output streams will be closed as well.\n * @param reactiveOrSource \n * @param cases \n * @param options \n * @returns \n */\nexport const switcher = <TValue, TRec extends Record<string, FilterPredicate<TValue>>, TLabel extends keyof TRec>(reactiveOrSource: ReactiveOrSource<TValue>, cases: TRec, options: Partial<SwitcherOptions> = {}): Record<TLabel, Reactive<TValue>> => {\n  // return (r: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n  const match = options.match ?? `first`;\n  const source = resolveSource(reactiveOrSource);\n  let disposed = false;\n  // Setup output streams\n  const t: Partial<Record<TLabel, ReactiveStream<TValue>>> = {}\n  for (const label of Object.keys(cases)) {\n    (t as any)[ label ] = initStream<TValue>();\n  }\n\n  const performDispose = () => {\n    if (disposed) return;\n    unsub();\n    disposed = true;\n    for (const stream of Object.values(t)) {\n      (stream as ReactiveStream<any>).dispose(`switcher source dispose`);\n    }\n  }\n\n  // Listen to source\n  const unsub = source.on(message => {\n    // Got a value\n    if (messageHasValue(message)) {\n      for (const [ lbl, pred ] of Object.entries(cases)) {\n        if (pred(message.value)) {\n          ((t as any)[ lbl ] as ReactiveStream<TValue>).set(message.value);\n          if (match === `first`) break;\n        }\n      }\n    } else if (messageIsDoneSignal(message)) {\n      performDispose();\n    }\n  })\n  return t as Record<TLabel, Reactive<TValue>>;\n  // }\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { intervalToMs } from \"@ixfx/core\";\nimport { initStream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport type { ReactiveOrSource, Reactive, RxValueTypes } from \"../types.js\";\nimport { messageIsSignal } from \"../util.js\";\nimport type { SyncOptions } from \"./types.js\";\n\n/**\n * Waits for all sources to produce a value, sending the combined results as an array.\n * After sending, it waits again for each source to send at least one value.\n * \n * Use {@link syncToObject} to output objects based on labelled sources rather than an array of values.\n * \n * Pace will be set by the slowest source. Alternatively, use {@link combineLatestToArray} where the rate is determined by fastest source.\n * \n * Only complete results are sent. For example if source A & B finish and source C is still producing values,\n * synchronisation is not possible because A & B stopped producing values. Thus the stream will self-terminate\n * after `maximumWait` (2 seconds). The newer values from C are lost.\n */\nexport function syncToArray<const T extends readonly ReactiveOrSource<any>[]>(reactiveSources: T, options: Partial<SyncOptions> = {}): Reactive<RxValueTypes<T>> {\n  const onSourceDone = options.onSourceDone ?? `break`;\n  const finalValue = options.finalValue ?? `undefined`;\n  const maximumWait = intervalToMs(options.maximumWait, 2000);\n\n  let watchdog: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  type State<V> = {\n    done: boolean,\n    finalData: V | undefined,\n    source: Reactive<V>\n    unsub: () => void\n  }\n\n  const data: (RxValueTypes<T> | undefined)[] = [];\n  //const finalData: Array<RxValueTypes<T> | undefined> = [];\n\n  // Resolve sources\n  //const sources = reactiveSources.map(source => resolveSource(source));\n  //const noop = () => {/*no-op*/ }\n  //const sourcesUnsub: Array<Unsubscriber> = sources.map(_ => noop);\n\n  const states: State<any>[] = reactiveSources.map(source => ({\n    finalData: undefined,\n    done: false,\n    source: resolveSource(source),\n    unsub: () => {/**no-op */ }\n  }));\n\n\n  const unsubscribe = () => {\n    for (const s of states) {\n      s.unsub();\n      s.unsub = () => {/**no-op */ }\n    }\n  }\n\n  const isDataSetComplete = () => {\n\n    for (let index = 0; index < data.length; index++) {\n      if (onSourceDone === `allow` && states[ index ].done) continue;\n      if (data[ index ] === undefined) return false;\n    }\n    return true;\n  }\n\n  const hasIncompleteSource = () => states.some(s => !s.done);\n  const resetDataSet = () => {\n    for (let index = 0; index < data.length; index++) {\n      if (finalValue === `last` && states[ index ].done) continue; // Don't overwrite\n      data[ index ] = undefined;\n    }\n  }\n\n  const onWatchdog = () => {\n    done(`Sync timeout exceeded (${ maximumWait.toString() })`);\n  }\n\n  const done = (reason: string) => {\n    if (watchdog) clearTimeout(watchdog);\n    unsubscribe();\n    event.dispose(reason);\n  }\n\n  const init = () => {\n    watchdog = setTimeout(onWatchdog, maximumWait);\n\n    for (const [ index, state ] of states.entries()) {\n      data[ index ] = undefined; // init array positions to be undefined\n\n      state.unsub = state.source.on(valueChanged => {\n        if (messageIsSignal(valueChanged)) {\n          if (valueChanged.signal === `done`) {\n            state.finalData = data[ index ];\n            state.unsub();\n            state.done = true;\n            state.unsub = () => { /** no-op */ }\n            if (finalValue === `undefined`) data[ index ] = undefined;\n            if (onSourceDone === `break`) {\n              done(`Source '${ index.toString() }' done, and onSourceDone:'break' is set`);\n              return;\n            }\n            if (!hasIncompleteSource()) {\n              done(`All sources done`);\n              return;\n            }\n          }\n          return;\n        }\n        data[ index ] = valueChanged.value;\n\n        if (isDataSetComplete()) {\n          // All array elements contain values\n          // Emit data and reset\n          event.set([ ...data ] as RxValueTypes<T>);\n          resetDataSet();\n          if (watchdog) clearTimeout(watchdog);\n          watchdog = setTimeout(onWatchdog, maximumWait);\n        }\n      });\n    }\n  }\n\n  const event = initStream<RxValueTypes<T>>({\n    onFirstSubscribe() {\n      unsubscribe();\n      init();\n    },\n    onNoSubscribers() {\n      if (watchdog) clearTimeout(watchdog);\n      unsubscribe();\n\n    },\n  });\n\n  return {\n    dispose: event.dispose,\n    isDisposed: event.isDisposed,\n    on: event.on,\n    onValue: event.onValue\n  }\n\n}\n","import { zipKeyValue } from \"@ixfx/core/maps\";\nimport type { ReactiveOrSource, Reactive, RxValueTypeObject } from \"../types.js\";\nimport { syncToArray } from \"./sync-to-array.js\";\nimport { transform } from \"./transform.js\";\nimport type { SyncOptions } from \"./types.js\";\n\nexport function syncToObject<const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options: Partial<SyncOptions> = {}): Reactive<RxValueTypeObject<T>> {\n  const keys = Object.keys(reactiveSources)\n  const values = Object.values(reactiveSources);\n\n  const s = syncToArray(values, options);\n  const st = transform(s, (streamValues) => {\n    return zipKeyValue(keys, streamValues);\n  });\n  return st as Reactive<RxValueTypeObject<T>>;\n}","import type { Processors } from \"@ixfx/process\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport type { ReactiveOrSource, Reactive, ReactiveWritable, ReactiveOp } from \"../types.js\";\n\n/**\n * 'Taps' the values from 'input', passing them to the 'process' function.\n * Return stream is the input stream, unaffected by what 'process' does.\n * @param input Input stream\n * @param processors List of processors\n * @returns \n */\nexport function tapProcess<In, T2, T3, T4, T5, T6>(input: ReactiveOrSource<In>, ...processors: Processors<In, T2, T3, T4, T5, T6>): Reactive<In> {\n  const inputStream = resolveSource(input);\n  // @ts-expect-error\n  const chain = Process.flow(...processors);\n  inputStream.onValue(value => {\n    chain(value);\n  });\n  return inputStream;\n}\n\n/**\n * 'Taps' the values from 'input', passing them to 'diverged'\n * Returns the original input stream, unaffected by what 'diverged' does.\n * @param input Input stream\n * @param diverged Stream to write to \n * @returns \n */\nexport function tapStream<In>(input: ReactiveOrSource<In>, diverged: ReactiveWritable<In>): Reactive<In> {\n  const inputStream = resolveSource(input);\n  inputStream.onValue(value => {\n    diverged.set(value);\n  });\n  return inputStream;\n}\n\n/**\n * Create a parallel 'tap' of processing\n * @param input Input stream\n * @param ops Series of ops to process data\n * @returns \n */\nexport const tapOps = <TIn, TOut>(input: ReactiveOrSource<TIn>, ...ops: ReactiveOp<TIn, TOut>[]): Reactive<TOut> => {\n  for (const op of ops) {\n    // @ts-expect-error\n    input = op(input);\n  }\n  return input as any as Reactive<TOut>;\n}","import { intervalToMs } from \"@ixfx/core\";\nimport { initUpstream } from \"../init-stream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../types.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport type { ThrottleOptions } from \"./types.js\";\n\n/**\n * Only allow a value through if a minimum amount of time has elapsed.\n * since the last value. This effectively slows down a source to a given number\n * of values/ms. Values emitted by the source which are too fast are discarded.\n * \n * Throttle will fire on the first value received.\n * \n * In more detail:\n * Every time throttle passes a value, it records the time it allowed something through. For every\n * value received, it checks the elapsed time against this timestamp, throwing away values if\n * the period hasn't elapsed.\n * \n * With this logic, a fury of values of the source might be discarded if they fall within the elapsed time\n * window. But then if there is not a new value for a while, the actual duration between values can be longer\n * than expected. This is in contrast to {@link debounce}, which will emit the last value received after a duration, \n * even if the source stops sending.\n * @param options \n * @returns \n */\nexport function throttle<V>(throttleSource: ReactiveOrSource<V>, options: Partial<ThrottleOptions> = {}): Reactive<V> {\n  const elapsed = intervalToMs(options.elapsed, 0);\n  let lastFire = performance.now();\n  let lastValue: V | undefined;\n\n  const upstream = initUpstream<V, V>(throttleSource, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      trigger();\n    },\n  });\n\n  const trigger = () => {\n    const now = performance.now();\n    if (elapsed > 0 && (now - lastFire > elapsed)) {\n      lastFire = now;\n      if (lastValue !== undefined) {\n        upstream.set(lastValue);\n      }\n    }\n  }\n\n\n  return toReadable(upstream);\n\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { initUpstream } from \"../init-stream.js\";\nimport type { ReactiveOrSource, Reactive } from \"../types.js\";\nimport { isTrigger, resolveTriggerValue } from \"../util.js\";\nimport type { TimeoutValueOptions } from \"../from/types.js\";\n\n/**\n * Emits a value if `source` does not emit a value after `interval`\n * has elapsed. This can be useful to reset a reactive to some\n * 'zero' state if nothing is going on.\n * \n * If `source` emits faster than the `interval`, it won't get triggered.\n * \n * Default for 'timeout': 1000s.\n * \n * ```js\n * // Emit 'hello' if 'source' doesn't emit a value after 1 minute\n * const r = Rx.timeoutValue(source, { value: 'hello', interval: { mins: 1 } });\n * ```\n * \n * Can also emit results from a function or generator\n * ```js\n * // Emits a random number if 'source' doesn't emit a value after 500ms\n * const r = Rx.timeoutValue(source, { fn: Math.random, interval: 500 });\n * ```\n * \n * If `immediate` option is _true_ (default), the timer starts from stream initialisation.\n * Otherwise it won't start until it observes the first value from `source`.\n * @param source \n * @param options \n */\nexport function timeoutValue<TSource, TTriggerValue>(source: ReactiveOrSource<TSource>, options: TimeoutValueOptions<TTriggerValue>): Reactive<TSource | TTriggerValue> {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  const immediate = options.immediate ?? true;\n  const repeat = options.repeat ?? false;\n  const timeoutMs = intervalToMs(options.interval, 1000);\n  if (!isTrigger(options)) {\n    throw new Error(`Param 'options' does not contain trigger 'value' or 'fn' fields`);\n  }\n\n  // Send value from trigger\n  const sendFallback = () => {\n    const [ value, done ] = resolveTriggerValue(options);\n    if (done) {\n      events.dispose(`Trigger completed`);\n    } else {\n      if (events.isDisposed()) return;\n      events.set(value);\n      if (repeat) {\n        timer = setTimeout(sendFallback, timeoutMs);\n      }\n    }\n  }\n\n  const events = initUpstream<TSource, TSource | TTriggerValue>(source, {\n    disposeIfSourceDone: true,\n    // Received a value from upstream source\n    onValue(v) {\n      // Reset timeout\n      if (timer) clearTimeout(timer);\n      timer = setTimeout(sendFallback, timeoutMs);\n      // Emit value\n      events.set(v);\n    },\n    onDispose() {\n      if (timer) clearTimeout(timer);\n    },\n  });\n\n  if (immediate && !timer) {\n    timer = setTimeout(sendFallback, timeoutMs);\n  }\n  return events;\n}\n","import { intervalToMs } from \"@ixfx/core\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport type { ReactiveOrSource, Reactive, ReactivePingable } from \"../types.js\";\nimport { isPingable, isTrigger, messageHasValue, messageIsDoneSignal, resolveTriggerValue } from \"../util.js\";\nimport type { TimeoutPingOptions, TimeoutValueOptions } from \"../from/types.js\";\n\n/**\n * Pings a reactive if no value is emitted at after `interval`.\n * Returns `source`.\n * \n * ```js\n * // Ping `source` if no value is emitted after one minute\n * const r = Rx.timeoutPing(source, { mins: 1 });\n * ```\n * \n * Behavior can be stopped using an abort signal.\n * @see {@link ReactivePingable}\n * @param source \n * @param options \n */\nexport function timeoutPing<TSource>(source: ReactiveOrSource<TSource>, options: TimeoutPingOptions): Reactive<TSource> {\n  let timer: ReturnType<typeof setTimeout> | undefined;\n  const rx = resolveSource(source);\n  const abort = options.abort;\n  const timeoutMs = intervalToMs(options, 1000);\n\n  // Send ping\n  const sendPing = () => {\n    if (abort?.aborted || rx.isDisposed()) {\n      off();\n      return;\n    }\n    if (isPingable(rx)) rx.ping(); // ignore if not pingable\n    timer = setTimeout(sendPing, timeoutMs);\n  }\n\n  const cancel = () => {\n    if (timer) clearTimeout(timer);\n  }\n\n  const off = rx.on(message => {\n    if (messageHasValue(message)) {\n      // Reset timeout\n      cancel();\n      timer = setTimeout(sendPing, timeoutMs);\n    } else if (messageIsDoneSignal(message)) {\n      off();\n      cancel();\n    }\n  });\n\n  timer = setTimeout(sendPing, timeoutMs);\n  return rx;\n}\n","import { initStream } from \"../init-stream.js\";\nimport { resolveSource } from \"../resolve-source.js\";\nimport type { ValueToPingOptions } from \"../from/types.js\";\nimport type { Reactive, ReactiveOrSource, ReactivePingable, Unsubscriber } from \"../types.js\";\nimport { messageHasValue, messageIsDoneSignal, messageIsSignal } from \"../util.js\";\n\n/**\n * Pings `target` whenever `source` emits a value. The value itself is ignored, it just\n * acts as a trigger.\n * \n * Returns a new stream capturing the output of `target`.\n * \n * It `source` or `target` closes, output stream closes too.\n * \n * @returns \n */\nexport function valueToPing<TSource, TTarget>(source: ReactiveOrSource<TSource>, target: ReactivePingable<TTarget>, options: Partial<ValueToPingOptions<TSource>> = {}): Reactive<TTarget> {\n  const lazy = options.lazy ?? `initial`;\n  const signal = options.signal;\n  const sourceRx = resolveSource(source);\n  const gate = options.gate ?? ((value: TSource) => true);\n  let upstreamOff: Unsubscriber | undefined;\n  let downstreamOff: Unsubscriber | undefined;\n\n  if (signal) {\n    signal.addEventListener(`abort`, () => {\n      done(`Abort signal ${ signal.reason }`);\n    }, { once: true });\n  }\n\n  const events = initStream<TTarget>({\n    onFirstSubscribe() {\n      if (lazy !== `never` && upstreamOff === undefined) start();\n    },\n    onNoSubscribers() {\n      // Unsubscribe from source if we're very lazy\n      // Stay subscribed if we're only initially lazy or not lazy at all\n      if (lazy === `very` && upstreamOff !== undefined) {\n        upstreamOff();\n        upstreamOff = undefined;\n      }\n    },\n  })\n\n  const start = () => {\n    //console.log(`Rx.valueToPing  start`);\n\n    upstreamOff = sourceRx.on(message => {\n      if (messageIsDoneSignal(message)) {\n        done(`Upstream closed`);\n      } else if (messageIsSignal(message)) {\n        events.signal(message.signal);\n      } else if (messageHasValue(message)) {\n        //console.log(`Rx.valueToPing got value: ${ message.value }`);\n        if (gate(message.value)) {\n          target.ping();\n        }\n      }\n    });\n    downstreamOff = target.on(message => {\n      if (messageIsDoneSignal(message)) {\n        done(`Downstream closed`);\n      } else if (messageIsSignal(message)) {\n        events.signal(message.signal, message.context);\n      } else if (messageHasValue(message)) {\n        events.set(message.value);\n      }\n    });\n  }\n\n  const done = (reason: string) => {\n    events.dispose(reason);\n    if (upstreamOff) upstreamOff();\n    if (downstreamOff) downstreamOff();\n  }\n\n  if (lazy === `never`) start();\n  return events;\n}","import { initUpstream } from \"../init-stream.js\";\nimport type { ReactiveOrSource, WithValueOptions, ReactiveInitial } from \"../types.js\";\nimport { toReadable } from \"../to-readable.js\";\n\n/**\n * A reactive where the last value can be read at any time.\n * An initial value must be provided.\n * ```js\n * const r = Rx.withValue(source, { initial: `hello` });\n * r.last(); // Read last value\n * ```\n * \n * Warning: Since most reactives only active when subscribed to, it's important to also subscribe\n * to the results of `r` for this flow to happen. Alternatively, use `lazy: 'never'` as an option.\n * @param input \n * @param options \n * @returns \n */\nexport function withValue<In>(input: ReactiveOrSource<In>, options: WithValueOptions<In>): ReactiveInitial<In> {\n  let lastValue: In | undefined = options.initial;\n  const upstream = initUpstream<In, In>(input, {\n    ...options,\n    onValue(value) {\n      //console.log(`Rx.Ops.WithValue onValue: ${ value }`);\n      lastValue = value;\n      upstream.set(value);\n    },\n  })\n\n  const readable = toReadable(upstream);\n  return {\n    ...readable,\n    last() {\n      return lastValue!;\n    },\n  }\n}","\nimport { continuously } from \"@ixfx/core\";\nimport { intervalToMs } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\nimport type { Reactive, ReactiveFinite, ReactiveInitial } from \"../types.js\";\nimport type { ArrayOptions } from \"./types.js\";\n\nexport const of = <V>(source: V[] | Iterable<V>, options: Partial<ArrayOptions> = {}) => {\n  if (Array.isArray(source)) {\n    return array(source, options);\n  } else {}\n}\n\n/**\n * Reads the contents of `array` into a Reactive, with optional time interval\n * between values. A copy of the array is used, so changes will not\n * affect the reactive.\n * \n * See also {@link arrayObject} which monitors changes to array values.\n *\n * Reads items from an array with a given interval, by default 5ms\n * \n * ```js\n * const data = [`apples`, `oranges`, `pears` ];\n * const rx = Rx.From.array(data);\n * rx.onValue(v => {\n *  // v will be each fruit in turn\n * })\n * ```\n * \n * Note that there is the possibility of missing values since there is delay between subscribing and when items start getting emitted.\n * If a new subscriber connects to the reactive, they won't get values already emitted.\n * @param sourceArray \n * @param options \n * @returns \n */\nexport const array = <V>(sourceArray: V[], options: Partial<ArrayOptions> = {}): Reactive<V> & ReactiveFinite & ReactiveInitial<V> => {\n  const lazy = options.lazy ?? `initial`;\n  const signal = options.signal;\n  const whenStopped = options.whenStopped ?? `continue`;\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const array = [ ...sourceArray ];\n\n  if (lazy !== `very` && whenStopped === `reset`) throw new Error(`whenStopped:'reset' has no effect with 'lazy:${ lazy }'. Use lazy:'very' instead.`);\n\n  const intervalMs = intervalToMs(options.interval, 5);\n  let index = 0;\n  let lastValue = array[ 0 ];\n\n  const s = initLazyStream<V>({\n    ...options,\n    lazy,\n    onStart() {\n      if (debugLifecycle) console.log(`Rx.readFromArray:onStart`);\n      c.start();\n    },\n    onStop() {\n      if (debugLifecycle) console.log(`Rx.readFromArray:onStop. whenStopped: ${ whenStopped } index: ${ index }`);\n\n      c.cancel();\n      if (whenStopped === `reset`) index = 0;\n    },\n    // onFirstSubscribe() {\n    //   if (debugLifecycle) console.log(`Rx.readFromArray:onFirstSubscribe lazy: ${ lazy } runState: '${ c.runState }'`);\n    //   // Start if in lazy mode and not running\n    //   if (lazy !== `never` && c.runState === `idle`) c.start();\n    // },\n    // onNoSubscribers() {\n    //   if (debugLifecycle) console.log(`Rx.readFromArray:onNoSubscribers lazy: ${ lazy } runState: '${ c.runState }' whenStopped: '${ whenStopped }'`);\n    //   if (lazy === `very`) {\n    //     c.cancel();\n    //     if (whenStopped === `reset`) {\n    //       index = 0;\n    //     }\n    //   }\n    // }\n  });\n\n  const c = continuously(() => {\n    if (signal?.aborted) {\n      s.dispose(`Signalled (${ signal.reason })`);\n      return false; // stop looping\n    }\n    lastValue = array[ index ];\n    index++;\n\n    s.set(lastValue)\n    if (index === array.length) {\n      s.dispose(`Source array complete`);\n      return false; // stop loop\n    }\n  }, intervalMs);\n\n  if (!lazy) c.start();\n\n  return {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    dispose: s.dispose,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    isDisposed: s.isDisposed,\n    isDone() {\n      return index === array.length;\n    },\n    last() {\n      return lastValue;\n    },\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    on: s.on,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    onValue: s.onValue\n  }\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { isEqualValueDefault } from \"@ixfx/core\";\nimport { initStream } from \"../init-stream.js\";\nimport type { ReactiveInitial, ReactiveNonInitial, ReactiveArray, Reactive } from \"../types.js\";\nimport type { ArrayObjectOptions } from \"./types.js\";\nimport { compareArrays, type ChangeRecord } from \"@ixfx/core/records\";\nimport { remove as ArraysRemove, insertAt as ArraysInsertAt } from '@ixfx/arrays';\n/**\n * Wraps an array object.\n * \n * It returns an reactive along with some array-ish functions to manipulating it.\n * @param initialValue \n * @param options \n * @returns \n */\nexport function arrayObject<V>(initialValue: readonly V[] = [], options: Partial<ArrayObjectOptions<V>> = {}): ReactiveArray<V> & ReactiveInitial<readonly V[]> {\n  const eq = options.eq ?? isEqualValueDefault;\n  const setEvent = initStream<V[]>();\n  //const diffEvent = initStream<Array<Immutable.Change<any>>>();\n  const arrayEvent = initStream<ChangeRecord<number>[]>();\n  let value: readonly V[] = initialValue;\n  let disposed = false;\n\n  const set = (replacement: V[] | readonly V[]) => {\n    const diff = compareArrays<V>(value as V[], replacement as V[], eq);\n    //console.log(`Rx.fromArray.set diff`, diff);\n    //if (diff.length === 0) return;\n    //diffEvent.set(diff);\n    value = replacement;\n    setEvent.set([ ...replacement ]);\n  }\n\n  const setAt = (index: number, v: V) => {\n    (value as V[])[ index ] = v;\n    setEvent.set([ ...value ]);\n  }\n\n  const push = (v: V) => {\n    value = [ ...value, v ];\n    setEvent.set([ ...value ]);\n    const cr: ChangeRecord<number> = [ `add`, value.length - 1, v ];\n    arrayEvent.set([ cr ]);\n  }\n\n  const deleteAt = (index: number) => {\n    const valueChanged = ArraysRemove(value, index);\n    if (valueChanged.length === value.length) return; // no change\n    const diff = compareArrays<V>(value as V[], valueChanged, eq);\n    //console.log(diff.summary);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n  }\n\n  const deleteWhere = (filter: (value: V) => boolean) => {\n    const valueChanged = value.filter(v => !filter(v));\n    const count = value.length - valueChanged.length;\n    const diff = compareArrays<V>(value as V[], valueChanged, eq);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n    return count;\n  }\n\n  const insertAt = (index: number, v: V) => {\n    const valueChanged = ArraysInsertAt(value, index, v);\n    const diff = compareArrays<V>(value as V[], valueChanged, eq);\n    value = valueChanged;\n    setEvent.set([ ...value ]);\n    arrayEvent.set(diff.summary);\n  }\n\n  // const update = (toMerge: Partial<V>) => {\n  //   // eslint-disable-next-line unicorn/prefer-ternary\n  //   if (value === undefined) {\n  //     value = toMerge as V;\n  //   } else {\n  //     const diff = Immutable.compareData(toMerge, value);\n  //     // console.log(`Rx.fromObject.update value: ${ JSON.stringify(value) }`);\n  //     // console.log(`Rx.fromObject.update  diff: ${ JSON.stringify(diff) }`);\n  //     if (diff.length === 0) return; // No changes\n  //     value = {\n  //       ...value,\n  //       ...toMerge\n  //     }\n  //     diffEvent.set(diff);\n  //   }\n  //   setEvent.set(value);\n  // }\n\n  const dispose = (reason: string) => {\n    if (disposed) return;\n    //diffEvent.dispose(reason);\n    setEvent.dispose(reason);\n    disposed = true;\n  }\n\n  const r = {\n    dispose,\n    isDisposed() {\n      return disposed\n    },\n    last: () => value,\n    on: setEvent.on,\n    onArray: arrayEvent.on,\n    onValue: setEvent.onValue,\n    setAt,\n    push,\n    deleteAt,\n    deleteWhere,\n    insertAt,\n    /**\n     * Set the whole object\n     */\n    set\n  }\n  return r;\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../types.js\";\n\nexport function boolean(initialValue: boolean): ReactiveWritable<boolean> & ReactiveInitial<boolean>;\nexport function boolean(): ReactiveWritable<boolean> & ReactiveNonInitial<boolean>;\nexport function boolean(initialValue?: boolean): ReactiveWritable<boolean> & (ReactiveNonInitial<boolean> | ReactiveInitial<boolean>) {\n  let value = initialValue;\n  const events = initStream<boolean>();\n\n  const set = (v: boolean) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set\n  }\n}","import { intervalToMs } from \"@ixfx/core\";\nimport { continuously } from \"@ixfx/core\";\nimport type { CountOptions } from \"./types.js\";\nimport { initLazyStream } from \"../init-stream.js\";\n\n/**\n * Produces an incrementing value. By default starts at 0 and counts\n * forever, incrementing every second.\n * \n * ```js\n * const r = Rx.From.count();\n * r.onValue(c => {\n *  // 0, 1, 2, 3 ... every second\n * });\n * ```\n * \n * The `limit` is exclusive\n * ```js\n * const r = Rx.From.count({limit:5});\n * // Yields 0,1,2,3,4\n * ```\n * \n * If limit is less than start, it will count down instead.\n * ```js\n * const r = Rx.count({start:5, limit: 0});\n * // Yie:ds 5,4,3,2,1\n * ```\n * \n * ```js\n * // Count 10, 12, 14 ... every 500ms\n * const r = Rx.From.count({ start: 10, amount: 2, interval: 500 });\n * ```\n * \n * In addition to setting `limit` (which is exclusive), you can stop with an abort signal\n * ```js\n * const ac = new AbortController();\n * const r = Rx.From.count({signal:ac.signal});\n * ...\n * ac.abort(`stop`);\n * ```\n * @param options \n */\nexport function count(options: Partial<CountOptions> = {}) {\n\n  const lazy = options.lazy ?? `initial`;\n  const interval = intervalToMs(options.interval, 1000);\n  const amount = options.amount ?? 1;\n  const offset = options.offset ?? 0;\n\n  let produced = 0;\n  let value = offset;\n\n  const done = (reason: string) => {\n    events.dispose(reason);\n  }\n\n  const timer = continuously(() => {\n    if (options.signal?.aborted) {\n      done(`Aborted (${ options.signal.reason })`);\n      return false;\n    }\n    events.set(value);\n    value += 1;\n    produced++;\n    if (produced >= amount) {\n      done(`Limit reached`);\n      return false;\n    }\n  }, interval);\n\n  const events = initLazyStream<number>({\n    onStart() {\n      timer.start();\n    },\n    onStop() {\n      timer.cancel();\n    },\n    onDispose() {\n      timer.cancel();\n    },\n    lazy\n  });\n  return events;\n}\n","import { isEqualValueDefault } from \"@ixfx/core\";\nimport { cache } from \"../cache.js\";\nimport { initUpstream } from \"../init-stream.js\";\nimport { type CombineLatestToObject, combineLatestToObject } from \"../ops/combine-latest-to-object.js\";\nimport type { ReactiveNonInitial, ReactiveOrSource, RxValueTypeObject } from \"../types.js\";\nimport type { DerivedOptions } from \"./types.js\";\n\nexport function derived<TResult, const T extends Record<string, ReactiveOrSource<any>>>(fn: (combined: RxValueTypeObject<T>) => TResult | undefined, reactiveSources: T, options: Partial<DerivedOptions<TResult, CombineLatestToObject<T>>> = {}): ReactiveNonInitial<TResult> {\n  const ignoreIdentical = options.ignoreIdentical ?? true;\n  const eq = options.eq ?? isEqualValueDefault<TResult>;\n\n  const sources = combineLatestToObject(reactiveSources);\n\n  const handle = (v: RxValueTypeObject<T>) => {\n    const last = output.last();\n    const vv = fn(v);\n    if (vv !== undefined) {\n      if (ignoreIdentical && last !== undefined) {\n        if (eq(vv, last)) return vv;\n      }\n      output.set(vv);\n    }\n\n    return vv;\n  }\n\n  // When the combined stream emits a value, output it\n  const s = initUpstream<RxValueTypeObject<T>, TResult>(sources, {\n    ...options,\n    onValue(v) {\n      handle(v);\n    },\n  });\n  const output = cache(s, fn(sources.last()));\n  return output;\n}\n\n","import type { Passed, Reactive, ReactiveInitial } from \"../types.js\";\nimport { field } from \"../ops/field.js\";\nimport { object } from \"./object.js\";\nimport type { FieldOptions } from \"../ops/types.js\";\nimport type { EventSourceOptions, EventSourceTriggerOptions } from \"./types.js\";\nimport { initLazyStream } from \"../init-stream.js\";\nimport { elapsedInterval } from \"@ixfx/core/elapsed\";\n/**\n * Fired when `eventName` fires on `target`. \n * \n * Rather than whole event args being emitted on the stream,\n * it plucks a field from the event args, or if that's missing, from the target.\n * \n * ```js\n * // Emits the the value of a field named 'x'\n * // on the change event args\n * eventField(el, `pointermove`, `x`);\n * ```\n * @param targetOrQuery Event target, HTML element or HTML query (eg '#someId') \n * @param eventName Name of event, eg. 'pointermove'\n * @param fieldName Name of field, eg 'x'\n * @param initialValue Initial data\n * @param options Options for source\n */\nexport function eventField<TFieldValue = string>(targetOrQuery: EventTarget | string | null, eventName: string, fieldName: string, initialValue: TFieldValue, options: Partial<EventSourceOptions & FieldOptions<any, TFieldValue>> = {}) {\n\n  const initial: Record<string, any> = {};\n  initial[ fieldName ] = initialValue;\n\n  const rxField = field<any, TFieldValue>(\n    event(targetOrQuery, eventName, initial, options),\n    fieldName,\n    options\n  );\n  return rxField;\n}\n\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options: EventOptions<V>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options?: Optional<EventOptions<V>, `transform`>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n\n/**\n * Subscribes to an event, emitting data\n * \n * @example Print x,y position of mouse as it moves\n * ```js\n * const r = Rx.From.event(document, `pointermove`);\n * r.onValue(event => {\n *  const { x, y } = event;\n * });\n * ```\n * \n * If `options.lazy` is _true_ (default: _false_), event will only be subscribed to when the stream\n * itself has a subscriber.\n * \n * `options.debugFiring` and `options.debugLifecycle` can be turned on to troubleshoot behaviour\n * of the stream if necessary.\n * @param targetOrQuery Event emitter, HTML element or string. If a string, it will be queryed as a selector.\n * @param name Event name\n * @param options Options\n * @returns \n */\n\nexport function event<TEventArgs extends Record<string, any>>(targetOrQuery: EventTarget | null | string, name: string, initialValue: TEventArgs | undefined, options: Partial<EventSourceOptions> = {}): ReactiveInitial<TEventArgs> & Reactive<TEventArgs> {\n  let target: EventTarget | null;\n  if (typeof targetOrQuery === `string`) {\n    target = document.querySelector(targetOrQuery);\n    if (target === null) throw new Error(`Target query did not resolve to an element. Query: '${ targetOrQuery }'`)\n  } else {\n    target = targetOrQuery;\n  }\n\n  if (target === null) throw new Error(`Param 'targetOrQuery' is null`);\n\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const debugFiring = options.debugFiring ?? false;\n  const lazy = options.lazy ?? false;\n  // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n  if (initialValue === undefined) initialValue = {} as TEventArgs;\n  const rxObject = object<TEventArgs>(initialValue, { deepEntries: true });\n  let eventAdded = false;\n  let disposed = false;\n\n  const callback = (args: any) => {\n    if (debugFiring) console.log(`Reactive.event '${ name }' firing '${ JSON.stringify(args) }`)\n    rxObject.set(args as TEventArgs);\n  }\n\n  const remove = () => {\n    if (!eventAdded) return;\n    eventAdded = false;\n    target.removeEventListener(name, callback);\n    if (debugLifecycle) {\n      console.log(`Rx.From.event remove '${ name }'`);\n    }\n  }\n\n  const add = () => {\n    if (eventAdded) return;\n    eventAdded = true;\n    target.addEventListener(name, callback);\n    if (debugLifecycle) {\n      console.log(`Rx.From.event add '${ name }'`);\n    }\n  }\n\n  if (!lazy) add();\n\n  return {\n    last: () => {\n      if (lazy) add();\n      return rxObject.last();\n    },\n    dispose: (reason: string) => {\n      if (disposed) return;\n      disposed = true;\n      remove();\n      rxObject.dispose(reason);\n    },\n    isDisposed() {\n      return disposed;\n    },\n    on: (handler: (v: Passed<TEventArgs>) => void) => {\n      if (lazy) add();\n      return rxObject.on(handler);\n    },\n    onValue: (handler: (v: TEventArgs) => void) => {\n      if (lazy) add();\n      return rxObject.onValue(handler);\n    }\n  }\n}\n\nexport type TriggerData = {\n  sinceLast: number\n  total: number\n}\n\n/**\n * Emits a value whenever event happens.\n * Data emitted is `{ sinceLast, total }`, where 'sinceLast'\n * is milliseconds since last event and 'total' is total number of \n * times event has been fired.\n * @param targetOrQuery \n * @param name \n * @param options \n * @returns \n */\nexport function eventTrigger(targetOrQuery: EventTarget | null | string, name: string, options: Partial<EventSourceTriggerOptions> = {}): Reactive<TriggerData> {\n  let target: EventTarget | null;\n  if (typeof targetOrQuery === `string`) {\n    target = document.querySelector(targetOrQuery);\n    if (target === null) throw new Error(`Target query did not resolve to an element. Query: '${ targetOrQuery }'`)\n  } else {\n    target = targetOrQuery;\n  }\n\n  if (target === null) throw new Error(`Param 'targetOrQuery' is null`);\n\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const debugFiring = options.debugFiring ?? false;\n  const fireInitial = options.fireInitial ?? false;\n\n  let count = 0;\n  const elapsed = elapsedInterval();\n\n  const stream = initLazyStream<TriggerData>({\n    lazy: options.lazy ?? `very`,\n    onStart() {\n      target.addEventListener(name, callback);\n      if (debugLifecycle) {\n        console.log(`Rx.From.eventTrigger add '${ name }'`);\n      }\n      if (fireInitial && count === 0) {\n        if (debugLifecycle || debugFiring) console.log(`Rx.From.eventTrigger: firing initial`);\n        callback();\n      }\n    },\n    onStop() {\n      target.removeEventListener(name, callback);\n      if (debugLifecycle) {\n        console.log(`Rx.From.eventTrigger remove '${ name }'`);\n      }\n    },\n  });\n\n  const callback = (_args?: any) => {\n    if (debugFiring) console.log(`Rx.From.eventTrigger '${ name }' triggered'`)\n    stream.set({\n      sinceLast: elapsed(),\n      total: ++count\n    });\n  }\n\n  return stream;\n}","import { initLazyStream } from \"../init-stream.js\";\nimport type { InitLazyStreamOptions, Reactive, Unsubscriber } from \"../types.js\";\n\n/**\n * Returns a stream that merges the output of a list of homogenous streams.\n * Use {@link mergedWithOptions} to specify additional options.\n * @param sources \n * @returns \n */\nexport function merged<T>(...sources: Reactive<T>[]): Reactive<T> {\n  return mergedWithOptions(sources);\n}\n\n/**\n * Returns a stream that merges the output of a list of homogenous streams.\n * \n * @param sources \n * @param options \n * @returns \n */\nexport function mergedWithOptions<T>(sources: Reactive<T>[], options: Partial<InitLazyStreamOptions> = {}): Reactive<T> {\n  let unsubs: Unsubscriber[] = [];\n  const stream = initLazyStream<T>({\n    ...options,\n    onStart() {\n      for (const s of sources) {\n        unsubs.push(s.onValue(v => {\n          stream.set(v);\n        }));\n      }\n    },\n    onStop() {\n      for (const un of unsubs) {\n        un();\n      }\n      unsubs = [];\n    },\n  });\n  return stream;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../types.js\";\n\nexport function number(initialValue: number): ReactiveWritable<number> & ReactiveInitial<number>;\nexport function number(): ReactiveWritable<number> & ReactiveNonInitial<number>;\nexport function number(initialValue?: number): ReactiveWritable<number> & (ReactiveNonInitial<number> | ReactiveInitial<number>) {\n  let value = initialValue;\n  const events = initStream<number>();\n\n  const set = (v: number) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set\n  }\n}\n","import type { Interval, Primitive } from '@ixfx/core';\n//import * as Immutable from '../data/Pathed.js';\n\nimport type { ChunkOptions, DebounceOptions, FieldOptions, FilterPredicate, SplitOptions, SyncOptions, SwitcherOptions, TransformOpts, ThrottleOptions, OpMathOptions } from './ops/types.js';\nimport type { TimeoutPingOptions, TimeoutValueOptions } from './from/types.js';\nimport type { SetHtmlOptions } from './sinks/dom.js';\nimport type { Processors } from '@ixfx/process';\nimport type { TallyOptions } from './ops/math.js';\nimport type { ChangeRecord } from '@ixfx/core/records';\nimport type { RecursivePartial } from '@ixfx/core';\nimport type { PathDataChange } from '@ixfx/core/records';\n\nexport type CombineLatestOptions = {\n  /**\n   * If _true_, disposes all the merged sources when the merged reactive closes.\n   * Default: _true_.\n   */\n  disposeSources: boolean\n  /**\n   * How to handle when a source ends.\n   * * 'allow': continue combined stream, last value for done stream will kept\n   * * 'break': stop combined stream\n   * \n   * Default: 'break'\n   */\n  onSourceDone: `allow` | `break`\n  /**\n   * If _true_ (default), emits a value when initialised.\n   */\n  emitInitial: boolean\n}\n\nexport type Optional<T, K extends keyof T> = Pick<Partial<T>, K> & Omit<T, K>;\n\nexport const symbol = Symbol(`Rx`);\n\nexport type SignalKinds = `done` | `warn`;\nexport type Passed<V> = {\n  value: V | undefined\n  signal?: SignalKinds\n  context?: string\n}\n\nexport type PassedSignal = Passed<any> & {\n  value: undefined\n  signal: SignalKinds\n  context: string\n}\n\nexport type PassedValue<V> = Passed<V> & {\n  value: V\n}\n\nexport type UpstreamOptions<In> = {\n  lazy: Lazy\n  /**\n   * If _true_ (default), we dispose the underlying stream if the upstream closes. This happens after onStop() is called.\n   */\n  disposeIfSourceDone: boolean\n  onValue: (v: In) => void\n  /**\n   * Called just before we subscribe to source\n   * @returns \n   */\n  onStart: () => void\n  /**\n   * Called after we unsubscribe from source\n   * @returns\n   */\n  onStop: () => void\n  debugLabel: string\n  onDispose: (reason: string) => void\n}\n\nexport type UpstreamInitialOptions<In> = UpstreamOptions<In> & {\n  initialValue: In\n}\n\n//export type Processor = <TIn, TOptions>(source: ReactiveOrSource<TIn>) => (options: TOptions) => () => void;\n\n/**\n * Wrapped Reactive for object-oriented access\n */\nexport type Wrapped<TIn> = {\n  enacts: {\n    setHtmlText: (options: SetHtmlOptions) => () => void\n  }\n  source: Reactive<TIn>,\n\n  /**\n   * Annotate values with output from the `annotation` function.\n   * Returned values will be in the form `{ value:TIn, annotation:TAnnotation }`\n   * @param transformer \n   * @returns \n   */\n  annotate: <TAnnotation>(transformer: (value: TIn) => TAnnotation) => Wrapped<{ value: TIn, annotation: TAnnotation }>\n  annotateWithOp: <TOut>(op: ReactiveOp<TIn, TOut>) => Wrapped<{ value: TIn, annotation: TOut }>\n  /**\n  * Accumulate a chunk of values, emitted as an array\n  * @param options \n  * @returns \n  */\n  chunk: (options: Partial<ChunkOptions>) => Wrapped<TIn[]>\n\n  debounce: (options: Partial<DebounceOptions>) => Wrapped<TIn>\n\n\n  /**\n   * Pluck and emit a single field from values\n   * @param fieldName \n   * @param options \n   * @returns \n   */\n  field: <TSource, TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TSource, TFieldType>>) => Wrapped<TFieldType>\n  /**\n   * Throws away values that don't match `predicate`\n   * @param predicate \n   * @param options \n   * @returns \n   */\n  filter: (predicate: FilterPredicate<TIn>, options: Partial<InitStreamOptions>) => Wrapped<TIn>\n\n  combineLatestToArray: <const T extends readonly ReactiveOrSource<any>[]>(sources: T, options: Partial<CombineLatestOptions>) => Wrapped<RxValueTypes<T>>\n  combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name: string } & Partial<CombineLatestOptions>) => Wrapped<RxValueTypeObject<T>>\n\n  min: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  max: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  average: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  sum: (options?: Partial<OpMathOptions>) => Wrapped<number>\n  tally: (options?: Partial<TallyOptions>) => Wrapped<number>\n\n  /**\n   * Converts one source stream into two, with values being emitted by both\n   * @param options \n   * @returns \n   */\n  split: (options?: Partial<SplitOptions>) => Wrapped<TIn>[]\n  /**\n * Emits values when this stream and any additional streams produce a value. The resulting stream is\n * thus an array of values, each source at a given index.\n * Waits to output a value until each stream has produced a value. Thus, the pace is determined by\n * the slowest stream.\n * @returns \n */\n  syncToArray: <const T extends readonly ReactiveOrSource<any>[]>(reactiveSources: T, options?: Partial<SyncOptions>) => Wrapped<[ TIn, ...RxValueTypes<T> ]>\n\n  syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(reactiveSources: T, options?: { name?: string } & Partial<SyncOptions>) => Wrapped<RxValueTypeObject<T>>\n\n  /**\n   * Creates new streams for each case, sending values to the stream if they match the filter predicate\n   * @param cases \n   * @param options \n   * @returns \n   */\n  switcher: <TRec extends Record<string, FilterPredicate<TIn>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions>) => Record<TLabel, Wrapped<TIn>>\n  /**\n   * Creates new streams for each case\n   * @param labels \n   * @returns \n   */\n  splitLabelled: <K extends keyof TIn>(...labels: K[]) => Record<K, Wrapped<TIn>>\n  /**\n   * Taps the stream, passing values to one or more 'processor' functions.\n   * This processing essentially happens in parallel, not affecting the main stream.\n   * \n   * ```js\n   * // Stream of pointermove events with {x:0,y:0} as default\n   * const move = Rx.From.event(document.body, `pointermove`, {x:0,y:0});\n   * // Wrap it for fluent access\n   * const ptr = Rx.wrap(move)\n   *  .tapProcess(\n   *    // Create a string representation\n   *    v => `${v.x},${v.y}`\n   *    // Set to DOM\n   *    v => {\n   *      document.getElementById(`coords`).innerText = v;\n   *    }\n   *   )\n   *  .onValue(value => {\n   *    // 'value' will be original PointerEvent, since .tapProcess happened in parallel,\n   *    // not affecting stream\n   *  });\n   * ```\n   * @param processors One-five processing functions\n   * @returns \n   */\n  tapProcess: <T2, T3, T4, T5, T6>(...processors: Processors<TIn, T2, T3, T4, T5, T6>) => Wrapped<TIn>\n  tapStream: (divergedStream: ReactiveWritable<TIn>) => Wrapped<TIn>\n  tapOps: <TOut>(source: ReactiveOrSource<TIn>, ...ops: ReactiveOp<TIn, TOut>[]) => Wrapped<TIn>\n  /**\n   * Transforms all values\n   * @param transformer \n   * @param options \n   * @returns \n   */\n  transform: <TOut>(transformer: (value: TIn) => TOut, options?: Partial<TransformOpts>) => Wrapped<TOut>\n  /**\n   * Only allow values through if a minimum of time has elapsed. Throws away values.\n   * Ie. converts a fast stream into a slower one.\n   * @param options \n   * @returns \n   */\n  throttle: (options: Partial<ThrottleOptions>) => Wrapped<TIn>\n  /**\n   * Emits a value if `source` does not emit a value after `interval`\n   * has elapsed. This can be useful to reset a reactive to some\n   * 'zero' state if nothing is going on.\n   * \n   * If `source` emits faster than the `interval`, it won't get triggered.\n   * \n   * Default for 'timeout': 1000s.\n   * \n   * ```js\n   * // Emit 'hello' if 'source' doesn't emit a value after 1 minute\n   * const r = Rx.timeoutValue(source, { value: 'hello', interval: { mins: 1 } });\n   * ```\n   * \n   * Can also emit results from a function or generator\n   * ```js\n   * // Emits a random number if 'source' doesn't emit a value after 500ms\n   * const r = Rx.timeoutValue(source, { fn: Math.random, interval: 500 });\n   * ```\n   * \n   * If `immediate` option is _true_ (default), the timer starts from stream initialisation.\n   * Otherwise it won't start until it observes the first value from `source`.\n   * @param options \n   */\n  timeoutValue: <TTriggerValue>(options: TimeoutValueOptions<TTriggerValue>) => Wrapped<TIn | TTriggerValue>\n  /**\n   * 'Pings' reactive (if it supports it) if a value is not received within a given interval.\n   * Behaviour can be stopped using an abort signal.\n   * @param options \n   * @returns \n   */\n  timeoutPing: (options: TimeoutPingOptions) => Wrapped<TIn>\n\n  /**\n   * Copies values from source into an array, throwing\n   * an error if expected number of items is not reached\n   * @param options \n   * @returns \n   */\n  toArrayOrThrow: (options: Partial<ToArrayOptions<TIn>>) => Promise<TIn[]>\n  /**\n   * Copies values from source into an array.\n   * @param options \n   * @returns \n   */\n  toArray: (options: Partial<ToArrayOptions<TIn>>) => Promise<(TIn | undefined)[]>\n  /**\n   * Listen for values\n   * @param callback \n   * @returns \n   */\n  onValue: (callback: (value: TIn) => void) => void\n}\n\nexport type ToArrayOptions<V> = {\n  /**\n   * Maximim time to wait for `limit` to be reached. 10s by default.\n   */\n  maximumWait: Interval\n  /**\n   * Number of items to read\n   */\n  limit: number\n  /**\n   * Behaviour if threshold is not reached.\n   * partial: return partial results\n   * throw: throw an error\n   * fill: fill remaining array slots with `fillValue`\n   */\n  underThreshold: `partial` | `throw` | `fill`\n  /**\n   * Value to fill empty slots with if `underThreshold = 'fill'`.\n   */\n  fillValue: V\n}\n\n/**\n * Laziness\n * * start: only begins on first subscriber. Keeps running even when there are no subscribers\n * * very: only begins on first subscriber. Stops looping if there are no subscribers\n * * never: begins calling function when initalised and doesn't stop until Reactive is disposed\n */\nexport type Lazy = `initial` | `never` | `very`\nexport type InitLazyStreamOptions = Partial<InitStreamOptions> & {\n  lazy?: Lazy\n  debugLabel?: string\n  onStart: () => void\n  onStop: () => void\n};\n\nexport type InitLazyStreamInitedOptions<T> = InitLazyStreamOptions & {\n  initialValue: T\n}\n\n\nexport type ReactiveOrSource<V> = Wrapped<V> | Reactive<V> | IterableIterator<V> | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V> | V[] | (() => V)\n\n\n\n/**\n * A Reactive\n */\nexport type Reactive<V> = {\n  /**\n   * Subscribes to a reactive. Receives\n   * data as well as signals. Use `onValue` if you\n   * just care about values.\n   * \n   * Return result unsubscribes.\n   * \n   * ```js\n   * const unsub = someReactive.on(msg => {\n   *    // Do something with msg.value\n   * });\n   * \n   * unsub(); // Unsubscribe\n   * ```\n   * @param handler \n   */\n  on(handler: (value: Passed<V>) => void): Unsubscriber\n  /**\n   * Subscribes to a reactive's values.\n   * Returns a function that unsubscribes.\n   * @param handler\n   */\n  onValue(handler: (value: V) => void): Unsubscriber\n\n  /**\n   * Disposes the reactive, providing a reason for debug tracing\n   * @param reason \n   */\n  dispose(reason: string): void\n  /**\n   * Returns _true_ if Reactive is disposed\n   */\n  isDisposed(): boolean\n  /**\n   * Optional 'set' to write a value. Use {@link ReactiveWritable} if you want this non-optional\n   * @param value \n   */\n  set?(value: V): void\n}\n\n/**\n * A reactive that can be 'pinged' to produce a value.\n * \n * Use {@link isPingable} to check if a reactive is pingable.\n * \n * Pingable reactives are returned from\n * * interpolate\n * * computeWithPrevious\n * * valueToPing\n */\nexport type ReactivePingable<V> = Reactive<V> & {\n  ping(): void\n}\n\nexport type Unsubscriber = () => void;\n\nexport type ReactiveNonInitial<V> = Reactive<V> & {\n  last(): V | undefined\n}\n\n/**\n * A stream that can be written to\n */\nexport type ReactiveWritable<TIn, TOut = TIn> = Reactive<TOut> & {\n  /**\n   * Sets a value\n   * @param value Value to write\n   */\n  set(value: TIn): void\n}\n\nexport type ReactiveInitial<V> = Reactive<V> & {\n  last(): V\n}\n\nexport type ReactiveFinite = {\n  isDone(): boolean\n}\n\nexport type ReactiveArray<V> = ReactiveWritable<V[]> & {\n  push(value: V): void\n  deleteAt(index: number): void\n  deleteWhere(filter: (value: V) => boolean): number\n  setAt(index: number, value: V): void\n  insertAt(index: number, value: V): void\n  onArray(handler: (changes: Passed<ChangeRecord<number>[]>) => void): () => void\n}\nexport type ObjectFieldHandler = { value: any, fieldName: string, pattern: string };\n\nexport type ReactiveDiff<V> = Reactive<V> & ReactiveWritable<V> & {\n  /**\n   * Notifies when the value of `fieldName` is changed.\n   * \n   * Use the returned function to unsubscribe.\n   * @param fieldName \n   * @param handler \n   */\n  onField(fieldName: string, handler: (result: ObjectFieldHandler) => void): () => void\n  /**\n   * Notifies of which field(s) were changed.\n   * If you just care about the whole, changed data use the `value` event.\n   * \n   * Use the returned function to unsubscribe.\n   * @param changes \n   */\n  onDiff(changes: (changes: PathDataChange<any>[]) => void): () => void\n  /**\n   * Updates the reactive with some partial key-value pairs.\n   * Keys omitted are left the same as the current value.\n   * @param changedPart \n   * @returns Returns new value\n   */\n  update(changedPart: RecursivePartial<V>): V\n  /**\n   * Updates a particular field by its path\n   * @param field \n   * @param value \n   */\n  updateField(field: string, value: any): void\n}\n\n/**\n * A reactive stream which can be read and written to\n */\nexport type ReactiveStream<V> = Reactive<V> & ReactiveWritable<V> & {\n  /**\n   * Removes all the subscribers from this stream.\n   */\n  removeAllSubscribers(): void\n  /**\n   * Dispatches a signal\n   * @param signal \n   * @param context \n   */\n  signal(signal: SignalKinds, context?: string): void\n}\n\nexport type ReactiveInitialStream<V> = ReactiveStream<V> & ReactiveInitial<V>;\n\n// export type PipeSet<In, Out> = [\n//   Reactive<In>,\n//   ...Array<Reactive<any> & ReactiveWritable<any>>,\n//   ReactiveWritable<Out> & Reactive<any>\n// ]\nexport type PipeSet<In, Out> = [\n  Reactive<In>,\n  ...(Reactive<any> & ReactiveWritable<any>)[]\n]\n\nexport type InitStreamOptions = {\n  /**\n   * Optional label to associate with this stream. Useful for debugging.\n   */\n  debugLabel: string\n  /**\n   * Called when there is a subscriber after there were no subscribers.\n   * Useful for 'startup' types of things that we want to run only when someone is actually listening.\n   * \n   * During the lifeycle of a stream, this could be called multiple times. Eg if all subscribers are removed\n   * next time someone subscribes it will get called again.\n   * @returns \n   */\n  onFirstSubscribe: () => void\n  /**\n   * Called when there are no longer any subscribers. Useful for shutting down\n   * activities now that no-one is listening.\n   * \n   * During the lifecycle of a stream, this could be called multiple times.\n   * @returns\n   */\n  onNoSubscribers: () => void\n  /**\n   * Called whenever the stream disposes. Useful for cleaning up.\n   * @param reason \n   * @returns \n   */\n  onDispose: (reason: string) => void\n}\n\n\n/**\n * WithValue stream options\n */\nexport type WithValueOptions<V> = Partial<InitStreamOptions> & {\n  /**\n   * Initial value\n   */\n  initial: V,\n  /**\n   * Laziness\n   */\n  lazy?: Lazy\n}\n\n\nexport type ResolveOptions = {\n  /**\n   * How many times to return value or call function.\n   * If _infinite_ is set to true, this value is ignored\n   */\n  loops: number\n  /**\n   * If _true_ loops forever\n   */\n  infinite: boolean\n  /**\n   * Delay before value\n   */\n  interval: Interval\n\n  lazy: Lazy\n}\n\nexport type ReactiveOpInit<TIn, TOut, TOpts> = (options: Partial<TOpts>) => ReactiveOp<TIn, TOut>\nexport type ReactiveOp<TIn, TOut> = (source: ReactiveOrSource<TIn>) => Reactive<TOut>\n\nexport type ReactiveOpLinks<In, Out> = [\n  ReactiveOrSource<In>,\n  ...ReactiveOp<any, any>[],\n  ReactiveOp<any, Out>\n]\n\nexport type RxValueTypes<T extends readonly ReactiveOrSource<any>[]> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V | undefined :\n    T[ K ] extends Wrapped<infer V> ? V | undefined :\n    T[ K ] extends Generator<infer V> ? V | undefined :\n    T[ K ] extends AsyncGenerator<infer V> ? V | undefined :\n    T[ K ] extends IterableIterator<infer V> ? V | undefined :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V | undefined :\n    T[ K ] extends (infer V)[] ? V | undefined :\n    never };\n\nexport type RxValueTypeObject<T extends Record<string, ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V :\n    T[ K ] extends Wrapped<infer V> ? V :\n    T[ K ] extends Generator<infer V> ? V :\n    T[ K ] extends AsyncGenerator<infer V> ? V :\n    T[ K ] extends IterableIterator<infer V> ? V :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V :\n    T[ K ] extends (infer V)[] ? V :\n    never };\n\nexport type RxValueTypeObjectOrUndefined<T extends Record<string, ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? V | undefined :\n    T[ K ] extends Wrapped<infer V> ? V | undefined :\n    T[ K ] extends Generator<infer V> ? V | undefined :\n    T[ K ] extends AsyncGenerator<infer V> ? V | undefined :\n    T[ K ] extends IterableIterator<infer V> ? V | undefined :\n    T[ K ] extends AsyncIterableIterator<infer V> ? V | undefined :\n    T[ K ] extends (infer V)[] ? V | undefined :\n    never };\n\nexport type RxValueTypeRx<T extends Record<string, ReactiveOrSource<any>>> =\n  { [ K in keyof T ]: T[ K ] extends Reactive<infer V> ? Reactive<V> :\n    T[ K ] extends Wrapped<infer V> ? Reactive<V> :\n    T[ K ] extends Generator<infer V> ? Reactive<V> :\n    T[ K ] extends AsyncGenerator<infer V> ? Reactive<V> :\n    T[ K ] extends IterableIterator<infer V> ? Reactive<V> :\n    T[ K ] extends AsyncIterableIterator<infer V> ? Reactive<V> :\n    T[ K ] extends (infer V)[] ? Reactive<V> :\n    never };\n\nexport type PrimitiveValueTypeObject<T extends Record<string, Primitive>> =\n  { [ K in keyof T ]:\n    T[ K ] extends number ? number | undefined :\n    T[ K ] extends string ? string | undefined :\n    T[ K ] extends boolean ? boolean | undefined :\n    T[ K ] extends bigint ? bigint | undefined :\n    never };\n\n\n","import { object } from \"./object.js\";\nimport { symbol, type ReactiveArray, type ReactiveDiff, type ReactiveInitial } from \"../types.js\";\nimport { array } from \"./array.js\";\nimport { arrayObject } from \"./array-object.js\";\n\nexport type ReactiveProxied<V> = V & {\n  [ symbol ]: ReactiveDiff<V> & ReactiveInitial<V>\n}\n/**\n * Creates a proxy of `target` object (or array), so that regular property setting will be intercepted and output\n * on a {@link Reactive} object as well.\n * \n * ```js\n * const { proxy, rx } = Rx.From.objectProxy({ colour: `red`, x: 10, y: 20 });\n * \n * rx.onValue(v => {\n *  // Get notified when proxy is changed\n * });\n * \n * // Get and set properties as usual\n * console.log(proxy.x);\n * proxy.x = 20; // Triggers Reactive\n * ```\n * \n * Keep in mind that changing `target` directly won't affect the proxied object or Reactive. Thus,\n * only update the proxied object after calling `fromProxy`.\n * \n * The benefit of `objectProxy` instead of {@link From.object} is because the proxied object can be passed to other code that doesn't need\n * to know anything about Reactive objects.\n * \n * You can assign the return values to more meaningful names using\n * JS syntax.\n * ```js\n * const { proxy:colour, rx:colourRx } = Rx.From.objectProxy({ colour: `red` });\n * ```\n * \n * If `target` is an array, it's not possible to change the shape of the array by adding or removing\n * elements, only by updating existing ones. This follows the same behaviour of objects. Alternatively, use {@link arrayProxy}.\n * \n * See also:\n * * {@link objectProxySymbol}: Instead of {proxy,rx} return result, puts the `rx` under a symbol on the proxy.\n * * {@link arrayProxy}: Proxy an array, allowing inserts and deletes.\n * @param target \n * @returns \n */\nexport const objectProxy = <V extends object>(target: V): { proxy: V, rx: ReactiveDiff<V> & ReactiveInitial<V> } => {\n\n  const rx = object(target);\n\n  const proxy = new Proxy(target, {\n    set(target, p, newValue, _receiver) {\n\n      const isArray = Array.isArray(target);\n      //console.log(`Rx.Sources.object set. Target: ${ JSON.stringify(target) } (${ typeof target } array: ${ Array.isArray(target) }) p: ${ JSON.stringify(p) } (${ typeof p }) newValue: ${ JSON.stringify(newValue) } recv: ${ _receiver }`);\n\n      // Ignore length if target is array\n      if (isArray && p === `length`) return true;\n\n      if (typeof p === `string`) {\n        rx.updateField(p, newValue);\n      }\n\n      // If target is array and field looks like an array index...\n      if (isArray && typeof p === `string`) {\n        const pAsNumber = Number.parseInt(p);\n        if (!Number.isNaN(pAsNumber)) {\n          target[ pAsNumber ] = newValue;\n          return true;\n        }\n      }\n      (target as any)[ p ] = newValue;\n      return true;\n    }\n  });\n  return { proxy, rx }\n}\n\nexport const arrayProxy = <V, T extends V[]>(target: T): { proxy: T, rx: ReactiveArray<V> & ReactiveInitial<readonly V[]> } => {\n  const rx = arrayObject(target);\n  const proxy = new Proxy(target, {\n    set(target, p, newValue, _receiver) {\n\n      //console.log(`Rx.Sources.arrayProxy set. Target: ${ JSON.stringify(target) } (${ typeof target } array: ${ Array.isArray(target) }) p: ${ JSON.stringify(p) } (${ typeof p }) newValue: ${ JSON.stringify(newValue) } recv: ${ _receiver }`);\n\n      // Ignore length if target is array\n      if (p === `length`) return true;\n      if (typeof p !== `string`) throw new Error(`Expected numeric index, got type: ${ typeof p } value: ${ JSON.stringify(p) }`);\n      const pAsNumber = Number.parseInt(p);\n      if (!Number.isNaN(pAsNumber)) {\n        rx.setAt(pAsNumber, newValue);\n        target[ pAsNumber ] = newValue;\n\n        return true;\n      } else {\n        throw new Error(`Expected numeric index, got: '${ p }'`);\n      }\n    }\n  });\n  return { proxy, rx }\n}\n\n/**\n * Same as {@link objectProxy}, but the return value is the proxied object along with \n * the Reactive wrapped as symbol property.\n * \n * ```js\n * const person = Rx.fromProxySymbol({name: `marie` });\n * person.name = `blah`;\n * person[Rx.symbol].on(msg => {\n *  // Value changed...\n * });\n * ```\n * \n * This means of access can be useful as the return result\n * is a bit neater, being a single object instead of two. \n * @param target \n * @returns \n */\nexport const objectProxySymbol = <V extends object>(target: V): ReactiveProxied<V> => {\n  const { proxy, rx } = objectProxy(target);\n\n  const p = proxy as ReactiveProxied<V>;\n  p[ symbol ] = rx;\n  return p;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport type { Reactive, ReactiveWritable } from \"../types.js\";\nimport { messageHasValue } from \"../util.js\";\nimport { manual } from \"../index.js\";\n\n/**\n * Creates a RxJs style observable\n * ```js\n * const o = observable(stream => {\n *  // Code to run for initialisation when we go from idle to at least one subscriber\n *  // Won't run again for additional subscribers, but WILL run again if we lose\n *  // all subscribers and then get one\n * \n *  // To send a value:\n *  stream.set(someValue);\n * \n *   // Optional: return function to call when all subscribers are removed\n *   return () => {\n *     // Code to run when all subscribers are removed\n *   }\n * });\n * ```\n * \n * For example:\n * ```js\n * const xy = observable<(stream => {\n *  // Send x,y coords from PointerEvent\n *  const send = (event) => {\n *    stream.set({ x: event.x, y: event.y });\n *  }\n *  window.addEventListener(`pointermove`, send);\n *  return () => {\n *    // Unsubscribe\n *    window.removeEventListener(`pointermove`, send);\n *  }\n * });\n * \n * xy.onValue(value => {\n *  console.log(value);\n * });\n * ```\n * @param init \n * @returns \n */\nexport function observable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined): Reactive<V> {\n  const ow = observableWritable(init);\n  return {\n    dispose: ow.dispose,\n    isDisposed: ow.isDisposed,\n    on: ow.on,\n    onValue: ow.onValue\n  }\n}\n\n/**\n * As {@link observable}, but returns a Reactive that allows writing\n * @param init \n * @returns \n */\nexport function observableWritable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined): ReactiveWritable<V> & Reactive<V> {\n  let onCleanup: (() => void) | undefined = () => {/** no-op */ };\n  const ow = manual<V>({\n    onFirstSubscribe() {\n      onCleanup = init(ow);\n    },\n    onNoSubscribers() {\n      if (onCleanup) onCleanup();\n    },\n  });\n\n  return {\n    ...ow,\n    onValue: (callback: (value: V) => void) => {\n      return ow.on(message => {\n        if (messageHasValue(message)) {\n          callback(message.value);\n        }\n      });\n    }\n  };\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport { initStream } from \"../init-stream.js\";\nimport type { ReactiveWritable, ReactiveInitial, ReactiveNonInitial } from \"../types.js\";\n\nexport function string(initialValue: string): ReactiveWritable<string> & ReactiveInitial<string>;\nexport function string(): ReactiveWritable<string> & ReactiveNonInitial<string>;\nexport function string(initialValue?: string): ReactiveWritable<string> & (ReactiveNonInitial<string> | ReactiveInitial<string>) {\n  let value = initialValue;\n  const events = initStream<string>();\n\n  const set = (v: string) => {\n    value = v;\n    events.set(v);\n  }\n\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    last: () => value,\n    on: events.on,\n    onValue: events.onValue,\n    set\n  }\n}","export * from './array.js';\nexport * from './array-object.js';\nexport * from './boolean.js';\nexport * from './count.js';\nexport * from './derived.js';\nexport * from './event.js';\nexport * from './function.js';\nexport * from './iterator.js';\nexport * from './merged.js';\nexport * from './number.js';\nexport * from './object.js';\nexport * from './object-proxy.js';\nexport * from './observable.js';\nexport * from './string.js';\nexport * from './types.js';","import type { IQueueMutableWithEvents, QueueMutableEvents } from \"@ixfx/collections/queue\";\nimport { manual } from \"../index.js\";\n\n\n/**\n * Changes to `queue` are output as a responsive stream.\n * The stream emits the full data of the queue (first item being the head of the queue)\n * whenever there is an enqueue, remove or clear operation.\n * \n * ```js\n * const queue = new QueueMutable();\n * const r = asResponsive(queue);\n * r.onValue(v => {\n *  // v is an array of values\n * });\n * \n * \n * Calling `set()` on the stream enqueues data to the wrapped queue.\n * ```js\n * r.set([ `1, `2` ]); // Enqueues 1, 2\n * ```\n * @param queue \n * @returns \n */\nexport function asResponsive<T>(queue: IQueueMutableWithEvents<T>) {\n  const events = manual<readonly T[]>({\n    onNoSubscribers() {\n      queue.removeEventListener(`removed`, onRemoved);\n      queue.removeEventListener(`enqueue`, onEnqueue);\n    },\n    onFirstSubscribe() {\n      queue.addEventListener(`removed`, onRemoved);\n      queue.addEventListener(`enqueue`, onEnqueue);\n      events.set(queue.toArray());\n    },\n  });\n\n  const onRemoved = (event: QueueMutableEvents<T>[ `removed` ]) => {\n    events.set(event.finalData);\n  }\n  const onEnqueue = (event: QueueMutableEvents<T>[ `enqueue` ]) => {\n    events.set(event.finalData);\n  }\n\n  const set = (data: T[]) => {\n    queue.enqueue(...data);\n  }\n\n  return {\n    ...events,\n    set\n  }\n}","export * from './responsive-queue.js';","import { Directed } from \"@ixfx/collections/graph\";\nimport { initStream } from \"./init-stream.js\";\nimport type { Reactive } from \"./types.js\";\nimport { isReactive } from \"./util.js\";\ntype RxNodeBase = {\n  type: `primitive` | `rx` | `object`\n}\n\ntype RxNodeRx = RxNodeBase & {\n  type: `rx`,\n  value: Reactive<any>\n}\n\ntype RxNodePrimitive = RxNodeBase & {\n  type: `primitive`,\n  value: any\n}\n\ntype RxNode = RxNodeRx | RxNodePrimitive;\n\n// function isReactive(o: object): o is Reactive<any> {\n//   if (typeof o !== `object`) return false;\n//   if (`on` in o) {\n//     return (typeof o.on === `function`);\n//   }\n//   return false;\n// }\n\n/**\n * Build a graph of reactive dependencies for `rx`\n * @param _rx \n */\nexport function prepare<V extends Record<string, any>>(_rx: V): Reactive<V> {\n  let g = Directed.graph();\n  const nodes = new Map<string, RxNode>();\n  const events = initStream<V>();\n\n  const process = (o: object, path: string) => {\n    for (const [ key, value ] of Object.entries(o)) {\n      const subPath = path + `.` + key;\n      g = Directed.connect(g, {\n        from: path,\n        to: subPath\n      });\n      if (isReactive(value)) {\n        nodes.set(subPath, { value, type: `rx` });\n        value.on(v => {\n          console.log(`Rx.prepare value: ${ JSON.stringify(v) } path: ${ subPath }`);\n        });\n      } else {\n        const valueType = typeof value;\n\n        if (valueType === `bigint` || valueType === `boolean` || valueType === `number` || valueType === `string`) {\n          nodes.set(subPath, { type: `primitive`, value });\n        } else if (valueType === `object`) {\n          process(value, subPath)\n        } else if (valueType === `function`) {\n          console.log(`Rx.process - not handling functions`);\n        }\n      }\n    }\n  }\n\n  // const produce = () => {\n  //   Object.fromEntries(entries);\n  // }\n\n  // process(rx, `_root`);\n  // console.log(DiGraph.dumpGraph(g));\n\n  // console.log(`--- Map ---`);\n\n  // for (const entries of nodes.entries()) {\n  //   console.log(entries[ 0 ]);\n  //   console.log(entries[ 1 ]);\n  //   console.log(``)\n  // }\n\n\n  const returnValue = {\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    dispose: events.dispose,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    isDisposed: events.isDisposed,\n    graph: g,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    on: events.on,\n    // eslint-disable-next-line @typescript-eslint/unbound-method\n    onValue: events.onValue\n  }\n  return returnValue;\n}\n\n","import { intervalToMs } from \"@ixfx/core\";\nimport type { ReactiveOrSource, ToArrayOptions } from \"./types.js\";\nimport { resolveSource } from \"./resolve-source.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./util.js\";\n\n/**\n * Reads a set number of values from `source`, returning as an array. May contain\n * empty values if desired values is not reached.\n * \n * After the limit is reached (or `source` completes), `source` is unsubscribed from.\n * \n * If no limit is set, it will read until `source` completes or `maximumWait` is reached.\n * `maximumWait` is 10 seconds by default.\n * \n * Use {@link toArrayOrThrow} to throw if desired limit is not reached.\n * \n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArray()(source);\n * // Read 5 items from `source`\n * const data = await toArray({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArray({ maximumWait: 10_1000 })(source);\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport async function toArray<V>(source: ReactiveOrSource<V>, options: Partial<ToArrayOptions<V>> = {}): Promise<(V | undefined)[]> {\n  const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n  const maximumWait = intervalToMs(options.maximumWait, 10 * 1000);\n  const underThreshold = options.underThreshold ?? `partial`\n  const read: (V | undefined)[] = [];\n\n  const rx = resolveSource(source);\n\n  const promise = new Promise<(V | undefined)[]>((resolve, reject) => {\n    const done = () => {\n      clearTimeout(maxWait);\n      unsub();\n      if (read.length < limit && underThreshold === `throw`) {\n        reject(new Error(`Threshold not reached. Wanted: ${ limit } got: ${ read.length }. Maximum wait: ${ maximumWait }`));\n        return;\n      }\n      if (read.length < limit && underThreshold === `fill`) {\n        for (let index = 0; index < limit; index++) {\n          if (read[ index ] === undefined) {\n            //console.log(`Rx.toArray filling at index: ${ index }`);\n            read[ index ] = options.fillValue;\n          }\n        }\n      }\n      resolve(read);\n    }\n\n    const maxWait = setTimeout(() => {\n      done();\n    }, maximumWait);\n\n    const unsub = rx.on(message => {\n      //console.log(`Rx.toArray: ${ JSON.stringify(message) }`);\n      if (messageIsDoneSignal(message)) {\n        done();\n      } else if (messageHasValue(message)) {\n        read.push(message.value);\n        //console.log(`Rx.toArray read buffer: ${ JSON.stringify(read) }`);\n        if (read.length === limit) {\n          done();\n        }\n      }\n    });\n  });\n\n  return promise;\n}\n\n\n/**\n * By default, reads all the values from `source`, or until 5 seconds has elapsed.\n * \n * If `limit` is provided as an option, it will exit early, or throw if that number of values was not acheived.\n * \n * ```js\n * // Read from `source` for 5 seconds\n * const data = await toArrayOrThrow()(source);\n * // Read 5 items from `source`\n * const data = await toArrayOrThrow({ limit: 5 })(source);\n * // Read for 10s\n * const data = await toArrayOrThrow({ maximumWait: 10_1000 })(source);\n * ```\n * @param source \n * @param options \n * @returns \n */\nexport async function toArrayOrThrow<V>(source: ReactiveOrSource<V>, options: Partial<ToArrayOptions<V>> = {}): Promise<V[]> {\n  const limit = options.limit ?? Number.MAX_SAFE_INTEGER;\n  const maximumWait = options.maximumWait ?? 5 * 1000;\n  const v = await toArray(source, { limit, maximumWait, underThreshold: `partial` });\n\n  // There was a limit, but it wasn't reached\n  if (options.limit && v.length < options.limit) throw new Error(`Threshold not reached. Wanted: ${ options.limit }, got ${ v.length }`);\n\n  // Otherwise, we may have been reading for a specified duration\n  return v as V[];\n\n}","import { resolveSource } from \"./resolve-source.js\";\nimport type { ReactiveOrSource } from \"./types.js\";\nimport { messageHasValue, messageIsDoneSignal } from \"./util.js\";\n\n/**\n * Returns an AsyncGenerator wrapper around Reactive.\n * This allows values to be iterated over using a `for await` loop,\n * like Chains.\n *\n * ```js\n * // Reactive numerical value\n * const number = Reactive.number(10);\n * \n * const g = Reactive.toGenerator(number);\n * for await (const v of g) {\n *  console.log(v); // Prints out whenever the reactive value changes\n * }\n * // Execution doesn't continue until Reactive finishes\n * ```\n * \n * When/if `source` closes, an exception is thrown.\n * To catch this, wrap the calling `for await` in a try-catch block\n * ```js\n * try {\n *  for await (const v of g) {\n *  }\n * } catch (error) {\n * }\n * // Completed\n * ``` \n * \n * Use something like `setTimeout` to loop over the generator\n * without impeding the rest of your code flow. For example:\n * ```js\n * // Listen for every pointerup event\n * const ptr = Reactive.fromEvent(document.body, `pointerup`);\n * // Start iterating\n * setTimeout(async () => {\n *  const gen = Reactive.toGenerator(ptr);\n *  try {\n *    for await (const v of gen) {\n *      // Prints out whenever there is a click\n *      console.log(v);\n *    }\n *  } catch (e) { }\n *  console.log(`Iteration done`);\n * });\n * \n * // Execution continues here immediately\n * ```\n * @param source \n */\nexport async function* toGenerator<V>(source: ReactiveOrSource<V>): AsyncGenerator<V> {\n  const s = resolveSource(source);\n  let promiseResolve: ((value: V | PromiseLike<V>) => void) = (_) => {/** noop */ };\n  let promiseReject: ((reason: string) => void) = (_) => {/** no-op */ }\n\n  const promiseInit = () => (new Promise<V>((resolve, reject) => {\n    promiseResolve = resolve;\n    promiseReject = reject;\n  }));\n  let promise = promiseInit();\n  let keepRunning = true;\n\n  s.on(message => {\n    if (messageHasValue(message)) {\n      promiseResolve(message.value);\n      promise = promiseInit();\n    } else if (messageIsDoneSignal(message)) {\n      keepRunning = false;\n      promiseReject(`Source has completed`);\n    }\n  });\n\n  while (keepRunning) {\n    yield await promise;\n  }\n}\n","import * as Ops from \"./ops/index.js\";\nimport * as Reactives from './reactives/index.js';\nimport { resolveSource } from \"./resolve-source.js\";\nimport { toArray, toArrayOrThrow } from \"./to-array.js\";\nimport type { ReactiveOrSource, Wrapped, ToArrayOptions, InitStreamOptions, Reactive, RxValueTypes, CombineLatestOptions, ReactiveOp, } from \"./types.js\";\nimport type { ChunkOptions, FieldOptions, FilterPredicate, DebounceOptions, SwitcherOptions, SplitOptions, ThrottleOptions, TransformOpts, SyncOptions, } from './ops/types.js'\nimport type { TimeoutPingOptions, TimeoutValueOptions } from './from/types.js'\nimport { messageHasValue } from \"./util.js\";\nimport { mapObjectShallow } from '@ixfx/core/records';\nimport * as Enacts from './sinks/index.js';\nimport type { Processors } from \"@ixfx/process\";\n\n/**\n * Wrap a reactive source to allow for chained\n * function calls.\n * \n * Example:\n * For every `pointerup` event on the body, chunk the events over\n * periods of 200ms, get the number of events in that period,\n * and print it out.\n * \n * eg. detecting single or double-clicks\n * ```js\n * wrap(Rx.fromEvent<{ x: number, y: number }>(document.body, `pointerup`))\n *  .chunk({ elapsed: 200 })\n *  .transform(v => v.length)\n *  .onValue(v => { console.log(v) });\n * ```\n * @param source \n * @returns \n */\nexport function wrap<TIn>(source: ReactiveOrSource<TIn>): Wrapped<TIn> {\n  return {\n    source: resolveSource(source),\n    enacts: {\n      setHtmlText: (options) => {\n        return Enacts.setHtmlText(source, options);\n      },\n    },\n    annotate: <TAnnotation>(transformer: (value: TIn) => TAnnotation): Wrapped<{ value: TIn, annotation: TAnnotation }> => {\n      const a = Ops.annotate<TIn, TAnnotation>(source, transformer);\n      return wrap(a);\n    },\n    annotateWithOp: <TOut>(op: ReactiveOp<TIn, TOut>): Wrapped<{ value: TIn, annotation: TOut }> => {\n      const a = Ops.annotateWithOp<TIn, TOut>(source, op);\n      return wrap(a);\n    },\n\n    chunk: (options: Partial<ChunkOptions>): Wrapped<TIn[]> => {\n      const w = wrap<TIn[]>(Ops.chunk(source, options));\n      return w;\n    },\n    // debounce: (options: Partial<DebounceOptions> = {}) => {\n    //   return wrap(Ops.debounce<TIn>(source, options));\n    // },\n    debounce: (options: Partial<DebounceOptions> = {}) => {\n      return wrap(Reactives.debounce(source, options));\n    },\n    field: <TSource, TFieldType>(fieldName: keyof TIn, options: Partial<FieldOptions<TSource, TFieldType>> = {}) => {\n      // Ops.field requires TIn extends object\n      // Would be good if `wrap` returns different versions depending on TIn, so .field\n      // would not be present at all if we had Reactive<number>, for example\n      // @ts-expect-error\n      const f = Ops.field<TIn, TFieldType>(source, fieldName, options);\n      return wrap<TFieldType>(f);\n    },\n    filter: (predicate: FilterPredicate<TIn>, options: Partial<InitStreamOptions>) => {\n      return wrap(Ops.filter(source, predicate, options));\n    },\n    combineLatestToArray: <const T extends readonly ReactiveOrSource<any>[]>(sources: T, options: Partial<CombineLatestOptions> = {}) => {\n      const srcs = [ source, ...sources ] as any as T;\n      return wrap(Ops.combineLatestToArray(srcs, options));\n    },\n    combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name?: string } & Partial<CombineLatestOptions>) => {\n      const name = options.name ?? `source`;\n      const o = { ...sources };\n      (o as any)[ name ] = source;\n      return wrap(Ops.combineLatestToObject(o, options));\n    },\n    min: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.min(source, options));\n    },\n    max: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.max(source, options));\n    },\n    average: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.average(source, options));\n    },\n    sum: (options: Partial<Ops.OpMathOptions> = {}) => {\n      return wrap(Ops.sum(source, options));\n    },\n    tally: (options: Partial<Ops.TallyOptions> = {}) => {\n      return wrap(Ops.tally(source, options));\n    },\n    split: (options: Partial<SplitOptions> = {}) => {\n      const streams = Ops.split<TIn>(source, options).map(v => wrap(v));\n      return streams;\n    },\n    splitLabelled: <K extends keyof TIn>(...labels: K[]) => {\n      const l = Ops.splitLabelled<TIn, keyof TIn>(source, labels);\n      const m = mapObjectShallow<typeof l, Wrapped<TIn>>(l, args => wrap(args.value as Reactive<TIn>)) as Record<K, Wrapped<TIn>>;\n      return m;\n    },\n    switcher: <TRec extends Record<string, FilterPredicate<TIn>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions> = {}) => {\n      const s = Ops.switcher<TIn, TRec, TLabel>(source, cases, options);\n      const m = mapObjectShallow<typeof s, Wrapped<TIn>>(s, args => wrap(args.value as Reactive<TIn>));\n      return m as Record<TLabel, Wrapped<TIn>>;\n    },\n    syncToArray: <const T extends readonly ReactiveOrSource<any>[]>(additionalSources: T, options: Partial<SyncOptions> = {}) => {\n      const unwrapped = [ source, ...additionalSources ].map(v => resolveSource(v));\n      const x = Ops.syncToArray(unwrapped, options) as Reactive<[ TIn, ...RxValueTypes<T> ]>;\n      return wrap(x); //synchronise<TIn>([ source, ...unwrapped ] as const));\n    },\n    syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(sources: T, options: { name?: string } & Partial<SyncOptions> = {}) => {\n      const name = options.name ?? `source`;\n      const o = { ...sources };\n      (o as any)[ name ] = source;\n      return wrap(Ops.syncToObject(o, options));\n    },\n    tapProcess: <T2, T3, T4, T5, T6>(...processors: Processors<TIn, T2, T3, T4, T5, T6>) => {\n      Ops.tapProcess(source, ...processors)\n      return wrap(source);\n    },\n    tapStream: (divergedStream) => {\n      Ops.tapStream(source, divergedStream);\n      return wrap(source);\n    },\n    tapOps: <TOut>(source: ReactiveOrSource<TIn>, ...ops: ReactiveOp<TIn, TOut>[]) => {\n      Ops.tapOps(source, ...ops);\n      return wrap(source);\n    },\n    throttle: (options: Partial<ThrottleOptions> = {}) => {\n      return wrap(Ops.throttle<TIn>(source, options));\n    },\n    transform: <TOut>(transformer: (value: TIn) => TOut, options: Partial<TransformOpts> = {}) => {\n      return wrap(Ops.transform(source, transformer, options));\n    },\n    timeoutValue: <TTrigger>(options: TimeoutValueOptions<TTrigger>) => {\n      return wrap(Ops.timeoutValue<TIn, TTrigger>(source, options));\n    },\n    timeoutPing: (options: TimeoutPingOptions) => {\n      return wrap(Ops.timeoutPing(source, options));\n    },\n    toArray: (options: Partial<ToArrayOptions<TIn>>) => {\n      return toArray(source, options);\n    },\n    toArrayOrThrow: (options: Partial<ToArrayOptions<TIn>>) => {\n      return toArrayOrThrow(source, options);\n    },\n    onValue: (callback: ((value: TIn) => void)) => {\n      const s = resolveSource(source);\n      s.on(message => {\n        if (messageHasValue(message)) callback(message.value);\n      })\n    }\n  }\n}\n","\n\nimport type { Reactive, ReactiveOrSource, ReactiveWritable, ReactiveOp, InitStreamOptions, WithValueOptions, CombineLatestOptions, RxValueTypes, RxValueTypeObject, PipeSet, ReactivePingable } from \"./types.js\";\nimport type { ChunkOptions, DebounceOptions, FieldOptions, SingleFromArrayOptions, SplitOptions, FilterPredicate, SwitcherOptions, SyncOptions, ThrottleOptions } from \"./ops/types.js\";\nimport type { RankFunction, RankOptions } from \"@ixfx/core\";\nimport type { TimeoutPingOptions, TimeoutValueOptions } from \"./from/types.js\";\nimport { type Interval, intervalToMs } from '@ixfx/core';\nimport { isWritable, messageHasValue, messageIsDoneSignal, opify } from \"./util.js\";\nimport { initStream } from \"./init-stream.js\";\nimport { resolveSource } from './resolve-source.js';\nimport * as SinkFns from './sinks/index.js';\nimport * as OpFns from './ops/index.js';\n\nexport * as From from './from/index.js';\nexport * as Collections from './collections/index.js';\n\nexport * from './ops/index.js';\nexport * from './sinks/index.js';\nexport * from './graph.js';\nexport * from './types.js';\nexport * from './to-array.js';\nexport * from './to-generator.js';\nexport * from './util.js';\nexport * from './wrap.js';\nexport * from './resolve-source.js';\nexport * from './cache.js';\nexport * from './init-stream.js';\n\nexport function run<TIn, TOut>(source: ReactiveOrSource<any>, ...ops: ReactiveOp<any, any>[]) {\n  let s = resolveSource(source);\n  for (const op of ops) {\n    // @ts-ignore\n    s = op(s);\n  }\n  return s;\n}\n\nexport function writable<TIn, TOut>(source: ReactiveOrSource<TIn>, ...ops: ReactiveOp<any, any>[]): ReactiveWritable<TIn, TOut> {\n  let s = resolveSource(source);\n  const head = s;\n  for (const op of ops) {\n    // @ts-ignore\n    s = op(s);\n  }\n  const ss = s as any as Reactive<TOut>;\n  return {\n    ...ss,\n    set(value: TIn) {\n      if (isWritable(head)) {\n        head.set(value);\n      } else throw new Error(`Original source is not writable`);\n    }\n  } as ReactiveWritable<TIn, TOut>\n  //return s as Reactive<T2 | T3 | T4 | T5 | T6>;\n  //const raw = chainer<T1, T2, T3, T4, T5, T6>(...ops);\n  //return raw(source);\n}\n\n/**\n * Initialises a reactive that pipes values to listeners directly.\n * @returns \n */\nexport function manual<V>(options: Partial<InitStreamOptions> = {}): Reactive<V> & ReactiveWritable<V> {\n  const events = initStream<V>(options);\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    set(value: V) {\n      events.set(value);\n    },\n    on: events.on,\n    onValue: events.onValue\n  };\n}\n\nexport const Sinks = {\n  setHtmlText: (options: SinkFns.SetHtmlOptions) => {\n    return (source: ReactiveOrSource<string>) => {\n      SinkFns.setHtmlText(source, options);\n    }\n  }\n}\n\nexport const Ops = {\n  /**\n * Annotates values with the result of a function.\n * The input value needs to be an object.\n * \n * For every value `input` emits, run it through `annotator`, which should\n * return the original value with additional fields.\n * \n * Conceptually the same as `transform`, just with typing to enforce result\n * values are V & TAnnotation\n * @param annotator \n * @returns \n */\n  annotate: <V, TAnnotation>(annotator: (input: V) => V & TAnnotation) => opify(OpFns.annotate, annotator),\n  /**\n   * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n   * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n   * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n   * \n   * ```js\n   * // Emit values from an array\n   * const r1 = Rx.run(\n   *  Rx.From.array([ 1, 2, 3 ]),\n   *  Rx.Ops.annotateWithOp(\n   *    // Add the 'max' operator to emit the largest-seen value\n   *    Rx.Ops.sum()\n   *  )\n   * );\n   * const data = await Rx.toArray(r1);\n   * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n   * ```\n   * @param annotatorOp \n   * @returns \n   */\n  annotateWithOp: <TIn, TAnnotation>(annotatorOp: ReactiveOp<TIn, TAnnotation>) => opify(OpFns.annotateWithOp, annotatorOp),\n  /**\n   * Takes a stream of values and chunks them up (by quantity or time elapsed),\n   * emitting them as an array.\n   * @param options \n   * @returns \n   */\n  chunk: <V>(options: Partial<ChunkOptions>): ReactiveOp<V, V[]> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.chunk(source, options);\n    }\n  },\n\n  cloneFromFields: <V>(): ReactiveOp<V, V> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.cloneFromFields(source);\n    }\n  },\n  /**\n * Merges values from several sources into a single source that emits values as an array.\n * @param options \n * @returns \n */\n  combineLatestToArray: <const T extends readonly ReactiveOrSource<any>[]>(options: Partial<CombineLatestOptions> = {}) => {\n    return (sources: T) => {\n      return OpFns.combineLatestToArray(sources, options);\n    }\n  },\n  /**\n   * Merges values from several sources into a single source that emits values as an object.\n   * @param options\n   * @returns \n   */\n  combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(options: Partial<CombineLatestOptions> = {}) => {\n    return (reactiveSources: T) => {\n      return OpFns.combineLatestToObject(reactiveSources, options);\n    }\n  },\n\n  /**\n * Debounce values from the stream. It will wait until a certain time\n * has elapsed before emitting latest value.\n * \n * Effect is that no values are emitted if input emits faster than the provided\n * timeout.\n * \n * See also: throttle\n * @param options \n * @returns \n */\n  // debounce: <V>(options: Partial<DebounceOptions>): ReactiveOp<V, V> => {\n  //   return (source: ReactiveOrSource<V>) => {\n  //     return OpFns.debounce(source, options);\n  //   }\n  // },\n  /**\n   * Drops values from the input stream that match `predicate`\n   * @param predicate If it returns _true_ value is ignored\n   * @returns \n   */\n  drop: <V>(predicate: (value: V) => boolean) => opify(OpFns.drop, predicate),\n  /**\n   * Every upstream value is considered the target for interpolation.\n   * Output value interpolates by a given amount toward the target.\n   * @returns \n   */\n  elapsed: <V>(): ReactiveOp<V, number> => opify(OpFns.elapsed),\n  /**\n   * Yields the value of a field from an input stream of values.\n   * Eg if the source reactive emits `{ colour: string, size: number }`,\n   * we might use `field` to pluck out the `colour` field, thus returning\n   * a stream of string values.\n   * @param fieldName \n   * @param options \n   * @returns \n   */\n  field: <TSource extends object, TFieldType>(fieldName: keyof TSource, options: FieldOptions<TSource, TFieldType>) => {\n    return (source: ReactiveOrSource<TSource>) => {\n      return OpFns.field(source, fieldName, options);\n    }\n  },\n  /**\n   * Filters the input stream, only re-emitting values that pass the predicate\n   * @param predicate If it returns _true_ value is allowed through\n   * @returns \n   */\n  filter: <V>(predicate: (value: V) => boolean) => opify(OpFns.filter, predicate),\n  /**\n   * Every upstream value is considered the target for interpolation.\n   * Output value interpolates by a given amount toward the target.\n   * @param options \n   * @returns \n   */\n  interpolate: <TIn = number>(options?: Partial<OpFns.OpInterpolateOptions>) => opify<TIn, ReactivePingable<number>>(OpFns.interpolate as any, options),\n  /**\n * Outputs the minimum numerical value of the stream.\n * A value is only emitted when minimum decreases.\n * @returns \n */\n  min: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.min, options),\n  /**\n   * Outputs the maxium numerical value of the stream.\n   * A value is only emitted when maximum increases.\n   * @returns \n   */\n  max: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.max, options),\n  sum: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.sum, options),\n  average: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.average, options),\n  tally: <TIn>(options?: OpFns.TallyOptions) => opify<TIn, Reactive<number>>(OpFns.tally, options),\n  rank: <TIn>(rank: RankFunction<TIn>, options?: RankOptions & OpFns.OpMathOptions) => opify<TIn>(OpFns.rank, rank, options),\n\n  pipe: <TInput, TOutput>(...streams: (Reactive<any> & ReactiveWritable<any>)[]) => {\n    return (source: ReactiveOrSource<TInput>) => {\n      const resolved = resolveSource(source);\n      const s = [ resolved, ...streams ] as PipeSet<TInput, TOutput>;\n      return OpFns.pipe(...s);\n    }\n  },\n\n  singleFromArray: <V>(options: Partial<SingleFromArrayOptions<V>> = {}) => {\n    return (source: ReactiveOrSource<V[]>) => {\n      return OpFns.singleFromArray(source, options)\n    }\n  },\n\n  split: <V>(options: Partial<SplitOptions> = {}) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.split(source, options);\n    }\n  },\n  splitLabelled: <V>(labels: string[]) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.splitLabelled(source, labels);\n    }\n  },\n  switcher: <TValue, TRec extends Record<string, FilterPredicate<TValue>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions> = {}) => {\n    return (source: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n      return OpFns.switcher(source, cases, options);\n    }\n  },\n  syncToArray: <const T extends readonly ReactiveOrSource<any>[]>(options: Partial<SyncOptions> = {}) => {\n    return (reactiveSources: T): Reactive<RxValueTypes<T>> => {\n      return OpFns.syncToArray(reactiveSources, options);\n    }\n  },\n  syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(options: Partial<SyncOptions> = {}) => {\n    return (reactiveSources: T): Reactive<RxValueTypeObject<T>> => {\n      return OpFns.syncToObject(reactiveSources, options);\n    }\n  },\n  tapProcess: <In>(processor: ((value: In) => any)): ReactiveOp<In, In> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapProcess(source, processor);\n    }\n  },\n  tapStream: <In>(divergedStream: ReactiveWritable<In>): ReactiveOp<In, In> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapStream(source, divergedStream);\n    }\n  },\n  tapOps: <In, Out>(...ops: ReactiveOp<In, Out>[]) => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapOps(source, ...ops);\n    }\n  },\n\n  /**\n * Throttle values from the stream.\n * Only emits a value if some minimum time has elapsed.\n * @param options \n * @returns \n */\n  throttle: <V>(options: Partial<ThrottleOptions>) => opify<V>(OpFns.throttle, options),\n  /**\n   * Trigger a value if 'source' does not emit a value within an interval.\n   * Trigger value can be a fixed value, result of function, or step through an iterator.\n   * @param options \n   * @returns \n   */\n  timeoutValue: <V, TTriggerValue>(options: TimeoutValueOptions<TTriggerValue>) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.timeoutValue<V, TTriggerValue>(source, options);\n    }\n  },\n\n  timeoutPing: <V>(options: TimeoutPingOptions) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.timeoutPing(source, options);\n    }\n  },\n  transform: <In, Out>(transformer: ((value: In) => Out), options: Partial<OpFns.TransformOpts> = {}): ReactiveOp<In, Out> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.transform(source, transformer, options);\n    }\n  },\n\n  /**\n  * Reactive where last (or a given initial) value is available to read\n  * @param opts \n  * @returns \n  */\n  withValue: <V>(opts: Partial<WithValueOptions<V>>): ReactiveOp<V, V> => {\n    return opify<V>(OpFns.withValue, opts);\n  },\n} as const;\n\n\n// export const chain = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       // @ts-expect-error\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n\n// export const chainStream = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>): ReactiveStream<TIn, TOut> => {\n//   const stream = manual<TIn>();\n//   const c = chain(...ops);\n//   const x = c(stream);\n//   return x;\n// }\n\n\n\n// function chainx<TIn, TOut>(...ops: Array<ReactiveOp<any, any>>) {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n\n\n\n// export function runWithInitial<TIn, TOut>(initial: TOut, source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<any, any>>): ReactiveInitial<TOut> & ReactiveDisposable<TOut> {\n//   let lastValue = initial;\n//   const raw = prepareOps<TIn, TOut>(...ops);\n//   const r = raw(source);\n//   let disposed = false;\n\n//   r.onValue(value => {\n//     lastValue = value;\n//   });\n\n//   return {\n//     ...r,\n//     isDisposed() {\n//       return disposed\n//     },\n//     dispose(reason) {\n//       if (disposed) return;\n//       if (isDisposable(r)) {\n//         r.dispose(reason);\n//       }\n//       disposed = true;\n//     },\n//     last() {\n//       return lastValue;\n//     },\n//   }\n// }\n\n/**\n * Grabs the next value emitted from `source`.\n * By default waits up to a maximum of one second.\n * Handles subscribing and unsubscribing.\n * \n * ```js\n * const value = await Rx.takeNextValue(source);\n * ```\n * \n * Throws an error if the source closes without\n * a value or the timeout is reached.\n * \n * @param source \n * @param maximumWait \n * @returns \n */\nexport async function takeNextValue<V>(source: ReactiveOrSource<V>, maximumWait: Interval = 1000): Promise<V> {\n  const rx = resolveSource(source);\n  let off = () => {/** no-op */ };\n  let watchdog: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  const p = new Promise<V>((resolve, reject) => {\n    off = rx.on(message => {\n      if (watchdog) clearTimeout(watchdog);\n      if (messageHasValue(message)) {\n        off();\n        resolve(message.value);\n      } else {\n        if (messageIsDoneSignal(message)) {\n          reject(new Error(`Source closed. ${ message.context ?? `` }`));\n          off();\n        }\n      }\n    });\n\n    watchdog = setTimeout(() => {\n      watchdog = undefined;\n      off();\n      reject(new Error(`Timeout waiting for value (${ JSON.stringify(maximumWait) })`))\n    }, intervalToMs(maximumWait));\n  });\n  return p;\n}\n\n\n/**\n * Connects reactive A to B, optionally transforming the value as it does so.\n * \n * Returns a function to unsubcribe A->B\n * @param a \n * @param b \n * @param transform \n */\nexport const to = <TA, TB>(a: Reactive<TA>, b: ReactiveWritable<TB>, transform?: (valueA: TA) => TB, closeBonA = false) => {\n  const unsub = a.on(message => {\n    if (messageHasValue(message)) {\n      const value = transform ? transform(message.value) : message.value as TB;\n      b.set(value);\n    } else if (messageIsDoneSignal(message)) {\n      unsub();\n      if (closeBonA) {\n        b.dispose(`Source closed (${ message.context ?? `` })`);\n      }\n    } else {\n      // eslint-disable-nex Unsupported message: ${ JSON.stringify(message) }`);\n    }\n\n  });\n  return unsub;\n}"],"mappings":"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"}