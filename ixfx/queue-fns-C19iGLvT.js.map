{"version":3,"file":"queue-fns-C19iGLvT.js","names":[],"sources":["../../collections/dist/src/queue/queue-fns.js"],"sourcesContent":["export const debug = (opts, message) => {\n    opts.debug ? console.log(`queue:${message}`) : undefined;\n};\nexport const trimQueue = (opts, queue, toAdd) => {\n    const potentialLength = queue.length + toAdd.length;\n    const capacity = opts.capacity ?? potentialLength;\n    const toRemove = potentialLength - capacity;\n    const policy = opts.discardPolicy ?? `additions`;\n    // debug(\n    //   opts,\n    //   `queueLen: ${queue.length} potentialLen: ${potentialLength} toRemove: ${toRemove} policy: ${policy} toAdd.length: ${toAdd.length} capacity: ${capacity}`\n    // );\n    // debug(opts, `to add: ${JSON.stringify(toAdd)}`);\n    switch (policy) {\n        // Only add what we can from toAdd\n        case `additions`: {\n            // debug(\n            //   opts,\n            //   `trimQueue:DiscardAdditions: queueLen: ${queue.length} slice: ${\n            //     potentialLength - capacity\n            //   } toAddLen: ${toAdd.length} nowFull: ${queue.length === opts.capacity}`\n            // );\n            if (queue.length === 0)\n                return toAdd.slice(0, toAdd.length - toRemove);\n            // eslint-disable-next-line unicorn/prefer-ternary\n            if (queue.length === opts.capacity) {\n                return queue; // Completely full\n            }\n            else {\n                // Only add some from the new array (from the front)\n                return [...queue, ...toAdd.slice(0, toRemove - 1)];\n            }\n        }\n        // Remove from rear of queue (last index) before adding new things\n        case `newer`: {\n            if (toRemove >= queue.length) {\n                // New items will completely flush out old\n                //debug(opts, `slice start: ${toAdd.length - capacity}`);\n                if (queue.length === 0) {\n                    // Special case when queue starts off empty\n                    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                    return [...toAdd.slice(0, capacity - 1), toAdd.at(-1)];\n                }\n                return toAdd.slice(Math.max(0, toAdd.length - capacity), Math.min(toAdd.length, capacity) + 1);\n                //debug(opts, `Final value: ${JSON.stringify(tmp)}`);\n                //return tmp;\n            }\n            else {\n                // Keep some of the old\n                // const toAddFinal = toAdd.slice(\n                //   0,\n                //   Math.min(toAdd.length, capacity - toRemove + 1)\n                // );\n                // Cap 5, queue 5, toAdd: 10.\n                const countToAdd = Math.max(1, toAdd.length - queue.length);\n                const toAddFinal = toAdd.slice(toAdd.length - countToAdd, toAdd.length);\n                const toKeep = queue.slice(0, Math.min(queue.length, capacity - 1)); //toRemove);\n                // debug(\n                //   opts,\n                //   `trimQueue: countToAdd: ${countToAdd} qLen: ${\n                //     queue.length\n                //   } capacity: ${capacity} toRemove: ${toRemove} keeping: ${JSON.stringify(\n                //     toKeep\n                //   )} from orig: ${JSON.stringify(queue)} toAddFinal: ${JSON.stringify(\n                //     toAddFinal\n                //   )}`\n                // );\n                const t = [...toKeep, ...toAddFinal];\n                //debug(opts, `final: ${JSON.stringify(t)}`);\n                return t;\n            }\n        }\n        // Remove from the front of the queue (0 index). ie. older items are discarded\n        case `older`: {\n            // If queue is A, B and toAdd is C, D this yields A, B, C, D\n            return [...queue, ...toAdd].slice(toRemove);\n        }\n        default: {\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            throw new Error(`Unknown overflow policy ${policy}`);\n        }\n    }\n};\n/**\n * Adds to the back of the queue (last array index)\n * Last item of `toAdd` will potentially be the new end of the queue (depending on capacity limit and overflow policy)\n * @typeParam V - Type of values\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @param {...V[]} toAdd\n * @returns {V[]}\n */\nexport const enqueue = (opts, queue, ...toAdd) => {\n    if (opts === undefined)\n        throw new Error(`opts parameter undefined`);\n    const potentialLength = queue.length + toAdd.length;\n    const overSize = opts.capacity && potentialLength > opts.capacity;\n    const toReturn = overSize\n        ? trimQueue(opts, queue, toAdd)\n        : [...queue, ...toAdd];\n    if (opts.capacity && toReturn.length !== opts.capacity && overSize) {\n        throw new Error(`Bug! Expected return to be at capacity. Return len: ${toReturn.length} capacity: ${opts.capacity} opts: ${JSON.stringify(opts)}`);\n    }\n    if (!opts.capacity && toReturn.length !== potentialLength) {\n        throw new Error(`Bug! Return length not expected. Return len: ${toReturn.length} expected: ${potentialLength} opts: ${JSON.stringify(opts)}`);\n    }\n    return toReturn;\n};\n// Remove from front of queue (0 index)\nexport const dequeue = (opts, queue) => {\n    if (queue.length === 0)\n        throw new Error(`Queue is empty`);\n    return queue.slice(1);\n};\n/**\n * Returns front of queue (oldest item), or undefined if queue is empty\n *\n * @typeParam V - Type of values stored\n * @param {QueueOpts} opts\n * @param {V[]} queue\n * @returns {(V | undefined)}\n */\nexport const peek = (opts, queue) => queue[0];\nexport const isEmpty = (opts, queue) => queue.length === 0;\nexport const isFull = (opts, queue) => {\n    if (opts.capacity) {\n        return queue.length >= opts.capacity;\n    }\n    return false;\n};\n"],"mappings":";AAGA,MAAa,YAAY,CAAC,MAAM,OAAO,UAAU;CAC7C,MAAM,kBAAkB,MAAM,SAAS,MAAM;CAC7C,MAAM,WAAW,KAAK,YAAY;CAClC,MAAM,WAAW,kBAAkB;CACnC,MAAM,SAAS,KAAK,iBAAiB,CAAC,SAAS,CAAC;AAMhD,SAAQ,QAAR;EAEI,KAAK,CAAC,SAAS,CAAC,EAAE;AAOd,OAAI,MAAM,WAAW,EACjB,QAAO,MAAM,MAAM,GAAG,MAAM,SAAS,SAAS;AAElD,OAAI,MAAM,WAAW,KAAK,SACtB,QAAO;OAIP,QAAO,CAAC,GAAG,OAAO,GAAG,MAAM,MAAM,GAAG,WAAW,EAAE,AAAC;EAEzD;EAED,KAAK,CAAC,KAAK,CAAC,CACR,KAAI,YAAY,MAAM,QAAQ;AAG1B,OAAI,MAAM,WAAW,EAGjB,QAAO,CAAC,GAAG,MAAM,MAAM,GAAG,WAAW,EAAE,EAAE,MAAM,GAAG,GAAG,AAAC;AAE1D,UAAO,MAAM,MAAM,KAAK,IAAI,GAAG,MAAM,SAAS,SAAS,EAAE,KAAK,IAAI,MAAM,QAAQ,SAAS,GAAG,EAAE;EAGjG,OACI;GAOD,MAAM,aAAa,KAAK,IAAI,GAAG,MAAM,SAAS,MAAM,OAAO;GAC3D,MAAM,aAAa,MAAM,MAAM,MAAM,SAAS,YAAY,MAAM,OAAO;GACvE,MAAM,SAAS,MAAM,MAAM,GAAG,KAAK,IAAI,MAAM,QAAQ,WAAW,EAAE,CAAC;GAWnE,MAAM,IAAI,CAAC,GAAG,QAAQ,GAAG,UAAW;AAEpC,UAAO;EACV;EAGL,KAAK,CAAC,KAAK,CAAC,CAER,QAAO,CAAC,GAAG,OAAO,GAAG,KAAM,EAAC,MAAM,SAAS;EAE/C,QAEI,OAAM,IAAI,MAAM,CAAC,wBAAwB,EAAE,QAAQ;CAE1D;AACJ;;;;;;;;;;AAUD,MAAa,UAAU,CAAC,MAAM,OAAO,GAAG,UAAU;AAC9C,KAAI,SAAS,OACT,OAAM,IAAI,MAAM,CAAC,wBAAwB,CAAC;CAC9C,MAAM,kBAAkB,MAAM,SAAS,MAAM;CAC7C,MAAM,WAAW,KAAK,YAAY,kBAAkB,KAAK;CACzD,MAAM,WAAW,WACX,UAAU,MAAM,OAAO,MAAM,GAC7B,CAAC,GAAG,OAAO,GAAG,KAAM;AAC1B,KAAI,KAAK,YAAY,SAAS,WAAW,KAAK,YAAY,SACtD,OAAM,IAAI,MAAM,CAAC,oDAAoD,EAAE,SAAS,OAAO,WAAW,EAAE,KAAK,SAAS,OAAO,EAAE,KAAK,UAAU,KAAK,EAAE;AAErJ,KAAI,CAAC,KAAK,YAAY,SAAS,WAAW,gBACtC,OAAM,IAAI,MAAM,CAAC,6CAA6C,EAAE,SAAS,OAAO,WAAW,EAAE,gBAAgB,OAAO,EAAE,KAAK,UAAU,KAAK,EAAE;AAEhJ,QAAO;AACV;AAED,MAAa,UAAU,CAAC,MAAM,UAAU;AACpC,KAAI,MAAM,WAAW,EACjB,OAAM,IAAI,MAAM,CAAC,cAAc,CAAC;AACpC,QAAO,MAAM,MAAM,EAAE;AACxB;;;;;;;;;AASD,MAAa,OAAO,CAAC,MAAM,UAAU,MAAM;AAC3C,MAAa,UAAU,CAAC,MAAM,UAAU,MAAM,WAAW;AACzD,MAAa,SAAS,CAAC,MAAM,UAAU;AACnC,KAAI,KAAK,SACL,QAAO,MAAM,UAAU,KAAK;AAEhC,QAAO;AACV"}