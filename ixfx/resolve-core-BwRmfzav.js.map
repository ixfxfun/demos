{"version":3,"file":"resolve-core-BwRmfzav.js","names":[],"sources":["../../core/dist/src/reactive-core.js","../../debug/dist/src/util.js","../../debug/dist/src/logger.js","../../debug/dist/src/fps-counter.js","../../debug/dist/src/error-message.js","../../debug/dist/src/index.js","../../core/dist/src/resolve-core.js"],"sourcesContent":["/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx\n * @returns\n */\nexport const isReactive = (rx) => {\n    if (typeof rx !== `object`)\n        return false;\n    if (rx === null)\n        return false;\n    return (`on` in rx && `onValue` in rx);\n};\n/**\n * Returns _true_ if `rx` has a last value\n *\n * Judged seeing if `.last()` exists on `rx`.\n * @param rx Reactive\n * @returns\n */\nexport const hasLast = (rx) => {\n    if (!isReactive(rx))\n        return false;\n    if (`last` in rx) {\n        // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n        const v = rx.last();\n        if (v !== undefined)\n            return true;\n    }\n    return false;\n};\n","export const getOrGenerateSync = (map, fn) => (key, args) => {\n    let value = map.get(key);\n    if (value !== undefined)\n        return value;\n    value = fn(key, args);\n    map.set(key, value);\n    return value;\n};\n","import { getOrGenerateSync } from \"./util.js\";\n/**\n * Returns a console logging function which prefixes messages. This is\n * useful for tracing messages from different components. Each prefix\n * is assigned a colour, further helping to distinguish messages.\n *\n * Use {@link logSet} to get a bundled set.\n *\n * ```\n * // Initialise once\n * const log = logger(`a`);\n * const error = logger(`a`, `error`);\n * const warn = logger(`a`, `warn);\n *\n * // And then use\n * log(`Hello`);    // console.log(`a Hello`);\n * error(`Uh-oh`);  // console.error(`a Uh-oh`);\n * warn(`Eek!`);    // console.warn(`a Eeek!`);\n * ```\n *\n * Provide the `colourKey` parameter to make log messages\n * be coloured the same, even though the prefix is different.\n * ```js\n * // Both loggers will use the same colour because they\n * // share the colour key `system`\n * const log = logger(`a`,`log`,`system`);\n * const log2 = logger(`b`, `log`, `system`);\n * ```\n * @param prefix\n * @param kind\n * @param colourKey Optional key to colour log lines by instead of prefix\n * @returns\n */\nexport const logger = (prefix, kind = `log`, colourKey) => (m) => {\n    if (m === undefined) {\n        m = `(undefined)`;\n    }\n    else if (typeof m === `object`) {\n        m = JSON.stringify(m);\n    }\n    const colour = colourKey ?? prefix;\n    switch (kind) {\n        case `log`: {\n            console.log(`%c${prefix} ${m}`, `color: ${logColours(colour)}`);\n            break;\n        }\n        case `warn`: {\n            console.warn(prefix, m);\n            break;\n        }\n        case `error`: {\n            console.error(prefix, m);\n            break;\n        }\n    }\n};\n/**\n* Returns a bundled collection of {@link logger}s\n*\n* ```js\n* const con = logSet(`a`);\n* con.log(`Hello`);  // console.log(`a Hello`);\n* con.warn(`Uh-oh`); // console.warn(`a Uh-oh`);\n* con.error(`Eek!`); // console.error(`a Eek!`);\n* ```\n*\n* By default each prefix is assigned a colour. To use\n* another logic, provide the `colourKey` parameter.\n*\n* ```js\n* // Both set of loggers will use same colour\n* const con = logSet(`a`, true, `system`);\n* const con2 = logSet(`b`, true, `system`);\n* ```\n* @param prefix Prefix for log messages\n* @param verbose True by default. If false, log() messages are a no-op\n* @param colourKey If specified, log messages will be coloured by this key instead of prefix (default)\n* @returns\n*/\nexport const logSet = (prefix, verbose = true, colourKey) => {\n    if (verbose) {\n        return {\n            log: logger(prefix, `log`, colourKey),\n            warn: logger(prefix, `warn`, colourKey),\n            error: logger(prefix, `error`, colourKey),\n        };\n    }\n    return {\n        log: (_) => {\n            /** no-op */\n        },\n        warn: logger(prefix, `warn`, colourKey),\n        error: logger(prefix, `error`, colourKey),\n    };\n};\n/**\n * Resolve a LogOption to a function\n * @param l\n * @returns\n */\nexport const resolveLogOption = (l, defaults = {}) => {\n    if (l === undefined || (typeof l === `boolean` && !l)) {\n        return (_) => {\n            /** no-op */\n        };\n    }\n    const defaultCat = defaults.category ?? ``;\n    const defaultKind = defaults.kind ?? undefined;\n    if (typeof l === `boolean`) {\n        return (messageOrString) => {\n            const m = typeof messageOrString === `string` ? { msg: messageOrString } : messageOrString;\n            const kind = m.kind ?? defaultKind;\n            const category = m.category ?? defaultCat;\n            let message = m.msg;\n            if (category)\n                message = `[${category}] ${message}`;\n            switch (kind) {\n                case `error`: {\n                    console.error(message);\n                    break;\n                }\n                case `warn`: {\n                    console.warn(message);\n                    break;\n                }\n                case `info`: {\n                    console.info(message);\n                    break;\n                }\n                default: {\n                    console.log(message);\n                }\n            }\n        };\n    }\n    return l;\n};\nlet logColourCount = 0;\nexport const logColours = getOrGenerateSync(new Map(), () => {\n    const hue = ++logColourCount * 137.508; // use golden angle approximation\n    return `hsl(${hue},50%,75%)`;\n});\n","/**\n * Calculates frames per second.\n *\n * Returns a function which needs to be called at the end of each frame.\n *\n * ```js\n * const fps = fpsCounter();\n *\n * function loop() {\n *  fps(); // Calculate fps\n *  window.requestAnimationFrame(loop);\n * }\n *\n * loop();\n * ```\n * @param autoDisplay If true (default), prints out the FPS to the console\n * @param computeAfterFrames Calculates after this many frames. Higher numbers smoothes the value somewhat\n * @returns\n */\nexport const fpsCounter = (autoDisplay = true, computeAfterFrames = 500) => {\n    let count = 0;\n    let lastFps = 0;\n    let countStart = performance.now();\n    return () => {\n        if (count++ >= computeAfterFrames) {\n            const elapsed = performance.now() - countStart;\n            countStart = performance.now();\n            count = 0;\n            lastFps = Math.floor((computeAfterFrames / elapsed) * 1000);\n            if (autoDisplay)\n                console.log(`fps: ${lastFps}`);\n        }\n        return lastFps;\n    };\n};\n","/**\n * Returns a string representation of an error\n * @param ex\n * @returns\n */\nexport const getErrorMessage = (ex) => {\n    if (typeof ex === `string`)\n        return ex;\n    if (ex instanceof Error) {\n        return ex.message;\n    }\n    return ex;\n};\n","export * from './types.js';\nexport * from './logger.js';\nexport * from './fps-counter.js';\nexport * from './error-message.js';\n","import { getErrorMessage } from \"@ixfx/debug\";\nimport { hasLast, isReactive } from \"./reactive-core.js\";\n/**\n * Resolves `r` to a value, where `r` is:\n * * primitive value\n * * a/sync function\n * * a/sync generator/iterator\n * * ReactiveNonInitial\n * ```js\n * await resolve(10);       // 10\n * await resolve(() => 10); // 10\n * await resole(async () => {\n *  sleep(100);\n *  return 10;\n * });                // 10\n * ```\n *\n * To resolve an object's properties, use {@link resolveFields}.\n *\n * Resolve is not recursive. So if `r` is an object, it will be returned, even\n * though its properties may be resolvable.\n * @param r\n * @param args\n * @returns\n */\nexport async function resolve(r, ...args) {\n    if (typeof r === `object`) {\n        if (`next` in r) {\n            const tag = r[Symbol.toStringTag];\n            if (tag === `Generator` || tag == `Array Iterator`) {\n                const v = r.next();\n                if (`done` in v && `value` in v)\n                    return v.value;\n                return v;\n            }\n            else if (tag === `AsyncGenerator`) {\n                const v = await r.next();\n                //console.log(`  hasDone: ${ `done` in v } value:`, v);\n                if (`done` in v && `value` in v)\n                    return v.value;\n                return v;\n            }\n            else {\n                throw new Error(`Object has 'next' prop, but does not have 'AsyncGenerator', 'Generator' or 'Array Iterator' string tag symbol. Got: '${tag}'`);\n            }\n        }\n        else if (isReactive(r)) {\n            if (hasLast(r))\n                return r.last();\n            throw new Error(`Reactive does not have last value`);\n        }\n        else {\n            // Some regular object\n            return r;\n        }\n    }\n    else if (typeof r === `function`) {\n        const v = await r(args);\n        return v;\n    }\n    else {\n        // Primitive value?\n        return r;\n    }\n}\n/**\n * For a given input `r`, attempts to 'resolve' it. See {@link resolve} for details.\n * @param r\n * @param args\n * @returns\n */\nexport function resolveSync(r, ...args) {\n    if (typeof r === `object`) {\n        if (`next` in r) {\n            const tag = r[Symbol.toStringTag];\n            if (tag === `Generator` || tag == `Array Iterator`) {\n                const v = r.next();\n                if (`done` in v && `value` in v)\n                    return v.value;\n                return v;\n            }\n            else if (tag === `AsyncGenerator`) {\n                throw new Error(`resolveSync cannot work with an async generator`);\n            }\n            else {\n                throw new Error(`Object has 'next' prop, but does not have 'Generator' or 'Array Iterator' string tag symbol. Got: '${tag}'`);\n            }\n        }\n        else if (isReactive(r)) {\n            if (hasLast(r))\n                return r.last();\n            throw new Error(`Reactive does not have last value`);\n        }\n        else {\n            // Some regular object\n            return r;\n        }\n    }\n    else if (typeof r === `function`) {\n        return r(args);\n    }\n    else {\n        // Primitive value?\n        return r;\n    }\n}\n/**\n * Resolves a value as per {@link resolve}, however\n * If an error is thrown or the resolution results in _undefined_\n * or NaN, `fallbackValue` is returned instead.\n *\n * `null` is an allowed return value.\n *\n * ```js\n * // Function returns undefined 50% of the time or 0\n * const fn = () => {\n *  if (Math.random() >= 0.5) return; // undefined\n *  return 0;\n * }\n * const r = resolveWithFallback(fn, 1);\n * const value = r(); // Always 0 or 1\n * ```\n * @param p Thing to resolve\n * @param fallback Fallback value if an error happens, undefined or NaN\n * @param args\n * @returns\n */\nexport async function resolveWithFallback(p, fallback, ...args) {\n    let errored = false;\n    let fallbackValue = fallback.value;\n    const overrideWithLast = fallback.overrideWithLast ?? false;\n    if (fallbackValue === undefined)\n        throw new Error(`Needs a fallback value`);\n    try {\n        const r = await resolve(p, ...args);\n        if (typeof r === `undefined`)\n            return fallbackValue;\n        if (typeof r === `number` && Number.isNaN(r))\n            return fallbackValue;\n        if (overrideWithLast)\n            fallbackValue = r;\n        return r;\n    }\n    catch (error) {\n        if (!errored) {\n            errored = true;\n            console.warn(`resolveWithFallback swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n        }\n        return fallbackValue;\n    }\n}\nexport function resolveWithFallbackSync(p, fallback, ...args) {\n    let errored = false;\n    let fallbackValue = fallback.value;\n    const overrideWithLast = fallback.overrideWithLast ?? false;\n    if (fallbackValue === undefined)\n        throw new Error(`Needs a fallback value`);\n    try {\n        const r = resolveSync(p, ...args);\n        if (typeof r === `undefined`)\n            return fallbackValue;\n        if (typeof r === `number` && Number.isNaN(r))\n            return fallbackValue;\n        if (overrideWithLast)\n            fallbackValue = r;\n        return r;\n    }\n    catch (error) {\n        if (!errored) {\n            errored = true;\n            console.warn(`resolveWithFallbackSync swallowed an error. Additional errors not reported.`, getErrorMessage(error));\n        }\n        return fallbackValue;\n    }\n}\n"],"mappings":"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"}