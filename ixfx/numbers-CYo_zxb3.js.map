{"version":3,"file":"numbers-CYo_zxb3.js","names":["array: readonly V[] | V[]","equality?: IsEqual<V>","array","returnValue: any[]","total","array","clamp","min","max","min","max","scale","min","max","interpolate","#store","average","smoothingFactor","scaler","total","min","max","min","max"],"sources":["../../packages/arrays/src/equality.ts","../../packages/arrays/src/zip.ts","../../packages/numbers/dist/src/apply-to-values.js","../../packages/numbers/dist/src/numeric-arrays.js","../../packages/numbers/dist/src/average-weighted.js","../../packages/numbers/dist/src/clamp.js","../../packages/numbers/dist/src/difference.js","../../packages/numbers/dist/src/guard.js","../../packages/numbers/dist/src/filter.js","../../packages/numbers/dist/src/flip.js","../../packages/numbers/dist/src/round.js","../../packages/numbers/dist/src/is-approx.js","../../packages/numbers/dist/src/bipolar.js","../../packages/numbers/dist/src/wrap.js","../../packages/numbers/dist/src/pi-pi.js","../../packages/numbers/dist/src/interpolate.js","../../packages/numbers/dist/src/linear-space.js","../../packages/numbers/dist/src/util/queue-mutable.js","../../packages/numbers/dist/src/moving-average.js","../../packages/numbers/dist/src/scale.js","../../packages/numbers/dist/src/number-array-compute.js","../../packages/numbers/dist/src/normalise.js","../../packages/numbers/dist/src/proportion.js","../../packages/numbers/dist/src/quantise.js","../../packages/numbers/dist/src/softmax.js","../src/numbers.ts"],"sourcesContent":["import { isEqualDefault, isEqualValueDefault, type IsEqual } from \"./util/is-equal.js\";\nimport { arrayTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Returns _true_ if the two arrays have the same items at same indexes. \n * \n * Returns _false_ if arrays are of different length.\n * By default uses === semantics for equality checking.\n * \n * ```js\n * isEqual([ 1, 2, 3], [ 1, 2, 3 ]); // true\n * isEqual([ 1, 2, 3], [ 3, 2, 1 ]); // false\n * ```\n * \n * Compare by value\n * ```js\n * isEqual(a, b, isEqualValueDefault);\n * ```\n * \n * Custom compare, eg based on `name` field:\n * ```js\n * isEqual(a, b, (compareA, compareB) => compareA.name === compareB.name);\n * ```\n * @param arrayA \n * @param arrayB \n * @param equality Function to compare values\n */\nexport const isEqual = <V>(arrayA: V[], arrayB: V[], equality = isEqualDefault<V>): boolean => {\n  // TODO: 'eq' function could be a key-generating function too\n  resultThrow(\n    arrayTest(arrayA, `arrayA`),\n    arrayTest(arrayB, `arrayB`)\n  );\n\n  if (arrayA.length !== arrayB.length) return false;\n\n  for (let indexA = 0; indexA < arrayA.length; indexA++) {\n    if (!(equality(arrayA[ indexA ], arrayB[ indexA ]))) return false;\n  }\n  return true;\n}\n\n/**\n * Returns _true_ if all values in the array are the same\n * \n * Uses value-based equality checking by default.\n * \n * @example Uses default equality function:\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const a1 = [ 10, 10, 10 ];\n * Arrays.isContentsTheSame(a1); // True\n *\n * const a2 = [ { name:`Jane` }, { name:`John` } ];\n * Arrays.isContentsTheSame(a2); // True, even though object references are different\n * ```\n *\n * If we want to compare by value for objects that aren't readily\n * converted to JSON, you need to provide a function:\n *\n * ```js\n * Arrays.isContentsTheSame(someArray, (a, b) => {\n *  return (a.eventType === b.eventType);\n * });\n * ```\n *\n * Returns _true_ if `array` is empty.\n * @param array Array\n * @param equality Equality checker. Uses string-conversion checking by default\n * @returns\n */\nexport const isContentsTheSame = <V>(\n  array: readonly V[] | V[],\n  equality?: IsEqual<V>\n): boolean => {\n  // TODO: 'equality' function could be a key-generating function too\n\n  if (!Array.isArray(array)) throw new Error(`Param 'array' is not an array.`);\n  if (array.length === 0) return true;\n  const eq = equality ?? isEqualValueDefault;\n  const a = array[ 0 ];\n  const r = array.some((v) => !eq(a, v));\n  if (r) return false;\n  return true;\n};","import { isContentsTheSame } from \"./equality.js\";\n\n/**\n * Zip combines the elements of two or more arrays based on their index.\n *\n * ```js\n * import { Arrays } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * const a = [1,2,3];\n * const b = [`red`, `blue`, `green`];\n *\n * const c = Arrays.zip(a, b);\n * // Yields:\n * // [\n * //   [1, `red`],\n * //   [2, `blue`],\n * //   [3, `green`]\n * // ]\n * ```\n *\n * Typically the arrays you zip together are all about the same logical item. Eg, in the above example\n * perhaps `a` is size and `b` is colour. So thing #1 (at array index 0) is a red thing of size 1. Before\n * zipping we'd access it by `a[0]` and `b[0]`. After zipping, we'd have c[0], which is array of [1, `red`].\n * @param arrays\n * @returns Zipped together array\n */\nexport const zip = (\n  ...arrays: any[][] | readonly any[][] | readonly (readonly any[])[]\n): any[] => {\n  if (arrays.some((a) => !Array.isArray(a))) {\n    throw new Error(`All parameters must be an array`);\n  }\n  const lengths = arrays.map((a) => (a as any[]).length);\n  if (!isContentsTheSame(lengths)) {\n    throw new Error(`Arrays must be of same length`);\n  }\n\n  const returnValue: any[] = [];\n  const length = lengths[ 0 ];\n\n  for (let index = 0; index < length; index++) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n    returnValue.push(arrays.map((a) => a[ index ]));\n  }\n  return returnValue;\n};","/**\n * Apples `fn` to every key of `obj` which is numeric.\n * ```js\n * const o = {\n *  name: 'john',\n *  x: 10,\n *  y: 20\n * };\n * const o2 = applyToValues(o, (v) => v * 2);\n *\n * // Yields: { name: 'john', x: 20, y: 40 }\n * ```\n * @param object\n * @param apply\n * @returns\n */\nexport const applyToValues = (object, apply) => {\n    const o = { ...object };\n    for (const [key, value] of Object.entries(object)) {\n        if (typeof value === `number`) {\n            // Run number through function\n            //eslint-disable-next-line functional/immutable-data\n            o[key] = apply(value);\n        }\n        else {\n            // Copy value\n            //eslint-disable-next-line functional/immutable-data,@typescript-eslint/no-unsafe-assignment\n            o[key] = value;\n        }\n    }\n    return o;\n};\n","/**\n * Applies a function `fn` to the elements of an array, weighting them based on their relative position.\n *\n * ```js\n * // Six items\n * weight([1,1,1,1,1,1], Modulation.gaussian());\n *\n * // Yields:\n * // [0.02, 0.244, 0.85, 0.85, 0.244, 0.02]\n * ```\n *\n * `fn` is expected to map (0..1) => (0..1), such as an easing function. The input to the\n * `fn` is the relative position of an element. Thus the first element will be 0, the middle 0.5 and so on.\n * The output of `fn` is then multiplied by the original value.\n *\n * In the below example (which is also the default if `fn` is not specified), the relative position is\n * how values are weighted:\n *\n * ```js\n * weight([1,1,1,1,1,1], (relativePos) => relativePos);\n * // Yields:\n * // [0, 0.2, 0.4, 0.6, 0.8, 1]\n * ```\n *\n * Throws TypeError if `data` is not an array or for any element not a number.\n * @param data Array of numbers\n * @param fn Returns a weighting based on the given relative position. If unspecified, `(x) => x` is used.\n */\nexport const weight = (data, fn) => {\n    if (!Array.isArray(data))\n        throw new TypeError(`Param 'data' is expected to be an array. Got type: ${typeof data}`);\n    const weightingFunction = fn ?? ((x) => x);\n    return data.map((value, index) => {\n        if (typeof value !== `number`)\n            throw new TypeError(`Param 'data' contains non-number at index: '${index}'. Type: '${typeof value}' value: '${value}'`);\n        const relativePos = index / (data.length - 1);\n        const weightForPosition = weightingFunction(relativePos);\n        if (typeof weightForPosition !== `number`)\n            throw new TypeError(`Weighting function returned type '${typeof weightForPosition}' rather than number for input: '${relativePos}'`);\n        const finalResult = value * weightForPosition;\n        //console.log(`finalResult: ${ finalResult.toFixed(2) } rel: ${ relativePos.toFixed(2) } weightForPosition: ${ weightForPosition.toFixed(2) } input: ${ value } index: ${ index }`);\n        return finalResult;\n    });\n};\n/**\n * Returns an array of all valid numbers from `data`\n *\n * @param data\n * @returns\n */\nexport const validNumbers = (data) => data.filter((d) => typeof d === `number` && !Number.isNaN(d));\n/**\n * Returns the dot product of arbitrary-sized arrays. Assumed they are of the same length.\n * @param values\n * @returns\n */\nexport const dotProduct = (values) => {\n    let r = 0;\n    const length = values[0].length;\n    for (let index = 0; index < length; index++) {\n        let t = 0;\n        for (const [p, value] of values.entries()) {\n            if (p === 0)\n                t = value[index];\n            else {\n                t *= value[index];\n            }\n        }\n        r += t;\n    }\n    return r;\n};\n/**\n * Calculates the average of all numbers in an array.\n * Array items which aren't a valid number are ignored and do not factor into averaging.\n *\n * Use {@link minMaxAvg} if you want min, max and total as well.\n *\n * @example\n * ```js\n * import * as Numbers from 'https://unpkg.com/ixfx/dist/numbers.js';\n *\n * // Average of a list\n * const avg = Numbers.average([1, 1.4, 0.9, 0.1]);\n *\n * // Average of a variable\n * const data = [100,200];\n * Numbers.average(data);\n * ```\n *\n * @see {@link averageWeighted} To weight items based on position in array\n * @param data Data to average.\n * @returns Average of array\n */\nexport const average = (data) => {\n    // âœ” UNIT TESTED\n    if (data === undefined)\n        throw new Error(`data parameter is undefined`);\n    const valid = validNumbers(data);\n    const total = valid.reduce((accumulator, v) => accumulator + v, 0);\n    return total / valid.length;\n};\n/**\n * Returns the minimum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/Numbers.js';\n * Numbers.min([10, 20, 0]); // Yields 0\n * ```\n * @param data\n * @returns Minimum number\n */\nexport const min = (data) => Math.min(...validNumbers(data));\n/**\n * Returns the index of the largest value.\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/Numbers.js';\n * const v = [ 10, 40, 5 ];\n * Numbers.maxIndex(v); // Yields 1\n * ```\n * @param data Array of numbers\n * @returns Index of largest value\n */\nexport const maxIndex = (data) => data.reduce((bestIndex, value, index, array) => value > array[bestIndex] ? index : bestIndex, 0);\n/**\n * Returns the index of the smallest value.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/Numbers.js';\n * const v = [ 10, 40, 5 ];\n * Numbers.minIndex(v); // Yields 2\n * ```\n * @param data Array of numbers\n * @returns Index of smallest value\n */\nexport const minIndex = (...data) => data.reduce((bestIndex, value, index, array) => value < array[bestIndex] ? index : bestIndex, 0);\n/**\n * Returns the maximum number out of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.max(100, 200, 50); // 200\n * ```\n * @param data List of numbers\n * @returns Maximum number\n */\nexport const max = (data) => Math.max(...validNumbers(data));\n/**\n * Returns the total of `data`.\n * Undefined and non-numbers are silently ignored.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.total([1, 2, 3]); // 6\n * ```\n * @param data Array of numbers\n * @returns Total\n */\nexport const total = (data) => data.reduce((previous, current) => {\n    if (typeof current !== `number`)\n        return previous;\n    if (Number.isNaN(current))\n        return previous;\n    if (!Number.isFinite(current))\n        return previous;\n    return previous + current;\n}, 0);\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.maxFast([ 10, 0, 4 ]); // 10\n * ```\n * @param data\n * @returns Maximum\n */\nexport const maxFast = (data) => {\n    let m = Number.MIN_SAFE_INTEGER;\n    for (const datum of data) {\n        m = Math.max(m, datum);\n    }\n    return m;\n};\n/**\n * Returns the total of `data` without pre-filtering for speed.\n *\n * For most uses, {@link total} should suffice.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.totalFast([ 10, 0, 4 ]); // 14\n * ```\n * @param data\n * @returns Maximum\n */\nexport const totalFast = (data) => {\n    let m = 0;\n    for (const datum of data) {\n        m += datum;\n    }\n    return m;\n};\n/**\n * Returns the maximum out of `data` without pre-filtering for speed.\n *\n * For most uses, {@link max} should suffice.\n *\n * ```js\n * import { Numbers } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * Numbers.minFast([ 10, 0, 100 ]); // 0\n * ```\n * @param data\n * @returns Maximum\n */\nexport const minFast = (data) => {\n    let m = Number.MIN_SAFE_INTEGER;\n    for (const datum of data) {\n        m = Math.min(m, datum);\n    }\n    return m;\n};\n","import { zip } from '@ixfx/arrays';\nimport { weight } from './numeric-arrays.js';\n/**\n * Computes an average of an array with a set of weights applied.\n *\n * Weights can be provided as an array, expected to be on 0..1 scale, with indexes\n * matched up to input data. Ie. data at index 2 will be weighed by index 2 in the weightings array.\n *\n * ```js\n * // All items weighted evenly\n * averageWeighted([1,2,3], [1,1,1]); // 2\n *\n * // First item has full weight, second half, third quarter\n * averageWeighted([1,2,3], [1, 0.5, 0.25]); // 1.57\n *\n * // With reversed weighting of [0.25,0.5,1] value is 2.42\n * ```\n *\n * A function can alternatively be provided to compute the weighting based on array index, via {@link weight}.\n *\n * ```js\n * averageWeighted[1,2,3], Random.gaussian()); // 2.0\n * ```\n *\n * This is the same as:\n *\n * ```js\n * const data = [1,2,3];\n * const w = weight(data, Random.gaussian());\n * const avg = averageWeighted(data, w); // 2.0\n * ```\n * @param data Data to average\n * @param weightings Array of weightings that match up to data array, or an easing function\n * @see {@link average} Compute averages without weighting.\n */\nexport const averageWeighted = (data, weightings) => {\n    if (typeof weightings === `function`)\n        weightings = weight(data, weightings);\n    const ww = zip(data, weightings);\n    const [totalV, totalW] = ww.reduce((accumulator, v) => [accumulator[0] + v[0] * v[1], accumulator[1] + v[1]], [0, 0]);\n    return totalV / totalW;\n};\n","/**\n * Clamps a value between min and max (both inclusive)\n * Defaults to a 0-1 range, useful for percentages.\n *\n * @example Usage\n * ```js\n * // 0.5 - just fine, within default of 0 to 1\n * clamp(0.5);\n * // 1 - above default max of 1\n * clamp(1.5);\n * // 0 - below range\n * clamp(-50, 0, 100);\n * // 50 - within range\n * clamp(50, 0, 50);\n * ```\n *\n * For clamping integer ranges, consider {@link clampIndex }\n * For clamping `{ x, y }` points, consider {@link Geometry.Points.clamp | Geometry.Points.clamp}.\n * For clamping bipolar values: {@link Bipolar.clamp}\n * @param value Value to clamp\n * @param min value (inclusive)\n * @param max value (inclusive)\n * @returns Clamped value\n */\nexport const clamp = (value, min = 0, max = 1) => {\n    // âœ” UNIT TESTED\n    if (Number.isNaN(value))\n        throw new Error(`Param 'value' is NaN`);\n    if (Number.isNaN(min))\n        throw new Error(`Param 'min' is NaN`);\n    if (Number.isNaN(max))\n        throw new Error(`Param 'max' is NaN`);\n    if (value < min)\n        return min;\n    if (value > max)\n        return max;\n    return value;\n};\n/**\n * Returns a function that clamps values.\n *\n * ```js\n * const c = clamper(0,100);\n * c(50);   // 50\n * c(101); // 100\n * c(-5);  // 0\n * ```\n * @param min Minimum value. Default: 0\n * @param max Maximum value. Default: 1\n */\nexport const clamper = (min = 0, max = 1) => {\n    if (Number.isNaN(min))\n        throw new Error(`Param 'min' is NaN`);\n    if (Number.isNaN(max))\n        throw new Error(`Param 'max' is NaN`);\n    return (v) => {\n        if (v > max)\n            return max;\n        if (v < min)\n            return min;\n        return v;\n    };\n};\n/**\n * Clamps integer `v` between 0 (inclusive) and array length or length (exclusive).\n * Returns value then will always be at least zero, and a valid array index.\n *\n * @example Usage\n * ```js\n * // Array of length 4\n * const myArray = [`a`, `b`, `c`, `d`];\n * clampIndex(0, myArray);    // 0\n * clampIndex(5, 3); // 2\n * ```\n *\n * Throws an error if `v` is not an integer.\n *\n * For some data it makes sense that data might 'wrap around' if it exceeds the\n * range. For example rotation angle. Consider using {@link wrap} for this.\n *\n * @param v Value to clamp (must be an interger)\n * @param arrayOrLength Array, or length of bounds (must be an integer)\n * @returns Clamped value, minimum will be 0, maximum will be one less than `length`.\n */\nexport const clampIndex = (v, arrayOrLength) => {\n    // âœ” UNIT TESTED\n    if (!Number.isInteger(v)) {\n        throw new TypeError(`v parameter must be an integer (${v})`);\n    }\n    const length = Array.isArray(arrayOrLength)\n        ? arrayOrLength.length\n        : arrayOrLength;\n    if (!Number.isInteger(length)) {\n        throw new TypeError(`length parameter must be an integer (${length}, ${typeof length})`);\n    }\n    v = Math.round(v);\n    if (v < 0)\n        return 0;\n    if (v >= length)\n        return length - 1;\n    return v;\n};\n","/**\n * Returns the difference from the `initial` value. Defaults to absolute difference.\n * ```js\n * const rel = differenceFromFixed(100);\n * rel(100); // 0\n * rel(150); // 50\n * rel(50);  // 50\n * ```\n *\n * 'numerical' gives sign:\n * ```js\n * const rel = differenceFromFixed(100, `numerical`);\n * rel(100); // 0\n * rel(150); // 50\n * rel(50); // -50\n * ```\n *\n * 'relative' gives proportion to initial\n * ```js\n * const rel = differenceFromFixed(100, `relative`);\n * rel(100); // 0\n * rel(150); // 0.5\n * rel(10);  // 0.90\n * ```\n *\n * Using 'relativeSigned', we get negative relative result\n * when value is below the initial value.\n *\n * Use {@link differenceFromLast} to compare against the last value,\n * rather than the same fixed value.\n * @param {number} initial Value to compare against\n * @returns Difference from initial value\n */\nexport const differenceFromFixed = (initial, kind = `absolute`) => (value) => differenceFrom(kind, value, initial);\n/**\n * Returns a function which yields difference compared to last value.\n *\n * If no initial value is provided, the first difference will be returned as 0.\n *\n * Difference can be returned in various formats:\n * * 'absolute': numerical difference, without sign\n * * 'numerical': numerical difference, with sign, so you can see if difference is higher or lower\n * * 'relative': difference divided by last value, giving a proportional difference. Unsigned.\n * * 'relativeSigned': as above, but with sign\n *\n * Use {@link differenceFromFixed} to compare against a fixed value instead of the last value.\n *\n * ```js\n * let d = differenceFromLast(`absolute`);\n * d(10); // 0\n * d(11); // 1\n * d(10); // 1\n * ```\n *\n * ```js\n * let d = differenceFromLast(`numerical`);\n * d(10); // 0\n * d(11); // 1\n * d(10); // -1\n * ```\n *\n * ```js\n * let d = differenceFromLast(`relative`);\n * d(10); // 0\n * d(11); // 0.1\n * d(10); // 0.1\n * ```\n * ```js\n * let d = differenceFromLast(`relativeSigned`);\n * d(10); // 0\n * d(11); // 0.1\n * d(10); // -0.1\n * ```\n *\n * An initial value can be provided, eg:\n * ```js\n * let d = differenceFromLast(`absolute`, 10);\n * d(11); // 1\n * ```\n * @param kind Kind of output value\n * @param initialValue Optional initial value\n * @returns\n */\nexport const differenceFromLast = (kind = `absolute`, initialValue = Number.NaN) => {\n    let lastValue = initialValue;\n    return (value) => {\n        const x = differenceFrom(kind, value, lastValue);\n        lastValue = value;\n        return x;\n    };\n};\n//   const compute = (v: number) => {\n//     if (Number.isNaN(lastValue)) {\n//       lastValue = v;\n//       return 0;\n//     }\n//     const d = v - lastValue;\n//     let r = 0;\n//     if (kind === `absolute`) {\n//       r = Math.abs(d);\n//     } else if (kind === `numerical`) {\n//       r = d;\n//     } else if (kind === `relative`) {\n//       r = Math.abs(d / lastValue);\n//     } else if (kind === `relativeSigned`) {\n//       r = d / lastValue;\n//     } else throw new TypeError(`Unknown kind: '${ kind }' Expected: 'absolute', 'relative', 'relativeSigned' or 'numerical'`);\n//     lastValue = v;\n//     return r;\n//   }\n//   return compute;\n// }\nconst differenceFrom = (kind = `absolute`, value, from) => {\n    if (Number.isNaN(from)) {\n        return 0;\n    }\n    const d = value - from;\n    let r = 0;\n    if (kind === `absolute`) {\n        r = Math.abs(d);\n    }\n    else if (kind === `numerical`) {\n        r = d;\n    }\n    else if (kind === `relative`) {\n        r = Math.abs(d / from);\n    }\n    else if (kind === `relativeSigned`) {\n        r = d / from;\n    }\n    else\n        throw new TypeError(`Unknown kind: '${kind}' Expected: 'absolute', 'relative', 'relativeSigned' or 'numerical'`);\n    return r;\n};\n","/**\n * Returns true if `possibleNumber` is a number and not NaN\n * @param possibleNumber\n * @returns\n */\nexport const isValid = (possibleNumber) => {\n    if (typeof possibleNumber !== `number`)\n        return false;\n    if (Number.isNaN(possibleNumber))\n        return false;\n    return true;\n};\n","import { isValid } from './guard.js';\n/**\n * Filters an iterator of values, only yielding\n * those that are valid numbers\n *\n * ```js\n * import * as Numbers from 'https://unpkg.com/ixfx/dist/numbers.js';\n *\n * const data = [true, 10, '5', { x: 5 }];\n * for (const n of Numbers.filterIterable(data)) {\n *  // 5\n * }\n * ```\n * @param it\n */\nexport function* filterIterable(it) {\n    for (const v of it) {\n        if (isValid(v))\n            yield v;\n    }\n}\n/**\n * Returns a function that yields _true_ if a value\n * is at least `threshold`\n * ```js\n * const t = thresholdAtLeast(50);\n * t(50); // true\n * t(0);  // false\n * t(55); // true\n * ```\n * @param threshold\n * @returns\n */\nexport const thresholdAtLeast = (threshold) => {\n    return (v) => {\n        return v >= threshold;\n    };\n};\n/**\n * Returns a function that yields _true_\n * if a number is at least _min_ and no greater than _max_\n *\n * ```js\n * const t = rangeInclusive(50, 100);\n * t(40); // false\n * t(50); // true\n * t(60); // true\n * t(100); // true\n * t(101);  // false\n * ```\n * @param min\n * @param max\n * @returns\n */\nexport const rangeInclusive = (min, max) => {\n    return (v) => {\n        return v >= min && v <= max;\n    };\n};\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Flips a percentage-scale number: `1 - v`.\n *\n * The utility of this function is that it sanity-checks\n * that `v` is in 0..1 scale.\n *\n * ```js\n * flip(1);   // 0\n * flip(0.5); // 0.5\n * flip(0);   // 1\n * ```\n * @param v\n * @returns\n */\nexport const flip = (v) => {\n    if (typeof v === `function`)\n        v = v();\n    resultThrow(numberTest(v, `percentage`, `v`));\n    return 1 - v;\n};\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Rounds a number.\n *\n * If one parameter is given, it's the decimal places,\n * and a rounding function is returned:\n * ```js\n * import { round } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * const r = round(2);\n * r(10.12355); // 10.12\n * ```\n *\n * If two parameters are given, the first is decimal places,\n * the second the value to round.\n * ```js\n * round(2, 10.12355); // 10.12\n * ```\n * @param decimalPlaces\n * @returns\n */\nexport function round(a, b, roundUp) {\n    resultThrow(integerTest(a, `positive`, `decimalPlaces`));\n    const up = (typeof b === `boolean`) ? b : (roundUp ?? false);\n    let rounder;\n    if (a === 0) {\n        rounder = Math.round;\n    }\n    else {\n        const p = Math.pow(10, a);\n        if (up) {\n            rounder = (v) => Math.ceil(v * p) / p;\n        }\n        else {\n            rounder = (v) => Math.floor(v * p) / p;\n        }\n    }\n    if (typeof b === `number`)\n        return rounder(b);\n    return rounder;\n}\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { round } from \"./round.js\";\n/**\n * Checks if a value is within range of a base value\n *\n * ```js\n * // Check if 101 is within 10% of 100\n * isApprox(0.1, 100, 101);\n *\n * // Gets a function to compare some value of 10% range to 100\n * const c = isApprox(0.1,100);\n * c(101);\n *\n * // Gets a function to compare some base value and value to 10% range\n * const c = isApprox(0.1);\n * c(100, 101);\n * ```\n *\n * Throws an error if range or base values are NaN.\n * If value being checked is NaN or infinity, _false_ is returned.\n * @param rangePercent\n * @param baseValue\n * @param v\n * @returns\n */\nexport function isApprox(rangePercent, baseValue, v) {\n    resultThrow(numberTest(rangePercent, `percentage`, `rangePercent`));\n    // Round percentages to avoid floating point nonsense\n    const range = Math.floor(rangePercent * 100);\n    const test = (base, value) => {\n        try {\n            if (typeof value !== `number`)\n                return false;\n            if (Number.isNaN(value))\n                return false;\n            if (!Number.isFinite(value))\n                return false;\n            // Round value\n            const diff = Math.abs(value - base);\n            const relative = base === 0 ? Math.floor(diff * 100) : Math.floor((diff / base) * 100);\n            //console.log(`v: ${ value } base: ${ base } rel: ${ relative } range: ${ range } diff: ${ diff }`);\n            return relative <= range;\n        }\n        catch {\n            return false;\n        }\n    };\n    if (baseValue === undefined)\n        return test;\n    resultThrow(numberTest(baseValue, ``, `baseValue`));\n    if (v === undefined) {\n        return (value) => test(baseValue, value);\n    }\n    else {\n        return test(baseValue, v);\n    }\n}\nexport const isCloseTo = (a, b, precision = 3) => {\n    const aa = a.toPrecision(precision);\n    const bb = b.toPrecision(precision);\n    if (aa !== bb)\n        return [false, `A is not close enough to B. A: ${a} B: ${b} Precision: ${precision}`];\n    else\n        return [true];\n};\n","//import { floatSource,type RandomOptions, type RandomSource } from '@ixfx/random';\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport { interpolate, scaler as numberScaler } from '@ixfx/numbers';\n/**\n * Wrapper for bipolar-based values. Immutable.\n * All functions will clamp to keep it in legal range.\n *\n * ```js\n * let v = immutable(); // Starts with 0 by default\n * v = v.add(0.1);      // v.value is 0.1\n * v = v.inverse();     // v.value is -0.1\n * v = v.multiply(0.2); // v.value is -0.02\n *\n * v = immutable(1);\n * v = v.towardZero(0.1); // 0.9\n * v = v.interpolate(0.1, 1);\n * ```\n *\n * Wrapped values can be coerced into number:\n * ```js\n * const v = immutable(1);\n * const x = +v+10;\n * // x = 11\n * ```\n * @param startingValueOrBipolar Initial numeric value or BipolarWrapper instance\n * @returns\n */\nexport const immutable = (startingValueOrBipolar = 0) => {\n    if (typeof startingValueOrBipolar === `undefined`)\n        throw new Error(`Start value is undefined`);\n    const startingValue = (typeof startingValueOrBipolar === `number`) ? startingValueOrBipolar : startingValueOrBipolar.value;\n    if (startingValue > 1)\n        throw new Error(`Start value cannot be larger than 1`);\n    if (startingValue < -1)\n        throw new Error(`Start value cannot be smaller than -1`);\n    if (Number.isNaN(startingValue))\n        throw new Error(`Start value is NaN`);\n    const v = startingValue;\n    return {\n        [Symbol.toPrimitive](hint) {\n            if (hint === `number`)\n                return v;\n            else if (hint === `string`)\n                return v.toString();\n            return true;\n        },\n        value: v,\n        towardZero: (amt) => {\n            return immutable(towardZero(v, amt));\n        },\n        add: (amt) => {\n            return immutable(clamp(v + amt));\n        },\n        multiply: (amt) => {\n            return immutable(clamp(v * amt));\n        },\n        inverse: () => {\n            return immutable(-v);\n        },\n        interpolate: (amt, b) => {\n            return immutable(clamp(interpolate(amt, v, b)));\n        },\n        asScalar: () => {\n            return toScalar(v);\n        }\n    };\n};\n/**\n * Converts bipolar value to a scalar\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.toScalar(-1); // 0.0\n * Bipolar.toScalar( 0); // 0.5\n * Bipolar.toScalar( 1); // 1.0\n * ```\n *\n * Throws an error if `bipolarValue` is not a number or NaN\n * @param bipolarValue Value to convert to scalar\n * @returns Scalar value on 0..1 range.\n */\nexport const toScalar = (bipolarValue) => {\n    if (typeof bipolarValue !== `number`)\n        throw new Error(`Expected v to be a number. Got: ${typeof bipolarValue}`);\n    if (Number.isNaN(bipolarValue))\n        throw new Error(`Parameter is NaN`);\n    return (bipolarValue + 1) / 2;\n};\n/**\n * Makes a scalar into a bipolar value.\n *\n * That is, input range is 0..1, output range is -1...1\n *\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.fromScalar(1);   // 1\n * Bipolar.fromScalar(0);   // -1\n * Bipolar.fromScalar(0.5); // 0\n * ```\n *\n * Throws an error if `scalarValue` is not on 0..1 scale.\n * @param scalarValue Scalar value to convert\n * @returns Bipolar value on -1..1 scale\n */\nexport const fromScalar = (scalarValue) => {\n    resultThrow(numberTest(scalarValue, `percentage`, `v`));\n    return (scalarValue * 2) - 1;\n};\n/**\n * Scale & clamp resulting number to bipolar range (-1..1)\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Scale 100 on 0..100 scale\n * Bipolar.scale(100, 0, 100); // 1\n * Bipolar.scale(50, 0, 100);  // 0\n * Bipolar.scale(0, 0, 100);   // -1\n * ```\n *\n * Return value is clamped.\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scale = (inputValue, inMin, inMax) => {\n    return clamp(numberScaler(inMin, inMax, -1, 1)(inputValue));\n};\n/**\n * Scale a number to bipolar range (-1..1). Not clamped to scale.\n *\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Scale 100 on 0..100 scale\n * Bipolar.scale(100, 0, 100); // 1\n * Bipolar.scale(50, 0, 100);  // 0\n * Bipolar.scale(0, 0, 100);   // -1\n * ```\n *\n * @param inputValue Value to scale\n * @param inMin Minimum of scale\n * @param inMax Maximum of scale\n * @returns Bipolar value on -1..1 scale\n */\nexport const scaleUnclamped = (inputValue, inMin, inMax) => {\n    return numberScaler(inMin, inMax, -1, 1)(inputValue);\n};\n/**\n * Clamp a bipolar value\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.clamp(-1);   // -1\n * Bipolar.clamp(-1.1); // -1\n * ```\n *\n * Throws an error if `bipolarValue` is not a number or NaN.\n * @param bipolarValue Value to clamp\n * @returns Clamped value on -1..1 scale\n */\nexport const clamp = (bipolarValue) => {\n    if (typeof bipolarValue !== `number`)\n        throw new Error(`Param 'bipolarValue' must be a number. Got: ${typeof bipolarValue}`);\n    if (Number.isNaN(bipolarValue))\n        throw new Error(`Param 'bipolarValue' is NaN`);\n    if (bipolarValue > 1)\n        return 1;\n    if (bipolarValue < -1)\n        return -1;\n    return bipolarValue;\n};\n/**\n * Pushes a bipolar value toward zero by `amount`.\n * Return value is clamped on bipolar range of -1..1\n *\n * ```js\n * import { Bipolar } from 'https://unpkg.com/ixfx/dist/data.js';\n * Bipolar.towardZero(-1, 0.1); // -0.9\n * Bipolar.towardZero( 1, 0.1); //  0.9\n * Bipolar.towardZero( 0, 0.1); //  0.0\n * Bipolar.towardZero( 1, 1.1); //  0.0\n * ```\n *\n * If `amount` is greater than 1, 0 is returned.\n * Throws an error if `bipolarValue` or `amount` are not numbers.\n * Throws an error if `amount` is below zero.\n * @param bipolarValue Bipolar value to nudge toward zero\n * @param amount Amount to nudge by\n * @returns Bipolar value -1...1\n */\nexport const towardZero = (bipolarValue, amount) => {\n    if (typeof bipolarValue !== `number`)\n        throw new Error(`Parameter 'v' must be a number. Got: ${typeof bipolarValue}`);\n    if (typeof amount !== `number`)\n        throw new Error(`Parameter 'amt' must be a number. Got: ${typeof amount}`);\n    if (amount < 0)\n        throw new Error(`Parameter 'amt' must be positive`);\n    if (bipolarValue < 0) {\n        bipolarValue += amount;\n        if (bipolarValue > 0)\n            bipolarValue = 0;\n    }\n    else if (bipolarValue > 0) {\n        bipolarValue -= amount;\n        if (bipolarValue < 0)\n            bipolarValue = 0;\n    }\n    return bipolarValue;\n};\n","/* eslint-disable unicorn/prevent-abbreviations */\nimport { numberTest, integerTest, resultThrow } from '@ixfx/guards';\n/**\n * Wraps an integer number within a specified range, defaulting to degrees (0-360). Use {@link wrap} for floating-point wrapping.\n *\n * This is useful for calculations involving degree angles and hue, which wrap from 0-360.\n * Eg: to add 200 to 200, we don't want 400, but 40.\n *\n * ```js\n * const v = wrapInteger(200+200, 0, 360); // 40\n * ```\n *\n * Or if we minus 100 from 10, we don't want -90 but 270\n * ```js\n * const v = wrapInteger(10-100, 0, 360); // 270\n * ```\n *\n * `wrapInteger` uses 0-360 as a default range, so both of these\n * examples could just as well be:\n *\n * ```js\n * wrapInteger(200+200);  // 40\n * wrapInteger(10-100);  // 270\n * ```\n *\n * Non-zero starting points can be used. A range of 20-70:\n * ```js\n * const v = wrapInteger(-20, 20, 70); // 50\n * ```\n *\n * Note that the minimum value is inclusive, while the maximum is _exclusive_.\n * So with the default range of 0-360, 360 is never reached:\n *\n * ```js\n * wrapInteger(360); // 0\n * wrapInteger(361); // 1\n * ```\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * @param v Value to wrap\n * @param min Integer minimum of range (default: 0). Inclusive\n * @param max Integer maximum of range (default: 360). Exlusive\n * @returns\n */\nexport const wrapInteger = (v, min = 0, max = 360) => {\n    resultThrow(integerTest(v, undefined, `v`), integerTest(min, undefined, `min`), integerTest(max, undefined, `max`));\n    if (v === min)\n        return min;\n    if (v === max)\n        return min; // Wraps\n    if (v > 0 && v < min)\n        v += min;\n    v -= min;\n    max -= min;\n    v = v % max;\n    if (v < 0)\n        v = max - Math.abs(v) + min;\n    return v + min;\n};\n/**\n * Wraps floating point numbers to be within a range (default: 0..1). Use {@link wrapInteger} if you want to wrap integer values.\n *\n * This logic makes sense for some things like rotation angle.\n *\n * If you just want to lock values to a range without wrapping, consider {@link clamp}.\n *\n * ```js\n * wrap(1.2);   // 0.2\n * wrap(2);     // 1.0\n * wrap(-0.2); // 0.8\n * ```\n *\n * A range can be provided too:\n * ```js\n * wrap(30, 20, 50);  \t // 30\n * wrap(60, 20, 50);    //  30\n * ```\n * @param v\n * @param min\n * @param max\n * @returns\n */\nexport const wrap = (v, min = 0, max = 1) => {\n    resultThrow(numberTest(v, ``, `min`), numberTest(min, ``, `min`), numberTest(max, ``, `max`));\n    if (v === min)\n        return min;\n    if (v === max)\n        return min; // Wraps\n    while (v <= min || v >= max) {\n        if (v === max)\n            break;\n        if (v === min)\n            break;\n        if (v > max) {\n            v = min + (v - max);\n        }\n        else if (v < min) {\n            v = max - (min - v);\n        }\n    }\n    return v;\n};\n/**\n * Performs a calculation within a wrapping number range. This is a lower-level function.\n * See also: {@link wrapInteger} for simple wrapping within a range.\n *\n * `min` and `max` define the start and end of the valid range, inclusive. Eg for hue degrees it'd be 0, 360.\n * `a` and `b` is the range you want to work in.\n *\n * For example, let's say you want to get the middle point between a hue of 30 and a hue of 330 (ie warmer colours):\n * ```js\n * wrapRange(0,360, (distance) => {\n *  // for a:0 and b:330, distance would be 90 from 30 degrees to 330 (via zero)\n *  return distance * 0.5; // eg return middle point\n * }, 30, 330);\n * ```\n *\n * The return value of the callback should be in the range of 0-distance. `wrapRange` will subsequently\n * conform it to the `min` and `max` range before it's returned to the caller.\n *\n * @param a Output start (eg. 60)\n * @param b Output end (eg 300)\n * @param min Range start (eg 0)\n * @param max Range end (eg 360)\n * @param fn Returns a computed value from 0 to `distance`.\n * @returns\n */\nexport const wrapRange = (min, max, fn, a, b) => {\n    let r = 0;\n    const distF = Math.abs(b - a);\n    // When b is wrapped forwards\n    const distFwrap = Math.abs(max - a + b);\n    // When b is wrapped backwards (10, 300)\n    const distBWrap = Math.abs(a + (360 - b));\n    const distMin = Math.min(distF, distFwrap, distBWrap);\n    if (distMin === distBWrap) {\n        // (10, 300) = 70\n        r = a - fn(distMin);\n    }\n    else if (distMin === distFwrap) {\n        // (300, 60) = 120\n        r = a + fn(distMin);\n    }\n    else {\n        // Forwards or backwards without wrapping\n        if (a > b) {\n            // (240,120) -- backwards\n            r = a - fn(distMin);\n        }\n        else {\n            // (120,240) -- forwards\n            r = a + fn(distMin);\n        }\n    }\n    return wrapInteger(r, min, max);\n};\n","export const piPi = Math.PI * 2;\n","import { wrap } from './wrap.js';\nimport { numberTest, resultThrow } from '@ixfx/guards';\nimport { clamp } from './clamp.js';\nimport { piPi } from './pi-pi.js';\n/**\n * Interpolates between `a` and `b` by `amount`. Aka `lerp`.\n *\n * [ixfx Guide on Interpolation](https://ixfx.fun/data/interpolation/overview/)\n *\n * @example Get the halfway point between 30 and 60\n * ```js\n * interpolate(0.5, 30, 60);\n * ```\n *\n * See also {@link interpolatorStepped} and {@link interpolatorInterval} for functions\n * which help to manage progression from A->B over steps or interval.\n *\n * Usually interpolation amount is on a 0...1 scale, inclusive. What is the interpolation result\n * if this scale is exceeded? By default it is clamped to 0..1, so the return value is always between `a` and `b` (inclusive).\n *\n * Alternatively, set the `limits` option to process `amount`:\n * * 'wrap': wrap amount, eg 1.5 is the same as 0.5, 2 is the same as 1\n * * 'ignore': allow exceeding values. eg 1.5 will yield b*1.5.\n * * 'clamp': default behaviour of clamping interpolation amount to 0..1\n *\n * Interpolation can be non-linear using 'easing' option or 'transform' funciton.\n * ```js\n * interpolate(0.1, 0, 100, { easing: `quadIn` });\n * ```\n * To interpolate certain types: {@link Visual.Colour.interpolator | Visual.Colour.interpolator }, {@link Geometry.Points.interpolate | Points.interpolate}.\n *\n * There are a few variations when calling `interpolate`, depending on what parameters are fixed.\n * * `interpolate(amount)`: returns a function that needs a & b\n * * `interpolate(a, b)`:  returns a function that needs the interpolation amount\n */\nexport function interpolate(pos1, pos2, pos3, pos4) {\n    let amountProcess;\n    let limits = `clamp`;\n    const handleAmount = (amount) => {\n        if (amountProcess)\n            amount = amountProcess(amount);\n        if (limits === undefined || limits === `clamp`) {\n            amount = clamp(amount);\n        }\n        else if (limits === `wrap`) {\n            if (amount > 1)\n                amount = amount % 1;\n            else if (amount < 0) {\n                amount = 1 + (amount % 1);\n            }\n        }\n        return amount;\n    };\n    const doTheEase = (_amt, _a, _b) => {\n        resultThrow(numberTest(_a, ``, `a`), numberTest(_b, ``, `b`), numberTest(_amt, ``, `amount`));\n        _amt = handleAmount(_amt);\n        return (1 - _amt) * _a + _amt * _b;\n    };\n    const readOpts = (o = {}) => {\n        if (o.transform) {\n            if (typeof o.transform !== `function`)\n                throw new Error(`Param 'transform' is expected to be a function. Got: ${typeof o.transform}`);\n            amountProcess = o.transform;\n        }\n        limits = o.limits ?? `clamp`;\n    };\n    const rawEase = (_amt, _a, _b) => (1 - _amt) * _a + _amt * _b;\n    if (typeof pos1 !== `number`)\n        throw new TypeError(`First param is expected to be a number. Got: ${typeof pos1}`);\n    if (typeof pos2 === `number`) {\n        let a;\n        let b;\n        if (pos3 === undefined || typeof pos3 === `object`) {\n            //interpolate(a: number, b: number, options?: Partial<InterpolateOptions>): (amount: number) => number;\n            a = pos1;\n            b = pos2;\n            readOpts(pos3);\n            return (amount) => doTheEase(amount, a, b);\n        }\n        else if (typeof pos3 === `number`) {\n            //interpolate(amount: number, a: number, b: number, options?: Partial<InterpolateOptions>): number;\n            a = pos2;\n            b = pos3;\n            readOpts(pos4);\n            return doTheEase(pos1, a, b);\n        }\n        else {\n            throw new Error(`Values for 'a' and 'b' not defined`);\n        }\n    }\n    else if (pos2 === undefined || typeof pos2 === `object`) {\n        //interpolate(amount: number, options?: Partial<InterpolateOptions>): (a:number,b:number)=>number;\n        const amount = handleAmount(pos1);\n        readOpts(pos2);\n        resultThrow(numberTest(amount, ``, `amount`));\n        return (aValue, bValue) => rawEase(amount, aValue, bValue);\n    }\n}\n;\n/**\n * Returns a function that interpolates from A to B.\n * It steps through the interpolation with each call to the returned function.\n * This means that the `incrementAmount` will hinge on the rate\n * at which the function is called. Alternatively, consider {@link interpolatorInterval}\n * which steps on the basis of clock time.\n *\n * ```js\n * // Interpolate from 0..1 by 0.01\n * const v = interpolatorStepped(0.01, 100, 200);\n * v(); // Each call returns a value closer to target\n * // Eg: 100, 110, 120, 130 ...\n * ```\n *\n * Under the hood, it calls `interpolate` with an amount that\n * increases by `incrementAmount` each time.\n *\n * When calling `v()` to step the interpolator, you can also pass\n * in new B and A values. Note that the order is swapped: the B (target) is provided first, and\n * then optionally A.\n *\n * ```js\n * const v = interpolatorStepped(0.1, 100, 200); // Interpolate 100->200\n * v(300, 200); // Retarget to 200->300 and return result\n * v(150); // Retarget 200->150 and return result\n * ```\n *\n * This allows you to maintain the current interpolation progress.\n * @param incrementAmount Amount to increment by\n * @param a Start value. Default: 0\n * @param b End value. Default: 1\n * @param startInterpolationAt Starting interpolation amount. Default: 0\n * @param options Options for interpolation\n * @returns\n */\nexport const interpolatorStepped = (incrementAmount, a = 0, b = 1, startInterpolationAt = 0, options) => {\n    let amount = startInterpolationAt;\n    return (retargetB, retargetA) => {\n        if (retargetB !== undefined)\n            b = retargetB;\n        if (retargetA !== undefined)\n            a = retargetA;\n        if (amount >= 1)\n            return b;\n        const value = interpolate(amount, a, b, options);\n        amount += incrementAmount;\n        return value;\n    };\n};\n/**\n * Interpolate between angles `a` and `b` by `amount`. Angles are in radians.\n *\n * ```js\n * import { interpolateAngle } from 'https://unpkg.com/ixfx/dist/data.js';\n * interpolateAngle(0.5, Math.PI, Math.PI/2);\n * ```\n * @param amount\n * @param aRadians Start angle (radian)\n * @param bRadians End angle (radian)\n * @returns\n */\nexport const interpolateAngle = (amount, aRadians, bRadians, options) => {\n    const t = wrap(bRadians - aRadians, 0, piPi);\n    return interpolate(amount, aRadians, aRadians + (t > Math.PI ? t - piPi : t), options);\n};\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { round } from \"./round.js\";\n/**\n * Generates a `step`-length series of values between `start` and `end` (inclusive).\n * Each value will be equally spaced.\n *\n * ```js\n * for (const v of linearSpace(1, 5, 6)) {\n *  // Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]\n * }\n * ```\n *\n * Numbers can be produced from large to small as well\n * ```js\n * const values = [...linearSpace(10, 5, 3)];\n * // Yields: [10, 7.5, 5]\n * ```\n * @param start Start number (inclusive)\n * @param end  End number (inclusive)\n * @param steps How many steps to make from start -> end\n * @param precision Number of decimal points to round to\n */\nexport function* linearSpace(start, end, steps, precision) {\n    resultThrow(numberTest(start, ``, `start`), numberTest(end, ``, `end`), numberTest(steps, ``, `steps`));\n    const r = precision ? round(precision) : (v) => v;\n    const step = (end - start) / (steps - 1);\n    resultThrow(numberTest(step, ``, `step`));\n    if (!Number.isFinite(step)) {\n        throw new TypeError(`Calculated step value is infinite`);\n    }\n    for (let index = 0; index < steps; index++) {\n        const v = start + step * index;\n        yield r(v);\n    }\n}\n","export class BasicQueueMutable {\n    #store = [];\n    enqueue(data) {\n        this.#store.push(data);\n    }\n    dequeue() {\n        return this.#store.shift();\n    }\n    get data() {\n        return this.#store;\n    }\n    get size() {\n        return this.#store.length;\n    }\n}\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { BasicQueueMutable } from \"./util/queue-mutable.js\";\nimport { averageWeighted } from \"./average-weighted.js\";\nimport { average } from \"./numeric-arrays.js\";\nconst PiPi = Math.PI * 2;\n/**\n * A moving average calculator (exponential weighted moving average) which does not keep track of\n * previous samples. Less accurate, but uses less system resources.\n *\n * The `scaling` parameter determines smoothing. A value of `1` means that\n * the latest value is used as the average - that is, no smoothing. Higher numbers\n * introduce progressively more smoothing by weighting the accumulated prior average more heavily.\n *\n * ```\n * const ma = movingAverageLight(); // default scaling of 3\n * ma(50);  // 50\n * ma(100); // 75\n * ma(75);  // 75\n * ma(0);   // 50\n * ```\n *\n * Note that the final average of 50 is pretty far from the last value of 0. To make it more responsive,\n * we could use a lower scaling factor: `movingAverageLight(2)`. This yields a final average of `37.5` instead.\n *\n * @param scaling Scaling factor. 1 is no smoothing. Default: 3\n * @returns Function that adds to average.\n */\nexport const movingAverageLight = (scaling = 3) => {\n    resultThrow(numberTest(scaling, `aboveZero`, `scaling`));\n    let average = 0;\n    let count = 0;\n    return (v) => {\n        const r = numberTest(v, ``, `v`);\n        if (r[0] && v !== undefined) {\n            // Valid number\n            count++;\n            average = average + (v - average) / Math.min(count, scaling);\n        }\n        return average;\n    };\n};\n/**\n * Creates a moving average for a set number of `samples`.\n * It returns a function which in turn yields an average value.\n *\n * Moving average are useful for computing the average over a recent set of numbers.\n * A lower number of samples produces a computed value that is lower-latency yet more jittery.\n * A higher number of samples produces a smoother computed value which takes longer to respond to\n * changes in data.\n *\n * Sample size is considered with respect to the level of latency/smoothness trade-off, and also\n * the rate at which new data is added to the moving average.\n *\n *\n * ```js\n * const ma = movingAverage(10);\n * ma(10); // 10\n * ma(5);  // 7.5\n * ```\n *\n * A weighting function can be provided to shape how the average is\n * calculated - eg privileging the most recent data over older data.\n * It uses `Arrays.averageWeighted` under the hood.\n *\n * ```js\n * import { movingAverage } from 'https://unpkg.com/ixfx/dist/data.js';\n * import { gaussian } from 'https://unpkg.com/ixfx/dist/modulation.js';\n *\n * // Give more weight to data in middle of sampling window\n * const ma = movingAverage(100, gaussian());\n * ```\n *\n * Because it keeps track of `samples` previous data, there is a memory impact. A lighter version is {@link movingAverageLight} which does not keep a buffer of prior data, but can't be as easily fine-tuned.\n * @param samples Number of samples to compute average from\n * @param weighter Optional weighting function\n * @returns\n */\nexport const movingAverage = (samples = 100, weighter) => {\n    const q = new BasicQueueMutable();\n    return (v) => {\n        const r = numberTest(v);\n        if (r[0] && v !== undefined) {\n            q.enqueue(v);\n            while (q.size > samples) {\n                q.dequeue();\n            }\n        }\n        return weighter === undefined ? average(q.data) : averageWeighted(q.data, weighter);\n    };\n};\n// export const movingAverageTimed = (\n//   updateRateMs = 200,\n//   value = 0,\n//   scaling = 3\n// ): MovingAverage => {\n//   throwNumberTest(scaling, `aboveZero`, `scaling`);\n//   throwNumberTest(updateRateMs, `aboveZero`, `decayRateMs`);\n//   const mal = movingAverageLight(scaling);\n//   //eslint-disable-next-line functional/no-let\n//   let timer = 0;\n//   const reschedule = () => {\n//     if (timer !== 0) clearTimeout(timer);\n//     // eslint-disable-next-line @typescript-eslint/prefer-ts-expect-error\n//     // @ts-ignore\n//     timer = setTimeout(decay, updateRateMs) as number;\n//   };\n//   const decay = () => {\n//     mal.add(value);\n//     if (!mal.isDisposed) setTimeout(decay, updateRateMs);\n//   };\n//   const ma: MovingAverage = {\n//     add(v: number) {\n//       reschedule();\n//       return mal.add(v);\n//     },\n//     dispose() {\n//       mal.dispose();\n//     },\n//     clear: function (): void {\n//       mal.clear();\n//     },\n//     compute: function (): number {\n//       return mal.compute();\n//     },\n//     isDisposed: false,\n//   };\n//   return ma;\n// };\nconst smoothingFactor = (timeDelta, cutoff) => {\n    const r = PiPi * cutoff * timeDelta;\n    return r / (r + 1);\n};\nconst exponentialSmoothing = (smoothingFactor, value, previous) => {\n    return smoothingFactor * value + (1 - smoothingFactor) * previous;\n};\n/**\n * Noise filtering\n *\n * Algorithm: https://gery.casiez.net/1euro/\n *\n * Based on [Jaan Tollander de Balsch's implementation](https://jaantollander.com/post/noise-filtering-using-one-euro-filter/)\n * @param cutoffMin Default: 1\n * @param speedCoefficient Default: 0\n * @param cutoffDefault Default: 1\n */\nexport const noiseFilter = (cutoffMin = 1, speedCoefficient = 0, cutoffDefault = 1) => {\n    let previousValue = 0;\n    let derivativeLast = 0;\n    let timestampLast = 0;\n    const compute = (value, timestamp) => {\n        timestamp ??= performance.now();\n        const timeDelta = timestamp - timestampLast;\n        // Filtered derivative\n        const s = smoothingFactor(timeDelta, cutoffDefault);\n        const valueDelta = (value - previousValue) / timeDelta;\n        const derivative = exponentialSmoothing(s, valueDelta, derivativeLast);\n        // Filtered signal\n        const cutoff = cutoffMin + speedCoefficient * Math.abs(derivative);\n        const a = smoothingFactor(timeDelta, cutoff);\n        const smoothed = exponentialSmoothing(a, value, previousValue);\n        previousValue = smoothed;\n        derivativeLast = derivative;\n        timestampLast = timestamp;\n        return smoothed;\n    };\n    return compute;\n};\n","import { clamp, clamper } from './clamp.js';\nimport { numberTest, resultThrow } from '@ixfx/guards';\n/**\n * Scales `v` from an input range to an output range (aka `map`)\n *\n * For example, if a sensor's useful range is 100-500, scale it to a percentage:\n *\n * ```js\n * import { scale } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * scale(sensorReading, 100, 500, 0, 1);\n * ```\n *\n * `scale` defaults to a percentage-range output, so you can get away with:\n * ```js\n * scale(sensorReading, 100, 500);\n * ```\n *\n * If `v` is outside of the input range, it will likewise be outside of the output range.\n * Use {@link scaleClamped} to clip value to range.\n *\n * If inMin and inMax are equal, outMax will be returned.\n *\n * An easing function can be provided for non-linear scaling. In this case\n * the input value is 'pre scaled' using the function before it is applied to the\n * output range.\n *\n * ```js\n * scale(sensorReading, 100, 500, 0, 1, Easings.gaussian());\n * ```\n * @param v Value to scale\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @returns Scaled value\n */\nexport const scale = (v, inMin, inMax, outMin, outMax, easing) => scaler(inMin, inMax, outMin, outMax, easing)(v);\n/**\n * Returns a scaling function\n * @param inMin Input minimum\n * @param inMax Input maximum\n * @param outMin Output minimum. If not specified, 0\n * @param outMax Output maximum. If not specified, 1\n * @param easing Easing function\n * @param clamped If true, value is clamped. Default: false\n * @returns\n */\nexport const scaler = (inMin, inMax, outMin, outMax, easing, clamped) => {\n    resultThrow(numberTest(inMin, `finite`, `inMin`), numberTest(inMax, `finite`, `inMax`));\n    const oMax = outMax ?? 1;\n    const oMin = outMin ?? 0;\n    const clampFunction = clamped ? clamper(outMin, outMax) : undefined;\n    return (v) => {\n        if (inMin === inMax)\n            return oMax;\n        let a = (v - inMin) / (inMax - inMin);\n        if (easing !== undefined)\n            a = easing(a);\n        const x = a * (oMax - oMin) + oMin;\n        if (clampFunction)\n            return clampFunction(x);\n        return x;\n    };\n};\n/**\n * Returns a 'null' scaler that does nothing - the input value is returned as output.\n * @returns\n */\nexport const scalerNull = () => (v) => v;\n/**\n * As {@link scale}, but result is clamped to be\n * within `outMin` and `outMax`.\n *\n * @param v\n * @param inMin\n * @param inMax\n * @param outMin 1 by default\n * @param outMax 0 by default d\n * @param easing\n * @returns\n */\nexport const scaleClamped = (v, inMin, inMax, outMin, outMax, easing) => {\n    if (typeof outMax === `undefined`)\n        outMax = 1;\n    if (typeof outMin === `undefined`)\n        outMin = 0;\n    if (inMin === inMax)\n        return outMax;\n    const x = scale(v, inMin, inMax, outMin, outMax, easing);\n    return clamp(x, outMin, outMax);\n};\n/**\n * Scales an input percentage to a new percentage range.\n *\n * If you have an input percentage (0-1), `scalePercentageOutput` maps it to an\n * _output_ percentage of `outMin`-`outMax`.\n *\n * ```js\n * import { scalePercentages } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Scales 50% to a range of 0-10%\n * scalePercentages(0.5, 0, 0.10); // 0.05 - 5%\n * ```\n *\n * An error is thrown if any parameter is outside of percentage range. This added\n * safety is useful for catching bugs. Otherwise, you could just as well call\n * `scale(percentage, 0, 1, outMin, outMax)`.\n *\n * If you want to scale some input range to percentage output range, just use `scale`:\n * ```js\n * import { scale } from 'https://unpkg.com/ixfx/dist/data.js';\n *\n * // Yields 0.5\n * scale(2.5, 0, 5);\n * ```\n * @param percentage Input value, within percentage range\n * @param outMin Output minimum, between 0-1\n * @param outMax Output maximum, between 0-1\n * @returns Scaled value between outMin-outMax.\n */\nexport const scalePercentages = (percentage, outMin, outMax = 1) => {\n    resultThrow(numberTest(percentage, `percentage`, `v`), numberTest(outMin, `percentage`, `outMin`), numberTest(outMax, `percentage`, `outMax`));\n    return scale(percentage, 0, 1, outMin, outMax);\n};\n/**\n * Scales an input percentage value to an output range\n * If you have an input percentage (0-1), `scalePercent` maps it to an output range of `outMin`-`outMax`.\n * ```js\n * import { scalePercent } from 'https://unpkg.com/ixfx/dist/data.js';\n * scalePercent(0.5, 10, 20); // 15\n * ```\n *\n * @see {@link scalerPercent} Returns a function\n * @param v Value to scale\n * @param outMin Minimum for output\n * @param outMax Maximum for output\n * @returns\n */\nexport const scalePercent = (v, outMin, outMax) => scalerPercent(outMin, outMax)(v);\n/**\n * Returns a function that scales an input percentage value to an output range\n * @see {@link scalePercent} Calculates value\n * @param outMin\n * @param outMax\n * @returns Function that takes a single argument\n */\nexport const scalerPercent = (outMin, outMax) => {\n    return (v) => {\n        resultThrow(numberTest(v, `percentage`, `v`));\n        return scale(v, 0, 1, outMin, outMax);\n    };\n};\n/**\n * Returns a two-way scaler\n * ```js\n * // Input range 0..100, output range 0..1\n * const s = scalerTwoWay(0,100,0,1);\n *\n * // Scale from input to output\n * s.out(50); // 0.5\n *\n * // Scale from output range to input\n * s.in(1); // 100\n * ```\n * @param inMin\n * @param inMax\n * @param outMin\n * @param outMax\n * @returns\n */\nexport const scalerTwoWay = (inMin, inMax, outMin = 0, outMax = 1, clamped = false, easing) => {\n    const toOut = scaler(inMin, inMax, outMin, outMax, easing, clamped);\n    const toIn = scaler(outMin, outMax, inMin, inMax, easing, clamped);\n    return { out: toOut, in: toIn };\n};\n","/**\n * Calculate the min, max, total, average and count of input array `data`.\n * ```js\n * const { total, min, max, avg, count } = numberArrayCompute([ 1, 2, 3 ]);\n * ```\n * @param data\n * @param opts\n * @returns\n */\nexport const numberArrayCompute = (data, opts = {}) => {\n    if (data.length === 0) {\n        return {\n            total: Number.NaN,\n            min: Number.NaN,\n            max: Number.NaN,\n            avg: Number.NaN,\n            count: Number.NaN\n        };\n    }\n    const nonNumbers = opts.nonNumbers ?? `throw`;\n    let total = 0;\n    let min = Number.MAX_SAFE_INTEGER;\n    let max = Number.MIN_SAFE_INTEGER;\n    let count = 0;\n    for (let index = 0; index < data.length; index++) {\n        let value = data[index];\n        if (typeof value !== `number`) {\n            if (nonNumbers === `ignore`)\n                continue;\n            if (nonNumbers === `throw`)\n                throw new Error(`Param 'data' contains a non-number at index: ${index.toString()}`);\n            if (nonNumbers === `nan`)\n                value = Number.NaN;\n        }\n        if (Number.isNaN(value))\n            continue;\n        min = Math.min(min, value);\n        max = Math.max(max, value);\n        total += value;\n        count++;\n    }\n    return {\n        total, max, min, count,\n        avg: total / count\n    };\n};\n","import { scale } from './scale.js';\nimport { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { clamp } from './clamp.js';\nimport { numberArrayCompute } from './number-array-compute.js';\n/**\n * Normalises numbers, adjusting min/max as new values are processed.\n * Normalised return values will be in the range of 0-1 (inclusive).\n *\n * [ixfx Guide on Normalising](https://ixfx.fun/cleaning/normal/)\n *\n * @example\n * ```js\n * import {Normalise} from 'https://unpkg.com/ixfx/dist/numbers.js'\n * const s = Normalise.stream();\n * s(2);    // 1 (because 2 is highest seen)\n * s(1);    // 0 (because 1 is the lowest so far)\n * s(1.5);  // 0.5 (50% of range 1-2)\n * s(0.5);  // 0 (because it's the new lowest)\n * ```\n *\n * Since normalisation is being adjusted as new min/max are encountered, it might\n * be that value normalised to 1 at one time is different to what normalises to 1\n * at a later time.\n *\n * If you already know what to expect of the number range, passing in `minDefault`\n * and `maxDefault` primes the normalisation.\n * ```js\n * const s = Normalise.stream();\n * s(5); // 1, because it's the highest seen\n *\n * // With priming:\n * const s = Normalise.stream(0, 10);\n * s(5); // 0.5, because we're expecting range 0-10\n * ```\n *\n * If a value exceeds the default range, normalisation adjusts.\n * Errors are thrown if min/max defaults are NaN or if one attempts to\n * normalise NaN.\n * @returns\n */\nexport const stream = (minDefault, maxDefault) => {\n    let min = minDefault ?? Number.MAX_SAFE_INTEGER;\n    let max = maxDefault ?? Number.MIN_SAFE_INTEGER;\n    resultThrow(numberTest(min), numberTest(max));\n    return (v) => {\n        resultThrow(numberTest(v));\n        min = Math.min(min, v);\n        max = Math.max(max, v);\n        return scale(v, min, max);\n    };\n};\n/**\n * Normalises an array. By default uses the actual min/max of the array\n * as the normalisation range. [ixfx Guide on Normalising](https://ixfx.fun/cleaning/normal/)\n *\n * ```js\n * import {Normalise} from 'https://unpkg.com/ixfx/dist/numbers.js'\n * // Yields: [0.5, 0.1, 0.0, 0.9, 1]\n * Normalise.array([5,1,0,9,10]);\n * ```\n *\n * `minForced` and/or `maxForced` can\n * be provided to use an arbitrary range.\n * ```js\n * // Forced range 0-100\n * // Yields: [0.05, 0.01, 0.0, 0.09, 0.10]\n * Normalise.array([5,1,0,9,10], 0, 100);\n * ```\n *\n * Return values are clamped to always be 0-1, inclusive.\n *\n * @param values Values\n * @param minForced If provided, this will be min value used\n * @param maxForced If provided, this will be the max value used\n */\nexport const array = (values, minForced, maxForced) => {\n    if (!Array.isArray(values)) {\n        throw new TypeError(`Param 'values' should be an array. Got: ${typeof values}`);\n    }\n    const mma = numberArrayCompute(values);\n    const min = minForced ?? mma.min;\n    const max = maxForced ?? mma.max;\n    return values.map((v) => clamp(scale(v, min, max)));\n};\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Scales a percentage-scale number, ie: `v * t`.\n * The utility of this function is that it sanity-checks that\n *  both parameters are in the 0..1 scale.\n * @param v Value\n * @param t Scale amount\n * @returns Scaled value\n */\nexport const proportion = (v, t) => {\n    if (typeof v === `function`)\n        v = v();\n    if (typeof t === `function`)\n        t = t();\n    resultThrow(numberTest(v, `percentage`, `v`), numberTest(t, `percentage`, `t`));\n    return v * t;\n};\n","import { integerTest, numberTest, resultThrow } from \"@ixfx/guards\";\n/**\n * Rounds `v` by `every`. Middle values are rounded up by default.\n *\n * ```js\n * quantiseEvery(11, 10);  // 10\n * quantiseEvery(25, 10);  // 30\n * quantiseEvery(0, 10);   // 0\n * quantiseEvery(4, 10);   // 0\n * quantiseEvery(100, 10); // 100\n * ```\n *\n * Also works with decimals\n * ```js\n * quantiseEvery(1.123, 0.1); // 1.1\n * quantiseEvery(1.21, 0.1);  // 1.2\n * ```\n *\n * @param v Value to quantise\n * @param every Number to quantise to\n * @param middleRoundsUp If _true_ (default), the exact middle rounds up to next step.\n * @returns\n */\nexport const quantiseEvery = (v, every, middleRoundsUp = true) => {\n    const everyString = every.toString();\n    const decimal = everyString.indexOf(`.`);\n    let multiplier = 1;\n    if (decimal >= 0) {\n        const d = everyString.substring(decimal + 1).length;\n        multiplier = 10 * d;\n        every = Math.floor(multiplier * every);\n        v = v * multiplier;\n    }\n    resultThrow(numberTest(v, ``, `v`), integerTest(every, ``, `every`));\n    let div = v / every;\n    const divModule = div % 1;\n    div = Math.floor(div);\n    if ((divModule === 0.5 && middleRoundsUp) || divModule > 0.5)\n        div++;\n    const vv = (every * div) / multiplier;\n    return vv;\n};\n","/**\n * Via: https://gist.github.com/cyphunk/6c255fa05dd30e69f438a930faeb53fe\n * @param logits\n * @returns\n */\nexport const softmax = (logits) => {\n    const maxLogit = logits.reduce((a, b) => Math.max(a, b), Number.NEGATIVE_INFINITY);\n    const scores = logits.map((l) => Math.exp(l - maxLogit));\n    const denom = scores.reduce((a, b) => a + b);\n    return scores.map((s) => s / denom);\n};\n","\nexport const HelloTest = () => { console.log(`hello test`) };\n\nexport * from '@ixfx/numbers';\nexport type * from '@ixfx/numbers';"],"mappings":"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"}