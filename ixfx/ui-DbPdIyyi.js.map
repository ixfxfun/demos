{"version":3,"file":"ui-DbPdIyyi.js","names":["callback: FunctionFunction<V>","options: Partial<FunctionOptions>","manual","reason: string","source: IterableIterator<V> | V[] | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V>","options: Partial<GeneratorOptions>","message: string","_: string","iterator: IterableIterator<V> | AsyncIterableIterator<V> | undefined","ourAc: AbortController | undefined","iterator","reason: string","message: Passed<V> | PassedSignal","v: Passed<V> | PassedSignal","rx: Reactive<V> | ReactiveDiff<V> | object","rx: object","v: any","source: ReactiveOrSource<V>","options: Partial<ResolveSourceOptions>","upstreamSource: ReactiveOrSource<In>","options: Partial<UpstreamOptions<In>>","_v: In","unsub: undefined | (() => void)","options: InitLazyStreamOptions","options: Partial<InitStreamOptions>","dispatcher: DispatchList<Passed<V>> | undefined","handler: Dispatch<Passed<V>>","reason: string","v: V","signal: SignalKinds","context?: string","handler: (value: V) => void","initialValue?: V","options: Partial<ObjectOptions<V>>","fieldChangeEvents: [ matcher: (value: string) => boolean, pattern: string, DispatchList<ObjectFieldHandler> ][]","value: V | undefined","v: V","field: string","value: any","updateCompareOptions: Partial<Pathed.CompareDataOptions<V>>","toMerge: Partial<V>","path: string","valueForField: any","reason: string","fieldPattern: string","handler: (result: ObjectFieldHandler) => void","stream: ReactiveStream<V>","targetOrQuery: EventTarget | null | string","name: string","initialValue: TEventArgs | undefined","options: Partial<EventSourceOptions>","target: EventTarget | null","args: any","reason: string","handler: (v: Passed<TEventArgs>) => void","handler: (v: TEventArgs) => void","options: Partial<EventSourceTriggerOptions>","_args?: any","input: ReactiveOrSource<In>","transformer: (value: In) => Out","options: Partial<TransformOpts>","debounce","source: ReactiveOrSource<V>","options: Partial<DebounceOptions>","lastValue: V | undefined","options: Partial<DebounceOptions>","source: ReactiveOrSource<V>","options: Partial<InitStreamOptions>","value: V","init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined","init","onCleanup: (() => void) | undefined","callback: (value: V) => void","elements","bind","init","changes"],"sources":["../../packages/rx/src/from/function.ts","../../packages/rx/src/from/iterator.ts","../../packages/rx/src/util.ts","../../packages/rx/src/resolve-source.ts","../../packages/rx/src/init-stream.ts","../../packages/rx/src/from/object.ts","../../packages/rx/src/to-readable.ts","../../packages/rx/src/from/event.ts","../../packages/rx/src/ops/transform.ts","../../packages/rx/src/reactives/debounce.ts","../../packages/rx/src/ops/debounce.ts","../../packages/rx/src/index.ts","../../packages/rx/src/from/observable.ts","../../packages/ui/dist/src/rx/browser-resize.js","../../packages/ui/dist/src/rx/browser-theme-change.js","../../packages/ui/dist/src/rx/colour.js","../../packages/ui/dist/src/rx/dom-source.js","../../packages/ui/dist/src/rx/dom.js","../../packages/ui/dist/src/rx/index.js","../src/ui.ts"],"sourcesContent":["import { continuously, intervalToMs } from \"@ixfx/core\";\nimport { getErrorMessage } from \"@ixfx/debug\";\n\nimport { sleep } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\nimport type { ReactivePingable } from \"../types.js\";\nimport type { FunctionFunction, FunctionOptions } from \"./types.js\";\n\n\n/**\n * Produces a reactive from the basis of a function. `callback` is executed, with its result emitted via the returned reactive.\n * \n * ```js\n * // Produce a random number every second\n * const r = Rx.From.func(Math.random, { interval: 1000 });\n * ```\n * \n * `callback` can be called repeatedly by providing the `interval` option to set the rate of repeat.\n * Looping can be limited with `options.maximumRepeats`, or passing a signal `options.signal`\n * and then activating it. \n * ```js\n * // Reactive that emits a random number every second, five times\n * const r1 = Rx.From.func(Math.random, { interval: 1000, maximumRepeats: 5 }\n * ```\n * \n * ```js\n * // Generate a random number every second until ac.abort() is called\n * const ac = new AbortController();\n * const r2 = Rx.From.func(Math.random, { interval: 1000, signal: ac.signal });\n * ```\n * \n * The third option is for `callback` to fire the provided abort function.\n * ```js\n * Rx.From.func((abort) => {\n *  if (Math.random() > 0.5) abort('Random exit');\n *  return 1;\n * });\n * ```\n *\n * By default has a laziness of 'very' meaning that `callback` is run only when there's a subscriber \n * By default stream closes if `callback` throws an error. Use `options.closeOnError:'ignore'` to change.\n * @param callback \n * @param options \n * @returns \n */\n\nexport function func<V>(callback: FunctionFunction<V>, options: Partial<FunctionOptions> = {}): ReactivePingable<V> {\n  const maximumRepeats = options.maximumRepeats ?? Number.MAX_SAFE_INTEGER;\n  const closeOnError = options.closeOnError ?? true;\n  const intervalMs = options.interval ? intervalToMs(options.interval) : -1;\n  let manual = options.manual ?? false;\n\n  // If niether interval or manual is set, assume manual\n  if (options.interval === undefined && options.manual === undefined) manual = true;\n\n  if (manual && options.interval) throw new Error(`If option 'manual' is set, option 'interval' cannot be used`);\n  const predelay = intervalToMs(options.predelay, 0);\n  const lazy = options.lazy ?? `very`;\n  const signal = options.signal;\n\n  const internalAbort = new AbortController();\n  const internalAbortCallback = (reason: string) => { internalAbort.abort(reason) };\n  let sentResults = 0;\n  let enabled = false;\n\n  const done = (reason: string) => {\n    events.dispose(reason);\n    enabled = false;\n    if (run) run.cancel();\n  }\n\n  const ping = async () => {\n    if (!enabled) return false;\n    if (predelay) await sleep(predelay);\n    if (sentResults >= maximumRepeats) {\n      done(`Maximum repeats reached ${ maximumRepeats.toString() }`);\n      return false;\n    }\n    //console.log(`sent: ${ sentResults } max: ${ maximumRepeats }`);\n    try {\n      if (signal?.aborted) {\n        done(`Signal (${ signal.aborted })`);\n        return false;\n      }\n      const value = await callback(internalAbortCallback);\n      sentResults++;\n      events.set(value);\n      return true;\n    } catch (error) {\n      if (closeOnError) {\n        done(`Function error: ${ getErrorMessage(error) }`);\n        return false;\n      } else {\n        events.signal(`warn`, getErrorMessage(error));\n        return true;\n      }\n    }\n  }\n\n  const run = manual ? undefined : continuously(async () => {\n    const pingResult = await ping();\n    if (!pingResult) return false;\n\n    // if (!loop) {\n    //   done(`fromFunction done`);\n    //   return false; // Stop loop\n    // }\n    if (internalAbort.signal.aborted) {\n      done(`callback function aborted (${ internalAbort.signal.reason })`);\n      return false\n    }\n\n  }, intervalMs);\n\n  const events = initLazyStream<V>({\n    lazy,\n    onStart() {\n      enabled = true;\n      if (run) run.start();\n    },\n    onStop() {\n\n      enabled = false;\n      if (run) run.cancel();\n    },\n  });\n\n  if (lazy === `never` && run) run.start();\n  return { ...events, ping };\n}\n\n","\nimport { nextWithTimeout } from \"@ixfx/iterables/async\";\nimport { intervalToMs } from \"@ixfx/core\";\nimport { initLazyStream } from \"../init-stream.js\";\nimport { isAsyncIterable } from \"@ixfx/iterables\";\nimport type { Reactive } from \"../types.js\";\nimport type { GeneratorOptions } from \"./types.js\";\nimport * as StateMachine from \"@ixfx/flow/state-machine\";\n\n/**\n * Creates a Reactive from an AsyncGenerator or Generator\n * @param gen \n * @returns \n */\n// export function readFromGenerator<V>(gen: AsyncGenerator<V> | Generator<V>) {\n//   const rx = initStream<V>();\n//   // eslint-disable-next-line @typescript-eslint/no-misused-promises\n//   setTimeout(async () => {\n//     try {\n//       for await (const value of gen) {\n//         rx.set(value);\n//       }\n//       rx.dispose(`Source generator complete`);\n//     } catch (error) {\n//       console.error(error);\n//       rx.dispose(`Error while iterating`);\n//     }\n//   }, 1);\n//   return rx;\n// }\n\n/**\n * Creates a readable reactive based on a (async)generator or iterator\n * ```js\n * // Generator a random value every 5 seconds\n * const valuesOverTime = Flow.interval(() => Math.random(), 5000);\n * // Wrap the generator\n * const r = Rx.From.iterator(time);\n * // Get notified when there is a new value\n * r.onValue(v => {\n *   console.log(v);\n * });\n * ```\n * \n * Awaiting values could potentially hang code. Thus there is a `readTimeout`, the maximum time to wait for a value from the generator. Default: 5 minutes.\n * If `signal` is given, this will also cancel waiting for the value.\n * @param source \n */\nexport function iterator<V>(source: IterableIterator<V> | V[] | AsyncIterableIterator<V> | Generator<V> | AsyncGenerator<V>, options: Partial<GeneratorOptions> = {}): Reactive<V> {\n  const lazy = options.lazy ?? `very`;\n  const log = options.traceLifecycle ? (message: string) => { console.log(`Rx.From.iterator ${ message }`); } : (_: string) => {/* no-up */ }\n\n  const readIntervalMs = intervalToMs(options.readInterval, 5);\n  const readTimeoutMs = intervalToMs(options.readTimeout, 5 * 60 * 1000);\n  const whenStopped = options.whenStopped ?? `continue`;\n\n  let iterator: IterableIterator<V> | AsyncIterableIterator<V> | undefined;\n  //let reading = false;\n  let ourAc: AbortController | undefined;\n  let sm = StateMachine.init({\n    idle: [ `wait_for_next` ],\n    wait_for_next: [ `processing_result`, `stopping`, `disposed` ],\n    processing_result: [ `queued`, `disposed`, `stopping` ],\n    queued: [ `wait_for_next`, `disposed`, `stopping` ],\n    stopping: `idle`,\n\n    disposed: null\n  }, `idle`);\n\n  const onExternalSignal = () => {\n    log(`onExternalSignal`);\n    ourAc?.abort(options.signal?.reason);\n  }\n  if (options.signal) {\n    options.signal.addEventListener(`abort`, onExternalSignal, { once: true });\n  };\n\n  const read = async () => {\n    log(`read. State: ${ sm.value }`);\n    ourAc = new AbortController();\n    try {\n      sm = StateMachine.to(sm, `wait_for_next`);\n      const v = await nextWithTimeout(iterator!, { signal: ourAc.signal, millis: readTimeoutMs });\n      sm = StateMachine.to(sm, `processing_result`);\n      ourAc.abort(`nextWithTimeout completed`);\n\n      if (v.done) {\n        log(`read v.done true`);\n        events.dispose(`Generator complete`);\n        //reading = false;\n        sm = StateMachine.to(sm, `disposed`);\n      }\n      //if (!reading) return;\n      if (sm.value === `stopping`) {\n        log(`read. sm.value = stopping`)\n        sm = StateMachine.to(sm, `idle`);\n        return;\n      }\n      if (sm.value === `disposed`) {\n        log(`read. sm.value = disposed`);\n        return;\n      }\n      events.set(v.value);\n\n    } catch (error) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n      events.dispose(`Generator error: ${ (error as any).toString() }`);\n      return;\n    }\n    //if (events.isDisposed()) return;\n    //if (!reading) return;\n\n    if (sm.value === `processing_result`) {\n      sm = StateMachine.to(sm, `queued`);\n      log(`scheduling read. State: ${ sm.value }`);\n      // eslint-disable-next-line @typescript-eslint/no-misused-promises\n      setTimeout(read, readIntervalMs);\n    } else {\n      sm = StateMachine.to(sm, `idle`);\n    }\n  }\n\n  const events = initLazyStream<V>({\n    ...options,\n    lazy,\n    onStart() {\n      log(`onStart state: ${ sm.value } whenStopped: ${ whenStopped }`);\n      if (sm.value !== `idle`) return;\n      if ((sm.value === `idle` && whenStopped === `reset`) || iterator === undefined) {\n        iterator = isAsyncIterable(source) ? source[ Symbol.asyncIterator ]() : source[ Symbol.iterator ]();\n      }\n      //reading = true;\n      void read();\n    },\n    onStop() {\n      log(`onStop state: ${ sm.value } whenStopped: ${ whenStopped }`);\n      //reading = false;\n      sm = StateMachine.to(sm, `stopping`);\n      if (whenStopped === `reset`) {\n        log(`onStop reiniting iterator`);\n        iterator = isAsyncIterable(source) ? source[ Symbol.asyncIterator ]() : source[ Symbol.iterator ]();\n      }\n    },\n    onDispose(reason: string) {\n      log(`onDispose (${ reason })`);\n      ourAc?.abort(`Rx.From.iterator disposed (${ reason })`);\n      if (options.signal) options.signal.removeEventListener(`abort`, onExternalSignal);\n    },\n  });\n\n  // const readingStart = () => {\n\n  // }\n  //if (!lazy) readingStart();\n\n  // return {\n  //   on: events.on,\n  //   value: events.value,\n  //   dispose: events.dispose,\n  //   isDisposed: events.isDisposed\n  // }\n  return events;\n}\n","import { isIterable } from \"@ixfx/iterables\";\nimport type { Passed, PassedSignal, PassedValue, Reactive, ReactiveDiff, ReactiveInitial, ReactiveOrSource, ReactivePingable, ReactiveWritable, Wrapped } from \"./types.js\";\nimport type { Trigger, TriggerValue, TriggerFunction, TriggerGenerator } from \"./from/types.js\";\n\nexport function messageIsSignal<V>(message: Passed<V> | PassedSignal): message is PassedSignal {\n  if (message.value !== undefined) return false;\n  if (`signal` in message && message.signal !== undefined) return true;\n  return false;\n}\n\nexport function messageIsDoneSignal<V>(message: Passed<V> | PassedSignal): boolean {\n  if (message.value !== undefined) return false;\n  if (`signal` in message && message.signal === `done`) return true;\n  return false;\n}\n\n/**\n * Returns _true_ if `v` has a non-undefined value. Note that sometimes\n * _undefined_ is a legal value to pass\n * @param v \n * @returns \n */\nexport function messageHasValue<V>(v: Passed<V> | PassedSignal): v is PassedValue<V> {\n  if (v.value !== undefined) return true;\n  return false;\n}\n\nexport const isPingable = <V>(rx: Reactive<V> | ReactiveDiff<V> | object): rx is ReactivePingable<V> => {\n  if (!isReactive(rx)) return false;\n  if (`ping` in rx) {\n    return true;\n  }\n  return false;\n}\n\nexport const hasLast = <V>(rx: Reactive<V> | ReactiveDiff<V> | object): rx is ReactiveInitial<V> => {\n  if (!isReactive(rx)) return false;\n  if (`last` in rx) {\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-call\n    const v = (rx as any).last();\n    if (v !== undefined) return true;\n  }\n  return false;\n}\n\n/**\n * Returns _true_ if `rx` is a Reactive\n * @param rx \n * @returns \n */\nexport const isReactive = <V>(rx: object): rx is Reactive<V> => {\n  if (typeof rx !== `object`) return false;\n  if (rx === null) return false;\n  return (`on` in rx && `onValue` in rx)\n}\n\n/**\n * Returns true if `rx` is a disposable reactive.\n * @param rx \n * @returns \n */\n// export const isDisposable = <V>(rx: Reactive<V> | ReactiveWritable<V>): rx is ReactiveDisposable<V> => {\n//   if (!isReactive(rx)) return false;\n//   return (`isDisposed` in rx && `dispose` in rx);\n// }\n\n/**\n * Returns _true_ if `rx` is a writable Reactive\n * @param rx \n * @returns \n */\nexport const isWritable = <V>(rx: Reactive<V> | ReactiveWritable<V>): rx is ReactiveWritable<V> => {\n  if (!isReactive(rx)) return false;\n  if (`set` in rx) return true;\n  return false;\n}\n\nexport const isWrapped = <T>(v: any): v is Wrapped<T> => {\n  if (typeof v !== `object`) return false;\n  if (!(`source` in v)) return false;\n  if (!(`annotate` in v)) return false;\n  return true;\n}\n\n// export const opify = <TIn, TOut = TIn,>(fn: (source: ReactiveOrSource<TIn>, ...args: Array<any>) => Reactive<TOut>, ...args: Array<any>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     return fn(source, ...args);\n//   }\n// }\n\nexport const opify = <TIn, TRxOut = Reactive<TIn>>(fn: (source: ReactiveOrSource<TIn>, ...args: any[]) => TRxOut, ...args: any[]) => {\n  return (source: ReactiveOrSource<TIn>) => {\n    return fn(source, ...args);\n  }\n}\n\n\nexport const isTriggerValue = <V>(t: Trigger<V>): t is TriggerValue<V> => (`value` in t);\nexport const isTriggerFunction = <V>(t: Trigger<V>): t is TriggerFunction<V> => (`fn` in t);\nexport const isTriggerGenerator = <V>(t: Trigger<V>): t is TriggerGenerator<V> => isIterable(t);\nexport const isTrigger = <V>(t: any): t is Trigger<V> => {\n  if (typeof t !== `object`) return false;\n  if (isTriggerValue(t)) return true;\n  if (isTriggerFunction(t)) return true;\n  if (isTriggerGenerator(t)) return true;\n  return false;\n}\n\nexport type ResolveTriggerValue<V> = [ value: V, false ];\nexport type ResolveTriggerDone = [ undefined, true ];\n\n/**\n * Resolves a trigger value.\n * \n * A trigger can be a value, a function or generator. Value triggers never complete.\n * A trigger function is considered complete if it returns undefined.\n * A trigger generator is considered complete if it returns done.\n * \n * Returns `[value, _false_]` if we have a value and trigger is not completed.\n * Returns `[value, _true_]` trigger is completed\n * @param t \n * @returns \n */\nexport function resolveTriggerValue<V>(t: Trigger<V>): ResolveTriggerDone | ResolveTriggerValue<V> {\n  if (isTriggerValue(t)) return [ t.value, false ];\n  if (isTriggerFunction(t)) {\n    const v = t.fn();\n    if (v === undefined) return [ undefined, true ];\n    return [ v, false ];\n  }\n  if (isTriggerGenerator(t)) {\n    const v = t.gen.next();\n    if (v.done) return [ undefined, true ];\n    return [ v.value, false ];\n  }\n  throw new Error(`Invalid trigger. Missing 'value' or 'fn' fields`);\n}","import { isAsyncIterable, isIterable } from \"@ixfx/iterables\";\nimport { func } from \"./from/function.js\";\nimport { iterator } from \"./from/iterator.js\";\nimport type { GeneratorOptions, FunctionOptions } from \"./from/types.js\";\nimport type { Reactive, ReactiveOrSource } from \"./types.js\";\nimport { isReactive, isWrapped } from \"./util.js\";\n\nexport type ResolveSourceOptions = {\n  /**\n   * Options when creating a reactive from a generator\n   * Default:  `{ lazy: true, interval: 5 }`\n   */\n  generator: GeneratorOptions\n  /**\n   * Options when creating a reactive from a function.\n   */\n  function: FunctionOptions\n}\n\n/**\n * Resolves various kinds of sources into a Reactive.\n * If `source` is an iterable/generator, it gets wrapped via `generator()`.\n * \n * Default options:\n * * generator: `{ lazy: true, interval: 5 }`\n * @param source \n * @returns \n */\nexport const resolveSource = <V>(source: ReactiveOrSource<V>, options: Partial<ResolveSourceOptions> = {}): Reactive<V> => {\n  if (isReactive(source)) return source;\n  const generatorOptions = options.generator ?? { lazy: `initial`, interval: 5 }\n  const functionOptions = options.function ?? { lazy: `very` }\n\n  if (Array.isArray(source)) {\n    return iterator(source.values(), generatorOptions);\n  } else if (typeof source === `function`) {\n    return func<V>(source, functionOptions)\n  } else if (typeof source === `object`) {\n    //console.log(`resolveSource is object`);\n    if (isWrapped<V>(source)) {\n      //console.log(`resolveSource is object - wrapped`);\n      return source.source;\n    }\n    if (isIterable(source) || isAsyncIterable(source)) {\n      //console.log(`resolveSource is object - iterable`);\n      return iterator(source, generatorOptions);\n    }\n  }\n  throw new TypeError(`Unable to resolve source. Supports: array, Reactive, Async/Iterable. Got type: ${ typeof source }`);\n}","import { type Dispatch, DispatchList } from \"@ixfx/flow\";\nimport { resolveSource } from \"./resolve-source.js\";\nimport type { InitLazyStreamInitedOptions, InitLazyStreamOptions, InitStreamOptions, Passed, ReactiveInitialStream, ReactiveOrSource, ReactiveStream, SignalKinds, UpstreamOptions } from \"./types.js\";\nimport { messageHasValue, messageIsSignal } from \"./util.js\";\nimport { cache } from \"./cache.js\";\n\n\n/**\n * Initialise a stream based on an upstream source.\n * Calls initLazyStream under the hood.\n * \n * Options:\n * * onValue: called when upstream emits a value (default: does nothing with upstream value)\n * * lazy: laziness of stream (default: 'initial')\n * * disposeIfSourceDone: disposes stream if upstream disposes (default: true)\n * @ignore\n * @param upstreamSource \n * @param options \n * @returns \n */\nexport function initUpstream<In, Out>(upstreamSource: ReactiveOrSource<In>, options: Partial<UpstreamOptions<In>>): ReactiveStream<Out> {\n  const lazy = options.lazy ?? `initial`;\n  const disposeIfSourceDone = options.disposeIfSourceDone ?? true;\n  const onValue = options.onValue ?? ((_v: In) => {/** no-op */ })\n  const source = resolveSource(upstreamSource);\n  let unsub: undefined | (() => void);\n  const debugLabel = options.debugLabel ? `[${ options.debugLabel }]` : ``;\n  //console.log(`initUpstream${ debugLabel } creating`);\n\n  const onStop = () => {\n    //console.log(`Rx.initStream${ debugLabel } stop`);\n    if (unsub === undefined) return;\n    unsub();\n    unsub = undefined;\n    if (options.onStop) options.onStop();\n  }\n\n  const onStart = () => {\n    //console.log(`Rx.initStream${ debugLabel } start unsub ${ unsub !== undefined }`);\n    if (unsub !== undefined) return;\n    if (options.onStart) options.onStart();\n\n    unsub = source.on(value => {\n      //console.log(`Rx.initStream${ debugLabel } onValue`, value);\n      if (messageIsSignal(value)) {\n        if (value.signal === `done`) {\n          onStop();\n          events.signal(value.signal, value.context);\n          if (disposeIfSourceDone) events.dispose(`Upstream source ${ debugLabel } has completed (${ value.context ?? `` })`);\n        } else {\n          //events.through_(value);\n          events.signal(value.signal, value.context);\n        }\n      } else if (messageHasValue(value)) {\n        //lastValue = value.value;\n        onValue(value.value);\n      }\n    });\n  }\n\n\n\n  //const initOpts = \n  // const events:ReactiveInitialStream<Out>|ReactiveStream<Out> = ((`initialValue` in options) && options.initialValue !== undefined) ?\n  //   initLazyStreamWithInitial<Out>({ ...initOpts, initialValue: options.initialValue }) :\n  //   initLazyStream<Out>(initOpts);\n  //console.log(`initUpstream${ debugLabel } creating initLazyStream`);\n\n  const events = initLazyStream<Out>({\n    ...options,\n    lazy,\n    onStart,\n    onStop\n  });\n  return events;\n}\n\n/**\n * Initialises a lazy stream with an initial value.\n * Uses {@link initLazyStream} and {@link cache} together.\n * @param options \n * @returns \n */\nexport function initLazyStreamWithInitial<V>(options: InitLazyStreamInitedOptions<V>): ReactiveInitialStream<V> {\n  const r = initLazyStream<V>(options);\n  const c = cache<V, typeof r>(r, options.initialValue);\n  return c;\n}\n\n/**\n * Initialises a lazy stream\n * Consider also: {@link initLazyStreamWithInitial}\n * \n * Uses {@link lazyStream} internally.\n * @param options \n * @returns \n */\nexport function initLazyStream<V>(options: InitLazyStreamOptions): ReactiveStream<V> {\n  const lazy = options.lazy ?? `initial`;\n  const onStop = options.onStop ?? (() => { /* no-op*/ })\n  const onStart = options.onStart ?? (() => {/* no-op*/ })\n  const debugLabel = options.debugLabel ? `[${ options.debugLabel }]` : ``;\n  const events = initStream<V>({\n    ...options,\n    onFirstSubscribe() {\n      if (lazy !== `never`) {\n        //console.log(`initLazyStream${ debugLabel } onFirstSubscribe, lazy: ${ lazy }. Calling onStart`);\n        onStart();\n      }\n    },\n    onNoSubscribers() {\n      if (lazy === `very`) {\n        //console.log(`initLazyStream${ debugLabel } onNoSubscribers, lazy: ${ lazy }. Calling onStop`);\n        onStop();\n      }\n    },\n  });\n  if (lazy === `never`) onStart();\n  return events;\n}\n\n/**\n * Initialises a new stream.\n * \n * Options:\n * * onFirstSubscribe: Called when there is a subscriber after there have been no subscribers.\n * * onNoSubscribers: Called when there are no more subscribers. 'onFirstSubscriber' will be called next time a subscriber is added.\n * \n * Alternatives:\n * * {@link initLazyStream} - a stream with callbacks for when there is some/none subscribers\n * @ignore\n * @param options \n * @returns \n */\nexport function initStream<V>(options: Partial<InitStreamOptions> = {}): ReactiveStream<V> {\n  let dispatcher: DispatchList<Passed<V>> | undefined;\n  let disposed = false;\n  let firstSubscribe = false;\n  let emptySubscriptions = true;\n  const onFirstSubscribe = options.onFirstSubscribe ?? undefined;\n  const onNoSubscribers = options.onNoSubscribers ?? undefined;\n  const debugLabel = options.debugLabel ? `[${ options.debugLabel }]` : ``;\n\n  const isEmpty = () => {\n    if (dispatcher === undefined) return;\n    if (!dispatcher.isEmpty) return;\n    if (!emptySubscriptions) {\n      emptySubscriptions = true;\n      firstSubscribe = false;\n      if (onNoSubscribers) onNoSubscribers();\n    }\n  }\n\n  const subscribe = (handler: Dispatch<Passed<V>>) => {\n    if (disposed) throw new Error(`Disposed, cannot subscribe ${ debugLabel }`);\n    if (dispatcher === undefined) dispatcher = new DispatchList();\n    //console.log(`initStream${ debugLabel } subscribe handler:`, handler);\n    const id = dispatcher.add(handler);\n    emptySubscriptions = false;\n    if (!firstSubscribe) {\n      firstSubscribe = true;\n      //if (onFirstSubscribe) setTimeout(() => { onFirstSubscribe() }, 10);\n      if (onFirstSubscribe) onFirstSubscribe();\n    }\n    return () => {\n      dispatcher?.remove(id);\n      isEmpty();\n    }\n  }\n\n  return {\n    dispose: (reason: string) => {\n      if (disposed) return;\n      dispatcher?.notify({ value: undefined, signal: `done`, context: `Disposed: ${ reason }` });\n      disposed = true;\n      if (options.onDispose) options.onDispose(reason);\n    },\n    isDisposed: () => {\n      return disposed\n    },\n    removeAllSubscribers: () => {\n      dispatcher?.clear();\n      isEmpty();\n    },\n    set: (v: V) => {\n      if (disposed) throw new Error(`${ debugLabel } Disposed, cannot set`);\n      dispatcher?.notify({ value: v });\n    },\n    // through: (pass: Passed<V>) => {\n    //   if (disposed) throw new Error(`Disposed, cannot through`);\n    //   dispatcher?.notify(pass)\n    // },\n    signal: (signal: SignalKinds, context?: string) => {\n      if (disposed) throw new Error(`${ debugLabel } Disposed, cannot signal`);\n      dispatcher?.notify({ signal, value: undefined, context });\n    },\n    on: (handler: Dispatch<Passed<V>>) => subscribe(handler),\n    onValue: (handler: (value: V) => void) => {\n      const unsub = subscribe(message => {\n        //console.log(`initStream${ debugLabel } onValue wrapper`, message);\n        if (messageHasValue(message)) {\n          handler(message.value);\n        }\n      });\n      return unsub;\n    }\n  }\n}\n","\nimport { DispatchList } from \"@ixfx/flow\";\nimport * as Pathed from \"@ixfx/core/records\";\nimport { initStream } from \"../init-stream.js\";\nimport type { ObjectFieldHandler, ReactiveDiff, ReactiveInitial, ReactiveNonInitial } from \"../types.js\";\nimport type { ObjectOptions } from \"./types.js\";\nimport { isEqualContextString } from \"@ixfx/core\";\nimport { wildcard } from \"@ixfx/core/text\";\nimport { resultIsError, resultThrow, resultThrowSingle, resultToError } from \"@ixfx/guards\";\n\nexport function object<V extends Record<string, any>>(initialValue: V, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveInitial<V>;\nexport function object<V extends Record<string, any>>(initialValue: undefined, options?: Partial<ObjectOptions<V>>): ReactiveDiff<V> & ReactiveNonInitial<V>;\n\n\n/**\n * Creates a Reactive wrapper with the shape of the input object.\n * \n * Changing the wrapped object directly does not update the Reactive. \n * Instead, to update values use:\n * * `set()`, 'resets' the whole object\n * * `update()` changes a particular field\n * \n * Consider using {@link Rx.From.objectProxy} to return a object with properties that can be\n * set in the usual way yet is also Reactive.\n * \n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onValue(changed => {\n * });\n * o.set({ name: `mary`, level: 3 });\n * \n * // `onValue` will get called, with `changed` having a value of:\n * // { name: `mary`, level: 3 }\n * ```\n * \n * Use `last()` to get the most recently set value.\n * \n * `onDiff` subscribes to a rough diff of the object.\n * \n * ```js\n * const o = Rx.From.object({ name: `bob`, level: 2 });\n * o.onDiff(diffValue => {\n *  const diff = diffValue.value;\n * })\n * o.set({ name: `mary`, level: 3 });\n * \n * // onDiff would fire with `diff` of:\n * [\n *  { path: `name`, previous: `bob`, value: `mary` },\n *  { path: `level`, previous: 2, value: 3 }\n * ]\n * ```\n * \n * You can also listen to updates on a field via `onField`.\n * ```js\n * o.onField(`name`, value => {\n *  // Called whenever the 'name' field is updated\n * });\n * ```\n * @param initialValue  Initial value\n * @param options Options\n * @returns \n */\nexport function object<V extends Record<string, any>>(initialValue?: V, options: Partial<ObjectOptions<V>> = {}): ReactiveDiff<V> & (ReactiveInitial<V> | ReactiveNonInitial<V>) {\n  const eq = options.eq ?? isEqualContextString;\n  const setEvent = initStream<V>();\n  const diffEvent = initStream<Pathed.PathDataChange<any>[]>();\n\n  //const fieldChangeEvents = new Map<string, DispatchList<ObjectFieldHandler>>;\n  const fieldChangeEvents: [ matcher: (value: string) => boolean, pattern: string, DispatchList<ObjectFieldHandler> ][] = [];\n\n  let value: V | undefined = initialValue;\n  let disposed = false;\n\n  const set = (v: V) => {\n    const diff = [ ...Pathed.compareData(value ?? {} as V, v, { ...options, includeMissingFromA: true }) ];\n    if (diff.length === 0) return;\n    value = v;\n    setEvent.set(v);\n    diffEvent.set(diff);\n  }\n\n  const fireFieldUpdate = (field: string, value: any) => {\n    for (const [ matcher, pattern, list ] of fieldChangeEvents) {\n      if (matcher(field)) {\n        list.notify({ fieldName: field, pattern, value });\n      }\n    }\n    //const l = fieldChangeEvents.get(field.toLowerCase());\n    //if (l === undefined) return;\n    //l.notify(value);\n  }\n\n  const updateCompareOptions: Partial<Pathed.CompareDataOptions<V>> = {\n    asPartial: true,\n    includeParents: true\n  }\n\n  const update = (toMerge: Partial<V>) => {\n    //console.log(`Rx.From.object update: toMerge: ${ JSON.stringify(toMerge) } value: ${ JSON.stringify(value) }`);\n\n    if (value === undefined) {\n      value = toMerge as V;\n      setEvent.set(value);\n      for (const [ k, v ] of Object.entries(toMerge as V)) {\n        fireFieldUpdate(k, v);\n      }\n      return value;\n    } else {\n      const diff = [ ...Pathed.compareData(value, toMerge, updateCompareOptions) ];\n      //const diffWithoutRemoved = diff.filter(d => d.state !== `removed`);\n      if (diff.length === 0) return value; // No changes\n      value = {\n        ...value,\n        ...toMerge\n      }\n      setEvent.set(value);\n      diffEvent.set(diff);\n      //console.log(`diff`, diff);\n      for (const d of diff) {\n        fireFieldUpdate(d.path, d.value);\n      }\n      return value;\n    }\n  }\n\n  const updateField = (path: string, valueForField: any) => {\n    if (value === undefined) throw new Error(`Cannot update value when it has not already been set`);\n    //console.log(`Rx.Sources.Object.updateField path: ${ path } value: ${ JSON.stringify(valueForField) }`);\n\n    const existing = Pathed.getField<any>(value, path);\n    //resultThrowSingle(existing);\n    if (resultIsError(existing)) {\n      throw resultToError(existing);\n    }\n\n    //console.log(`Rx.fromObject.updateField path: ${ path } existing: ${ JSON.stringify(existing) }`);\n    if (eq(existing.value, valueForField, path)) {\n      //console.log(`Rx.object.updateField identical existing: ${ existing } value: ${ valueForField } path: ${ path }`);\n      return;\n    }\n    let diff = [ ...Pathed.compareData(existing.value, valueForField, { ...options, includeMissingFromA: true }) ];\n    diff = diff.map(d => {\n      if (d.path.length > 0) return { ...d, path: path + `.` + d.path };\n      return { ...d, path };\n    })\n\n    //console.log(`Rx.fromObject.updateField diff path: ${ path }`, diff);\n    const o = Pathed.updateByPath(value, path, valueForField, true);\n    value = o;\n    //diffEvent.set([ { path, value: valueForField, previous: existing } ]);\n\n    setEvent.set(o);\n    diffEvent.set(diff);\n    fireFieldUpdate(path, valueForField);\n    //console.log(`Rx.fromObject.updateField: path: '${ path }' value: '${ JSON.stringify(valueForField) }' o: ${ JSON.stringify(o) }`);\n  }\n\n  const dispose = (reason: string) => {\n    if (disposed) return;\n    diffEvent.dispose(reason);\n    setEvent.dispose(reason);\n    disposed = true;\n  }\n\n  return {\n    dispose,\n    isDisposed() {\n      return disposed\n    },\n    /**\n     * Update a field.\n     * Exception is thrown if field does not exist\n     */\n    updateField,\n    last: () => value,\n    on: setEvent.on,\n    onValue: setEvent.onValue,\n    onDiff: diffEvent.onValue,\n    onField(fieldPattern: string, handler: (result: ObjectFieldHandler) => void) {\n      const matcher = wildcard(fieldPattern);\n      const listeners = new DispatchList<ObjectFieldHandler>();\n      fieldChangeEvents.push([ matcher, fieldPattern, listeners ]);\n      const id = listeners.add(handler);\n      return () => listeners.remove(id);\n      // let listeners = fieldChangeEvents.get(fieldName.toLowerCase());\n      // if (listeners === undefined) {\n      //   listeners = new DispatchList();\n      //   fieldChangeEvents.set(fieldName.toLowerCase(), listeners);\n      // }\n      // const id = listeners.add((value) => {\n      //   setTimeout(() => { handler(value, fieldName) }, 1);\n      // });\n      // return () => listeners.remove(id);\n    },\n    /**\n     * Set the whole object\n     */\n    set,\n    /**\n     * Update the object with a partial set of fields and values\n     */\n    update\n  }\n}\n","/* eslint-disable @typescript-eslint/unbound-method */\nimport type { Reactive, ReactiveStream } from \"./types.js\";\n\n/***\n * Returns a read-only version of `stream`\n */\nexport const toReadable = <V>(stream: ReactiveStream<V>): Reactive<V> => ({\n  on: stream.on,\n  dispose: stream.dispose,\n  isDisposed: stream.isDisposed,\n  onValue: stream.onValue\n});\n","import type { Passed, Reactive, ReactiveInitial } from \"../types.js\";\nimport { field } from \"../ops/field.js\";\nimport { object } from \"./object.js\";\nimport type { FieldOptions } from \"../ops/types.js\";\nimport type { EventSourceOptions, EventSourceTriggerOptions } from \"./types.js\";\nimport { initLazyStream } from \"../init-stream.js\";\nimport { elapsedInterval } from \"@ixfx/core/elapsed\";\n/**\n * Fired when `eventName` fires on `target`. \n * \n * Rather than whole event args being emitted on the stream,\n * it plucks a field from the event args, or if that's missing, from the target.\n * \n * ```js\n * // Emits the the value of a field named 'x'\n * // on the change event args\n * eventField(el, `pointermove`, `x`);\n * ```\n * @param targetOrQuery Event target, HTML element or HTML query (eg '#someId') \n * @param eventName Name of event, eg. 'pointermove'\n * @param fieldName Name of field, eg 'x'\n * @param initialValue Initial data\n * @param options Options for source\n */\nexport function eventField<TFieldValue = string>(targetOrQuery: EventTarget | string | null, eventName: string, fieldName: string, initialValue: TFieldValue, options: Partial<EventSourceOptions & FieldOptions<any, TFieldValue>> = {}) {\n\n  const initial: Record<string, any> = {};\n  initial[ fieldName ] = initialValue;\n\n  const rxField = field<any, TFieldValue>(\n    event(targetOrQuery, eventName, initial, options),\n    fieldName,\n    options\n  );\n  return rxField;\n}\n\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options: EventOptions<V>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n//export function event<V extends Record<string, any>>(target: EventTarget | null | string, name: string, options?: Optional<EventOptions<V>, `transform`>): ReactiveNonInitial<V> & ReactiveDisposable<V>;\n\n/**\n * Subscribes to an event, emitting data\n * \n * @example Print x,y position of mouse as it moves\n * ```js\n * const r = Rx.From.event(document, `pointermove`);\n * r.onValue(event => {\n *  const { x, y } = event;\n * });\n * ```\n * \n * If `options.lazy` is _true_ (default: _false_), event will only be subscribed to when the stream\n * itself has a subscriber.\n * \n * `options.debugFiring` and `options.debugLifecycle` can be turned on to troubleshoot behaviour\n * of the stream if necessary.\n * @param targetOrQuery Event emitter, HTML element or string. If a string, it will be queryed as a selector.\n * @param name Event name\n * @param options Options\n * @returns \n */\n\nexport function event<TEventArgs extends Record<string, any>>(targetOrQuery: EventTarget | null | string, name: string, initialValue: TEventArgs | undefined, options: Partial<EventSourceOptions> = {}): ReactiveInitial<TEventArgs> & Reactive<TEventArgs> {\n  let target: EventTarget | null;\n  if (typeof targetOrQuery === `string`) {\n    target = document.querySelector(targetOrQuery);\n    if (target === null) throw new Error(`Target query did not resolve to an element. Query: '${ targetOrQuery }'`)\n  } else {\n    target = targetOrQuery;\n  }\n\n  if (target === null) throw new Error(`Param 'targetOrQuery' is null`);\n\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const debugFiring = options.debugFiring ?? false;\n  const lazy = options.lazy ?? false;\n  // eslint-disable-next-line @typescript-eslint/prefer-nullish-coalescing\n  if (initialValue === undefined) initialValue = {} as TEventArgs;\n  const rxObject = object<TEventArgs>(initialValue, { deepEntries: true });\n  let eventAdded = false;\n  let disposed = false;\n\n  const callback = (args: any) => {\n    if (debugFiring) console.log(`Reactive.event '${ name }' firing '${ JSON.stringify(args) }`)\n    rxObject.set(args as TEventArgs);\n  }\n\n  const remove = () => {\n    if (!eventAdded) return;\n    eventAdded = false;\n    target.removeEventListener(name, callback);\n    if (debugLifecycle) {\n      console.log(`Rx.From.event remove '${ name }'`);\n    }\n  }\n\n  const add = () => {\n    if (eventAdded) return;\n    eventAdded = true;\n    target.addEventListener(name, callback);\n    if (debugLifecycle) {\n      console.log(`Rx.From.event add '${ name }'`);\n    }\n  }\n\n  if (!lazy) add();\n\n  return {\n    last: () => {\n      if (lazy) add();\n      return rxObject.last();\n    },\n    dispose: (reason: string) => {\n      if (disposed) return;\n      disposed = true;\n      remove();\n      rxObject.dispose(reason);\n    },\n    isDisposed() {\n      return disposed;\n    },\n    on: (handler: (v: Passed<TEventArgs>) => void) => {\n      if (lazy) add();\n      return rxObject.on(handler);\n    },\n    onValue: (handler: (v: TEventArgs) => void) => {\n      if (lazy) add();\n      return rxObject.onValue(handler);\n    }\n  }\n}\n\nexport type TriggerData = {\n  sinceLast: number\n  total: number\n}\n\n/**\n * Emits a value whenever event happens.\n * Data emitted is `{ sinceLast, total }`, where 'sinceLast'\n * is milliseconds since last event and 'total' is total number of \n * times event has been fired.\n * @param targetOrQuery \n * @param name \n * @param options \n * @returns \n */\nexport function eventTrigger(targetOrQuery: EventTarget | null | string, name: string, options: Partial<EventSourceTriggerOptions> = {}): Reactive<TriggerData> {\n  let target: EventTarget | null;\n  if (typeof targetOrQuery === `string`) {\n    target = document.querySelector(targetOrQuery);\n    if (target === null) throw new Error(`Target query did not resolve to an element. Query: '${ targetOrQuery }'`)\n  } else {\n    target = targetOrQuery;\n  }\n\n  if (target === null) throw new Error(`Param 'targetOrQuery' is null`);\n\n  const debugLifecycle = options.debugLifecycle ?? false;\n  const debugFiring = options.debugFiring ?? false;\n  const fireInitial = options.fireInitial ?? false;\n\n  let count = 0;\n  const elapsed = elapsedInterval();\n\n  const stream = initLazyStream<TriggerData>({\n    lazy: options.lazy ?? `very`,\n    onStart() {\n      target.addEventListener(name, callback);\n      if (debugLifecycle) {\n        console.log(`Rx.From.eventTrigger add '${ name }'`);\n      }\n      if (fireInitial && count === 0) {\n        if (debugLifecycle || debugFiring) console.log(`Rx.From.eventTrigger: firing initial`);\n        callback();\n      }\n    },\n    onStop() {\n      target.removeEventListener(name, callback);\n      if (debugLifecycle) {\n        console.log(`Rx.From.eventTrigger remove '${ name }'`);\n      }\n    },\n  });\n\n  const callback = (_args?: any) => {\n    if (debugFiring) console.log(`Rx.From.eventTrigger '${ name }' triggered'`)\n    stream.set({\n      sinceLast: elapsed(),\n      total: ++count\n    });\n  }\n\n  return stream;\n}","import { initUpstream } from \"../init-stream.js\";\nimport type { Reactive, ReactiveOrSource } from \"../types.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport type { TransformOpts } from \"./types.js\";\n\n/**\n * Transforms values from `source` using the `transformer` function.\n * @param transformer \n * @returns \n */\nexport function transform<In, Out>(input: ReactiveOrSource<In>, transformer: (value: In) => Out, options: Partial<TransformOpts> = {}): Reactive<Out> {\n  const traceInput = options.traceInput ?? false;\n  const traceOutput = options.traceOutput ?? false;\n\n  const upstream = initUpstream<In, Out>(input, {\n    lazy: `initial`,\n    ...options,\n    onValue(value) {\n      const t = transformer(value);\n      if (traceInput && traceOutput) {\n        console.log(`Rx.Ops.transform input: ${ JSON.stringify(value) } output: ${ JSON.stringify(t) }`);\n      } else if (traceInput) {\n        console.log(`Rx.Ops.transform input: ${ JSON.stringify(value) }`);\n      } else if (traceOutput) {\n        console.log(`Rx.Ops.transform output: ${ JSON.stringify(t) }`);\n      }\n\n      upstream.set(t);\n    },\n  })\n  return toReadable(upstream);\n}\n\n","import { type Reactive, intervalToMs } from \"@ixfx/core\";\nimport { timeout } from \"@ixfx/flow\";\nimport { initUpstream } from \"../init-stream.js\";\nimport type { DebounceOptions } from \"../ops/types.js\";\nimport { toReadable } from \"../to-readable.js\";\nimport type { ReactiveOrSource } from \"../types.js\";\n\n/**\n * Debounce waits for `elapsed` time after the last received value before emitting it.\n * \n * If a flurry of values are received that are within the interval, it won't emit anything. But then\n * as soon as there is a gap in the messages that meets the interval, the last received value is sent out.\n * \n * `debounce` always emits with at least `elapsed` as a delay after a value received. While {@link throttle} potentially\n * sends immediately, if it's outside of the elapsed period.\n * \n * This is a subtly different logic to {@link throttle}. `throttle` more eagerly sends the first value, potentially\n * not sending later values. `debouce` however will send later values, potentially ignoring earlier ones.\n * @param source \n * @param options \n * @returns \n */\nexport function debounce<V>(source: ReactiveOrSource<V>, options: Partial<DebounceOptions> = {}): Reactive<V> {\n  const elapsed = intervalToMs(options.elapsed, 50);\n  let lastValue: V | undefined;\n\n  const timer = timeout(() => {\n    const v = lastValue;\n    if (v) {\n      upstream.set(v);\n      lastValue = undefined;\n    }\n  }, elapsed);\n\n  const upstream = initUpstream<V, V>(source, {\n    ...options,\n    onValue(value) {\n      lastValue = value;\n      timer.start();\n    }\n  });\n  return toReadable(upstream);\n}\n","import type { ReactiveOp, ReactiveOrSource } from \"../types.js\";\nimport type { DebounceOptions } from \"./types.js\";\nimport { debounce as  debounceReactive  } from \"../reactives/debounce.js\";\n\nexport function debounce<V>(options: Partial<DebounceOptions>): ReactiveOp<V, V>  {\n  return (source: ReactiveOrSource<V>) => {\n    return debounceReactive<V>(source, options);\n  }\n}\n","\n\nimport type { Reactive, ReactiveOrSource, ReactiveWritable, ReactiveOp, InitStreamOptions, WithValueOptions, CombineLatestOptions, RxValueTypes, RxValueTypeObject, PipeSet, ReactivePingable } from \"./types.js\";\nimport type { ChunkOptions, DebounceOptions, FieldOptions, SingleFromArrayOptions, SplitOptions, FilterPredicate, SwitcherOptions, SyncOptions, ThrottleOptions } from \"./ops/types.js\";\nimport type { RankFunction, RankOptions } from \"@ixfx/core\";\nimport type { TimeoutPingOptions, TimeoutValueOptions } from \"./from/types.js\";\nimport { type Interval, intervalToMs } from '@ixfx/core';\nimport { isWritable, messageHasValue, messageIsDoneSignal, opify } from \"./util.js\";\nimport { initStream } from \"./init-stream.js\";\nimport { resolveSource } from './resolve-source.js';\nimport * as SinkFns from './sinks/index.js';\nimport * as OpFns from './ops/index.js';\n\nexport * from './ops/index.js';\nexport * from './sinks/index.js';\nexport * from './graph.js';\nexport * from './types.js';\nexport * from './to-array.js';\nexport * from './to-generator.js';\nexport * from './util.js';\nexport * from './wrap.js';\nexport * from './resolve-source.js';\nexport * from './cache.js';\nexport * as From from './from/index.js';\nexport * from './init-stream.js';\n\nexport function run<TIn, TOut>(source: ReactiveOrSource<any>, ...ops: ReactiveOp<any, any>[]) {\n  let s = resolveSource(source);\n  for (const op of ops) {\n    // @ts-ignore\n    s = op(s);\n  }\n  return s;\n}\n\nexport function writable<TIn, TOut>(source: ReactiveOrSource<TIn>, ...ops: ReactiveOp<any, any>[]): ReactiveWritable<TIn, TOut> {\n  let s = resolveSource(source);\n  const head = s;\n  for (const op of ops) {\n    // @ts-ignore\n    s = op(s);\n  }\n  const ss = s as any as Reactive<TOut>;\n  return {\n    ...ss,\n    set(value: TIn) {\n      if (isWritable(head)) {\n        head.set(value);\n      } else throw new Error(`Original source is not writable`);\n    }\n  } as ReactiveWritable<TIn, TOut>\n  //return s as Reactive<T2 | T3 | T4 | T5 | T6>;\n  //const raw = chainer<T1, T2, T3, T4, T5, T6>(...ops);\n  //return raw(source);\n}\n\n/**\n * Initialises a reactive that pipes values to listeners directly.\n * @returns \n */\nexport function manual<V>(options: Partial<InitStreamOptions> = {}): Reactive<V> & ReactiveWritable<V> {\n  const events = initStream<V>(options);\n  return {\n    dispose: events.dispose,\n    isDisposed: events.isDisposed,\n    set(value: V) {\n      events.set(value);\n    },\n    on: events.on,\n    onValue: events.onValue\n  };\n}\n\nexport const Sinks = {\n  setHtmlText: (options: SinkFns.SetHtmlOptions) => {\n    return (source: ReactiveOrSource<string>) => {\n      SinkFns.setHtmlText(source, options);\n    }\n  }\n}\n\nexport const Ops = {\n  /**\n * Annotates values with the result of a function.\n * The input value needs to be an object.\n * \n * For every value `input` emits, run it through `annotator`, which should\n * return the original value with additional fields.\n * \n * Conceptually the same as `transform`, just with typing to enforce result\n * values are V & TAnnotation\n * @param annotator \n * @returns \n */\n  annotate: <V, TAnnotation>(annotator: (input: V) => V & TAnnotation) => opify(OpFns.annotate, annotator),\n  /**\n   * Annotates the input stream using {@link ReactiveOp} as the source of annotations.\n   * The output values will have the shape of `{ value: TIn, annotation: TAnnotation }`.\n   * Meaning that the original value is stored under `.value`, and the annotation under `.annotation`.\n   * \n   * ```js\n   * // Emit values from an array\n   * const r1 = Rx.run(\n   *  Rx.From.array([ 1, 2, 3 ]),\n   *  Rx.Ops.annotateWithOp(\n   *    // Add the 'max' operator to emit the largest-seen value\n   *    Rx.Ops.sum()\n   *  )\n   * );\n   * const data = await Rx.toArray(r1);\n   * // Data =  [ { value: 1, annotation: 1 }, { value: 2, annotation: 3 }, { value: 3, annotation: 6 } ]\n   * ```\n   * @param annotatorOp \n   * @returns \n   */\n  annotateWithOp: <TIn, TAnnotation>(annotatorOp: ReactiveOp<TIn, TAnnotation>) => opify(OpFns.annotateWithOp, annotatorOp),\n  /**\n   * Takes a stream of values and chunks them up (by quantity or time elapsed),\n   * emitting them as an array.\n   * @param options \n   * @returns \n   */\n  chunk: <V>(options: Partial<ChunkOptions>): ReactiveOp<V, V[]> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.chunk(source, options);\n    }\n  },\n\n  cloneFromFields: <V>(): ReactiveOp<V, V> => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.cloneFromFields(source);\n    }\n  },\n  /**\n * Merges values from several sources into a single source that emits values as an array.\n * @param options \n * @returns \n */\n  combineLatestToArray: <const T extends readonly ReactiveOrSource<any>[]>(options: Partial<CombineLatestOptions> = {}) => {\n    return (sources: T) => {\n      return OpFns.combineLatestToArray(sources, options);\n    }\n  },\n  /**\n   * Merges values from several sources into a single source that emits values as an object.\n   * @param options\n   * @returns \n   */\n  combineLatestToObject: <const T extends Record<string, ReactiveOrSource<any>>>(options: Partial<CombineLatestOptions> = {}) => {\n    return (reactiveSources: T) => {\n      return OpFns.combineLatestToObject(reactiveSources, options);\n    }\n  },\n\n  /**\n * Debounce values from the stream. It will wait until a certain time\n * has elapsed before emitting latest value.\n * \n * Effect is that no values are emitted if input emits faster than the provided\n * timeout.\n * \n * See also: throttle\n * @param options \n * @returns \n */\n  // debounce: <V>(options: Partial<DebounceOptions>): ReactiveOp<V, V> => {\n  //   return (source: ReactiveOrSource<V>) => {\n  //     return OpFns.debounce(source, options);\n  //   }\n  // },\n  /**\n   * Drops values from the input stream that match `predicate`\n   * @param predicate If it returns _true_ value is ignored\n   * @returns \n   */\n  drop: <V>(predicate: (value: V) => boolean) => opify(OpFns.drop, predicate),\n  /**\n   * Every upstream value is considered the target for interpolation.\n   * Output value interpolates by a given amount toward the target.\n   * @returns \n   */\n  elapsed: <V>(): ReactiveOp<V, number> => opify(OpFns.elapsed),\n  /**\n   * Yields the value of a field from an input stream of values.\n   * Eg if the source reactive emits `{ colour: string, size: number }`,\n   * we might use `field` to pluck out the `colour` field, thus returning\n   * a stream of string values.\n   * @param fieldName \n   * @param options \n   * @returns \n   */\n  field: <TSource extends object, TFieldType>(fieldName: keyof TSource, options: FieldOptions<TSource, TFieldType>) => {\n    return (source: ReactiveOrSource<TSource>) => {\n      return OpFns.field(source, fieldName, options);\n    }\n  },\n  /**\n   * Filters the input stream, only re-emitting values that pass the predicate\n   * @param predicate If it returns _true_ value is allowed through\n   * @returns \n   */\n  filter: <V>(predicate: (value: V) => boolean) => opify(OpFns.filter, predicate),\n  /**\n   * Every upstream value is considered the target for interpolation.\n   * Output value interpolates by a given amount toward the target.\n   * @param options \n   * @returns \n   */\n  interpolate: <TIn = number>(options?: Partial<OpFns.OpInterpolateOptions>) => opify<TIn, ReactivePingable<number>>(OpFns.interpolate as any, options),\n  /**\n * Outputs the minimum numerical value of the stream.\n * A value is only emitted when minimum decreases.\n * @returns \n */\n  min: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.min, options),\n  /**\n   * Outputs the maxium numerical value of the stream.\n   * A value is only emitted when maximum increases.\n   * @returns \n   */\n  max: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.max, options),\n  sum: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.sum, options),\n  average: <TIn = number>(options?: OpFns.OpMathOptions) => opify<TIn, Reactive<number>>(OpFns.average, options),\n  tally: <TIn>(options?: OpFns.TallyOptions) => opify<TIn, Reactive<number>>(OpFns.tally, options),\n  rank: <TIn>(rank: RankFunction<TIn>, options?: RankOptions & OpFns.OpMathOptions) => opify<TIn>(OpFns.rank, rank, options),\n\n  pipe: <TInput, TOutput>(...streams: (Reactive<any> & ReactiveWritable<any>)[]) => {\n    return (source: ReactiveOrSource<TInput>) => {\n      const resolved = resolveSource(source);\n      const s = [ resolved, ...streams ] as PipeSet<TInput, TOutput>;\n      return OpFns.pipe(...s);\n    }\n  },\n\n  singleFromArray: <V>(options: Partial<SingleFromArrayOptions<V>> = {}) => {\n    return (source: ReactiveOrSource<V[]>) => {\n      return OpFns.singleFromArray(source, options)\n    }\n  },\n\n  split: <V>(options: Partial<SplitOptions> = {}) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.split(source, options);\n    }\n  },\n  splitLabelled: <V>(labels: string[]) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.splitLabelled(source, labels);\n    }\n  },\n  switcher: <TValue, TRec extends Record<string, FilterPredicate<TValue>>, TLabel extends keyof TRec>(cases: TRec, options: Partial<SwitcherOptions> = {}) => {\n    return (source: ReactiveOrSource<TValue>): Record<TLabel, Reactive<TValue>> => {\n      return OpFns.switcher(source, cases, options);\n    }\n  },\n  syncToArray: <const T extends readonly ReactiveOrSource<any>[]>(options: Partial<SyncOptions> = {}) => {\n    return (reactiveSources: T): Reactive<RxValueTypes<T>> => {\n      return OpFns.syncToArray(reactiveSources, options);\n    }\n  },\n  syncToObject: <const T extends Record<string, ReactiveOrSource<any>>>(options: Partial<SyncOptions> = {}) => {\n    return (reactiveSources: T): Reactive<RxValueTypeObject<T>> => {\n      return OpFns.syncToObject(reactiveSources, options);\n    }\n  },\n  tapProcess: <In>(processor: ((value: In) => any)): ReactiveOp<In, In> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapProcess(source, processor);\n    }\n  },\n  tapStream: <In>(divergedStream: ReactiveWritable<In>): ReactiveOp<In, In> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapStream(source, divergedStream);\n    }\n  },\n  tapOps: <In, Out>(...ops: ReactiveOp<In, Out>[]) => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.tapOps(source, ...ops);\n    }\n  },\n\n  /**\n * Throttle values from the stream.\n * Only emits a value if some minimum time has elapsed.\n * @param options \n * @returns \n */\n  throttle: <V>(options: Partial<ThrottleOptions>) => opify<V>(OpFns.throttle, options),\n  /**\n   * Trigger a value if 'source' does not emit a value within an interval.\n   * Trigger value can be a fixed value, result of function, or step through an iterator.\n   * @param options \n   * @returns \n   */\n  timeoutValue: <V, TTriggerValue>(options: TimeoutValueOptions<TTriggerValue>) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.timeoutValue<V, TTriggerValue>(source, options);\n    }\n  },\n\n  timeoutPing: <V>(options: TimeoutPingOptions) => {\n    return (source: ReactiveOrSource<V>) => {\n      return OpFns.timeoutPing(source, options);\n    }\n  },\n  transform: <In, Out>(transformer: ((value: In) => Out), options: Partial<OpFns.TransformOpts> = {}): ReactiveOp<In, Out> => {\n    return (source: ReactiveOrSource<In>) => {\n      return OpFns.transform(source, transformer, options);\n    }\n  },\n\n  /**\n  * Reactive where last (or a given initial) value is available to read\n  * @param opts \n  * @returns \n  */\n  withValue: <V>(opts: Partial<WithValueOptions<V>>): ReactiveOp<V, V> => {\n    return opify<V>(OpFns.withValue, opts);\n  },\n} as const;\n\n\n// export const chain = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>) => {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       // @ts-expect-error\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n\n// export const chainStream = <TIn, TOut>(...ops: Array<ReactiveOp<TIn, TOut>>): ReactiveStream<TIn, TOut> => {\n//   const stream = manual<TIn>();\n//   const c = chain(...ops);\n//   const x = c(stream);\n//   return x;\n// }\n\n\n\n// function chainx<TIn, TOut>(...ops: Array<ReactiveOp<any, any>>) {\n//   return (source: ReactiveOrSource<TIn>) => {\n//     for (const op of ops) {\n//       source = op(source);\n//     }\n//     return source as any as Reactive<TOut>;\n//   }\n// }\n\n\n\n// export function runWithInitial<TIn, TOut>(initial: TOut, source: ReactiveOrSource<TIn>, ...ops: Array<ReactiveOp<any, any>>): ReactiveInitial<TOut> & ReactiveDisposable<TOut> {\n//   let lastValue = initial;\n//   const raw = prepareOps<TIn, TOut>(...ops);\n//   const r = raw(source);\n//   let disposed = false;\n\n//   r.onValue(value => {\n//     lastValue = value;\n//   });\n\n//   return {\n//     ...r,\n//     isDisposed() {\n//       return disposed\n//     },\n//     dispose(reason) {\n//       if (disposed) return;\n//       if (isDisposable(r)) {\n//         r.dispose(reason);\n//       }\n//       disposed = true;\n//     },\n//     last() {\n//       return lastValue;\n//     },\n//   }\n// }\n\n/**\n * Grabs the next value emitted from `source`.\n * By default waits up to a maximum of one second.\n * Handles subscribing and unsubscribing.\n * \n * ```js\n * const value = await Rx.takeNextValue(source);\n * ```\n * \n * Throws an error if the source closes without\n * a value or the timeout is reached.\n * \n * @param source \n * @param maximumWait \n * @returns \n */\nexport async function takeNextValue<V>(source: ReactiveOrSource<V>, maximumWait: Interval = 1000): Promise<V> {\n  const rx = resolveSource(source);\n  let off = () => {/** no-op */ };\n  let watchdog: ReturnType<typeof globalThis.setTimeout> | undefined;\n\n  const p = new Promise<V>((resolve, reject) => {\n    off = rx.on(message => {\n      if (watchdog) clearTimeout(watchdog);\n      if (messageHasValue(message)) {\n        off();\n        resolve(message.value);\n      } else {\n        if (messageIsDoneSignal(message)) {\n          reject(new Error(`Source closed. ${ message.context ?? `` }`));\n          off();\n        }\n      }\n    });\n\n    watchdog = setTimeout(() => {\n      watchdog = undefined;\n      off();\n      reject(new Error(`Timeout waiting for value (${ JSON.stringify(maximumWait) })`))\n    }, intervalToMs(maximumWait));\n  });\n  return p;\n}\n\n\n/**\n * Connects reactive A to B, optionally transforming the value as it does so.\n * \n * Returns a function to unsubcribe A->B\n * @param a \n * @param b \n * @param transform \n */\nexport const to = <TA, TB>(a: Reactive<TA>, b: ReactiveWritable<TB>, transform?: (valueA: TA) => TB, closeBonA = false) => {\n  const unsub = a.on(message => {\n    if (messageHasValue(message)) {\n      const value = transform ? transform(message.value) : message.value as TB;\n      b.set(value);\n    } else if (messageIsDoneSignal(message)) {\n      unsub();\n      if (closeBonA) {\n        b.dispose(`Source closed (${ message.context ?? `` })`);\n      }\n    } else {\n      // eslint-disable-nex Unsupported message: ${ JSON.stringify(message) }`);\n    }\n\n  });\n  return unsub;\n}","/* eslint-disable @typescript-eslint/unbound-method */\nimport type { Reactive, ReactiveWritable } from \"../types.js\";\nimport { messageHasValue } from \"../util.js\";\nimport { manual } from \"../index.js\";\n\n/**\n * Creates a RxJs style observable\n * ```js\n * const o = observable(stream => {\n *  // Code to run for initialisation when we go from idle to at least one subscriber\n *  // Won't run again for additional subscribers, but WILL run again if we lose\n *  // all subscribers and then get one\n * \n *  // To send a value:\n *  stream.set(someValue);\n * \n *   // Optional: return function to call when all subscribers are removed\n *   return () => {\n *     // Code to run when all subscribers are removed\n *   }\n * });\n * ```\n * \n * For example:\n * ```js\n * const xy = observable<(stream => {\n *  // Send x,y coords from PointerEvent\n *  const send = (event) => {\n *    stream.set({ x: event.x, y: event.y });\n *  }\n *  window.addEventListener(`pointermove`, send);\n *  return () => {\n *    // Unsubscribe\n *    window.removeEventListener(`pointermove`, send);\n *  }\n * });\n * \n * xy.onValue(value => {\n *  console.log(value);\n * });\n * ```\n * @param init \n * @returns \n */\nexport function observable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined): Reactive<V> {\n  const ow = observableWritable(init);\n  return {\n    dispose: ow.dispose,\n    isDisposed: ow.isDisposed,\n    on: ow.on,\n    onValue: ow.onValue\n  }\n}\n\n/**\n * As {@link observable}, but returns a Reactive that allows writing\n * @param init \n * @returns \n */\nexport function observableWritable<V>(init: (stream: Reactive<V> & ReactiveWritable<V>) => (() => void) | undefined): ReactiveWritable<V> & Reactive<V> {\n  let onCleanup: (() => void) | undefined = () => {/** no-op */ };\n  const ow = manual<V>({\n    onFirstSubscribe() {\n      onCleanup = init(ow);\n    },\n    onNoSubscribers() {\n      if (onCleanup) onCleanup();\n    },\n  });\n\n  return {\n    ...ow,\n    onValue: (callback: (value: V) => void) => {\n      return ow.on(message => {\n        if (messageHasValue(message)) {\n          callback(message.value);\n        }\n      });\n    }\n  };\n}\n","import { observable } from \"@ixfx/rx/from\";\nimport { debounce } from \"@ixfx/rx/op/debounce\";\n/**\n * Observe when element resizes. Specify `interval` to debounce, uses 100ms by default.\n *\n * ```\n * const o = resizeObservable(myEl, 500);\n * o.subscribe(() => {\n *  // called 500ms after last resize\n * });\n * ```\n * @param elem\n * @param interval Tiemout before event gets triggered\n * @returns\n */\nexport const browserResizeObservable = (elem, interval) => {\n    if (elem === null) {\n        throw new Error(`Param 'elem' is null. Expected element to observe`);\n    }\n    if (elem === undefined) {\n        throw new Error(`Param 'elem' is undefined. Expected element to observe`);\n    }\n    const m = observable(stream => {\n        const ro = new ResizeObserver((entries) => {\n            stream.set(entries);\n        });\n        ro.observe(elem);\n        return () => {\n            ro.unobserve(elem);\n        };\n    });\n    //return debounce({ elapsed: interval ?? 100 })(m);\n    return debounce({ elapsed: interval ?? 100 })(m);\n};\n/**\n * Returns an Reactive for window resize. Default 100ms debounce.\n * @param elapsed\n * @returns\n */\n// export const windowResize = (elapsed?: Interval) => Rx.Ops.debounce<{ innerWidth: number, innerHeight: number }>({ elapsed: elapsed ?? 100 })(Rx.From.event(window, `resize`, { innerWidth: 0, innerHeight: 0 }));\n","import { observable } from \"@ixfx/rx/from/observable\";\n/**\n * Observe when a class changes on a target element, by default the document.\n * Useful for tracking theme changes.\n *\n * ```js\n * const c = cssClassChange();\n * c.on(msg => {\n *  // some class has changed on the document\n * });\n * ```\n */\nexport const cssClassChange = (target = document.documentElement) => {\n    const m = observable(stream => {\n        const ro = new MutationObserver((entries) => {\n            stream.set(entries);\n        });\n        const opts = {\n            attributeFilter: [`class`],\n            attributes: true,\n        };\n        ro.observe(target, opts);\n        return () => {\n            ro.disconnect();\n        };\n    });\n    return m;\n};\n","import { initStream } from \"@ixfx/rx\";\nexport function colour(initialValue) {\n    let value = initialValue;\n    const events = initStream();\n    const set = (v) => {\n        value = v;\n        events.set(v);\n    };\n    return {\n        dispose: events.dispose,\n        isDisposed: events.isDisposed,\n        last: () => value,\n        on: events.on,\n        onValue: events.onValue,\n        set,\n        setHsl: (hsl) => {\n            set(hsl);\n        }\n    };\n}\n","import { resolveEl } from '@ixfx/dom';\nimport { transform } from '@ixfx/rx';\nimport { hasLast } from '@ixfx/rx';\nimport { Colour } from \"@ixfx/visual\";\nimport { eventTrigger } from \"@ixfx/rx/from\";\n//import type { Colourish } from '@ixfx/visual/colour';\n/**\n * Reactive getting/setting of values to a HTML INPUT element.\n *\n * Options:\n * - relative: if _true_, values are 0..1 (default: false)\n * - inverted: if _true_, values are 1..0 (default: false)\n *\n * If element is missing a 'type' attribute, this will be set to 'range'.\n * @param targetOrQuery\n * @param options\n * @returns\n */\nexport function domNumberInputValue(targetOrQuery, options = {}) {\n    const input = domInputValue(targetOrQuery, options);\n    const el = input.el;\n    const relative = options.relative ?? false;\n    const inverted = options.inverted ?? false;\n    const rx = transform(input, v => {\n        return Number.parseFloat(v);\n    });\n    if (relative) {\n        //el.setAttribute(`max`, inverted ? \"0\" : \"1\");\n        el.max = inverted ? \"0\" : \"1\";\n        //el.setAttribute(`min`, inverted ? \"1\" : \"0\");\n        el.min = inverted ? \"1\" : \"0\";\n        if (!el.hasAttribute(`step`)) {\n            //el.setAttribute(`step`, \"0.1\");\n            el.step = \"0.1\";\n        }\n    }\n    if (el.getAttribute(`type`) === null) {\n        el.type = `range`;\n    }\n    const set = (value) => {\n        input.set(value.toString());\n    };\n    return {\n        ...rx,\n        last() {\n            //console.log(`domNumberInputValue last: ${ input.last() }`);\n            return Number.parseFloat(input.last());\n        },\n        set\n    };\n}\nexport function domHslInputValue(targetOrQuery, options = {}) {\n    const input = domInputValue(targetOrQuery, {\n        ...options,\n        upstreamFilter: (value) => {\n            return (typeof value === `object`) ? Colour.toCssColour(value) : value;\n        },\n    });\n    const rx = transform(input, v => {\n        return Colour.HslSpace.fromCssScalar(v, { ensureSafe: true });\n    });\n    return {\n        ...rx,\n        last() {\n            return Colour.HslSpace.fromCssScalar(input.last(), { ensureSafe: true });\n        },\n        set(value) {\n            input.set(Colour.HslSpace.toCss(value));\n        },\n    };\n}\n/**\n * A stream of values when the a HTMLInputElement changes. Eg a <input type=\"range\">\n * ```js\n * const r = Rx.From.domInputValue(`#myEl`);\n * r.onValue(value => {\n *  // value will be string\n * });\n * ```\n *\n * Options:\n * * emitInitialValue: If _true_ emits the HTML value of element (default: false)\n * * attributeName: If set, this is the HTML attribute value is set to when writing to stream (default: 'value')\n * * fieldName: If set, this is the DOM object field set when writing to stream (default: 'value')\n * * when: 'changed'|'changing' when values are emitted. (default: 'changed')\n * * fallbackValue:  Fallback value to use if field/attribute cannot be read (default: '')\n * @param targetOrQuery\n * @param options\n * @returns\n */\nexport function domInputValue(targetOrQuery, options = {}) {\n    const target = (typeof targetOrQuery === `string` ? document.querySelector(targetOrQuery) : targetOrQuery);\n    if (target === null && typeof targetOrQuery === `string`)\n        throw new Error(`Element query could not be resolved '${targetOrQuery}'`);\n    if (target === null)\n        throw new Error(`targetOrQuery is null`);\n    const el = resolveEl(targetOrQuery);\n    const when = options.when ?? `changed`;\n    const eventName = when === `changed` ? `change` : `input`;\n    const emitInitialValue = options.emitInitialValue ?? false;\n    const fallbackValue = options.fallbackValue ?? ``;\n    const upstreamSource = options.upstreamSource;\n    let upstreamSourceUnsub = () => { };\n    let attribName = options.attributeName;\n    let fieldName = options.fieldName;\n    if (fieldName === undefined && attribName === undefined) {\n        attribName = fieldName = `value`;\n    }\n    const readValue = () => {\n        let value;\n        if (attribName) {\n            value = el.getAttribute(attribName);\n            //console.log(`  attrib: ${ attribName } value: ${ value }`);\n        }\n        if (fieldName) {\n            value = el[fieldName];\n        }\n        if (value === undefined || value === null)\n            value = fallbackValue;\n        //console.log(`domInputValue readValue: ${ value }. attrib: ${ attribName } field: ${ fieldName }`);\n        return value;\n    };\n    const setValue = (value) => {\n        if (attribName) {\n            el.setAttribute(attribName, value);\n        }\n        if (fieldName) {\n            el[fieldName] = value;\n        }\n    };\n    const setUpstream = (v) => {\n        v = options.upstreamFilter ? options.upstreamFilter(v) : v;\n        setValue(v);\n    };\n    if (upstreamSource) {\n        upstreamSourceUnsub = upstreamSource.onValue(setUpstream);\n        if (hasLast(upstreamSource)) {\n            setUpstream(upstreamSource.last());\n        }\n    }\n    // Input element change event stream\n    const rxEvents = eventTrigger(el, eventName, {\n        fireInitial: emitInitialValue,\n        debugFiring: options.debugFiring ?? false,\n        debugLifecycle: options.debugLifecycle ?? false,\n    });\n    // Transform to get values\n    const rxValues = transform(rxEvents, _trigger => readValue());\n    return {\n        ...rxValues,\n        el,\n        last() {\n            return readValue();\n        },\n        set(value) {\n            setValue(value);\n        },\n        dispose(reason) {\n            upstreamSourceUnsub();\n            rxValues.dispose(reason);\n            rxEvents.dispose(reason);\n        },\n    };\n}\n/**\n * Listens for data changes from elements within a HTML form element.\n * Input elements must have a 'name' attribute.\n *\n * Simple usage:\n * ```js\n * const rx = Rx.From.domForm(`#my-form`);\n * rx.onValue(value => {\n *  // Object containing values from form\n * });\n *\n * rx.last(); // Read current values of form\n * ```\n *\n * UI can be updated\n * ```js\n * // Set using an object of key-value pairs\n * rx.set({\n *  size: 'large'\n * });\n *\n * // Or set a single name-value pair\n * rx.setNamedValue(`size`, `large`);\n * ```\n *\n * If an 'upstream' reactive is provided, this is used to set initial values of the UI, overriding\n * whatever may be in the HTML. Upstream changes modify UI elements, but UI changes do not modify the upstream\n * source.\n *\n * ```js\n * // Create a reactive object\n * const obj = Rx.From.object({\n *  when: `2024-10-03`,\n *  size: 12,\n *  checked: true\n * });\n *\n * // Use this as initial values for a HTML form\n * // (assuming appropriate INPUT/SELECT elements exist)\n * const rx = Rx.From.domForm(`form`, {\n *  upstreamSource: obj\n * });\n *\n * // Listen for changes in the UI\n * rx.onValue(value => {\n *\n * });\n * ```\n * @param formElOrQuery\n * @param options\n * @returns\n */\nexport function domForm(formElOrQuery, options = {}) {\n    const formEl = resolveEl(formElOrQuery);\n    const when = options.when ?? `changed`;\n    const eventName = when === `changed` ? `change` : `input`;\n    const emitInitialValue = options.emitInitialValue ?? false;\n    const upstreamSource = options.upstreamSource;\n    const typeHints = new Map();\n    let upstreamSourceUnsub = () => { };\n    const readValue = () => {\n        const fd = new FormData(formEl);\n        const entries = [];\n        for (const [k, v] of fd.entries()) {\n            const vString = v.toString();\n            // Get type hint for key\n            let typeHint = typeHints.get(k);\n            if (!typeHint) {\n                // If not found, use the kind of input element as a hint\n                const el = getFormElement(k, vString);\n                if (el) {\n                    if (el.type === `range` || el.type === `number`) {\n                        typeHint = `number`;\n                    }\n                    else if (el.type === `color`) {\n                        typeHint = `colour`;\n                    }\n                    else if (el.type === `checkbox` && (v === `true` || v === `on`)) {\n                        typeHint = `boolean`;\n                    }\n                    else {\n                        typeHint = `string`;\n                    }\n                    typeHints.set(k, typeHint);\n                }\n            }\n            if (typeHint === `number`) {\n                entries.push([k, Number.parseFloat(vString)]);\n            }\n            else if (typeHint === `boolean`) {\n                const vBool = (vString === `true`) ? true : false;\n                entries.push([k, vBool]);\n            }\n            else if (typeHint === `colour`) {\n                const vRgb = Colour.toCssColour(vString);\n                entries.push([k, Colour.RgbSpace.fromCss(vRgb)]);\n            }\n            else {\n                entries.push([k, v.toString()]);\n            }\n        }\n        // Checkboxes that aren't checked don't give a value, so find those\n        for (const el of formEl.querySelectorAll(`input[type=\"checkbox\"]`)) {\n            if (!el.checked && el.value === `true`) {\n                entries.push([el.name, false]);\n            }\n        }\n        const asObject = Object.fromEntries(entries);\n        //console.log(`readValue`, asObj);\n        return asObject;\n    };\n    const getFormElement = (name, value) => {\n        const el = formEl.querySelector(`[name=\"${name}\"]`);\n        if (!el) {\n            console.warn(`Form does not contain an element with name=\"${name}\"`);\n            return;\n        }\n        if (el.type === `radio`) {\n            // Get right radio option\n            const radioEl = formEl.querySelector(`[name=\"${name}\"][value=\"${value}\"]`);\n            if (!radioEl) {\n                console.warn(`Form does not contain radio option for name=${name} value=${value}`);\n                return;\n            }\n            return radioEl;\n        }\n        return el;\n    };\n    const setNamedValue = (name, value) => {\n        const el = getFormElement(name, value);\n        if (!el)\n            return;\n        //let typeHint = typeHints.get(name);\n        // if (typeHint) {\n        //   console.log(`${ name } hint: ${ typeHint } input type: ${ el.type }`);\n        // } else {\n        //   console.warn(`Rx.Sources.Dom.domForm no type hint for: ${ name }`);\n        // }\n        if (el.nodeName === `INPUT` || el.nodeName === `SELECT`) {\n            if (el.type === `color`) {\n                if (typeof value === `object`) {\n                    // Try to parse colour if value is an object\n                    value = Colour.toCssColour(value);\n                }\n            }\n            else if (el.type === `checkbox`) {\n                if (typeof value === `boolean`) {\n                    el.checked = value;\n                    return;\n                }\n                else {\n                    console.warn(`Rx.Sources.domForm: Trying to set non boolean type to a checkbox. Name: ${name} Value: ${value} (${typeof value})`);\n                }\n            }\n            else if (el.type === `radio`) {\n                el.checked = true;\n                return;\n            }\n            el.value = value;\n        }\n    };\n    const setFromUpstream = (value) => {\n        //console.log(`setUpstream`, value);\n        for (const [name, v] of Object.entries(value)) {\n            let hint = typeHints.get(name);\n            if (!hint) {\n                hint = typeof v;\n                if (hint === `object`) {\n                    const rgb = Colour.toColour(v);\n                    hint = `colour`;\n                    // const rgb = Colour.toColour(v);\n                    // if (rgb.success) {\n                    //   hint = `colour`;\n                    // }\n                }\n                typeHints.set(name, hint);\n            }\n            const valueFiltered = options.upstreamFilter ? options.upstreamFilter(name, v) : v;\n            setNamedValue(name, valueFiltered);\n        }\n    };\n    if (upstreamSource) {\n        upstreamSourceUnsub = upstreamSource.onValue(setFromUpstream);\n        if (hasLast(upstreamSource)) {\n            setFromUpstream(upstreamSource.last());\n        }\n    }\n    // Input element change event stream\n    const rxEvents = eventTrigger(formEl, eventName, {\n        fireInitial: emitInitialValue,\n        debugFiring: options.debugFiring ?? false,\n        debugLifecycle: options.debugLifecycle ?? false,\n    });\n    // Transform to get values\n    const rxValues = transform(rxEvents, _trigger => readValue());\n    return {\n        ...rxValues,\n        el: formEl,\n        last() {\n            return readValue();\n        },\n        set: setFromUpstream,\n        setNamedValue,\n        dispose(reason) {\n            upstreamSourceUnsub();\n            rxValues.dispose(reason);\n            rxEvents.dispose(reason);\n        },\n    };\n}\n","//import * as Immutable from \"@ixfx/core/records\";\nimport { resolveEl } from \"@ixfx/dom\";\nimport { getPathsAndData } from \"@ixfx/core/records\";\nimport * as Rx from \"@ixfx/rx\";\nimport * as RxFrom from \"@ixfx/rx/from\";\nimport { getFromKeys } from \"@ixfx/core/maps\";\nimport { afterMatch, beforeMatch, stringSegmentsWholeToEnd, stringSegmentsWholeToFirst } from \"@ixfx/core/text\";\nimport { QueueMutable } from \"@ixfx/collections\";\n/**\n * Reactive stream of array of elements that match `query`.\n * @param query\n * @returns\n */\nexport function fromDomQuery(query) {\n    const elements = [...document.querySelectorAll(query)];\n    return Rx.From.object(elements);\n    /// TODO: MutationObserver to update element list\n}\n/**\n * Updates an element's `textContent` when the source value changes.\n * ```js\n * bindText(source, `#blah`);\n * ```\n * @param elOrQuery\n * @param source\n * @param bindOpts\n */\nexport const bindText = (source, elOrQuery, bindOpts = {}) => {\n    return bindElement(source, elOrQuery, { ...bindOpts, elField: `textContent` });\n};\n/**\n * Updates an element's `value` (as well as the 'value' attribute) when the source value changes.s\n * @param source\n * @param elOrQuery\n * @param bindOpts\n * @returns\n */\nexport const bindValueText = (source, elOrQuery, bindOpts = {}) => {\n    return bindElement(source, elOrQuery, { ...bindOpts, elField: `value`, attribName: `value` });\n};\n/**\n * Updates an element's `valueAsNumber` (as well as the 'value' attribute) when the source value changes.\n * ```js\n * // Create a reactive number, with a default value of 10\n * const r1 = Rx.From.number(10);\n * // Bind reactive to HTML input element with id 'inputRange'\n * const b1 = Rx.Dom.bindValueRange(r1,`#inputRange`);\n *\n * // Demo: Change the reactive value every second\n * // ...changing the reactive in turn updates the HTML\n * setInterval(() => {\n *  r1.set(Math.floor(Math.random()*100));\n * }, 1000);\n * ```\n * @param source\n * @param elOrQuery\n * @param bindOpts\n * @returns\n */\n// export const bindValueRange = (source: Rx.Reactive<number>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindInputOptions<number, number>> = {}) => {\n//   const el = validateElement(elOrQuery, `range`);\n//   const b = bindElement<number, number>(source, el, { ...bindOpts, elField: `valueAsNumber`, attribName: `value` });\n//   const twoway = bindOpts.twoway ?? false;\n//   const transformFromInput = bindOpts.transformFromInput ?? ((value) => {\n//     if (typeof value === `number`) return value;\n//     return Number.parseFloat(value);\n//   });\n//   const input = Rx.From.domValueAsNumber(el);\n//   return setupInput(b, input, source, twoway, transformFromInput);\n// }\n// export const bindValueColour = (source: Rx.Reactive<Colour.Colourish>, elOrQuery: string | HTMLInputElement | null, bindOpts: Partial<Rx.DomBindInputOptions<Colour.Colourish, string>> = {}) => {\n//   const el = validateElement(elOrQuery, `color`);\n//   const b = bindElement<Colour.Colourish, string>(source, el, {\n//     ...bindOpts,\n//     elField: `value`,\n//     attribName: `value`,\n//     transform(input) {\n//       console.log(`transform from: ${ JSON.stringify(input) } to hex`);\n//       const c = Colour.resolve(input);\n//       return c.to(`srgb`).toString({ format: `hex`, collapse: false });\n//     },\n//   });\n//   const twoway = bindOpts.twoway ?? false;\n//   const transformFromInput = bindOpts.transformFromInput ?? ((value) => {\n//     const x = Colour.toHsl(value);\n//     console.log(`transformFromInput: ${ value } x: ${ JSON.stringify(x) }`);\n//     return x;\n//   });\n//   const input = Rx.From.domValue<Colour.Hsl>(el, {\n//     domToValue: transformFromInput\n//   });\n//   return setupInput(b, input, source, twoway, transformFromInput);\n// }\nconst setupInput = (b, input, source, twoway, transformFromInput) => {\n    input.onValue(value => {\n        const v = transformFromInput(value);\n        if (twoway && Rx.isWritable(source)) {\n            source.set(v);\n        }\n    });\n    const dispose = () => {\n        input.dispose(`bindInput twoway dispose`);\n        b.remove(false);\n    };\n    return { ...b, dispose, input };\n};\nconst validateElement = (elOrQuery, type) => {\n    const el = resolveEl(elOrQuery);\n    if (el.nodeName !== `INPUT`)\n        throw new Error(`HTML INPUT element expected. Got: ${el.nodeName}`);\n    if (type !== undefined && el.type !== type)\n        throw new Error(`HTML INPUT element expected with type 'range'. Got: ${el.type}`);\n    return el;\n};\n/**\n * Updates an element's `innerHTML` when the source value changes\n * ```js\n * bindHtml(source, `#blah`);\n * ```\n *\n * Uses {@link bindElement}, with `{elField:'innerHTML'}` as the options.\n * @param elOrQuery\n * @param source\n * @param bindOpts\n * @returns\n */\nexport const bindHtml = (source, elOrQuery, bindOpts = {}) => {\n    return bindElement(source, elOrQuery, { ...bindOpts, elField: `innerHTML` });\n};\n/**\n * Shortcut to bind to an elements attribute\n * @param elOrQuery\n * @param source\n * @param attribute\n * @param bindOpts\n * @returns\n */\n// export const bindAttribute = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, attribute: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, attribName: attribute });\n// }\n/**\n * Shortcut to bind to a CSS variable\n * @param elOrQuery\n * @param source\n * @param cssVariable\n * @param bindOpts\n * @returns\n */\n// export const bindCssVariable = <V>(elOrQuery: string | HTMLElement, source: Rx.Reactive<V>, cssVariable: string, bindOpts: Partial<DomBindOptions<V>> = {}) => {\n//   return bind(elOrQuery, source, { ...bindOpts, cssVariable: cssVariable });\n// }\n/**\n * Creates a new HTML element, calling {@link bind} on it to update when `source` emits new values.\n *\n *\n * ```js\n * // Set textContent of a SPAN with values from `source`\n * create(source, { tagName: `span`, parentEl: document.body })\n * ```\n *\n * If `parentEl` is not given in the options, the created element needs to be manually added\n * ```js\n * const b = create(source);\n * someEl.append(b.el); // Append manually\n * ```\n *\n * ```\n * // Set 'title' attribute based on values from `source`\n * create(source, { parentEl: document.body, attribName: `title` })\n * ```\n * @param source\n * @param options\n * @returns\n */\n// export const create = <V>(source: Rx.Reactive<V>, options: Partial<DomCreateOptions> & Partial<DomBindOptions<V>> = {}): PipeDomBinding => {\n//   const nodeType = options.tagName ?? `DIV`;\n//   const el = document.createElement(nodeType);\n//   const b = bind(el, source, options);\n//   if (options.parentEl) {\n//     const parentElementOrQuery = resolveEl(options.parentEl);\n//     if (parentElementOrQuery === undefined) throw new Error(`Parent element could not be resolved`);\n//     parentElementOrQuery.append(el);\n//   }\n//   return b;\n// }\n/**\n * Update a DOM element's field, attribute or CSS variable when `source` produces a value.\n *\n * ```js\n * // Access via DOM query. Binds to 'textContent' by default\n * bind(readableSource, `#someEl`);\n *\n * // Set innerHTML instead\n * bind(readableSource, someEl, { elField: `innerHTML` });\n *\n * // An attribute\n * bind(readableSource, someEl, { attribName: `width` });\n *\n * // A css variable ('--' optiona)\n * bind(readableSource, someEl, { cssVariable: `hue` });\n *\n * // Pluck a particular field from source data.\n * // Ie someEl.textContent = value.colour\n * bind(readableSource, someEl, { sourceField: `colour` });\n *\n * // Transform value before setting it to field\n * bind(readableSource, someEl, {\n *  field: `innerHTML`,\n *  transform: (v) => `Colour: ${v.colour}`\n * })\n * ```\n *\n * If `source` has an initial value, this is used when first bound.\n *\n * Returns {@link PipeDomBinding} to control binding:\n * ```js\n * const bind = bind(source, `#someEl`);\n * bind.remove();     // Unbind\n * bind.remove(true); // Unbind and remove HTML element\n * ```\n *\n * If several fields need to be updated based on a new value, consider using {@link bindUpdate} instead.\n * @param elOrQuery Element to update to, or query string such as '#someid'\n * @param source Source of data\n * @param binds Bindings\n */\nexport const bindElement = (source, elOrQuery, ...binds) => {\n    if (elOrQuery === null)\n        throw new Error(`Param 'elOrQuery' is null`);\n    if (elOrQuery === undefined)\n        throw new Error(`Param 'elOrQuery' is undefined`);\n    const el = resolveEl(elOrQuery);\n    let b = [];\n    if (binds.length === 0) {\n        b.push({ elField: `textContent` });\n    }\n    else {\n        b = [...binds];\n    }\n    const bb = b.map(bind => {\n        if (`element` in bind)\n            return bind;\n        return { ...bind, element: el };\n    });\n    return bind(source, ...bb);\n};\nconst resolveBindUpdater = (bind, element) => {\n    const b = resolveBindUpdaterBase(bind);\n    return (value) => {\n        b(value, element);\n    };\n};\nconst resolveBindUpdaterBase = (bind) => {\n    if (bind.elField !== undefined || (bind.cssVariable === undefined && bind.attribName === undefined && bind.cssProperty === undefined && bind.textContent === undefined && bind.htmlContent === undefined)) {\n        const field = bind.elField ?? `textContent`;\n        return (v, element) => {\n            element[field] = v;\n        };\n    }\n    if (bind.attribName !== undefined) {\n        const attrib = bind.attribName;\n        return (v, element) => {\n            element.setAttribute(attrib, v);\n        };\n    }\n    if (bind.textContent) {\n        return (v, element) => {\n            element.textContent = v;\n        };\n    }\n    if (bind.htmlContent) {\n        return (v, element) => {\n            element.innerHTML = v;\n        };\n    }\n    if (bind.cssVariable !== undefined) {\n        let css = bind.cssVariable;\n        if (!css.startsWith(`--`))\n            css = `--` + css;\n        return (v, element) => {\n            element.style.setProperty(css, v);\n        };\n    }\n    if (bind.cssProperty !== undefined) {\n        return (v, element) => {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            element.style[bind.cssProperty] = v;\n        };\n    }\n    return (_, _element) => {\n        /** no-op */\n    };\n};\nconst resolveTransform = (bind) => {\n    if (!bind.transform && !bind.transformValue)\n        return;\n    if (bind.transformValue) {\n        if (bind.sourceField === undefined)\n            throw new Error(`Expects 'sourceField' to be set when 'transformValue' is set`);\n        return (value) => {\n            const fieldValue = value[bind.sourceField];\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            return bind.transformValue(fieldValue);\n        };\n    }\n    else if (bind.transform) {\n        if (bind.sourceField !== undefined)\n            throw new Error(`If 'transform' is set, 'sourceField' is ignored`);\n        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n        return (value) => bind.transform(value);\n    }\n};\n/**\n * Binds `source` to one or more element(s). One or more bindings for the same source\n * can be provided.\n *\n * ```js\n * bind(source,\n *  // Binds .name field of source values to textContent of #some-element\n *  { query: `#some-element`, sourceField: `name` },\n *  { query: `section`, }\n * );\n * ```\n *\n * Can update\n * * CSS variables\n * * CSS styles\n * * textContent / innerHTML\n * * HTML DOM attributes and object fields\n *\n * Can use a particular field on source values, or use the whole value. These can\n * pass through `transformValue` or `transform` respectively.\n *\n * Returns a function to unbind from source and optionally remove HTML element\n * ```js\n * const unbind = bind( . . . );\n * unbind();     // Unbind\n * unbind(true); // Unbind and remove HTML element(s)\n * ```\n * @param source\n * @param bindsUnresolvedElements\n * @returns\n */\nexport const bind = (source, ...bindsUnresolvedElements) => {\n    const binds = bindsUnresolvedElements.map(bind => {\n        if (bind.element && bind.element !== undefined)\n            return bind;\n        if (bind.query)\n            return {\n                ...bind,\n                element: resolveEl(bind.query)\n            };\n        throw new Error(`Unable to resolve element. Missing 'element' or 'query' values on bind. ${JSON.stringify(bind)}`);\n    });\n    const bindsResolved = binds.map(bind => ({\n        update: resolveBindUpdater(bind, bind.element),\n        transformer: resolveTransform(bind),\n        sourceField: bind.sourceField\n    }));\n    const update = (value) => {\n        for (const bind of bindsResolved) {\n            if (bind.transformer) {\n                bind.update(bind.transformer(value));\n            }\n            else {\n                const v = (bind.sourceField) ? value[bind.sourceField] : value;\n                if (typeof v === `object`) {\n                    if (bind.sourceField) {\n                        bind.update(JSON.stringify(v));\n                    }\n                    else {\n                        bind.update(JSON.stringify(v));\n                    }\n                }\n                else\n                    bind.update(v);\n            }\n        }\n    };\n    const unsub = source.on(message => {\n        if (Rx.messageHasValue(message)) {\n            update(message.value);\n        }\n        else if (Rx.messageIsSignal(message)) {\n            console.warn(message);\n        }\n    });\n    if (Rx.hasLast(source)) {\n        update(source.last());\n    }\n    return {\n        remove: (removeElements) => {\n            unsub();\n            if (removeElements) {\n                for (const bind of binds) {\n                    bind.element.remove();\n                }\n            }\n        }\n    };\n};\n/**\n * Calls `updater` whenever `source` produces a value. Useful when several fields from a value\n * are needed to update an element.\n * ```js\n * bindUpdate(source, `#someEl`, (v, el) => {\n *  el.setAttribute(`width`, v.width);\n *  el.setAttribute(`height`, v.height);\n * });\n * ```\n *\n * Returns a {@link PipeDomBinding} to manage binding\n * ```js\n * const b = bindUpdate(...);\n * b.remove();     // Disconnect binding\n * b.remove(true); // Disconnect binding and remove element\n * b.el;           // HTML element\n * ```\n * @param elOrQuery\n * @param source\n * @param updater\n * @returns\n */\nexport const bindUpdate = (source, elOrQuery, updater) => {\n    const el = resolveEl(elOrQuery);\n    const update = (value) => {\n        updater(value, el);\n    };\n    const unsub = source.on(message => {\n        if (Rx.messageHasValue(message)) {\n            console.log(message);\n            update(message.value);\n        }\n        else {\n            console.warn(message);\n        }\n    });\n    if (Rx.hasLast(source)) {\n        update(source.last());\n    }\n    return {\n        remove: (removeElement) => {\n            unsub();\n            if (removeElement) {\n                el.remove();\n            }\n        }\n    };\n};\n/**\n * Updates a HTML element based on diffs on an object.\n * ```js\n * // Wrap an object\n * const o = Rx.object({ name: `Jane`, ticks: 0 });\n * const b = bindDiffUpdate(`#test`, o, (diffs, el) => {\n *  // el = reference to #test\n * // diff = Array of Changes,\n * //  eg [ { path: `ticks`, value: 797, previous: 0 } ]\n *  for (const diff of diffs) {\n *    if (diff.path === `ticks`) el.textContent = `${diff.previous} -> ${diff.value}`\n *  }\n * })\n *\n * // Eg. update field\n * o.updateField(`ticks`, Math.floor(Math.random()*1000));\n * ```\n *\n * If `initial` is provided as an option, this will be called if `source` has an initial value. Without this, the DOM won't be updated until the first data\n * update happens.\n * ```js\n * bindDiffUpdate(el, source, updater, {\n *  initial: (v, el) => {\n *    el.innerHTML = v.name;\n *  }\n * })\n * ```\n * @param elOrQuery\n * @param source\n * @param updater\n * @param opts\n * @returns\n */\nexport const bindDiffUpdate = (source, elOrQuery, updater, opts = {}) => {\n    if (elOrQuery === null)\n        throw new Error(`Param 'elOrQuery' is null`);\n    if (elOrQuery === undefined)\n        throw new Error(`Param 'elOrQuery' is undefined`);\n    const el = resolveEl(elOrQuery);\n    //const binds = opts.binds;\n    const update = (value) => {\n        updater(value, el);\n    };\n    const unsub = source.onDiff(value => {\n        update(value);\n    });\n    const init = () => {\n        if (Rx.hasLast(source) && opts.initial)\n            opts.initial(source.last(), el);\n    };\n    init();\n    return {\n        refresh: () => {\n            init();\n        },\n        remove: (removeElement) => {\n            unsub();\n            if (removeElement) {\n                el.remove();\n            }\n        }\n    };\n};\n/**\n * Creates a new HTML element and calls `bindUpdate` so values from `source` can be used\n * to update it.\n *\n *\n * ```js\n * // Creates a span, adding it to <body>\n * const b = createUpdate(dataSource, (value, el) => {\n *  el.width = value.width;\n *  el.height = value.height;\n * }, {\n *  tagName: `SPAN`,\n *  parentEl: document.body\n * })\n * ```\n * @param source\n * @param updater\n * @param options\n * @returns\n */\n// export const createUpdate = <V>(source: Rx.Reactive<V>, updater: (v: V, el: HTMLElement) => void, options: Partial<DomCreateOptions> = {}): PipeDomBinding => {\n//   const tag = options.tagName ?? `DIV`;\n//   const el = document.createElement(tag);\n//   if (options.parentEl) {\n//     const parent = resolveEl(options.parentEl);\n//     parent.append(el);\n//   }\n//   const b = bindUpdate(source, el, updater);\n//   return b;\n// }\n/**\n * Creates, updates & deletes elements based on pathed values from a reactive.\n *\n * This means that elements are only manipulated if its associated data changes,\n * and elements are not modified if there's no need to.\n * @param source\n * @param options\n */\nexport const elements = (source, options) => {\n    const containerEl = options.container ? resolveEl(options.container) : document.body;\n    const defaultTag = options.defaultTag ?? `div`;\n    const elByField = new Map();\n    const binds = new Map();\n    for (const [key, value] of Object.entries(options.binds ?? {})) {\n        const tagName = value.tagName ?? defaultTag;\n        //console.log(`key: ${ key }`);\n        binds.set(key, {\n            ...value,\n            update: resolveBindUpdaterBase(value),\n            transform: resolveTransform(value),\n            tagName,\n            path: key\n        });\n    }\n    const findBind = (path) => {\n        const bind = getFromKeys(binds, stringSegmentsWholeToEnd(path));\n        if (bind !== undefined)\n            return bind;\n        if (!path.includes(`.`))\n            return binds.get(`_root`);\n    };\n    function* ancestorBinds(path) {\n        for (const p of stringSegmentsWholeToFirst(path)) {\n            //console.log(` ancestorBinds path: ${ path } segment: ${ p }`)\n            if (binds.has(p)) {\n                //console.log(`  bind: ${ p } found: ${ JSON.stringify(binds.get(p)) }`);\n                yield binds.get(p);\n            }\n            else {\n                //console.log(` bind: ${ p } not found`);\n            }\n        }\n        if (binds.has(`_root`) && path.includes(`.`))\n            yield binds.get(`_root`);\n    }\n    const create = (path, value) => {\n        const rootedPath = getRootedPath(path);\n        console.log(`Rx.Dom.elements.create: ${path} rooted: ${rootedPath} value: ${JSON.stringify(value)}`);\n        // Create\n        const bind = findBind(getRootedPath(path));\n        let tagName = defaultTag;\n        if (bind?.tagName)\n            tagName = bind.tagName;\n        const el = document.createElement(tagName);\n        el.setAttribute(`data-path`, path);\n        update(path, el, value);\n        let parentForEl;\n        for (const b of ancestorBinds(rootedPath)) {\n            //console.log(`  path: ${ rootedPath } b: ${ JSON.stringify(b) }`);\n            if (b?.nestChildren) {\n                // Get root of path\n                const absoluteRoot = beforeMatch(path, `.`);\n                const findBy = b.path.replace(`_root`, absoluteRoot);\n                parentForEl = elByField.get(findBy);\n                if (parentForEl === undefined) {\n                    //console.log(`    could not find parent. path: ${ path } b.path: ${ b.path } findBy: ${ findBy }`);\n                }\n                else {\n                    //console.log(`    found parent`);\n                    break;\n                }\n            }\n        }\n        (parentForEl ?? containerEl).append(el);\n        elByField.set(path, el);\n        console.log(`Added el: ${path}`);\n    };\n    const update = (path, el, value) => {\n        console.log(`Rx.dom.update path: ${path} value:`, value);\n        const bind = findBind(getRootedPath(path));\n        if (bind === undefined) {\n            //console.log(`Rx.dom.update   no bind for ${ path }`)\n            if (typeof value === `object`)\n                value = JSON.stringify(value);\n            el.textContent = value;\n        }\n        else {\n            //console.log(`Rx.dom.update   got bind! ${ path } `);\n            if (bind.transform)\n                value = bind.transform(value);\n            bind.update(value, el);\n        }\n    };\n    const changes = (changes) => {\n        const queue = new QueueMutable({}, changes);\n        let d = queue.dequeue();\n        const seenPaths = new Set();\n        while (d !== undefined) {\n            //for (const d of changes) {\n            const path = d.path;\n            if (!(`previous` in d) || d.previous === undefined) {\n                // Create\n                console.log(`Rx.Dom.elements.changes no previous. path: ${path}`);\n                create(path, d.value);\n                const subdata = [...getPathsAndData(d.value, false, Number.MAX_SAFE_INTEGER, path)];\n                console.log(subdata);\n                for (const dd of subdata) {\n                    if (!seenPaths.has(dd.path)) {\n                        queue.enqueue(dd);\n                        seenPaths.add(dd.path);\n                    }\n                }\n            }\n            else if (d.value === undefined) {\n                // Delete\n                const el = elByField.get(path);\n                if (el === undefined) {\n                    console.warn(`No element to delete? ${path} `);\n                }\n                else {\n                    console.log(`Rx.Dom.elements.changes delete ${path}`);\n                    el.remove();\n                }\n            }\n            else {\n                // Update\n                const el = elByField.get(path);\n                if (el === undefined) {\n                    console.warn(`Rx.Dom.elements.changes No element to update ? ${path} `);\n                    create(path, d.value);\n                }\n                else {\n                    //console.log(`Rx.Dom.elements.changes Updating ${ path } `, el);\n                    update(path, el, d.value);\n                }\n            }\n            d = queue.dequeue();\n        }\n    };\n    /**\n     * Source has changed\n     */\n    source.onDiff(value => {\n        //console.log(`Rx.Dom.elements diff ${ JSON.stringify(value) } `);\n        changes(value);\n    });\n    // Source has an initial value, use that\n    if (Rx.hasLast(source)) {\n        const last = source.last();\n        // Get data of value as a set of paths and data\n        // but only at first level of depth, because changes() will probe\n        // deeper itself\n        changes([...getPathsAndData(last, false, 1)]);\n    }\n};\n/**\n * Replaces the root portion of `path` with the magic keyword `_root`\n * @param path\n * @returns\n */\nconst getRootedPath = (path) => {\n    const after = afterMatch(path, `.`);\n    return after === path ? `_root` : `_root.` + after;\n};\nexport function win() {\n    const generateRect = () => ({ width: window.innerWidth, height: window.innerHeight });\n    const size = RxFrom.event(window, `resize`, {\n        lazy: `very`,\n        transform: () => generateRect(),\n    });\n    const pointer = RxFrom.event(window, `pointermove`, {\n        lazy: `very`,\n        transform: (args) => {\n            if (args === undefined)\n                return { x: 0, y: 0 };\n            const pe = args;\n            return { x: pe.x, y: pe.y };\n        }\n    });\n    const dispose = (reason = `Reactive.win.dispose`) => {\n        size.dispose(reason);\n        pointer.dispose(reason);\n    };\n    return { dispose, size, pointer };\n}\n","export * from './browser-resize.js';\nexport * from './browser-theme-change.js';\nexport * from './colour.js';\nexport * from './dom-source.js';\nexport * from './dom.js';\n","export * from '@ixfx/ui';"],"mappings":"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"}