{"version":3,"file":"types-Bzjzk4dE.d.ts","names":["ISetMutable","GridVisual","Grid","GridCell","GridNeighbours","GridCardinalDirection","GridCardinalDirectionOptional","GridArray1d","T","GridReadable","GridWritable","GridBoundsLogic","GridNeighbourSelectionLogic","GridIdentifyNeighbours","GridNeighbourSelector","GridVisitorOpts","Readonly","GridCreateVisitor","Partial","Generator","GridCellAndValue","GridNeighbourMaybe","GridNeighbour","GridCellAccessor","TValue","GridCellSetter"],"sources":["../../geometry/dist/src/grid/types.d.ts"],"sourcesContent":["import type { ISetMutable } from \"@ixfx/collections\";\nexport type GridVisual = Grid & {\n    readonly size: number;\n};\nexport type Grid = {\n    readonly rows: number;\n    readonly cols: number;\n};\nexport type GridCell = {\n    readonly x: number;\n    readonly y: number;\n};\nexport type GridNeighbours = {\n    readonly n: GridCell | undefined;\n    readonly e: GridCell | undefined;\n    readonly s: GridCell | undefined;\n    readonly w: GridCell | undefined;\n    readonly ne: GridCell | undefined;\n    readonly nw: GridCell | undefined;\n    readonly se: GridCell | undefined;\n    readonly sw: GridCell | undefined;\n};\nexport type GridCardinalDirection = `n` | `ne` | `e` | `se` | `s` | `sw` | `w` | `nw`;\nexport type GridCardinalDirectionOptional = GridCardinalDirection | ``;\nexport type GridArray1d<T> = GridReadable<T> & GridWritable<T> & {\n    array: T[];\n};\n/**\n * Bounds logic\n * * Unbounded: attempts to read beyond limits\n * * Undefined: returns _undefined_ when reading beyond limits\n * * Stop: returns cell value at edge of limits\n * * Wrap: Wrap-around cell positions\n *\n */\nexport type GridBoundsLogic = \n/**\n * Unbounded: attempts to read beyond limits\n */\n`unbounded` | \n/**\n * Undefined: returns _undefined_ when reading beyond limits\n */\n`undefined` | \n/**\n * Stop: returns cell value at edge of limits\n */\n`stop` | \n/**\n * Wrap-around cell positions\n */\n`wrap`;\n/**\n * Logic to select the next cell based on a list of neighbours\n */\nexport type GridNeighbourSelectionLogic = {\n    /**\n     * Returns neighbours for a given cell in a grid\n     */\n    readonly getNeighbours?: GridIdentifyNeighbours;\n    /**\n     * Select a neighbour from given list\n     */\n    readonly select: GridNeighbourSelector;\n};\nexport type GridVisitorOpts = Readonly<{\n    start: GridCell;\n    visited: ISetMutable<GridCell>;\n    reversed: boolean;\n    debug: boolean;\n    boundsWrap: GridBoundsLogic;\n}>;\nexport type GridCreateVisitor = (grid: Grid, opts?: Partial<GridVisitorOpts>) => Generator<GridCell>;\nexport type GridCellAndValue<T> = {\n    cell: GridCell;\n    value: T | undefined;\n};\nexport type GridNeighbourMaybe = readonly [keyof GridNeighbours, GridCell | undefined];\nexport type GridNeighbour = readonly [keyof GridNeighbours, GridCell];\n/**\n * A function that returns a value (or _undefined_) based on a _cell_\n *\n * Implementations:\n * * {@link Array1d.access}: For accessing a single-dimension array as a grid\n * * {@link Array2d.access}: For accessing a two-dimension array as a grid\n *\n */\nexport type GridCellAccessor<TValue> = (cell: GridCell, wrap?: GridBoundsLogic) => TValue | undefined;\n/**\n * A function that sets the value of a cell.\n */\nexport type GridCellSetter<TValue> = (value: TValue, cell: GridCell, wrap?: GridBoundsLogic) => void;\n/**\n * Shape of a grid and a function to read values from it, based on\n * cell location.\n *\n * These functions create a GridReadable:\n * * {@link Grids.Array1d.wrap}: wrap an array and read as a grid\n * * {@link Grids.Array1d.wrapMutable}: wrap and modify an array as a grid\n * * {@link Grids.Array2d.wrap}: wrap a two-dimensional grid\n * * {@link Grids.Array2d.wrapMutable}\n */\nexport type GridReadable<T> = Grid & {\n    get: GridCellAccessor<T>;\n};\nexport type GridWritable<T> = Grid & {\n    set: GridCellSetter<T>;\n};\n/**\n * Neighbour selector logic. For a given set of `neighbours` pick one to visit next.\n */\nexport type GridNeighbourSelector = (neighbours: readonly GridNeighbour[]) => GridNeighbour | undefined;\n/**\n * Identify neighbours logic. For a given `grid` and `origin`, return a list of neighbours\n */\nexport type GridIdentifyNeighbours = (grid: Grid, origin: GridCell) => readonly GridNeighbour[];\n//# sourceMappingURL=types.d.ts.map"],"mappings":";;AAmCYW,KA/BAT,IAAAA,GA+BAS;EAoDAY,SAAAA,IAAAA,EAAAA,MAAgB;EAAA,SAAA,IAAA,EAAA,MAAA;CAAA;AAAmCZ,KA/EnDR,QAAAA,GA+EmDQ;EAAe,SAAKa,CAAAA,EAAAA,MAAAA;EAAM,SAAA,CAAA,EAAA,MAAA;AAIzF,CAAA;AAYyB,KAjFbnB,qBAAAA,GAiFa,GAAA,GAAA,IAAA,GAAA,GAAA,GAAA,IAAA,GAAA,GAAA,GAAA,IAAA,GAAA,GAAA,GAAA,IAAA;;AAGF;;;;;;;KAvEXM,eAAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;KAoDAY,kCAAkCpB,iBAAiBQ,oBAAoBa;;;;KAIvEC,iCAAiCD,cAAcrB,iBAAiBQ;;;;;;;;;;;KAWhEF,kBAAkBP;OACrBqB,iBAAiBf;;KAEdE,kBAAkBR;OACrBuB,eAAejB"}