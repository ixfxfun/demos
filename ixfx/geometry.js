import{n as e}from"./chunk-CVLEGGlw.js";import{bt as t}from"./src-DdJCbM4z.js";import{a as n,u as r,y as i}from"./numbers-BlBexQl9.js";import{t as a}from"./sort-DrK8Gr3I.js";import{i as o}from"./set-BX5QennO.js";import{c as s}from"./numeric-arrays-CRg0aU_z.js";import{t as c}from"./linear-space-DuZicrUG.js";import{t as l}from"./scale-DsFpif2S.js";import{A as u,C as d,E as ee,I as f,S as p,T as te,_ as ne,a as re,b as ie,c as ae,d as oe,f as se,g as ce,h as le,i as ue,k as m,l as de,m as fe,n as pe,o as h,p as me,r as he,s as ge,t as _e,u as ve,v as ye,w as be,x as xe,y as Se}from"./angles-DwQpnVfp.js";import{I as Ce,J as g,M as we,Q as Te,S as Ee,U as De,V as Oe,Z as ke,ct as Ae,et as _,g as je,i as v,lt as Me,z as Ne}from"./conversions-CmWd4trl.js";import{n as Pe,r as Fe,t as Ie}from"./rect-BBnae9UJ.js";import{B as Le,G as y,H as Re,J as b,K as ze,R as Be,U as Ve,V as He,W as Ue,X as We,Y as Ge,Z as Ke,_ as qe,a as Je,b as Ye,c as Xe,d as Ze,i as Qe,j as $e,m as et,n as x,o as tt,p as nt,q as S,r as rt,s as it,t as at,u as ot,v as C,x as st,y as ct,z as lt}from"./point-BnPODnGO.js";import{t as w}from"./from-top-left-blmXPyyI.js";import{t as ut}from"./bezier-DLbj6e9n.js";import{n as dt}from"./guard-CZZig1Fp.js";import{_ as T,a as ft,b as pt,c as mt,d as ht,g as gt,h as _t,i as vt,l as E,m as yt,n as bt,o as xt,p as St,r as D,s as Ct,t as wt,u as O,v as k,x as Tt,y as A}from"./corners-DSkNTQ9M.js";import{t as Et}from"./arrays-ILCJweVd.js";var Dt=e({angularSize:()=>Nt,bbox:()=>Rt,distanceCenter:()=>Bt,fromCircle:()=>Ft,fromCircleAmount:()=>It,fromDegrees:()=>kt,getStartEnd:()=>jt,guard:()=>N,interpolate:()=>Mt,isArc:()=>Ot,isEqual:()=>Vt,isPositioned:()=>j,length:()=>Lt,point:()=>M,toLine:()=>At,toPath:()=>Pt,toSvg:()=>zt});const Ot=e=>e.startRadian!==void 0&&e.endRadian!==void 0&&e.clockwise!==void 0,j=e=>e.x!==void 0&&e.y!==void 0;function kt(e,t,n,r,i){let a={radius:e,startRadian:h(t),endRadian:h(n),clockwise:r};if(f(i)){u(i);let e={...a,x:i.x,y:i.y};return Object.freeze(e)}else return Object.freeze(a)}const At=e=>De(M(e,e.startRadian),M(e,e.endRadian)),jt=(e,t)=>(N(e),[M(e,e.startRadian,t),M(e,e.endRadian,t)]),M=(e,t,n)=>(n===void 0&&(n=j(e)?e:{x:0,y:0}),{x:Math.cos(t)*e.radius+n.x,y:Math.sin(t)*e.radius+n.y}),N=e=>{if(e===void 0)throw TypeError(`Arc is undefined`);if(j(e)&&u(e,`arc`),e.radius===void 0)throw TypeError(`Arc radius is undefined (${JSON.stringify(e)})`);if(typeof e.radius!=`number`)throw TypeError(`Radius must be a number`);if(Number.isNaN(e.radius))throw TypeError(`Radius is NaN`);if(e.radius<=0)throw TypeError(`Radius must be greater than zero`);if(e.startRadian===void 0||e.endRadian===void 0)throw TypeError(`Arc is missing 'startRadian' field`);if(Number.isNaN(e.endRadian)||Number.isNaN(e.startRadian))throw TypeError(`Arc endRadian is NaN`);if(e.clockwise===void 0)throw TypeError(`Arc is missing 'clockwise field`);if(e.startRadian>=e.endRadian)throw TypeError(`startRadian is expected to be les than endRadian`)},Mt=(e,t,n,r)=>{if(N(t),!(n??!1)){if(e<0)throw Error(`Param 'amount' is under zero, and overflow is not allowed`);if(e>1)throw Error(`Param 'amount' is above 1 and overflow is not allowed`)}let i=Nt(t)*e;return M(t,p(t.startRadian,i,t.clockwise),r)},Nt=e=>me(e.startRadian,e.endRadian,e.clockwise),Pt=e=>(N(e),Object.freeze({...e,nearest:e=>{throw Error(`not implemented`)},interpolate:t=>Mt(t,e),bbox:()=>Rt(e),length:()=>Lt(e),toSvgString:()=>zt(e),relativePosition:(e,t)=>{throw Error(`Not implemented`)},distanceToPoint:e=>{throw Error(`Not implemented`)},kind:`arc`})),Ft=(e,t,n,r=!0)=>Object.freeze({...e,endRadian:n,startRadian:t,clockwise:r}),It=(e,t,n,r=!0)=>Ft(e,t,p(t,n,r)),Lt=e=>m*e.radius*((e.startRadian-e.endRadian)/m),Rt=e=>{if(j(e)){let t=Mt(.5,e),n=At(e);return st(t,n.a,n.b)}else return{width:e.radius*2,height:e.radius*2}},zt=(e,t,n,r,i)=>{if(Ot(e))return j(e)?f(t)?P(t,e.radius,e.startRadian,e.endRadian,n):P(e,e.radius,e.startRadian,e.endRadian,t):f(t)?P(t,e.radius,e.startRadian,e.endRadian,n):P({x:0,y:0},e.radius,e.startRadian,e.endRadian);if(n===void 0)throw Error(`startAngle undefined`);if(r===void 0)throw Error(`endAngle undefined`);if(f(e)){if(typeof t==`number`&&typeof n==`number`&&typeof r==`number`)return P(e,t,n,r,i);throw TypeError(`Expected (point, number, number, number). Missing a number param.`)}else throw Error(`Expected (point, number, number, number). Missing first point.`)},P=(e,t,n,r,i)=>{(i===void 0||typeof i!=`object`)&&(i={});let a=r-n===360,o=v(t,r-.01,e),s=v(t,n,e),{largeArc:c=!1,sweep:l=!1}=i,u=[`
    M ${o.x} ${o.y}
    A ${t} ${t} 0 ${c?`1`:`0`} ${l?`1`:`0`} ${s.x} ${s.y},
  `];return a&&u.push(`z`),u},Bt=(e,t)=>g(e,t),Vt=(e,t)=>{if(e.radius!==t.radius||e.endRadian!==t.endRadian||e.startRadian!==t.startRadian||e.clockwise!==t.clockwise)return!1;if(j(e)&&j(t)){if(e.x!==t.x||e.y!==t.y||e.z!==t.z)return!1}else if(!(!j(e)&&!j(t)))return!1;return!0},Ht=e=>(y(e),Math.PI*e.radius*e.radius),Ut=e=>b(e)?Fe(e,e.radius*2,e.radius*2):{width:e.radius*2,height:e.radius*2,x:0,y:0},Wt=e=>b(e)?Object.freeze({x:e.x,y:e.y}):Object.freeze({x:e.radius,y:e.radius});function*Gt(e){let{x:t,y:n,radius:r}=e,i=r,a=0,o=1-t;for(;i>=a;)yield{x:i+t,y:a+n},yield{x:a+t,y:i+n},yield{x:-i+t,y:a+n},yield{x:-a+t,y:i+n},yield{x:-i+t,y:-a+n},yield{x:-a+t,y:-i+n},yield{x:i+t,y:-a+n},yield{x:a+t,y:-i+n},a++,o<0?o+=2*a+1:(i--,o+=2*(a-i+1))}function*Kt(e){let t=e.x-e.radius,n=e.x+e.radius,r=e.y-e.radius,i=e.y+e.radius;for(let a=t;a<n;a++)for(let t=r;t<i;t++)Math.abs(g(e,a,t))<=e.radius&&(yield{x:a,y:t})}const qt=Math.PI*2,Jt=(e,t)=>{let n=e=>{let n=Math.sqrt((t.x-e.x)**2+(t.y-e.y)**2);return{x:e.x+e.radius*((t.x-e.x)/n),y:e.y+e.radius*((t.y-e.y)/n)}};if(Array.isArray(e)){let r=e.map(e=>n(e)),i=r.map(e=>g(e,t));return Object.freeze(r[s(i)])}else return Object.freeze(n(e))},Yt=(e,t,n)=>(n??=b(e)?e:{x:0,y:0},{x:Math.cos(-t)*e.radius+n.x,y:Math.sin(-t)*e.radius+n.y}),Xt=e=>(y(e),qt*e.radius),Zt=e=>Xt(e),Qt=Math.PI*2,$t=(e,t)=>Yt(e,t*Qt),en=(e,t,n)=>{let r=Ye(e,t);if(S(t))return r<Math.abs(e.radius-t.radius);if(f(t))return n===void 0?r<=e.radius:r<Math.abs(e.radius-n);throw Error(`b parameter is expected to be CirclePositioned or Point`)},F=(e,t,n)=>$e(e,t)||en(e,t,n)?!0:S(t)?Le(e,t):Me(t)?He(e,t):f(t)&&n!==void 0?Le(e,{...t,radius:n}):!1;function tn(e,t){if(b(e)){let n=je(e,t);return Object.freeze({...e,...n,radius:e.radius*t})}else return Object.freeze({...e,radius:e.radius*t})}const nn=Math.PI*2,rn=(e,t={})=>{let n=b(e)?e:{x:0,y:0},r=t.strategy??`uniform`,i=t.margin??0,a=e.radius-i,o=t.randomSource??Math.random;switch(r){case`naive`:return ke(n,v(o()*a,o()*nn));case`uniform`:return ke(n,v(Math.sqrt(o())*a,o()*nn));default:throw Error(`Unknown strategy '${r}'. Expects 'uniform' or 'naive'`)}},an=(e,t,n)=>{if(S(e)){if(n!==void 0)return I(e.radius,n,t);if(b(e))return I(e.radius,e,t);throw Error(`origin parameter needed for non-positioned circle`)}else if(n===void 0)throw Error(`origin parameter needed`);else return I(e,n,t)},I=(e,t,n)=>{let{x:r,y:i}=t,a=n?`1`:`0`;return`
    M ${r}, ${i}
    m -${e}, 0
    a ${e},${e} 0 1,${a} ${e*2},0
    a ${e},${e} 0 1,${a} -${e*2},0
  `.split(`
`)},on=e=>(y(e),{...e,nearest:t=>Jt(e,t),interpolate:t=>$t(e,t),bbox:()=>Ut(e),length:()=>Xt(e),toSvgString:(t=!0)=>an(e,t),relativePosition:(e,t)=>{throw Error(`Not implemented`)},distanceToPoint:e=>{throw Error(`Not implemented`)},kind:`circular`}),L=(e,t,n)=>{if(b(e))return e;let r=Te(t,n);return Object.freeze({...e,...r})};var sn=e({area:()=>Ht,bbox:()=>Ut,center:()=>Wt,circumference:()=>Xt,distanceCenter:()=>Ye,distanceFromExterior:()=>ct,exteriorIntegerPoints:()=>Gt,guard:()=>y,guardPositioned:()=>ze,interiorIntegerPoints:()=>Kt,interpolate:()=>$t,intersectionLine:()=>Re,intersections:()=>Ve,isCircle:()=>S,isCirclePositioned:()=>b,isContainedBy:()=>en,isEqual:()=>Ue,isIntersecting:()=>F,isNaN:()=>Ge,isPositioned:()=>We,length:()=>Zt,multiplyScalar:()=>tn,nearest:()=>Jt,pointOnPerimeter:()=>Yt,randomPoint:()=>rn,toPath:()=>on,toPositioned:()=>L,toSvg:()=>an}),cn=e({access:()=>ln,createArray:()=>_n,createMutable:()=>vn,set:()=>pn,setMutate:()=>dn,wrap:()=>gn,wrapMutable:()=>hn});const ln=(e,t)=>{let n=R(e,t);return(t,r=`undefined`)=>un(n,e,t,r)},un=(e,t,n,r)=>{let i=E(e,n,r);if(i!==void 0)return t[i]},dn=(e,t)=>{let n=R(e,t);return(t,r,i=`undefined`)=>fn(n,e,t,r,i)},fn=(e,t,n,r,i)=>{let a=E(e,r,i);if(a===void 0)throw RangeError(`Cell (${r.x},${r.y}) is out of range of grid cols: ${e.cols} rows: ${e.rows}`);return t[a]=n,t},pn=(e,t)=>{let n=R(e,t);return(t,r,i)=>mn(n,e,t,r,i)},mn=(e,t,n,r,i)=>{let a=E(e,r,i);if(a===void 0)throw RangeError(`Cell (${r.x},${r.y}) is out of range of grid cols: ${e.cols} rows: ${e.rows}`);let o=[...t];return o[a]=n,t=o,o},R=(e,t)=>({cols:t,rows:Math.ceil(e.length/t)}),hn=(e,t)=>({...R(e,t),get:ln(e,t),set:dn(e,t),get array(){return e}}),gn=(e,t)=>{let n=R(e,t);return{...n,get:(t,r=`undefined`)=>un(n,e,t,r),set:(r,i,a=`undefined`)=>(e=mn(n,e,r,i,a),gn(e,t)),get array(){return e}}},_n=(e,t,r)=>{let a=typeof t==`number`?t:t.rows,o=typeof t==`object`?t.cols:r;if(!o)throw Error(`Parameter 'columns' missing`);i(n(a,`aboveZero`,`rows`),n(o,`aboveZero`,`cols`));let s=[],c=a*o;for(let t=0;t<c;t++)s[t]=e;return s},vn=(e,t,n)=>{let r=typeof t==`number`?t:t.rows,i=typeof t==`object`?t.cols:n;if(!i)throw Error(`Parameter 'columns' missing`);return hn(_n(e,r,i),i)};var yn=e({access:()=>Sn,create:()=>z,set:()=>Tn,setMutate:()=>bn,wrap:()=>Dn,wrapMutable:()=>wn});const z=e=>{let t=NaN;for(let n of e)if(Number.isNaN(t))t=n.length;else if(t!==n.length)throw Error(`Array does not have uniform column length`);return{rows:e.length,cols:t}},bn=e=>{let t=z(e);return(n,r,i=`undefined`)=>xn(t,e,n,r,i)},xn=(e,t,n,r,i)=>{let a=T(e,r,i);if(a===void 0)throw RangeError(`Cell (${r.x},${r.y}) is out of range of grid cols: ${e.cols} rows: ${e.rows}`);return t[a.y][a.x]=n,t},Sn=e=>{let t=z(e);return(n,r=`undefined`)=>Cn(t,e,n,r)},Cn=(e,t,n,r)=>{let i=T(e,n,r);if(i!==void 0)return t[i.y][i.x]},wn=e=>({...z(e),get:Sn(e),set:bn(e),get array(){return e}}),Tn=e=>{let t=z(e);return(n,r,i)=>En(t,e,n,r,i)},En=(e,t,n,r,i)=>{let a=T(e,r,i);if(a===void 0)throw RangeError(`Cell (${r.x},${r.y}) is out of range of grid cols: ${e.cols} rows: ${e.rows}`);let o=[...t],s=[...o[a.y]];return s[a.x]=n,o[a.y]=s,t=o,o},Dn=e=>{let t=z(e);return{...t,get:(n,r=`undefined`)=>Cn(t,e,n,r),set:(n,r,i=`undefined`)=>(e=En(t,e,n,r,i),Dn(e)),get array(){return e}}},B=Object.freeze([`n`,`ne`,`nw`,`e`,`s`,`se`,`sw`,`w`]),On=Object.freeze([`n`,`e`,`s`,`w`]),kn=(e,r,a,o=`stop`)=>{A(e,`grid`),k(r,`start`),i(n(a,`aboveZero`,`steps`));let s=B,c=s.map(e=>An(e,a));return t(s,s.map((t,n)=>O(e,r,c[n],o)))},An=(e,t=1)=>{let n;switch(e){case`n`:n={x:0,y:-1*t};break;case`ne`:n={x:1*t,y:-1*t};break;case`e`:n={x:1*t,y:0};break;case`se`:n={x:1*t,y:1*t};break;case`s`:n={x:0,y:1*t};break;case`sw`:n={x:-1*t,y:1*t};break;case`w`:n={x:-1*t,y:0};break;case`nw`:n={x:-1*t,y:-1*t};break;default:n={x:0,y:0}}return Object.freeze(n)};var jn=e({cellValues:()=>St,cells:()=>yt,cellsAndValues:()=>_t});const Mn=(e,t)=>{k(e),k(t);let n=e.x,r=e.y,i=Math.abs(t.x-n),a=Math.abs(t.y-r),o=n<t.x?1:-1,s=r<t.y?1:-1,c=i-a,l=[];for(;l.push(Object.freeze({x:n,y:r})),!(n===t.x&&r===t.y);){let e=2*c;e>-a&&(c-=a,n+=o),e<i&&(c+=i,r+=s)}return l},Nn=function(e,t,n=!1){let r=[];if(e.x===t.x){let i=n?t.y+1:t.y;for(let t=e.y;t<i;t++)r.push({x:e.x,y:t})}else if(e.y===t.y){let i=n?t.x+1:t.x;for(let t=e.x;t<i;t++)r.push({x:t,y:e.y})}else throw Error(`Only does vertical and horizontal: ${e.x},${e.y} - ${t.x},${t.y}`);return r},Pn=(e,t)=>{if(t===void 0||e===void 0)return!1;if(`rows`in e&&`cols`in e)if(`rows`in t&&`cols`in t){if(e.rows!==t.rows||e.cols!==t.cols)return!1}else return!1;if(`size`in e)if(`size`in t){if(e.size!==t.size)return!1}else return!1;return!0},Fn=(e,t)=>t===void 0||e===void 0?!1:e.x===t.x&&e.y===t.y,V=e=>Et(e),In=e=>!(e===void 0||e[1]===void 0),Ln=(e,t,n,r)=>{let i=Rn(e,t,r,n);return Object.entries(i).filter(e=>In(e))},Rn=(e,n,r=`undefined`,i)=>{let a=i??B;return t(a,a.map(t=>O(e,n,An(t),r)))},zn=(e,t)=>{let n=[];for(let r=0;r<e.rows;r++)if(n[r]=Array.from({length:e.cols}),t)for(let i=0;i<e.cols;i++)n[r][i]=t;return n},Bn=e=>`Cell{${e.x},${e.y}}`;function*Vn(e){for(let t of yt(e))yield Un(e,t)}const Hn=(e,t)=>{let n=e.size;if(i(r(n,`positive`,`grid.size`)),t.x<0||t.y<0)return;let a=Math.floor(t.x/n),o=Math.floor(t.y/n);if(!(a>=e.cols)&&!(o>=e.rows))return{x:a,y:o}},Un=(e,t)=>{k(t);let n=e.size;return w({x:t.x*n,y:t.y*n},n,n)},Wn=(e,t)=>{k(t);let n=e.size,r=t.x*n,i=t.y*n;return Object.freeze({x:r+n/2,y:i+n/2})},Gn=()=>({select:e=>e[0]}),Kn=()=>({select:e=>e.at(0),getNeighbours:(e,t)=>Ln(e,t,B,`undefined`)}),qn=(e={})=>{let t=e.reversed??!1;return{select:e=>e.find(e=>e[0]===(t?`n`:`s`)),getNeighbours:(e,n)=>(n=t?n.y>0?{x:n.x,y:n.y-1}:n.x===0?{x:e.cols-1,y:e.rows-1}:{x:n.x-1,y:e.rows-1}:n.y<e.rows-1?{x:n.x,y:n.y+1}:n.x<e.cols-1?{x:n.x+1,y:0}:{x:0,y:0},[[t?`n`:`s`,n]])}},Jn=()=>({select:e=>e.at(-1)}),Yn=()=>({getNeighbours:(e,t)=>{let n=[];for(let r of yt(e,t))n.push([`n`,r]);return n},select:V}),Xn=()=>({select:V}),Zn=(e={})=>{let t=e.reversed??!1;return{select:e=>e.find(e=>e[0]===(t?`w`:`e`)),getNeighbours:(e,n)=>(n=t?n.x>0?{x:n.x-1,y:n.y}:n.y>0?{x:e.cols-1,y:n.y-1}:{x:e.cols-1,y:e.rows-1}:n.x<e.rows-1?{x:n.x+1,y:n.y}:n.y<e.rows-1?{x:0,y:n.y+1}:{x:0,y:0},[[t?`w`:`e`,n]])}};function*Qn(e,t,n={}){A(t,`grid`);let r=n.start??{x:0,y:0};k(r,`opts.start`,t);let i=n.visited??o(Bn),a=e.getNeighbours??((e,t)=>Ln(e,t,On,`undefined`)),s=[r],c=[],l;for(;s.length>0;){if(l===void 0){let e=s.pop();if(e===void 0)break;l=e}if(!i.has(l)){i.add(l),yield l;let e=a(t,l).filter(e=>e[1]===void 0?!1:!i.has(e[1]));if(e.length===0)l!==void 0&&(s=s.filter(e=>Fn(e,l)));else for(let t of e)t!==void 0&&t[1]!==void 0&&c.push(t)}if(c=c.filter(e=>!i.has(e[1])),c.length===0)l=void 0;else{let t=e.select(c);t!==void 0&&(s.push(t[1]),l=t[1])}}}const $n=(e,t,r={x:0,y:0},a=1)=>{A(e,`grid`),k(r,`start`),i(n(a,``,`resolution`));let o=[],s=0,c=0;for(let n of t(e,{start:r,boundsWrap:`undefined`}))s++,s%a===0&&o.push(n);return(e,t=!1)=>(i(n(e,``,`step`)),t?c=e:c+=e,o.at(c%o.length))};var er=e({breadthLogic:()=>Gn,columnLogic:()=>qn,create:()=>tr,depthLogic:()=>Jn,neighboursLogic:()=>Kn,randomContiguousLogic:()=>Xn,randomLogic:()=>Yn,rowLogic:()=>Zn,stepper:()=>$n,visitByNeighbours:()=>Qn,withLogic:()=>H});const tr=(e,t={})=>{switch(e){case`random-contiguous`:return H(Xn(),t);case`random`:return H(Yn(),t);case`depth`:return H(Jn(),t);case`breadth`:return H(Gn(),t);case`neighbours`:return H(Kn(),t);case`row`:return H(Zn(t),t);case`column`:return H(qn(t),t);default:throw TypeError(`Param 'type' unknown. Value: ${e}`)}},H=(e,t={})=>(n,r={})=>Qn(e,n,{...t,...r});var nr=e({Array1d:()=>cn,Array2d:()=>yn,As:()=>ht,By:()=>jn,Visit:()=>er,allDirections:()=>B,applyBounds:()=>T,asRectangles:()=>Vn,cellAtPoint:()=>Hn,cellEquals:()=>Fn,cellFromIndex:()=>mt,cellKeyString:()=>Bn,cellMiddle:()=>Wn,crossDirections:()=>On,getLine:()=>Mn,getVectorFromCardinal:()=>An,guardCell:()=>k,guardGrid:()=>A,indexFromCell:()=>E,inside:()=>Tt,isCell:()=>pt,isEqual:()=>Pn,neighbourList:()=>Ln,neighbours:()=>Rn,offset:()=>O,offsetCardinals:()=>kn,randomNeighbour:()=>V,rectangleForCell:()=>Un,simpleLine:()=>Nn,toArray2d:()=>zn,values:()=>gt});const rr=function(e){if(dt(e)||Ne(e))return e.a;throw Error(`Unknown path type ${JSON.stringify(e)}`)},ir=function(e){if(dt(e)||Ne(e))return e.b;throw Error(`Unknown path type ${JSON.stringify(e)}`)};var ar=e({bbox:()=>ur,computeDimensions:()=>U,distanceToPoint:()=>cr,fromPaths:()=>mr,guardContinuous:()=>fr,interpolate:()=>sr,relativePosition:()=>lr,setSegment:()=>or,toString:()=>dr,toSvgString:()=>pr});const or=(e,t,n)=>{let r=[...e.segments];return r[t]=n,mr(...r)},sr=(e,t,n,r)=>{r===void 0&&(r=U(e));let i=t*(n?r.totalWidth:r.totalLength),a=0,o=n?r.widths:r.lengths;for(let[t,n]of o.entries())if(a+n>=i){let r=(i-a)/n;return r>1&&(r=1),e[t].interpolate(r)}else a+=n;return{x:0,y:0}},cr=(e,t)=>{if(e.length===0)return 0;let n=e.map((e,n)=>({path:e,index:n,distance:e.distanceToPoint(t)}));if(n=a(n,`distance`),n.length===0)throw Error(`Could not look up distances`);return n[0].distance},lr=(e,t,n,r)=>{r===void 0&&(r=U(e));let i=e.map((e,n)=>({path:e,index:n,distance:e.distanceToPoint(t)}));if(i=a(i,`distance`),i.length<0)throw Error(`Point does not intersect with path`);let o=i[0];if(o.distance>n)throw Error(`Point does not intersect with path. Minimum distance: ${o.distance}, threshold: ${n}`);let s=o.path.relativePosition(t,n),c=0;for(let e=0;e<o.index;e++)c+=r.lengths[e];c+=r.lengths[o.index]*s;let l=c/r.totalLength;return console.log(`acc: ${c} rel: ${l} on path: ${s} path: ${o.index}`),l},U=e=>{let t=e.map(e=>e.bbox().width),n=e.map(e=>e.length()),r=0,i=0;for(let e of n)r+=e;for(let e of t)i+=e;return{totalLength:r,totalWidth:i,widths:t,lengths:n}},ur=e=>st(...e.map(e=>e.bbox()).flatMap(e=>_(e))),dr=e=>e.map(e=>e.toString()).join(`, `),fr=e=>{let t=ir(e[0]);for(let n=1;n<e.length;n++){let r=rr(e[n]);if(!$e(r,t))throw Error(`Path index ${n} does not start at prior path end. Start: ${r.x},${r.y} expected: ${t.x},${t.y}`);t=ir(e[n])}},pr=e=>e.flatMap(e=>e.toSvgString()),mr=(...e)=>{fr(e);let t=U(e);return Object.freeze({segments:e,length:()=>t.totalLength,nearest:e=>{throw Error(`not implemented`)},interpolate:(n,r=!1)=>sr(e,n,r,t),relativePosition:(n,r)=>lr(e,n,r,t),distanceToPoint:t=>cr(e,t),bbox:()=>ur(e),toString:()=>dr(e),toSvgString:()=>pr(e),kind:`compound`})};var hr=e({bbox:()=>ur,computeDimensions:()=>U,distanceToPoint:()=>cr,fromPaths:()=>mr,getEnd:()=>ir,getStart:()=>rr,guardContinuous:()=>fr,interpolate:()=>sr,relativePosition:()=>lr,setSegment:()=>or,toString:()=>dr,toSvgString:()=>pr});const gr=Object.freeze({a:{x:0,y:0},b:{x:0,y:0},c:{x:0,y:0}}),_r=Object.freeze({a:{x:NaN,y:NaN},b:{x:NaN,y:NaN},c:{x:NaN,y:NaN}}),W=(e,t=10,n=Math.PI/2)=>{e||=Object.freeze({x:0,y:0});let r=Qe(e,t,Math.PI- -n/2),i=Qe(e,t,Math.PI-n/2);return{a:r,b:e,c:i}},vr=(e,t,n={})=>{let r=n.tailLength??10,i=n.tailThickness??Math.max(r/5,5),a=n.angleRadian??0,o=n.arrowSize??Math.max(r/5,15),s=Math.PI/2,c,l;if(t===`tip`)c=W(e,o,s),l=_(w({x:c.a.x-r,y:e.y-i/2},r,i));else if(t===`middle`){let t=r+o/2,n=i/2;c=W({x:e.x+o*1.2,y:e.y},o,s),l=_(w({x:e.x-t,y:e.y-n},r+o,i))}else l=_(w({x:e.x,y:e.y-i/2},r,i)),c=W({x:e.x+r+o*.7,y:e.y},o,s);return x([l[0],l[1],c.a,c.b,c.c,l[2],l[3]],a,e)},G=e=>{D(e);let t=rt([e.a,e.b,e.c],(e,t)=>({x:e.x+t.x,y:e.y+t.y}));return{x:t.x/3,y:t.y/3}},yr=(e,t={})=>{if(b(e))return rn(e,t);if(Me(e))return Pe(e,t);throw Error(`Unknown shape. Only CirclePositioned and RectPositioned are supported.`)},br=e=>{if(e===void 0)return Object.freeze({x:.5,y:.5});if(Ae(e))return Ke(e);if(Ct(e))return G(e);if(S(e))return Wt(e);throw Error(`Unknown shape: ${JSON.stringify(e)}`)},xr=(e,t)=>{if(b(e))return F(e,t);if(Me(e))return lt(e,t);throw Error(`a or b are unknown shapes. a: ${JSON.stringify(e)} b: ${JSON.stringify(t)}`)},Sr=(e,t=5,r,a=Ee,o)=>{i(n(t,`positive`,`points`));let s=Math.PI*2/t,c=s/2,l=o?.initialAngleRadian??-Math.PI/2;r===void 0&&(r=e/2);let u=l,d=[];for(let n=0;n<t;n++){let i=v(e,u,a),o=v(r,u-c,a),l=v(r,u+c,a);d.push(o,i),n+1<t&&d.push(l),u+=s}return d};var Cr=e({arrow:()=>vr,center:()=>br,isIntersecting:()=>xr,randomPoint:()=>yr,starburst:()=>Sr}),wr=e({fromPoints:()=>Tr,init:()=>Er});const Tr=(e,t={})=>Er(Oe(...e).map(e=>Ze(e)),t),Er=(e,t={})=>{let n=t.maxDistanceFromLine??.1;return t=>{let r=a(e.map((e,r)=>{let i=e.nearest(t),a=g(t,i);return{positionRelative:e.relativePosition(i,n),path:e,index:r,nearest:i,distance:a,rank:2**53-1}}).filter(e=>e.distance<=n),`distance`);for(let e=0;e<r.length;e++)r[e].rank=e;return r}};var Dr=e({random:()=>Or});const Or=(e,t,n={})=>{if(!Array.isArray(e))throw Error(`Parameter 'circles' is not an array`);let r=n.attempts??2e3,i=a(e,`radius`),o=[],s=(e,t)=>o.some(n=>F(n,e,t));for(;i.length>0;){let e=i.pop();if(!e)break;let a={...n,margin:{x:e.radius,y:e.radius}};for(let n=0;n<r;n++){let n=yr(t,a);if(!s(n,e.radius)){o.push(Object.freeze({...e,...n}));break}}}return o};function*kr(e,t={}){let n=t.rings??5,r=L(e??{radius:1,x:0,y:0}),i=1/n,a=t.rotation??0,o=Math.cos,s=Math.sin,l=Math.asin,u=Math.PI,d=Math.PI*2,ee=1;yield Object.freeze({x:r.x,y:r.y});for(let e=i;e<=1;e+=i){let t=Math.round(u/l(1/(2*ee)));for(let n of c(0,d,t+1))yield Object.freeze({x:r.x+e*o(n+a)*r.radius,y:r.y+e*s(n+a)*r.radius});ee++}}var Ar=e({CirclePacking:()=>Dr,circleRings:()=>kr}),jr=e({fromDegrees:()=>Mr});const Mr=(e,t,n=0,r=0,i=360)=>({radiusX:e,radiusY:t,rotation:h(n),startAngle:h(r),endAngle:h(i)});var Nr=e({rdpPerpendicularDistance:()=>Fr,rdpShortestDistance:()=>Pr});const Pr=(e,t=.1)=>{let n=e[0],r=e.at(-1);if(e.length<3)return e;let i=-1,a=0;for(let t=1;t<e.length-1;t++){let o=Lr(e[t],n,r);o>a&&(a=o,i=t)}if(a>t){let n=e.slice(0,i+1),r=e.slice(i),a=Pr(n,t),o=Pr(r,t);return[...a.slice(0,-1),...o]}else return[n,r]},Fr=(e,t=.1)=>{let n=e[0],r=e.at(-1);if(e.length<3)return e;let i=-1,a=0;for(let t=1;t<e.length-1;t++){let o=Ir(e[t],n,r);o>a&&(a=o,i=t)}if(a>t){let n=e.slice(0,i+1),r=e.slice(i),a=Fr(n,t),o=Fr(r,t);return[...a.slice(0,-1),...o]}else return[n,r]};function Ir(e,t,n){let r,i,a;return t.x==n.x?r=Math.abs(e.x-t.x):(i=(n.y-t.y)/(n.x-t.x),a=t.y-i*t.x,r=Math.abs(i*e.x-e.y+a)/Math.sqrt(i**2+1)),r}const Lr=(e,t,n)=>{let r=g(t,n);if(r==0)return g(e,t);let i=((e.x-t.x)*(n.x-t.x)+(e.y-t.y)*(n.y-t.y))/r;return i<0?g(e,t):i>1?g(e,n):g(e,{x:t.x+i*(n.x-t.x),y:t.y+i*(n.y-t.y)})};var Rr=e({Direction:()=>zr,QuadTreeNode:()=>Vr,quadTree:()=>Br});let zr=function(e){return e[e.Nw=0]=`Nw`,e[e.Ne=1]=`Ne`,e[e.Sw=2]=`Sw`,e[e.Se=3]=`Se`,e}({});const Br=(e,t=[],n={})=>{let r=new Vr(void 0,e,0,{maxItems:n.maxItems??4,maxLevels:n.maxLevels??4});for(let e of t)r.add(e);return r};var Vr=class e{#e=[];#t=[];#n;constructor(e,t,n,r){this.boundary=t,this.level=n,this.opts=r,this.#n=e}getLengthChildren(){return this.#t.length}*parents(){let e=this;for(;e.#n!==void 0;)yield e.#n,e=e.#n}getParent(){return this.#n}*children(){for(let e of this.#t)yield e}getValue(){return this.#e}getIdentity(){return this}direction(e){return this.#t[e]}add(e){if(!xr(this.boundary,e))return!1;if(this.#t.length>0){for(let t of this.#t)t.add(e);return!0}if(this.#e.push(e),this.#e.length>this.opts.maxItems&&this.level<this.opts.maxLevels){this.#t.length===0&&this.#r();for(let e of this.#e)for(let t of this.#t)t.add(e);this.#e=[]}return!0}couldHold(e){return Be(this.boundary,e)}#r(){let t=this.boundary.width/2,n=this.boundary.height/2,r=this.boundary.x,i=this.boundary.y;this.#t=qe(r+t,i,r,i,r,i+n,r+t,i+n).map(e=>w(e,t,n)).map(t=>new e(this,t,this.level+1,this.opts))}},Hr=e({circleVogelSpiral:()=>Zr,ring:()=>$r,sphereFibonacci:()=>Qr});const Ur=Math.cos,Wr=Math.sin,Gr=Math.sqrt,Kr=Math.pow,qr=Math.PI,Jr=Math.PI*2,Yr=qr*(3-Gr(5)),Xr=(1+Gr(5))/2;function*Zr(e,t={}){let n=t.maxPoints??5e3,r=t.density??.95,i=t.rotation??0,a=L(e??{radius:1,x:0,y:0}),o=a.radius,s=a.radius*l(r,0,1,.3,.01);t.spacing&&(s=t.spacing);let c=0,u=0,d=0;for(;u<n&&c<o;)c=s*u**.5,d=i+u*2*qr/Xr,yield Object.freeze({x:a.x+c*Ur(d),y:a.y+c*Wr(d)}),u++}function*Qr(e=100,t=0,n){let r=2/e,i=n??{x:0,y:0,z:0,radius:1};for(let n=0;n<e;n++){let a=n*r-1+r/2,o=Gr(1-Kr(a,2)),s=(n+1)%e*Yr+t,c=Ur(s)*o,l=Wr(s)*o;yield Object.freeze({x:i.x+c*i.radius,y:i.y+a*i.radius,z:i.z+l*i.radius})}}function*$r(e,t){let n=qr,r=t.offset??0;if(`count`in t?n=(Jr-r)/t.count:`radians`in t?n=t.radians:`degrees`in t&&(n=h(t.degrees)),r<0)throw Error(`Offset should be at least 0`);if(r>Jr)throw Error(`Offset should be less than 2*PI`);if(n===0)throw Error(`Interval cannot be 0`);for(;r<Jr;)yield v({angleRadian:r,distance:e.radius},e),r+=n}const K=e=>(D(e),[we(e.a,e.b),we(e.b,e.c),we(e.c,e.a)]),ei=e=>(D(e),ce(K(e))),q=e=>(D(e),Oe(e.a,e.b,e.c,e.a)),ti=e=>{D(e,`t`);let t=q(e).map(e=>Ce(e)),n=(t[0]+t[1]+t[2])/2;return Math.sqrt(n*(n-t[0])*(n-t[1])*(n-t[2]))},ni=(e,t,n)=>{let r=Te(t,n),i=(e,t,n,r)=>(n.y-r.y)*e+(r.x-n.x)*t+n.x*r.y-r.x*n.y;return{a:i(r.x,r.y,e.b,e.c)/i(e.a.x,e.a.y,e.b,e.c),b:i(r.x,r.y,e.c,e.a)/i(e.b.x,e.b.y,e.c,e.a),c:i(r.x,r.y,e.a,e.b)/i(e.c.x,e.c.y,e.a,e.b)}},ri=(e,t)=>{D(e);let{a:n,b:r,c:i}=e,a=n.x*t.a+r.x*t.b+i.x*t.c,o=n.y*t.a+r.y*t.b+i.y*t.c;if(n.z&&r.z&&i.z){let e=n.z*t.a+r.z*t.b+i.z*t.c;return Object.freeze({x:a,y:o,z:e})}else return Object.freeze({x:a,y:o})},ii=(e,t=0)=>{let{a:n,b:r,c:i}=e,a=Math.min(n.x,r.x,i.x)-t,o=Math.max(n.x,r.x,i.x)+t,s=Math.min(n.y,r.y,i.y)-t,c=Math.max(n.y,r.y,i.y)+t;return{x:a,y:s,width:o-a,height:c-s}},ai=(e,t,n={})=>{i(r(t,`positive`,`radius`)),u(e,`origin`);let a=n.initialAngleRadian??0;return si([a,a+m*1/3,a+m*2/3].map(n=>v(t,n,e)))},oi=e=>{if(!Array.isArray(e))throw Error(`coords expected as array`);if(e.length!==6)throw Error(`coords array expected with 6 elements. Got ${e.length}`);return si(qe(...e))},si=e=>{if(!Array.isArray(e))throw Error(`points expected as array`);if(e.length!==3)throw Error(`points array expected with 3 elements. Got ${e.length}`);return{a:e[0],b:e[1],c:e[2]}},ci=e=>(D(e),q(e).reduce((e,t)=>e+Ce(t),0)),li=e=>{let t=G(e),n=ci(e)/2;return{radius:ti(e)/n,...t}},ui=(e,t,n)=>{let r=ii(e),i=Te(t,n);if(!Be(r,i))return!1;let a=ni(e,i);return 0<=a.a&&a.a<=1&&0<=a.b&&a.b<=1&&0<=a.c&&a.c<=1},di=e=>(D(e),[g(e.a,e.b),g(e.b,e.c),g(e.c,e.a)]),fi=e=>{D(e);let[t,n,r]=di(e);return t===n&&n===r},pi=e=>{let[t,n,r]=di(e);return t===n||n===r||r===t},mi=e=>K(e).includes(Math.PI/2),hi=e=>!mi(e),gi=e=>!K(e).some(e=>e>=Math.PI/2),_i=e=>K(e).some(e=>e>Math.PI/2),vi=(e,t)=>Object.freeze({...e,a:t(e.a,`a`),b:t(e.b,`b`),c:t(e.c,`c`)}),yi=e=>{let[t,n,r]=q(e).map(e=>Ce(e)),i=G(e);return{radius:t*n*r/Math.sqrt((t+n+r)*(-t+n+r)*(t-n+r)*(t+n-r)),...i}},bi=(e,t,n)=>t===void 0||t===0?e:(n===void 0&&(n=G(e)),Object.freeze({...e,a:x(e.a,t,n),b:x(e.b,t,n),c:x(e.c,t,n)})),xi=(e,t,n=`b`)=>{let r=n===`a`?e.a:n===`b`?e.b:e.c;return Object.freeze({a:x(e.a,t,r),b:x(e.b,t,r),c:x(e.c,t,r)})},Si=e=>(D(e),[e.a.x,e.a.y,e.b.x,e.b.y,e.c.x,e.c.y]);var Ci=e({area:()=>Mi,centerFromA:()=>Di,centerFromB:()=>Oi,centerFromC:()=>ki,circumcircle:()=>Ni,fromCenter:()=>Ei,height:()=>Ai,incircle:()=>Y,perimeter:()=>ji});const wi=Math.PI*4/3,Ti=Math.PI*2/3,J=e=>typeof e==`number`?e:e.length,Ei=(e,t,n)=>{t||=Object.freeze({x:0,y:0});let r=J(e)/Math.sqrt(3),i=n??Math.PI*1.5,a={x:r*Math.cos(i)+t.x,y:r*Math.sin(i)+t.y},o={x:r*Math.cos(i+wi)+t.x,y:r*Math.sin(i+wi)+t.y},s={x:r*Math.cos(i+Ti)+t.x,y:r*Math.sin(i+Ti)+t.y};return Object.freeze({a:o,b:a,c:s})},Di=(e,t)=>{t||=Object.freeze({x:0,y:0});let n=J(e),{radius:r}=Y(e);return{x:t.x+n/2,y:t.y-r}},Oi=(e,t)=>{t||=Object.freeze({x:0,y:0});let{radius:n}=Y(e);return{x:t.x,y:t.y+n*2}},ki=(e,t)=>{t||=Object.freeze({x:0,y:0});let n=J(e),{radius:r}=Y(e);return{x:t.x-n/2,y:t.y-r}},Ai=e=>Math.sqrt(3)/2*J(e),ji=e=>J(e)*3,Mi=e=>J(e)**2*Math.sqrt(3)/4,Ni=e=>({radius:Math.sqrt(3)/3*J(e)}),Y=e=>({radius:Math.sqrt(3)/6*J(e)});var Pi=e({adjacentFromHypotenuse:()=>qi,adjacentFromOpposite:()=>Ji,angleAtPointA:()=>Bi,angleAtPointB:()=>Vi,area:()=>zi,circumcircle:()=>Ui,fromA:()=>Fi,fromB:()=>Ii,fromC:()=>Li,height:()=>Z,hypotenuseFromAdjacent:()=>Xi,hypotenuseFromOpposite:()=>Yi,hypotenuseSegments:()=>Q,incircle:()=>Wi,medians:()=>Hi,oppositeFromAdjacent:()=>Gi,oppositeFromHypotenuse:()=>Ki,perimeter:()=>Ri,resolveLengths:()=>X});const Fi=(e,t)=>{t||=Object.freeze({x:0,y:0});let n=X(e),r=Q(e),i=Z(e);return{a:{x:t.x,y:t.y},b:{x:t.x+n.hypotenuse,y:t.y},c:{x:t.x+r[1],y:t.y-i}}},Ii=(e,t)=>{t||=Object.freeze({x:0,y:0});let n=X(e),r=Q(e),i=Z(e),a={x:t.x,y:t.y};return{a:{x:t.x-n.hypotenuse,y:t.y},b:a,c:{x:t.x-r[0],y:t.y-i}}},Li=(e,t)=>{t||=Object.freeze({x:0,y:0});let n=Q(e),r=Z(e),i={x:t.x,y:t.y};return{a:{x:t.x-n[1],y:t.y+r},b:{x:t.x+n[0],y:t.y+r},c:i}},X=e=>{let t=e.adjacent,n=e.opposite,r=e.hypotenuse;if(t!==void 0&&n!==void 0)return{...e,adjacent:t,opposite:n,hypotenuse:Math.hypot(t,n)};if(t&&r)return{...e,adjacent:t,hypotenuse:r,opposite:r*r-t*t};if(n&&r)return{...e,hypotenuse:r,opposite:n,adjacent:r*r-n*n};if(e.opposite&&e.hypotenuse&&e.adjacent)return e;throw Error(`Missing at least two edges`)},Z=e=>{let t=X(e),n=t.opposite*t.opposite/t.hypotenuse,r=t.adjacent*t.adjacent/t.hypotenuse;return Math.sqrt(n*r)},Q=e=>{let t=X(e);return[t.opposite*t.opposite/t.hypotenuse,t.adjacent*t.adjacent/t.hypotenuse]},Ri=e=>{let t=X(e);return t.adjacent+t.hypotenuse+t.opposite},zi=e=>{let t=X(e);return t.opposite*t.adjacent/2},Bi=e=>{let t=X(e);return Math.acos((t.adjacent*t.adjacent+t.hypotenuse*t.hypotenuse-t.opposite*t.opposite)/(2*t.adjacent*t.hypotenuse))},Vi=e=>{let t=X(e);return Math.acos((t.opposite*t.opposite+t.hypotenuse*t.hypotenuse-t.adjacent*t.adjacent)/(2*t.opposite*t.hypotenuse))},Hi=e=>{let t=X(e),n=t.adjacent*t.adjacent,r=t.hypotenuse*t.hypotenuse,i=t.opposite*t.opposite;return[Math.sqrt(2*(n+r)-i)/2,Math.sqrt(2*(r+i)-n)/2,Math.sqrt(2*(i+n)-r)/2]},Ui=e=>({radius:X(e).hypotenuse/2}),Wi=e=>{let t=X(e);return{radius:(t.adjacent+t.opposite-t.hypotenuse)/2}},Gi=(e,t)=>Math.tan(e)*t,Ki=(e,t)=>Math.sin(e)*t,qi=(e,t)=>Math.cos(e)*t,Ji=(e,t)=>t/Math.tan(e),Yi=(e,t)=>t/Math.sin(e),Xi=(e,t)=>t/Math.cos(e);var Zi=e({apexAngle:()=>$i,area:()=>na,baseAngle:()=>Qi,circumcircle:()=>ra,fromA:()=>sa,fromB:()=>ca,fromC:()=>la,fromCenter:()=>oa,height:()=>$,incircle:()=>ia,legHeights:()=>ea,medians:()=>aa,perimeter:()=>ta});const Qi=e=>Math.acos(e.base/(2*e.legs)),$i=e=>{let t=e.legs*e.legs,n=e.base*e.base;return Math.acos((2*t-n)/(2*t))},$=e=>{let t=e.legs*e.legs,n=e.base*e.base;return Math.sqrt((4*t-n)/4)},ea=e=>{let t=Qi(e);return e.base*Math.sin(t)},ta=e=>2*e.legs+e.base,na=e=>$(e)*e.base/2,ra=e=>{let t=$(e),n=t*t,r=e.base*e.base;return{radius:(4*n+r)/(8*t)}},ia=e=>{let t=$(e);return{radius:e.base*t/(2*e.legs+e.base)}},aa=e=>{let t=e.legs*e.legs,n=e.base*e.base,r=Math.sqrt(t+2*n)/2;return[r,r,Math.sqrt(4*t-n)/2]},oa=(e,t)=>{t||=Object.freeze({x:0,y:0});let n=$(e),r=ia(e).radius,i=n-r;return{a:{x:t.x-e.base/2,y:t.y+r},b:{x:t.x+e.base/2,y:t.y+r},c:{x:t.x,y:t.y-i}}},sa=(e,t)=>{t||=Object.freeze({x:0,y:0});let n=$(e);return{a:{x:t.x,y:t.y},b:{x:t.x+e.base,y:t.y},c:{x:t.x+e.base/2,y:t.y-n}}},ca=(e,t)=>{t||=Object.freeze({x:0,y:0});let n=$(e),r={x:t.x,y:t.y};return{a:{x:t.x-e.base,y:t.y},b:r,c:{x:t.x-e.base/2,y:t.y-n}}},la=(e,t)=>{t||=Object.freeze({x:0,y:0});let n=$(e),r={x:t.x,y:t.y};return{a:{x:t.x-e.base/2,y:t.y+n},b:{x:t.x+e.base/2,y:t.y+n},c:r}};var ua=e({Empty:()=>gr,Equilateral:()=>Ci,Isosceles:()=>Zi,Placeholder:()=>_r,Right:()=>Pi,angles:()=>K,anglesDegrees:()=>ei,apply:()=>vi,area:()=>ti,barycentricCoord:()=>ni,barycentricToCartestian:()=>ri,bbox:()=>ii,centroid:()=>G,corners:()=>wt,edges:()=>q,equilateralFromVertex:()=>W,fromFlatArray:()=>oi,fromPoints:()=>si,fromRadius:()=>ai,guard:()=>D,innerCircle:()=>li,intersectsPoint:()=>ui,isAcute:()=>gi,isEmpty:()=>vt,isEqual:()=>ft,isEquilateral:()=>fi,isIsosceles:()=>pi,isOblique:()=>hi,isObtuse:()=>_i,isPlaceholder:()=>xt,isRightAngle:()=>mi,isTriangle:()=>Ct,lengths:()=>di,outerCircle:()=>yi,perimeter:()=>ci,rotate:()=>bi,rotateByVertex:()=>xi,toFlatArray:()=>Si}),da=e({asFan:()=>ga,intersections:()=>fa,raycast2d:()=>ma});function*fa(e,t,n){for(let r=0;r<n.length;r++){let i=n[r],a=pa(e.x,e.y,t.x,t.y,[i.a.x,i.a.y,i.b.x,i.b.y]);if(Number.isFinite(a)){let n=Math.sqrt(a);yield{x:e.x+t.x*n,y:e.y+t.y*n,d:n,line:r}}}}function pa(e,t,n,r,i){let a=i[2]-i[0],o=i[3]-i[1],s=i[0]-e,c=i[1]-t,l=C(n,r,a,o);if(l===0)return 1/0;let u=C(s,c,a,o)/l;if(u<=0)return 1/0;let d=C(s,c,n,r)/l;return d<0||d>1?1/0:u*u}function ma(e){let t=e.map(e=>[e.a.x,e.a.y,e.b.x,e.b.y]);return e=>ha(e,t)}function ha(e,t,n=1e-4){let r=e.x,i=e.y,a=[];for(let e=0;e<t.length;e++){let o=t[e],s=Math.atan2(o[1]-i,o[0]-r),c=Math.atan2(o[3]-i,o[2]-r);a.push({angle:s-n,x:Math.cos(s-n),y:Math.sin(s-n)},{angle:s,x:Math.cos(s),y:Math.sin(s)},{angle:s+n,x:Math.cos(s+n),y:Math.sin(s+n)},{angle:c-n,x:Math.cos(c-n),y:Math.sin(c-n)},{angle:c,x:Math.cos(c),y:Math.sin(c)},{angle:c+n,x:Math.cos(c+n),y:Math.sin(c+n)})}a.sort((e,t)=>e.angle-t.angle);let o=[];for(let e=0;e<a.length;e++){let n=a[e],s=1/0,c=0,l=0,u=-1;for(let e=0;e<t.length;e++){let a=pa(r,i,n.x,n.y,t[e]);if(a<s){s=a;let t=Math.sqrt(a);c=r+n.x*t,l=i+n.y*t,u=e}}s<1/0&&o.push({d:s,x:c,y:l,line:u})}return o}function ga(e,t){let n=t.x,r=t.y;return e.sort((e,t)=>Math.atan2(e.y-r,e.x-n)-Math.atan2(t.y-r,t.x-n)),e.push({...e[0]}),e}export{Dt as Arcs,ut as Beziers,sn as Circles,ar as Compound,Nr as CurveSimplification,jr as Ellipses,nr as Grids,Ar as Layouts,ot as Lines,hr as Paths,Je as PointTracker,at as Points,tt as PointsTracker,et as Polar,Rr as QuadTree,da as Rays,Ie as Rects,Cr as Shapes,Hr as SurfacePoints,ua as Triangles,it as UserPointerTracker,Xe as UserPointersTracker,nt as Vectors,wr as Waypoints,_e as angleConvert,pe as angleParse,he as average,ue as degreeArc,re as degreeToGradian,h as degreeToRadian,ge as degreeToTurn,ae as degreesSum,de as fromUnitVector,ve as gradianToDegree,oe as gradianToRadian,se as isAngleType,me as radianArc,fe as radianInvert,le as radianRange,ce as radianToDegree,ne as radianToGradian,ye as radianToTurn,Se as radiansBetweenCircular,ie as radiansFromAxisX,xe as radiansNormalise,p as radiansSum,bt as scaler,d as toRadian,be as toUnitVector,te as turnToDegree,ee as turnToRadian};