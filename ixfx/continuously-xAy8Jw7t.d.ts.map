{"version":3,"file":"continuously-xAy8Jw7t.d.ts","names":["Interval","HasCompletionRunStates","HasCompletion","Continuously","ContinuouslySyncCallback","ContinuouslyAsyncCallback","Promise","OnStartCalled","ContinuouslyOpts","AbortSignal","Readonly","continuously","Partial"],"sources":["../../core/dist/src/continuously.d.ts"],"sourcesContent":["import { type Interval } from '@ixfx/core';\nexport type HasCompletionRunStates = `idle` | `scheduled` | `running`;\nexport type HasCompletion = {\n    /**\n     * Gets the current run state\n     * idle: not yet started or completed with no future run scheduled\n     * scheduled: waiting to run\n     * running: currently executing its callback\n     */\n    get runState(): HasCompletionRunStates;\n    /**\n     * Returns the number of times the scheduled function\n     * has been executed.\n     *\n     * This number will be reset in some conditions.\n     * For example `continuously` resets it when the loop stops.\n     *\n     * Use {@link startCountTotal} to track total number.\n     */\n    get startCount(): number;\n    /**\n     * Total number of times scheduled function has been\n     * executed.\n     */\n    get startCountTotal(): number;\n};\n/**\n * Runs a function continuously, returned by {@link continuously}\n */\nexport type Continuously = HasCompletion & {\n    /**\n     * Starts loop. If already running, does nothing\n     */\n    start(): void;\n    /**\n     * (Re-)starts the loop. If an existing iteration has been\n     * scheduled, this is cancelled and started again.\n     *\n     * This can be useful when adjusting the interval\n     */\n    reset(): void;\n    /**\n     * How many milliseconds since loop was started after being stopped.\n     */\n    get elapsedMs(): number;\n    /**\n     * If disposed, the continuously instance won't be re-startable\n     */\n    get isDisposed(): boolean;\n    /**\n     * Stops loop. It can be restarted using .start()\n     */\n    cancel(): void;\n    /**\n     * Sets the interval speed of loop. Change will take effect on next loop. For it to kick\n     * in earlier, call .reset() after changing the value.\n     */\n    set interval(interval: Interval);\n    /**\n     * Gets the current interval, ie. speed of loop.\n     */\n    get interval(): Interval;\n};\nexport type ContinuouslySyncCallback = (\n/**\n * Number of times loop\n * Ticks is reset when loop exits.\n */\nticks?: number, \n/**\n * Elapsed milliseconds.\n * Reset when loop exits\n */\nelapsedMs?: number) => boolean | void;\nexport type ContinuouslyAsyncCallback = (\n/**\n * Number of times loop has run\n * Reset when loop exits.\n */\nticks?: number, \n/**\n * Elapsed milliseconds.\n * Reset when loop exits.\n */\nelapsedMs?: number) => Promise<boolean | void>;\nexport type OnStartCalled = `continue` | `cancel` | `reset` | `dispose`;\n/**\n * Options for {@link continuously}\n */\nexport type ContinuouslyOpts = Readonly<{\n    /**\n     * Abort signal to exit loop\n     */\n    signal: AbortSignal;\n    /**\n     * If _true_, callback runs before waiting period.\n     * @defaultValue false\n     */\n    fireBeforeWait: boolean;\n    /**\n     * Called whenever .start() is invoked.\n     * If this function returns:\n     *  - `continue`: the loop starts if it hasn't started yet, or continues if already started\n     *  - `cancel`: loop stops, but can be re-started if .start() is called again\n     *  - `dispose`: loop stops and will throw an error if .start() is attempted to be called\n     *  - `reset`: loop resets (ie. existing scheduled task is cancelled)\n     *\n     */\n    onStartCalled: (\n    /**\n     * Number of times loop has run\n     * Reset when loop is exits.\n     */\n    ticks?: number, \n    /**\n     * Elapsed milliseconds.\n     * Reset when loop is exits.\n     */\n    elapsedMs?: number) => OnStartCalled;\n}>;\n/**\n * Returns a {@link Continuously} that continually executes `callback` at `interval` rate.\n *\n * By default, first the sleep period happens and then the callback happens.\n *\n * Call `start` to begin/reset loop. The looping stops when `cancel` is called, or when `callback` returns _false_.\n *\n * @example\n * Animation loop\n * ```js\n * const draw = () => {\n *  // Draw on canvas\n * }\n *\n * // Run draw() synchronised with monitor refresh rate via `window.requestAnimationFrame`\n * continuously(draw).start();\n * ```\n *\n * @example\n * With delay\n * ```js\n * const fn = () => {\n *  // Runs after one minute\n * }\n * const c = continuously(fn, { mins: 1 } );\n * c.start(); // Runs `fn` every minute\n * ```\n *\n * @example\n * Control a 'continuously'\n * ```js\n * c.cancel();   // Stop the loop, cancelling any up-coming calls to `fn`\n * c.elapsedMs;  // How many milliseconds have elapsed since start\n * c.ticks;      // How many iterations of loop since start\n * c.interval;   // Get/set speed of loop. Change kicks-in at next loop.\n *               // Use .start() to reset to new interval immediately\n * ```\n *\n * Asynchronous callback functions are supported too:\n * ```js\n * continuously(async () => { ..});\n * ```\n *\n * The `callback` function can receive a few arguments:\n *\n * ```js\n * continuously( (ticks, elapsedMs) => {\n *  // ticks: how many times loop has run\n *  // elapsedMs:  how long since last loop\n * }).start();\n * ```\n *\n * If the callback explicitly returns _false_, the loop will be cancelled.\n *\n * ```js\n * continuously(ticks => {\n *  // Stop after 100 iterations\n *  if (ticks > 100) return false;\n * }).start();\n * ```\n *\n * You can intercept the logic for calls to `start()` with `onStartCalled`. It can determine\n * whether the `start()` proceeds, if the loop is cancelled, or the whole thing disposed,\n * so it can't run any longer.\n *\n * ```js\n * continuously(callback, intervalMs, {\n *  onStartCalled:(ticks, elapsedMs) => {\n *    // Cancel the loop after 1000ms has elapsed\n *    if (elapsedMs > 1000) return `cancel`;\n *  }\n * }).start();\n * ```\n *\n * To run `callback` *before* the sleep happens, set `fireBeforeWait`:\n * ```js\n * continuously(callback, intervalMs, { fireBeforeWait: true });\n * ```\n * @param callback - Function to run. If it returns _false_, loop exits.\n * @param options - {@link ContinuouslyOpts ContinuouslyOpts}\n * @param interval - Speed of loop (default: 0)\n * @returns Instance to control looping.\n * @see Flow.timeout if you want to trigger something once.\n */\nexport declare const continuously: (callback: ContinuouslyAsyncCallback | ContinuouslySyncCallback, interval?: Interval, options?: Partial<ContinuouslyOpts>) => Continuously;\n//# sourceMappingURL=continuously.d.ts.map"],"mappings":";;;KACYC,sBAAAA;KACAC,aAAAA;EADAD;AACZ;AA2BA;;;;EA4BmC,IAIfD,QAAAA,EAAAA,EApDAC,sBAoDAD;EAAQ;AAE5B;AAWA;AAWA;AAIA;;;;;EAAuC,IAAA,UAAA,EAAA,EAAA,MAAA;EAmHlBW;;;;EAA6E,IAAaX,eAAAA,EAAAA,EAAAA,MAAAA;CAAQ;;;AAAsD;KA/KjKG,YAAAA,GAAeD;;;;;;;;;;;;;;;;;;;;;;;;;;;;yBA4BAF;;;;kBAIPA;;KAERI,wBAAAA;;;;;;;;;;;KAWAC,yBAAAA;;;;;;;;;;uBAUWC;KACXC,aAAAA;;;;KAIAC,gBAAAA,GAAmBE;;;;UAInBD;;;;;;;;;;;;;;;;;;;;;;;;;yBAyBeF;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;cAsFNI,yBAAyBN,4BAA4BD,qCAAqCJ,oBAAoBY,QAAQJ,sBAAsBL"}