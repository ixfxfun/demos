{"version":3,"file":"geometry-nKk9oeMG.js","names":["data: readonly V[] | V[]","propertyName: K","round","a: number","b?: number | boolean","roundUp?: boolean","rounder: ((v: number) => number) | undefined","v: number","start: number","end: number","steps: number","precision?: number","v: number","quantiseEvery","v: number","every: number","array: ArrayLike<V>","rand: RandomSource","keyString?: ToString<V>","keyString: ToString<V> | undefined","values","v: V","isNaN","guard","isEmpty","isPlaceholder","fromPoints","guard","getPointParameter","length","sum","interpolate","distance","fromA","distance","guard","guardPositioned","isEmpty","isPlaceholder","isPositioned","normaliseByRect","b","a","distance","nearest","point","line","length","point","bbox","bbox","divide","divide","point","fromNumbers","fromFlatArray","guard","piPi","point","piPi","rotate","invert","subtract","Empty","toCartesian","EmptyPoint","point","distance","toString","normalise","clampMagnitude","dotProduct","multiply","divide","Placeholder","angleRadian","piPi","toCartesian","toString","length","angleRadian","isEqual","isEqual","apply","point","centroid","sum","clamp","guard","isPositioned","distanceCenter","distanceFromExterior","isEqual","sum","centroid","isIntersecting","center","toArray","dotProduct","fromNumbers","interpolate","multiply","multiplyScalar","clampMagnitude","length","length","normalise","Empty","point","pipeline","toString","piPi","pi","point","PointEmpty","toString","dotProduct","sum","subtract","multiply","divide","asPoints","LinesEmpty","PointsPlaceholder","distance","random","rotate","withinRange","wrap","multiply","point","relativePosition","rotate","subtract","point","sum","point","toString","Empty","Placeholder","isEmpty","isPlaceholder","height","point","distance","toSvgString","toPath","point","distance","fromPoints","nearest","distance","Empty","Placeholder","length","angleRadian","corners","height","from","angleRadian","arrow","piPi","randomPoint","offset","random","randomPoint","center","guard","isEqual","isIntersecting","PointEmpty","area","fromCenter","height","bbox","piPi","point","angleRadian","length","piPi","interpolate","multiplyScalar","toSvg","toSvgFull","toPath","point","area","height","height","edges","height","isEqual","lengths","perimeter","interpolate","point","lengths","length","bbox","corners","wrap","access","wrap","accessWithGrid","setMutate","setMutateWithGrid","set","setWithGrid","wrapMutable","columns","rows","create","wrap","wrap","cells","cardinal","cells","wrap","isEqual","neighbours","BezierLibrary","toPath","cubic","quadratic","fromDegrees","slope","Direction","#parent","#children","#items","#subdivide","PlaceholderRect","normalise","abs","angleRadian","piPi","bbox","offset","area","lengths","angles","piPi","perimeter","fromCenter","height","perimeter","area","circumcircle","incircle","fromA","fromB","fromC","height","perimeter","area","medians","circumcircle","incircle","angleRadian"],"sources":["../../packages/arrays/src/sort.ts","../../packages/numbers/src/round.ts","../../packages/numbers/src/linear-space.ts","../../packages/numbers/src/quantise.ts","../../packages/random/src/arrays.ts","../../packages/collections/src/set/set-mutable.ts","../../packages/geometry/dist/src/point/guard.js","../../packages/geometry/dist/src/line/from-points.js","../../packages/geometry/dist/src/line/join-points-to-lines.js","../../packages/geometry/dist/src/line/guard.js","../../packages/geometry/dist/src/line/get-points-parameter.js","../../packages/geometry/dist/src/line/length.js","../../packages/geometry/dist/src/line/reverse.js","../../packages/geometry/dist/src/line/interpolate.js","../../packages/geometry/dist/src/line/angles.js","../../packages/geometry/dist/src/line/midpoint.js","../../packages/geometry/dist/src/rect/guard.js","../../packages/geometry/dist/src/point/normalise-by-rect.js","../../packages/geometry/dist/src/point/get-point-parameter.js","../../packages/geometry/dist/src/point/distance.js","../../packages/geometry/dist/src/line/nearest.js","../../packages/geometry/dist/src/line/distance-single-line.js","../../packages/geometry/dist/src/point/find-minimum.js","../../packages/geometry/dist/src/rect/max.js","../../packages/geometry/dist/src/point/bbox.js","../../packages/geometry/dist/src/line/bbox.js","../../packages/geometry/dist/src/point/divider.js","../../packages/geometry/dist/src/line/divide.js","../../packages/geometry/dist/src/line/from-numbers.js","../../packages/geometry/dist/src/line/from-flat-array.js","../../packages/geometry/dist/src/polar/guard.js","../../packages/geometry/dist/src/pi.js","../../packages/geometry/dist/src/angles.js","../../packages/geometry/dist/src/polar/angles.js","../../packages/geometry/dist/src/point/subtract.js","../../packages/geometry/dist/src/point/empty.js","../../packages/geometry/dist/src/polar/conversions.js","../../packages/geometry/dist/src/polar/math.js","../../packages/geometry/dist/src/point/point-type.js","../../packages/geometry/dist/src/point/angle.js","../../packages/geometry/dist/src/polar/ray.js","../../packages/geometry/dist/src/polar/spiral.js","../../packages/geometry/dist/src/polar/index.js","../../packages/geometry/dist/src/line/from-pivot.js","../../packages/geometry/dist/src/line/from-points-to-path.js","../../packages/geometry/dist/src/point/is-equal.js","../../packages/geometry/dist/src/line/is-equal.js","../../packages/geometry/dist/src/point/abs.js","../../packages/geometry/dist/src/point/apply.js","../../packages/geometry/dist/src/point/averager.js","../../packages/geometry/dist/src/point/centroid.js","../../packages/geometry/dist/src/point/clamp.js","../../packages/geometry/dist/src/point/compare.js","../../packages/geometry/dist/src/point/convex-hull.js","../../packages/geometry/dist/src/circle/guard.js","../../packages/geometry/dist/src/circle/distance-center.js","../../packages/geometry/dist/src/circle/distance-from-exterior.js","../../packages/geometry/dist/src/circle/is-equal.js","../../packages/geometry/dist/src/point/sum.js","../../packages/geometry/dist/src/circle/intersections.js","../../packages/geometry/dist/src/intersects.js","../../packages/geometry/dist/src/rect/Intersects.js","../../packages/geometry/dist/src/rect/center.js","../../packages/geometry/dist/src/rect/distance.js","../../packages/geometry/dist/src/point/distance-to-center.js","../../packages/geometry/dist/src/point/distance-to-exterior.js","../../packages/geometry/dist/src/point/to-array.js","../../packages/geometry/dist/src/point/dot-product.js","../../packages/geometry/dist/src/point/from.js","../../packages/geometry/dist/src/point/interpolate.js","../../packages/geometry/dist/src/point/invert.js","../../packages/geometry/dist/src/point/multiply.js","../../packages/geometry/dist/src/point/magnitude.js","../../packages/geometry/dist/src/point/most.js","../../packages/geometry/dist/src/point/normalise.js","../../packages/geometry/dist/src/point/pipeline.js","../../packages/geometry/dist/src/point/To.js","../../packages/geometry/dist/src/vector.js","../../packages/geometry/dist/src/point/relation.js","../../packages/geometry/dist/src/point/point-tracker.js","../../packages/geometry/dist/src/point/progress-between.js","../../packages/geometry/dist/src/point/project.js","../../packages/geometry/dist/src/point/quantise.js","../../packages/geometry/dist/src/point/random.js","../../packages/geometry/dist/src/point/reduce.js","../../packages/geometry/dist/src/point/rotate.js","../../packages/geometry/dist/src/point/rotate-point-array.js","../../packages/geometry/dist/src/point/round.js","../../packages/geometry/dist/src/point/within-range.js","../../packages/geometry/dist/src/point/wrap.js","../../packages/geometry/dist/src/point/index.js","../../packages/geometry/dist/src/line/multiply.js","../../packages/geometry/dist/src/line/relative-position.js","../../packages/geometry/dist/src/line/rotate.js","../../packages/geometry/dist/src/line/subtract.js","../../packages/geometry/dist/src/line/sum.js","../../packages/geometry/dist/src/line/to-string.js","../../packages/geometry/dist/src/line/index.js","../../packages/geometry/dist/src/line/to-path.js","../../packages/geometry/dist/src/waypoint.js","../../packages/geometry/dist/src/triangle/create.js","../../packages/geometry/dist/src/rect/corners.js","../../packages/geometry/dist/src/rect/from-top-left.js","../../packages/geometry/dist/src/shape/arrow.js","../../packages/geometry/dist/src/circle/random.js","../../packages/geometry/dist/src/rect/random.js","../../packages/geometry/dist/src/circle/center.js","../../packages/geometry/dist/src/triangle/guard.js","../../packages/geometry/dist/src/triangle/centroid.js","../../packages/geometry/dist/src/shape/etc.js","../../packages/geometry/dist/src/circle/is-contained-by.js","../../packages/geometry/dist/src/circle/intersecting.js","../../packages/geometry/dist/src/shape/is-intersecting.js","../../packages/geometry/dist/src/shape/starburst.js","../../packages/geometry/dist/src/shape/index.js","../../packages/geometry/dist/src/circle-packing.js","../../packages/geometry/dist/src/layout.js","../../packages/geometry/dist/src/circle/area.js","../../packages/geometry/dist/src/rect/from-center.js","../../packages/geometry/dist/src/circle/bbox.js","../../packages/geometry/dist/src/circle/exterior-points.js","../../packages/geometry/dist/src/circle/interior-points.js","../../packages/geometry/dist/src/circle/perimeter.js","../../packages/geometry/dist/src/circle/interpolate.js","../../packages/geometry/dist/src/circle/multiply.js","../../packages/geometry/dist/src/circle/svg.js","../../packages/geometry/dist/src/circle/to-path.js","../../packages/geometry/dist/src/circle/to-positioned.js","../../packages/geometry/dist/src/circle/index.js","../../packages/geometry/dist/src/rect/area.js","../../packages/geometry/dist/src/rect/apply.js","../../packages/geometry/dist/src/rect/cardinal.js","../../packages/geometry/dist/src/rect/divide.js","../../packages/geometry/dist/src/rect/edges.js","../../packages/geometry/dist/src/rect/empty.js","../../packages/geometry/dist/src/rect/encompass.js","../../packages/geometry/dist/src/rect/from-element.js","../../packages/geometry/dist/src/rect/from-numbers.js","../../packages/geometry/dist/src/rect/get-rect-positionedparameter.js","../../packages/geometry/dist/src/rect/is-equal.js","../../packages/geometry/dist/src/rect/lengths.js","../../packages/geometry/dist/src/rect/multiply.js","../../packages/geometry/dist/src/rect/nearest.js","../../packages/geometry/dist/src/rect/placeholder.js","../../packages/geometry/dist/src/rect/perimeter.js","../../packages/geometry/dist/src/rect/normalise-by-rect.js","../../packages/geometry/dist/src/rect/subtract.js","../../packages/geometry/dist/src/rect/sum.js","../../packages/geometry/dist/src/rect/to-array.js","../../packages/geometry/dist/src/rect/index.js","../../packages/geometry/dist/src/bezier/guard.js","../../packages/geometry/dist/src/path/start-end.js","../../packages/geometry/dist/src/path/compound-path.js","../../packages/geometry/dist/src/path/index.js","../../packages/geometry/dist/src/grid/inside.js","../../packages/geometry/dist/src/grid/guards.js","../../packages/geometry/dist/src/grid/apply-bounds.js","../../packages/geometry/dist/src/grid/array-1d.js","../../packages/geometry/dist/src/grid/array-2d.js","../../packages/geometry/dist/src/grid/values.js","../../packages/geometry/dist/src/grid/enumerators/cells.js","../../packages/geometry/dist/src/grid/as.js","../../packages/geometry/dist/src/grid/offset.js","../../packages/geometry/dist/src/grid/directions.js","../../packages/geometry/dist/src/grid/enumerators/index.js","../../packages/geometry/dist/src/grid/geometry.js","../../packages/geometry/dist/src/grid/indexing.js","../../packages/geometry/dist/src/grid/is-equal.js","../../packages/geometry/dist/src/grid/neighbour.js","../../packages/geometry/dist/src/grid/to-array.js","../../packages/geometry/dist/src/grid/to-string.js","../../packages/geometry/dist/src/grid/visual.js","../../packages/geometry/dist/src/grid/visitors/breadth.js","../../packages/geometry/dist/src/grid/visitors/cell-neighbours.js","../../packages/geometry/dist/src/grid/visitors/columns.js","../../packages/geometry/dist/src/grid/visitors/depth.js","../../packages/geometry/dist/src/grid/visitors/random.js","../../packages/geometry/dist/src/grid/visitors/random-contiguous.js","../../packages/geometry/dist/src/grid/visitors/rows.js","../../packages/geometry/dist/src/grid/visitors/visitor.js","../../packages/geometry/dist/src/grid/visitors/step.js","../../packages/geometry/dist/src/grid/visitors/index.js","../../packages/geometry/dist/src/grid/index.js","../../packages/geometry/dist/src/bezier/index.js","../../packages/geometry/dist/src/ellipse.js","../../packages/geometry/dist/src/curve-simplification.js","../../packages/geometry/dist/src/quad-tree.js","../../packages/geometry/dist/src/scaler.js","../../packages/geometry/dist/src/arc/index.js","../../packages/geometry/dist/src/surface-points.js","../../packages/geometry/dist/src/triangle/angles.js","../../packages/geometry/dist/src/triangle/edges.js","../../packages/geometry/dist/src/triangle/area.js","../../packages/geometry/dist/src/triangle/barycentric.js","../../packages/geometry/dist/src/triangle/bbox.js","../../packages/geometry/dist/src/triangle/corners.js","../../packages/geometry/dist/src/triangle/from.js","../../packages/geometry/dist/src/triangle/lengths.js","../../packages/geometry/dist/src/triangle/kinds.js","../../packages/geometry/dist/src/triangle/perimeter.js","../../packages/geometry/dist/src/triangle/inner-circle.js","../../packages/geometry/dist/src/triangle/outer-circle.js","../../packages/geometry/dist/src/triangle/rotate.js","../../packages/geometry/dist/src/triangle/equilateral.js","../../packages/geometry/dist/src/triangle/right.js","../../packages/geometry/dist/src/triangle/isosceles.js","../../packages/geometry/dist/src/triangle/index.js","../src/geometry.ts"],"sourcesContent":["import { arrayTest, resultThrow } from '@ixfx/guards';\n/**\n * Sorts an array of objects in ascending order\n * by the given property name, assuming it is a number.\n *\n * ```js\n * const data = [\n *  { size: 10, colour: `red` },\n *  { size: 20, colour: `blue` },\n *  { size: 5, colour: `pink` }\n * ];\n * const sorted = Arrays.sortByNumericProperty(data, `size`);\n *\n * Yields items ascending order:\n * [ { size: 5, colour: `pink` }, { size: 10, colour: `red` }, { size: 20, colour: `blue` } ]\n * ```\n * @param data\n * @param propertyName\n */\nexport const sortByNumericProperty = <V, K extends keyof V>(\n  data: readonly V[] | V[],\n  propertyName: K\n) => [ ...data ].sort((a, b) => {\n  resultThrow(arrayTest(data, `data`));\n  const av = a[ propertyName ];\n  const bv = b[ propertyName ];\n  if (av < bv) return -1;\n  if (av > bv) return 1;\n  return 0;\n});\n\nexport const sortByProperty = <V, K extends keyof V>(\n  data: readonly V[] | V[],\n  propertyName: K\n) => [ ...data ].sort((a, b) => {\n  resultThrow(arrayTest(data, `data`));\n\n  const av = a[ propertyName ];\n  const bv = b[ propertyName ];\n  if (av < bv) return -1;\n  if (av > bv) return 1;\n  return 0;\n});","import { integerTest, resultThrow } from \"@ixfx/guards\";\n\nexport function round(decimalPlaces: number, v: number, roundUp?: boolean): number;\nexport function round(decimalPlaces: number, roundUp?: boolean): (v: number) => number;\n\n/**\n * Rounds a number.\n *\n * If one parameter is given, it's the decimal places,\n * and a rounding function is returned:\n * ```js\n * import { round } from 'https://unpkg.com/ixfx/dist/numbers.js';\n * const r = round(2);\n * r(10.12355); // 10.12\n * ```\n *\n * If two parameters are given, the first is decimal places,\n * the second the value to round.\n * ```js\n * round(2, 10.12355); // 10.12\n * ```\n * @param decimalPlaces\n * @returns\n */\nexport function round(a: number, b?: number | boolean, roundUp?: boolean) {\n  resultThrow(integerTest(a, `positive`, `decimalPlaces`));\n\n  const up = (typeof b === `boolean`) ? b : (roundUp ?? false)\n  let rounder: ((v: number) => number) | undefined;\n  if (a === 0) {\n    rounder = Math.round;\n  } else {\n    const p = Math.pow(10, a);\n    if (up) {\n      rounder = (v: number) => Math.ceil(v * p) / p;\n    } else {\n      rounder = (v: number) => Math.floor(v * p) / p;\n    }\n  }\n  if (typeof b === `number`) return rounder(b);\n  return rounder;\n}\n\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { round } from \"./round.js\";\n\n/**\n * Generates a `step`-length series of values between `start` and `end` (inclusive).\n * Each value will be equally spaced.\n *\n * ```js\n * for (const v of linearSpace(1, 5, 6)) {\n *  // Yields: [ 1, 1.8, 2.6, 3.4, 4.2, 5 ]\n * }\n * ```\n *\n * Numbers can be produced from large to small as well\n * ```js\n * const values = [...linearSpace(10, 5, 3)];\n * // Yields: [10, 7.5, 5]\n * ```\n * @param start Start number (inclusive)\n * @param end  End number (inclusive)\n * @param steps How many steps to make from start -> end\n * @param precision Number of decimal points to round to\n */\nexport function* linearSpace(\n  start: number,\n  end: number,\n  steps: number,\n  precision?: number\n): IterableIterator<number> {\n\n  resultThrow(\n    numberTest(start, ``, `start`),\n    numberTest(end, ``, `end`),\n    numberTest(steps, ``, `steps`)\n  );\n  const r = precision ? round(precision) : (v: number) => v;\n  const step = (end - start) / (steps - 1);\n\n  resultThrow(numberTest(step, ``, `step`));\n  if (!Number.isFinite(step)) {\n    throw new TypeError(`Calculated step value is infinite`);\n  }\n\n  for (let index = 0; index < steps; index++) {\n    const v = start + step * index;\n    yield r(v);\n  }\n}\n","import { integerTest, numberTest, resultThrow } from \"@ixfx/guards\";\n\n/**\n * Rounds `v` by `every`. Middle values are rounded up by default.\n *\n * ```js\n * quantiseEvery(11, 10);  // 10\n * quantiseEvery(25, 10);  // 30\n * quantiseEvery(0, 10);   // 0\n * quantiseEvery(4, 10);   // 0\n * quantiseEvery(100, 10); // 100\n * ```\n * \n * Also works with decimals\n * ```js\n * quantiseEvery(1.123, 0.1); // 1.1\n * quantiseEvery(1.21, 0.1);  // 1.2\n * ```\n *\n * @param v Value to quantise\n * @param every Number to quantise to\n * @param middleRoundsUp If _true_ (default), the exact middle rounds up to next step.\n * @returns\n */\nexport const quantiseEvery = (\n  v: number,\n  every: number,\n  middleRoundsUp = true\n) => {\n\n  const everyString = every.toString();\n  const decimal = everyString.indexOf(`.`);\n  let multiplier = 1;\n  if (decimal >= 0) {\n    const d = everyString.substring(decimal + 1).length;\n    multiplier = 10 * d;\n    every = Math.floor(multiplier * every);\n    v = v * multiplier;\n  }\n\n  resultThrow(\n    numberTest(v, ``, `v`),\n    integerTest(every, ``, `every`)\n  );\n\n  let div = v / every;\n  const divModule = div % 1;\n  div = Math.floor(div);\n  if ((divModule === 0.5 && middleRoundsUp) || divModule > 0.5) div++;\n  const vv = (every * div) / multiplier;\n  return vv;\n};","import { arrayTest, resultThrow } from \"@ixfx/guards\";\nimport { weightedIndex } from \"./weighted-index.js\";\nimport type { RandomSource } from \"./types.js\";\n\n/**\n * Returns a random array index.\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomIndex(v); // Yields 0, 1 or 2\n * ```\n *\n * Use {@link randomElement} if you want a value from `array`, not index.\n *\n * @param array Array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomIndex = <V>(\n  array: ArrayLike<V>,\n  rand: RandomSource = Math.random\n): number => Math.floor(rand() * array.length);\n\n\n/**\n * Removes a random item from an array, returning both the item and the new array as a result.\n * Does not modify the original array unless `mutate` parameter is true.\n *\n * @example Without changing source\n * ```js\n * const data = [100, 20, 40];\n * const {value, array} = randomPluck(data);\n * // value: 20, array: [100, 40], data: [100, 20, 40];\n * ```\n *\n * @example Mutating source\n * ```js\n * const data = [100, 20, 40];\n * const {value} = randomPluck(data, true);\n * // value: 20, data: [100, 40];\n * ```\n *\n * @typeParam V - Type of items in array\n * @param array Array to pluck item from\n * @param mutate If _true_, changes input array. _False_ by default.\n * @param rand Random generatr. `Math.random` by default.\n * @return Returns an object `{value:V|undefined, array:V[]}`\n *\n */\nexport const randomPluck = <V>(\n  array: readonly V[] | V[],\n  mutate = false,\n  rand: RandomSource = Math.random\n): { readonly value: V | undefined; readonly array: V[] } => {\n  if (typeof array === `undefined`) throw new Error(`Param 'array' is undefined`);\n  if (!Array.isArray(array)) throw new Error(`Param 'array' is not an array`);\n  if (array.length === 0) return { value: undefined, array: [] };\n  const index = randomIndex(array, rand);\n  if (mutate) {\n    return {\n      value: array[ index ],\n      array: array.splice(index, 1),\n    };\n  } else {\n    // Copy array, remove item from that\n    const t = [ ...array ];\n    t.splice(index, 1);\n    return {\n      value: array[ index ],\n      array: t,\n    };\n  }\n};\n\n\n/**\n * Returns random element.\n *\n * ```js\n * const v = [`blue`, `red`, `orange`];\n * randomElement(v); // Yields `blue`, `red` or `orange`\n * ```\n *\n * Use {@link randomIndex} if you want a random index within `array`.\n *\n * @param array\n * @param rand Random generator. `Math.random` by default.\n * @returns\n */\nexport const randomElement = <V>(\n  array: ArrayLike<V>,\n  rand: RandomSource = Math.random\n): V => {\n  resultThrow(arrayTest(array, `array`));\n  return array[ Math.floor(rand() * array.length) ];\n};\n\n\n/**\n * Selects a random array index, biased by the provided `weightings`.\n * \n * In the below example, `a` will be picked 20% of the time, `b` 50% and so on.\n * ```js\n * const data =    [  `a`,  `b`,  `c`,  `d` ]\n * const weights = [ 0.2,  0.5,  0.1,  0.2 ] \n * ```\n * @param array \n * @param weightings \n * @param randomSource \n */\nexport const randomElementWeightedSource = <V>(array: ArrayLike<V>, weightings: number[], randomSource: RandomSource = Math.random) => {\n  if (array.length !== weightings.length) throw new Error(`Lengths of 'array' and 'weightings' should be the same.`);\n  const r = weightedIndex(weightings, randomSource);\n  return (): V => {\n    const index = r();\n    return array[ index ];\n  }\n}\n\n/**\n * Returns a shuffled copy of the input array.\n * @example\n * ```js\n * const d = [1, 2, 3, 4];\n * const s = shuffle(d);\n * // d: [1, 2, 3, 4], s: [3, 1, 2, 4]\n * ```\n * @param dataToShuffle\n * @param rand Random generator. `Math.random` by default.\n * @returns Copy with items moved around randomly\n * @typeParam V - Type of array items\n */\nexport const shuffle = <V>(\n  dataToShuffle: readonly V[],\n  rand: RandomSource = Math.random\n): V[] => {\n  const array = [ ...dataToShuffle ];\n  for (let index = array.length - 1; index > 0; index--) {\n    const index_ = Math.floor(rand() * (index + 1));\n    [ array[ index ], array[ index_ ] ] = [ array[ index_ ], array[ index ] ];\n  }\n  return array;\n};","// ✔ UNIT TESTED\nimport { defaultKeyer, type ToString } from '@ixfx/core';\nimport { SimpleEventEmitter } from '@ixfx/events';//'../../Events.js';\nimport { type ISetMutable } from './ISetMutable.js';\nimport { type ValueSetEventMap } from './Types.js';\n\n/**\n * Creates a {@link ISetMutable}.\n * @param keyString Function that produces a key based on a value. If unspecified, uses `JSON.stringify`\n * @returns\n */\nexport const mutable = <V>(\n  keyString?: ToString<V>\n): ISetMutable<V> => new SetStringMutable(keyString);\n\n/**\n * Mutable string set\n */\nexport class SetStringMutable<V>\n  extends SimpleEventEmitter<ValueSetEventMap<V>>\n  implements ISetMutable<V> {\n  // ✔ UNIT TESTED\n  /* eslint-disable functional/prefer-readonly-type */\n  store = new Map<string, V>();\n  keyString: ToString<V>;\n\n  /**\n   * Constructor\n   * @param keyString Function which returns a string version of added items. If unspecified `JSON.stringify`\n   */\n  constructor(keyString: ToString<V> | undefined) {\n    super();\n    this.keyString = keyString ?? defaultKeyer<V>;\n  }\n\n  /**\n   * Number of items stored in set\n   */\n  get size() {\n    return this.store.size;\n  }\n\n  /**\n   * Adds one or more items to set. `add` event is fired for each item\n   * @param values items to add\n   */\n  add(...values: V[]): boolean {\n    //eslint-disable-next-line functional/no-let\n    let somethingAdded = false;\n    for (const value of values) {\n      const isUpdated = this.has(value);\n      this.store.set(this.keyString(value), value);\n      super.fireEvent(`add`, { value: value, updated: isUpdated });\n      if (!isUpdated) somethingAdded = true;\n    }\n    return somethingAdded;\n  }\n\n  /**\n   * Returns values from set as an iterable\n   * @returns\n   */\n  //eslint-disable-next-line functional/prefer-tacit\n  values() {\n    return this.store.values();\n  }\n\n  /**\n   * Clear items from set\n   */\n  clear() {\n    this.store.clear();\n    super.fireEvent(`clear`, true);\n  }\n\n  /**\n   * Delete value from set.\n   * @param v Value to delete\n  * @returns _True_ if item was found and removed\n   */\n  delete(v: V): boolean {\n    const isDeleted = this.store.delete(this.keyString(v));\n    if (isDeleted) super.fireEvent(`delete`, v);\n    return isDeleted;\n  }\n\n  /**\n   * Returns _true_ if item exists in set\n   * @param v\n   * @returns\n   */\n  has(v: V): boolean {\n    return this.store.has(this.keyString(v));\n  }\n\n  /**\n   * Returns array copy of set\n   * @returns Array copy of set\n   */\n  toArray(): V[] {\n    return [ ...this.store.values() ];\n  }\n}\n","import { numberTest, resultThrow } from '@ixfx/guards';\n/**\n * Returns true if xy (and z, if present) are _null_.\n * @param p\n * @returns\n */\nexport const isNull = (p) => {\n    if (isPoint3d(p)) {\n        if (p.z !== null)\n            return false;\n    }\n    return p.x === null && p.y === null;\n};\n/***\n * Returns true if either x, y, z isNaN.\n */\nexport const isNaN = (p) => {\n    if (isPoint3d(p)) {\n        if (!Number.isNaN(p.z))\n            return false;\n    }\n    return Number.isNaN(p.x) || Number.isNaN(p.y);\n};\n/**\n * Throws an error if point is invalid\n * @param p\n * @param name\n */\nexport function guard(p, name = `Point`) {\n    if (p === undefined) {\n        throw new Error(`'${name}' is undefined. Expected {x,y} got ${JSON.stringify(p)}`);\n    }\n    if (p === null) {\n        throw new Error(`'${name}' is null. Expected {x,y} got ${JSON.stringify(p)}`);\n    }\n    if (p.x === undefined) {\n        throw new Error(`'${name}.x' is undefined. Expected {x,y} got ${JSON.stringify(p)}`);\n    }\n    if (p.y === undefined) {\n        throw new Error(`'${name}.y' is undefined. Expected {x,y} got ${JSON.stringify(p)}`);\n    }\n    if (typeof p.x !== `number`) {\n        throw new TypeError(`'${name}.x' must be a number. Got ${typeof p.x}`);\n    }\n    if (typeof p.y !== `number`) {\n        throw new TypeError(`'${name}.y' must be a number. Got ${typeof p.y}`);\n    }\n    if (p.z !== undefined) {\n        if (typeof p.z !== `number`)\n            throw new TypeError(`${name}.z must be a number. Got: ${typeof p.z}`);\n        if (Number.isNaN(p.z))\n            throw new Error(`'${name}.z' is NaN. Got: ${JSON.stringify(p)}`);\n    }\n    if (p.x === null)\n        throw new Error(`'${name}.x' is null`);\n    if (p.y === null)\n        throw new Error(`'${name}.y' is null`);\n    if (Number.isNaN(p.x))\n        throw new Error(`'${name}.x' is NaN`);\n    if (Number.isNaN(p.y))\n        throw new Error(`'${name}.y' is NaN`);\n}\n/**\n * Throws if parameter is not a valid point, or either x or y is 0\n * @param pt\n * @returns\n */\nexport const guardNonZeroPoint = (pt, name = `pt`) => {\n    guard(pt, name);\n    resultThrow(numberTest(pt.x, `nonZero`, `${name}.x`), numberTest(pt.y, `nonZero`, `${name}.y`), () => {\n        if (typeof pt.z !== `undefined`) {\n            return numberTest(pt.z, `nonZero`, `${name}.z`);\n        }\n    });\n    return true;\n};\n/**\n * Returns _true_ if `p` has x & y properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * Use {@link isPoint3d} to check further check for `z`.\n * @param p\n * @returns\n */\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport function isPoint(p) {\n    if (p === undefined)\n        return false;\n    if (p === null)\n        return false;\n    if (p.x === undefined)\n        return false;\n    if (p.y === undefined)\n        return false;\n    return true;\n}\n/**\n * Returns _true_ if `p` has x, y, & z properties.\n * Returns _false_ if `p` is undefined, null or does not contain properties.\n * @param p\n * @returns\n */\n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nexport const isPoint3d = (p) => {\n    if (p === undefined)\n        return false;\n    if (p === null)\n        return false;\n    if (p.x === undefined)\n        return false;\n    if (p.y === undefined)\n        return false;\n    if (p.z === undefined)\n        return false;\n    return true;\n};\n/**\n * Returns true if both xy (and z, if present) are 0.\n * Use `Points.Empty` to return an empty point.\n * @param p\n * @returns\n */\nexport const isEmpty = (p) => {\n    if (isPoint3d(p)) {\n        if (p.z !== 0)\n            return false;\n    }\n    return p.x === 0 && p.y === 0;\n};\n/**\n * Returns true if point is a placeholder, where xy (and z, if present)\n * are `NaN`.\n *\n * Use Points.Placeholder to return a placeholder point.\n * @param p\n * @returns\n */\nexport const isPlaceholder = (p) => {\n    if (isPoint3d(p)) {\n        if (!Number.isNaN(p.z))\n            return false;\n    }\n    return Number.isNaN(p.x) && Number.isNaN(p.y);\n};\n","import { guard as guardPoint } from '../point/guard.js';\n/**\n * Returns a line from two points\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line from 0,1 to 10,15\n * const line = Lines.fromPoints( { x:0, y:1 }, { x:10, y:15 });\n * // line is: { a: { x: 0, y: 1}, b: { x: 10, y: 15 } };\n * ```\n * @param a Start point\n * @param b End point\n * @returns\n */\nexport const fromPoints = (a, b) => {\n    guardPoint(a, `a`);\n    guardPoint(b, `b`);\n    a = Object.freeze({ ...a });\n    b = Object.freeze({ ...b });\n    return Object.freeze({\n        a: a,\n        b: b\n    });\n};\n","import { fromPoints } from \"./from-points.js\";\n/**\n * Returns an array of lines that connects provided points. Note that line is not closed.\n *\n * Eg, if points a,b,c are provided, two lines are provided: a->b and b->c.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const lines = Lines.joinPointsToLines(ptA, ptB, ptC);\n * // lines is an array of, well, lines\n * ```\n * @param points\n * @returns\n */\nexport const joinPointsToLines = (...points) => {\n    const lines = [];\n    let start = points[0];\n    for (let index = 1; index < points.length; index++) {\n        //eslint-disable-next-line functional/immutable-data\n        lines.push(fromPoints(start, points[index]));\n        start = points[index];\n    }\n    return lines;\n};\n","import { isPoint } from \"../point/guard.js\";\n/**\n * Returns true if `p` is a valid line, containing `a` and `b` Points.\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.isLine(l);\n * ```\n * @param p Value to check\n * @returns True if a valid line.\n */\nexport const isLine = (p) => {\n    if (p === undefined)\n        return false;\n    if (p.a === undefined)\n        return false;\n    if (p.b === undefined)\n        return false;\n    if (!isPoint(p.a))\n        return false;\n    if (!isPoint(p.b))\n        return false;\n    return true;\n};\n/**\n * Returns true if `p` is a {@link PolyLine}, ie. an array of {@link Line}s.\n * Validates all items in array.\n * @param p\n * @returns\n */\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isPolyLine = (p) => {\n    if (!Array.isArray(p))\n        return false;\n    const valid = !p.some(v => !isLine(v));\n    return valid;\n};\n/**\n * Throws an exception if:\n * * line is undefined\n * * a or b parameters are missing\n *\n * Does not validate points\n * @param line\n * @param name\n */\nexport const guard = (line, name = `line`) => {\n    if (line === undefined)\n        throw new Error(`${name} undefined`);\n    if (line.a === undefined)\n        throw new Error(`${name}.a undefined. Expected {a:Point, b:Point}. Got: ${JSON.stringify(line)}`);\n    if (line.b === undefined)\n        throw new Error(`${name}.b undefined. Expected {a:Point, b:Point} Got: ${JSON.stringify(line)}`);\n};\n","import { isLine } from \"./guard.js\";\nimport { guard as guardPoint } from '../point/guard.js';\n/**\n * Returns [a,b] points from either a line parameter, or two points.\n * It additionally applies the guardPoint function to ensure validity.\n * This supports function overloading.\n * @ignore\n * @param aOrLine\n * @param b\n * @returns\n */\nexport const getPointParameter = (aOrLine, b) => {\n    let a;\n    if (isLine(aOrLine)) {\n        b = aOrLine.b;\n        a = aOrLine.a;\n    }\n    else {\n        a = aOrLine;\n        if (b === undefined)\n            throw new Error(`Since first parameter is not a line, two points are expected. Got a: ${JSON.stringify(a)} b: ${JSON.stringify(b)}`);\n    }\n    guardPoint(a, `a`);\n    guardPoint(a, `b`);\n    return [a, b];\n};\n","import { getPointParameter } from \"./get-points-parameter.js\";\nimport { isPolyLine } from \"./guard.js\";\n/**\n * Returns length of line, polyline or between two points\n *\n * @param aOrLine Point A, line or polyline (array of lines)\n * @param pointB Point B, if first parameter is a point\n * @returns Length (total accumulated length for arrays)\n */\n//eslint-disable-next-line func-style\nexport function length(aOrLine, pointB) {\n    if (isPolyLine(aOrLine)) {\n        const sum = aOrLine.reduce((accumulator, v) => length(v) + accumulator, 0);\n        return sum;\n    }\n    if (aOrLine === undefined)\n        throw new TypeError(`Parameter 'aOrLine' is undefined`);\n    const [a, b] = getPointParameter(aOrLine, pointB);\n    const x = b.x - a.x;\n    const y = b.y - a.y;\n    if (a.z !== undefined && b.z !== undefined) {\n        const z = b.z - a.z;\n        return Math.hypot(x, y, z);\n    }\n    else {\n        return Math.hypot(x, y);\n    }\n}\n","import { guard } from \"./guard.js\";\n/**\n * Reverses a line.\n * ````js\n * const a = { x: 10, y: 20 };\n * const b = { x: 100, y: 200 };\n * const line = reverse({ a, b });\n * // { a: { x: 100, y: 200 }, b: { x: 10, y: 20 } }\n * ```\n * @param line\n * @returns\n */\nexport function reverse(line) {\n    guard(line, `line`);\n    return { a: line.b, b: line.a };\n}\n","import { numberTest, percentTest, resultThrow } from \"@ixfx/guards\";\nimport { getPointParameter } from \"./get-points-parameter.js\";\nimport { length } from \"./length.js\";\nimport { reverse } from \"./reverse.js\";\n/**\n * Calculates a point in-between a line's start and end points.\n *\n * @param amount Interpolation amount\n * @param aOrLine Line, or first point\n * @param pointBOrAllowOverflow Second point (if needed) or allowOverflow.\n * @param allowOverflow If true, interpolation amount is permitted to exceed 0..1, extending the line.\n * @returns\n */\nexport function interpolate(amount, aOrLine, pointBOrAllowOverflow, allowOverflow) {\n    if (typeof pointBOrAllowOverflow === `boolean`) {\n        allowOverflow = pointBOrAllowOverflow;\n        pointBOrAllowOverflow = undefined;\n    }\n    if (!allowOverflow)\n        resultThrow(percentTest(amount, `amount`));\n    else\n        resultThrow(numberTest(amount, ``, `amount`));\n    const [a, b] = getPointParameter(aOrLine, pointBOrAllowOverflow);\n    const d = length(a, b);\n    const d2 = d * (1 - amount);\n    // Points are identical, return a copy of b\n    if (d === 0 && d2 === 0)\n        return Object.freeze({ ...b });\n    const x = b.x - (d2 * (b.x - a.x) / d);\n    const y = b.y - (d2 * (b.y - a.y) / d);\n    return Object.freeze({\n        ...b,\n        x: x,\n        y: y\n    });\n}\n/**\n * Returns the point along a line from its start (A)\n * @param line Line\n * @param distance Distance\n * @param fromA If _true_ (default) returns from A. Use _false_ to calculate from end\n * @returns\n */\nexport function pointAtDistance(line, distance, fromA = true) {\n    if (!fromA)\n        line = reverse(line);\n    const dx = line.b.x - line.a.x;\n    const dy = line.b.y - line.a.y;\n    const theta = Math.atan2(dy, dx);\n    const xp = distance * Math.cos(theta);\n    const yp = distance * Math.sin(theta);\n    return { x: xp + line.a.x, y: yp + line.a.y };\n}\n","import { interpolate } from \"./interpolate.js\";\nimport { length } from \"./length.js\";\nconst directionVector = (line) => ({\n    x: line.b.x - line.a.x,\n    y: line.b.y - line.a.y\n});\nconst directionVectorNormalised = (line) => {\n    const l = length(line);\n    const v = directionVector(line);\n    return {\n        x: v.x / l,\n        y: v.y / l\n    };\n};\n/**\n * Returns a parallel line to `line` at `distance`.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = Lines.parallel(line, 10);\n * ```\n * @param line\n * @param distance\n */\nexport const parallel = (line, distance) => {\n    const dv = directionVector(line);\n    const dvn = directionVectorNormalised(line);\n    const a = {\n        x: line.a.x - dvn.y * distance,\n        y: line.a.y + dvn.x * distance\n    };\n    return {\n        a,\n        b: {\n            x: a.x + dv.x,\n            y: a.y + dv.y\n        }\n    };\n};\n/**\n * Returns a point perpendicular to `line` at a specified `distance`. Use negative\n * distances for the other side of line.\n * ```\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Project a point 100 units away from line, at its midpoint.\n * const pt = Lines.perpendicularPoint(line, 100, 0.5);\n * ```\n * @param line Line\n * @param distance Distance from line. Use negatives to flip side\n * @param amount Relative place on line to project point from. 0 projects from A, 0.5 from the middle, 1 from B.\n */\nexport const perpendicularPoint = (line, distance, amount = 0) => {\n    const origin = interpolate(amount, line);\n    const dvn = directionVectorNormalised(line);\n    return {\n        x: origin.x - dvn.y * distance,\n        y: origin.y + dvn.x * distance\n    };\n};\n","import { interpolate } from \"./interpolate.js\";\nimport { getPointParameter } from \"./get-points-parameter.js\";\n/**\n * Returns the mid-point of a line (same as `interpolate` with an amount of 0.5)\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.midpoint(line); // Returns {x, y}\n * ```\n * @param aOrLine\n * @param pointB\n * @returns\n */\nexport const midpoint = (aOrLine, pointB) => {\n    const [a, b] = getPointParameter(aOrLine, pointB);\n    return interpolate(0.5, a, b);\n};\n","import { guard as PointsGuard } from '../point/guard.js';\n/**\n * Throws an error if the dimensions of the rectangle are undefined, NaN or negative.\n * @param d\n * @param name\n */\nexport const guardDim = (d, name = `Dimension`) => {\n    if (d === undefined)\n        throw new Error(`${name} is undefined`);\n    if (Number.isNaN(d))\n        throw new Error(`${name} is NaN`);\n    if (d < 0)\n        throw new Error(`${name} cannot be negative`);\n};\n/**\n * Throws an error if rectangle is missing fields or they\n * are not valid.\n *\n * Checks:\n * * `width` and `height` must be defined on `rect`\n * * dimensions (w & h) must not be NaN\n * * dimensions (w & h) must not be negative\n *\n * If `rect` has x,y, this value is checked as well.\n * @param rect\n * @param name\n */\nexport const guard = (rect, name = `rect`) => {\n    if (rect === undefined)\n        throw new Error(`{$name} undefined`);\n    if (isPositioned(rect))\n        PointsGuard(rect, name);\n    guardDim(rect.width, name + `.width`);\n    guardDim(rect.height, name + `.height`);\n};\n/**\n * Returns a positioned rect or if it's not possible, throws an error.\n *\n * If `rect` does not have a position, `origin` is used.\n * If `rect` is positioned and `origin` is provided, returned result uses `origin` as x,y instead.\n * ```js\n * // Returns input because it's positioned\n * getRectPositioned({ x:1, y:2, width:10, height:20 });\n *\n * // Returns { x:1, y:2, width:10, height:20 }\n * getRectPositioned({ width:10, height:20 }, { x:1, y:2 });\n *\n * // Throws, because we have no point\n * getRectPositioned({width:10,height:20})\n * ```\n * @param rect\n * @param origin\n * @returns\n */\nexport const getRectPositioned = (rect, origin) => {\n    guard(rect);\n    if (isPositioned(rect) && origin === undefined) {\n        return rect;\n    }\n    if (origin === undefined)\n        throw new Error(`Unpositioned rect needs origin parameter`);\n    return Object.freeze({ ...rect, ...origin });\n};\n/**\n * Throws an error if `rect` is does not have a position, or\n * is an invalid rectangle\n * @param rect\n * @param name\n */\nexport const guardPositioned = (rect, name = `rect`) => {\n    if (!isPositioned(rect))\n        throw new Error(`Expected ${name} to have x,y`);\n    guard(rect, name);\n};\n/**\n * Returns _true_ if `rect` has width and height values of 0.\n * Use Rects.Empty or Rects.EmptyPositioned to generate an empty rectangle.\n * @param rect\n * @returns\n */\nexport const isEmpty = (rect) => rect.width === 0 && rect.height === 0;\n/**\n * Returns _true_ if `rect` is a placeholder, with both width and height values of NaN.\n * Use Rects.Placeholder or Rects.PlaceholderPositioned to generate a placeholder.\n * @param rect\n * @returns\n */\nexport const isPlaceholder = (rect) => Number.isNaN(rect.width) && Number.isNaN(rect.height);\n/**\n * Returns _true_ if `rect` has position (x,y) fields.\n * @param rect Point, Rect or RectPositiond\n * @returns\n */\nexport const isPositioned = (rect) => rect.x !== undefined && rect.y !== undefined;\n/**\n * Returns _true_ if `rect` has width and height fields.\n * @param rect\n * @returns\n */\nexport const isRect = (rect) => {\n    if (rect === undefined)\n        return false;\n    if (rect.width === undefined)\n        return false;\n    if (rect.height === undefined)\n        return false;\n    return true;\n};\n/**\n * Returns _true_ if `rect` is a positioned rectangle\n * Having width, height, x and y properties.\n * @param rect\n * @returns\n */\nexport const isRectPositioned = (rect) => isRect(rect) && isPositioned(rect);\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { isRect } from \"../rect/guard.js\";\nimport { isPoint } from \"./guard.js\";\n/**\n * Normalises a point so it is on a 0..1 scale\n * @param a Point, or x\n * @param b y coord or width\n * @param c height or width\n * @param d height\n * @returns Point\n */\nexport function normaliseByRect(a, b, c, d) {\n    // ✔️ Unit tested\n    if (isPoint(a)) {\n        if (typeof b === `number` && c !== undefined) {\n            resultThrow(numberTest(b, `positive`, `width`), numberTest(c, `positive`, `height`));\n        }\n        else {\n            if (!isRect(b)) {\n                throw new Error(`Expected second parameter to be a rect`);\n            }\n            c = b.height;\n            b = b.width;\n        }\n        return Object.freeze({\n            x: a.x / b,\n            y: a.y / c,\n        });\n    }\n    else {\n        resultThrow(numberTest(a, `positive`, `x`));\n        if (typeof b !== `number`) {\n            throw new TypeError(`Expecting second parameter to be a number (width)`);\n        }\n        if (typeof c !== `number`) {\n            throw new TypeError(`Expecting third parameter to be a number (height)`);\n        }\n        resultThrow(numberTest(b, `positive`, `y`));\n        resultThrow(numberTest(c, `positive`, `width`));\n        if (d === undefined)\n            throw new Error(`Expected height parameter`);\n        resultThrow(numberTest(d, `positive`, `height`));\n        return Object.freeze({\n            x: a / c,\n            y: b / d,\n        });\n    }\n}\n","import { isPoint, isPoint3d } from \"./guard.js\";\nexport function getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6) {\n    if (isPoint3d(a1) && isPoint3d(ab2))\n        return [a1, ab2];\n    if (isPoint(a1) && isPoint(ab2))\n        return [a1, ab2];\n    if (isPoint3d(a1)) {\n        const b = {\n            x: ab2,\n            y: ab3,\n            z: ab4\n        };\n        if (!isPoint3d(b))\n            throw new Error(`Expected x, y & z parameters`);\n        return [a1, b];\n    }\n    if (isPoint(a1)) {\n        const b = {\n            x: ab2,\n            y: ab3\n        };\n        if (!isPoint(b))\n            throw new Error(`Expected x & y parameters`);\n        return [a1, b];\n    }\n    if (typeof ab5 !== `undefined` && typeof ab4 !== `undefined`) {\n        const a = {\n            x: a1,\n            y: ab2,\n            z: ab3\n        };\n        const b = {\n            x: ab4,\n            y: ab5,\n            z: ab6\n        };\n        if (!isPoint3d(a))\n            throw new Error(`Expected x,y,z for first point`);\n        if (!isPoint3d(b))\n            throw new Error(`Expected x,y,z for second point`);\n        return [a, b];\n    }\n    const a = {\n        x: a1,\n        y: ab2\n    };\n    const b = {\n        x: ab3,\n        y: ab4\n    };\n    if (!isPoint(a))\n        throw new Error(`Expected x,y for first point`);\n    if (!isPoint(b))\n        throw new Error(`Expected x,y for second point`);\n    return [a, b];\n}\n/**\n * Returns a Point form of either a point, x,y params or x,y,z params.\n * If parameters are undefined, an empty point is returned (0, 0)\n * @ignore\n * @param a\n * @param b\n * @returns\n */\nexport function getPointParameter(a, b, c) {\n    if (a === undefined)\n        return { x: 0, y: 0 };\n    if (Array.isArray(a)) {\n        if (a.length === 0)\n            return Object.freeze({ x: 0, y: 0 });\n        if (a.length === 1)\n            return Object.freeze({ x: a[0], y: 0 });\n        if (a.length === 2)\n            return Object.freeze({ x: a[0], y: a[1] });\n        if (a.length === 3)\n            return Object.freeze({ x: a[0], y: a[1], z: a[2] });\n        throw new Error(`Expected array to be 1-3 elements in length. Got ${a.length}.`);\n    }\n    if (isPoint(a)) {\n        return a;\n    }\n    else if (typeof a !== `number` || typeof b !== `number`) {\n        throw new TypeError(`Expected point or x,y as parameters. Got: a: ${JSON.stringify(a)} b: ${JSON.stringify(b)}`);\n    }\n    // x,y,z\n    if (typeof c === `number`) {\n        return Object.freeze({ x: a, y: b, z: c });\n    }\n    // x,y\n    return Object.freeze({ x: a, y: b });\n}\n","import { guard, isPoint3d } from \"./guard.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\n/**\n * Calculate distance between two points.\n * If both points have a `z` property, the distance is 3D distance is calculated.\n * If only one point has a `z`, it is ignored.\n *\n * ```js\n * // Distance between two points\n * const ptA = { x: 0.5, y:0.8 };\n * const ptB = { x: 1, y: 0.4 };\n * distance(ptA, ptB);\n * // Or, provide x,y as parameters\n * distance(ptA, 0.4, 0.9);\n *\n * // Distance from ptA to x: 0.5, y:0.8, z: 0.1\n * const ptC = { x: 0.5, y:0.5, z: 0.3 };\n * // With x,y,z as parameters:\n * distance(ptC, 0.5, 0.8, 0.1);\n * ```\n * @param a First point\n * @param xOrB Second point, or x coord\n * @param y y coord, if x coord is given\n * @param z Optional z coord, if x and y are given.\n * @returns\n */\nexport function distance(a, xOrB, y, z) {\n    const pt = getPointParameter(xOrB, y, z);\n    guard(pt, `b`);\n    guard(a, `a`);\n    return isPoint3d(pt) && isPoint3d(a) ? Math.hypot(pt.x - a.x, pt.y - a.y, pt.z - a.z) : Math.hypot(pt.x - a.x, pt.y - a.y);\n}\n","import { distance as PointsDistance } from \"../point/distance.js\";\nimport { minIndex } from \"@ixfx/numbers\";\n/**\n * Returns the nearest point on `line` closest to `point`.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const pt = Lines.nearest(line, {x:10,y:10});\n * ```\n *\n * If an array of lines is provided, it will be the closest point amongst all the lines\n * @param line Line or array of lines\n * @param point\n * @returns Point `{ x, y }`\n */\nexport const nearest = (line, point) => {\n    const n = (line) => {\n        const { a, b } = line;\n        const atob = { x: b.x - a.x, y: b.y - a.y };\n        const atop = { x: point.x - a.x, y: point.y - a.y };\n        const length = atob.x * atob.x + atob.y * atob.y;\n        let dot = atop.x * atob.x + atop.y * atob.y;\n        const t = Math.min(1, Math.max(0, dot / length));\n        dot = (b.x - a.x) * (point.y - a.y) - (b.y - a.y) * (point.x - a.x);\n        return { x: a.x + atob.x * t, y: a.y + atob.y * t };\n    };\n    if (Array.isArray(line)) {\n        const pts = line.map(l => n(l));\n        const dists = pts.map(p => PointsDistance(p, point));\n        return Object.freeze(pts[minIndex(...dists)]);\n    }\n    else {\n        return Object.freeze(n(line));\n    }\n};\n","import { guard } from './guard.js';\nimport { guard as guardPoint } from '../point/guard.js';\nimport { length } from \"./length.js\";\nimport { nearest } from \"./nearest.js\";\n/**\n * Returns the distance of `point` to the nearest point on `line`\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const distance = Lines.distanceSingleLine(line, pt);\n * ```\n * @param line Line\n * @param point Target point\n * @returns\n */\nexport const distanceSingleLine = (line, point) => {\n    guard(line, `line`);\n    guardPoint(point, `point`);\n    if (length(line) === 0) {\n        // Line is really a point\n        return length(line.a, point);\n    }\n    const near = nearest(line, point);\n    return length(near, point);\n};\n","import { isPoint3d } from \"./guard.js\";\n/**\n * Returns the 'minimum' point from an array of points, using a comparison function.\n *\n * @example Find point closest to a coordinate\n * ```js\n * const points = [...];\n * const center = {x: 100, y: 100};\n *\n * const closestToCenter = findMinimum((a, b) => {\n *  const aDist = distance(a, center);\n *  const bDist = distance(b, center);\n *  if (aDistance < bDistance) return a;\n *  return b;\n * }, points);\n * ```\n * @param comparer Compare function returns the smallest of `a` or `b`\n * @param points\n * @returns\n */\nexport function findMinimum(comparer, ...points) {\n    if (points.length === 0)\n        throw new Error(`No points provided`);\n    let min = points[0];\n    for (const p of points) {\n        if (isPoint3d(min) && isPoint3d(p)) {\n            min = comparer(min, p);\n        }\n        else {\n            min = comparer(min, p);\n        }\n    }\n    return min;\n}\n;\n","/**\n * Returns a rectangle based on provided four corners.\n *\n * To create a rectangle that contains an arbitary set of points, use {@link Geometry.Points.bbox | Geometry.Points.bbox}.\n *\n * Does some sanity checking such as:\n *  - x will be smallest of topLeft/bottomLeft\n *  - y will be smallest of topRight/topLeft\n *  - width will be largest between top/bottom left and right\n *  - height will be largest between left and right top/bottom\n *\n */\nexport const maxFromCorners = (topLeft, topRight, bottomRight, bottomLeft) => {\n    if (topLeft.y > bottomRight.y) {\n        throw new Error(`topLeft.y greater than bottomRight.y`);\n    }\n    if (topLeft.y > bottomLeft.y) {\n        throw new Error(`topLeft.y greater than bottomLeft.y`);\n    }\n    const w1 = topRight.x - topLeft.x;\n    const w2 = bottomRight.x - bottomLeft.x;\n    const h1 = Math.abs(bottomLeft.y - topLeft.y);\n    const h2 = Math.abs(bottomRight.y - topRight.y);\n    return {\n        x: Math.min(topLeft.x, bottomLeft.x),\n        y: Math.min(topRight.y, topLeft.y),\n        width: Math.max(w1, w2),\n        height: Math.max(h1, h2),\n    };\n};\n","import { findMinimum } from \"./find-minimum.js\";\nimport { maxFromCorners as RectsMaxFromCorners } from '../rect/max.js';\n/**\n * Returns the minimum rectangle that can enclose all provided points\n * @param points\n * @returns\n */\nexport const bbox = (...points) => {\n    const leftMost = findMinimum((a, b) => {\n        return a.x < b.x ? a : b;\n    }, ...points);\n    const rightMost = findMinimum((a, b) => {\n        return a.x > b.x ? a : b;\n    }, ...points);\n    const topMost = findMinimum((a, b) => {\n        return a.y < b.y ? a : b;\n    }, ...points);\n    const bottomMost = findMinimum((a, b) => {\n        return a.y > b.y ? a : b;\n    }, ...points);\n    const topLeft = { x: leftMost.x, y: topMost.y };\n    const topRight = { x: rightMost.x, y: topMost.y };\n    const bottomRight = { x: rightMost.x, y: bottomMost.y };\n    const bottomLeft = { x: leftMost.x, y: bottomMost.y };\n    return RectsMaxFromCorners(topLeft, topRight, bottomRight, bottomLeft);\n};\nexport const bbox3d = (...points) => {\n    const box = bbox(...points);\n    const zMin = findMinimum((a, b) => {\n        return a.z < b.z ? a : b;\n    }, ...points);\n    const zMax = findMinimum((a, b) => {\n        return a.z > b.z ? a : b;\n    }, ...points);\n    return {\n        ...box,\n        z: zMin.z,\n        depth: zMax.z - zMin.z\n    };\n};\n","import { bbox as PointsBbox } from \"../point/bbox.js\";\n/**\n * Returns a rectangle that encompasses dimension of line\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js';\n * const rect = Lines.bbox(line);\n * ```\n */\nexport const bbox = (line) => PointsBbox(line.a, line.b);\n","import { getPointParameter, getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, guardNonZeroPoint, isPoint3d } from \"./guard.js\";\n/**\n * Returns a Point with the x,y,z values of two points divide (a/b).\n *\n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when dividing a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * divide(ptA, ptB);\n * divide(x1, y1, x2, y2);\n * divide(ptA, x2, y2);\n * ```\n */\nexport function divide(a1, ab2, ab3, ab4, ab5, ab6) {\n    const [ptA, ptB] = getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6);\n    guard(ptA, `a`);\n    guard(ptB, `b`);\n    if (ptB.x === 0)\n        throw new TypeError('Cannot divide by zero (b.x is 0)');\n    if (ptB.y === 0)\n        throw new TypeError('Cannot divide by zero (b.y is 0)');\n    const pt = {\n        x: ptA.x / ptB.x,\n        y: ptA.y / ptB.y,\n    };\n    if (isPoint3d(ptA) || isPoint3d(ptB)) {\n        if (ptB.z === 0)\n            throw new TypeError('Cannot divide by zero (b.z is 0)');\n        pt.z = (ptA.z ?? 0) / (ptB.z ?? 0);\n    }\n    ;\n    return Object.freeze(pt);\n}\n;\n/**\n * Returns a function that divides a point:\n * ```js\n * const f = divider(100, 200);\n * f(50,100); // Yields: { x: 0.5, y: 0.5 }\n * ```\n *\n * Input values can be Point, separate x,y and optional z values or an array:\n * ```js\n * const f = divider({ x: 100, y: 100 });\n * const f = divider( 100, 100 );\n * const f = divider([ 100, 100 ]);\n * ```\n *\n * Likewise the returned function an take these as inputs:\n * ```js\n * f({ x: 100, y: 100});\n * f( 100, 100 );\n * f([ 100, 100 ]);\n * ```\n *\n * Function throws if divisor has 0 for any coordinate (since we can't divide by 0)\n * @param a Divisor point, array of points or x\n * @param b Divisor y value\n * @param c Divisor z value\n * @returns\n */\n//eslint-disable-next-line functional/prefer-readonly-type\nexport function divider(a, b, c) {\n    const divisor = getPointParameter(a, b, c);\n    guardNonZeroPoint(divisor, `divisor`);\n    return (aa, bb, cc) => {\n        const dividend = getPointParameter(aa, bb, cc);\n        return typeof dividend.z === `undefined` ? Object.freeze({\n            x: dividend.x / divisor.x,\n            y: dividend.y / divisor.y,\n        }) : Object.freeze({\n            x: dividend.x / divisor.x,\n            y: dividend.y / divisor.y,\n            z: dividend.z / (divisor.z ?? 1),\n        });\n    };\n}\n","import { divide as PointDivide } from '../point/divider.js';\n/**\n * Divides both start and end points by given x,y\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.divide(l, {x:2, y:4});\n * // Yields: 0.5,0.25 -> 5,2.5\n * ```\n *\n * Dividing by zero will give Infinity for that dimension.\n * @param line\n * @param point\n * @returns\n */\nexport const divide = (line, point) => Object.freeze({\n    ...line,\n    a: PointDivide(line.a, point),\n    b: PointDivide(line.b, point)\n});\n","import { fromPoints } from \"./from-points.js\";\n/**\n * Returns a line from a basis of coordinates (x1, y1, x2, y2)\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line from 0,1 -> 10,15\n * Lines.fromNumbers(0, 1, 10, 15);\n * ```\n * @param x1\n * @param y1\n * @param x2\n * @param y2\n * @returns\n */\nexport const fromNumbers = (x1, y1, x2, y2) => {\n    if (Number.isNaN(x1))\n        throw new Error(`x1 is NaN`);\n    if (Number.isNaN(x2))\n        throw new Error(`x2 is NaN`);\n    if (Number.isNaN(y1))\n        throw new Error(`y1 is NaN`);\n    if (Number.isNaN(y2))\n        throw new Error(`y2 is NaN`);\n    const a = { x: x1, y: y1 };\n    const b = { x: x2, y: y2 };\n    return fromPoints(a, b);\n};\n","import { fromNumbers } from \"./from-numbers.js\";\n/**\n * Returns a line from four numbers [x1,y1,x2,y2].\n *\n * See {@link toFlatArray} to create an array from a line.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = Lines.fromFlatArray(...[0, 0, 100, 100]);\n * // line is {a: { x:0, y:0 }, b: { x: 100, y: 100 } }\n * ```\n * @param array Array in the form [x1,y1,x2,y2]\n * @returns Line\n */\nexport const fromFlatArray = (array) => {\n    if (!Array.isArray(array))\n        throw new Error(`arr parameter is not an array`);\n    if (array.length !== 4)\n        throw new Error(`array is expected to have length four`);\n    return fromNumbers(array[0], array[1], array[2], array[3]);\n};\n","/**\n * Returns true if `p` seems to be a {@link Polar.Coord} (ie has both distance & angleRadian fields)\n * @param p\n * @returns True if `p` seems to be a PolarCoord\n */\nexport const isPolarCoord = (p) => {\n    if (p.distance === undefined)\n        return false;\n    if (p.angleRadian === undefined)\n        return false;\n    return true;\n};\n/**\n * Throws an error if Coord is invalid\n * @param p\n * @param name\n */\nexport const guard = (p, name = `Point`) => {\n    if (p === undefined) {\n        throw new Error(`'${name}' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(p)}`);\n    }\n    if (p === null) {\n        throw new Error(`'${name}' is null. Expected {distance, angleRadian} got ${JSON.stringify(p)}`);\n    }\n    if (p.angleRadian === undefined) {\n        throw new Error(`'${name}.angleRadian' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(p)}`);\n    }\n    if (p.distance === undefined) {\n        throw new Error(`'${name}.distance' is undefined. Expected {distance, angleRadian} got ${JSON.stringify(p)}`);\n    }\n    if (typeof p.angleRadian !== `number`) {\n        throw new TypeError(`'${name}.angleRadian' must be a number. Got ${p.angleRadian}`);\n    }\n    if (typeof p.distance !== `number`) {\n        throw new TypeError(`'${name}.distance' must be a number. Got ${p.distance}`);\n    }\n    if (p.angleRadian === null)\n        throw new Error(`'${name}.angleRadian' is null`);\n    if (p.distance === null)\n        throw new Error(`'${name}.distance' is null`);\n    if (Number.isNaN(p.angleRadian)) {\n        throw new TypeError(`'${name}.angleRadian' is NaN`);\n    }\n    if (Number.isNaN(p.distance))\n        throw new Error(`'${name}.distance' is NaN`);\n};\n","export const piPi = Math.PI * 2;\n","import { piPi } from './pi.js';\nexport function degreeToRadian(angleInDegrees) {\n    return Array.isArray(angleInDegrees) ? angleInDegrees.map(v => v * (Math.PI / 180)) : angleInDegrees * (Math.PI / 180);\n}\n/**\n * Inverts the angle so it points in the opposite direction of a unit circle\n * @param angleInRadians\n * @returns\n */\nexport function radianInvert(angleInRadians) {\n    return (angleInRadians + Math.PI) % (2 * Math.PI);\n}\nexport function radianToDegree(angleInRadians) {\n    return Array.isArray(angleInRadians) ? angleInRadians.map(v => v * 180 / Math.PI) : angleInRadians * 180 / Math.PI;\n}\n/**\n * Angle from x-axis to point (ie. `Math.atan2`)\n * @param point\n * @returns\n */\nexport const radiansFromAxisX = (point) => Math.atan2(point.x, point.y);\n/**\n * Sum angles together, accounting for the 'wrap around'.\n *\n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n *\n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(Math.PI, Math.PI/2, true);\n * ```\n *\n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * {@link degreesSum} is the same, but uses degrees (0..360)\n * @param start Starting angle, in radian\n * @param amount Angle to add, in radian\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in radians\n */\nexport const radiansSum = (start, amount, clockwise = true) => {\n    if (clockwise) {\n        let x = start + amount;\n        if (x >= piPi)\n            x = x % piPi;\n        return x;\n    }\n    else {\n        const x = start - amount;\n        if (x < 0) {\n            return piPi + x;\n        }\n        return x;\n    }\n};\n/**\n * Sum angles together, accounting for the 'wrap around'.\n *\n * `clockwise` of _true_ (default) means angles are added in clockwise direction\n *\n * ```js\n * // From 180deg, add 90deg in the clockwise direction\n * radiansSum(180, 90, true);\n * ```\n *\n * {@link radiansSum} is the same, but uses radians (0..2 Pi)\n *\n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Starting angle, in degrees\n * @param amount Angle to add, in degrees\n * @param clockwise Add in clockwise direction (default: _true_)\n * @returns Sum result, in degrees\n */\nexport const degreesSum = (start, amount, clockwise = true) => radianToDegree(radiansSum(degreeToRadian(start), degreeToRadian(amount), clockwise));\n/**\n * Computes the angle arc between a start and end angle,\n * given in radians. It properly accounts for the wrap-around\n * values.\n *\n * ```js\n * // Between 0-90deg in clockwise direction\n * radianArc(0, Math.PI/2, true); // Yields: 3Pi/2 (270 deg)\n *\n * // In counter-clockwise direction\n * radianArc(0, Math.PI/2, false); // Yields: Math.PI/2 (90deg)\n * ```\n *\n * See {@link degreeArc} to operate in degrees.\n *\n * Orientation of angles is as follows:\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param start Start angle, in radians\n * @param end End angle, in radians\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in radians.\n */\nexport const radianArc = (start, end, clockwise = true) => {\n    let s = start;\n    if (end < s) {\n        s = 0;\n        end = piPi - start + end;\n    }\n    let d = end - s;\n    if (clockwise)\n        d = piPi - d;\n    if (d >= piPi)\n        return d % piPi;\n    return d;\n};\n/**\n * Computes the angle arc between a start and end angle,\n * given in degrees. It properly accounts for the wrap-around\n * values.\n *\n * ```js\n * // Between 0-90 in clockwise direction\n * degreeArc(0, 90, true); // Yields: 270\n *\n * // In counter-clockwise direction\n * degreeArc(0, 90, false); // Yields: 90\n * ```\n *\n * See {@link radianArc} to operate in radians.\n *\n * Orientation of angles is as follows:\n * ```\n *       90\n *        |\n * 180 ---+--- 0\n *        |\n *       270\n * ```\n * @param start Start angle, in degrees\n * @param end End angle, in degrees\n * @param clockwise Calculate in clockwise direction (default: _true_)\n * @returns Angle of arc, in degrees.\n */\nexport const degreeArc = (start, end, clockwise = true) => radianToDegree(radianArc(degreeToRadian(start), degreeToRadian(end), clockwise));\n","import { guard } from \"./guard.js\";\nimport { degreeToRadian } from '../angles.js';\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountRadian Amount to rotate, in radians\n * @returns\n */\nexport const rotate = (c, amountRadian) => Object.freeze({\n    ...c,\n    angleRadian: c.angleRadian + amountRadian,\n});\n/**\n * Inverts the direction of coordinate. Ie if pointing north, will point south.\n * @param p\n * @returns\n */\nexport const invert = (p) => {\n    guard(p, `c`);\n    return Object.freeze({\n        ...p,\n        angleRadian: p.angleRadian - Math.PI,\n    });\n};\n/**\n * Returns true if PolarCoords have same magnitude but opposite direction\n * @param a\n * @param b\n * @returns\n */\nexport const isOpposite = (a, b) => {\n    guard(a, `a`);\n    guard(b, `b`);\n    if (a.distance !== b.distance)\n        return false;\n    return a.angleRadian === -b.angleRadian;\n};\n/**\n * Returns true if Coords have the same direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport const isParallel = (a, b) => {\n    guard(a, `a`);\n    guard(b, `b`);\n    return a.angleRadian === b.angleRadian;\n};\n/**\n * Returns true if coords are opposite direction, regardless of magnitude\n * @param a\n * @param b\n * @returns\n */\nexport const isAntiParallel = (a, b) => {\n    guard(a, `a`);\n    guard(b, `b`);\n    return a.angleRadian === -b.angleRadian;\n};\n/**\n * Returns a rotated coordinate\n * @param c Coordinate\n * @param amountDeg Amount to rotate, in degrees\n * @returns\n */\nexport const rotateDegrees = (c, amountDeg) => Object.freeze({\n    ...c,\n    angleRadian: c.angleRadian + degreeToRadian(amountDeg),\n});\n","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\n/**\n * Returns a Point with the x,y,z values of two points subtracted (a-b).\n *\n * `z` parameter is used if present. Uses a default value of 0 for 'z' when subtracting a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * subtract(ptA, ptB);\n * subtract(x1, y1, x2, y2);\n * subtract(ptA, x2, y2);\n * ```\n */\nexport function subtract(a1, ab2, ab3, ab4, ab5, ab6) {\n    const [ptA, ptB] = getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6);\n    guard(ptA, `a`);\n    guard(ptB, `b`);\n    const pt = {\n        x: ptA.x - ptB.x,\n        y: ptA.y - ptB.y,\n    };\n    if (isPoint3d(ptA) || isPoint3d(ptB)) {\n        pt.z = (ptA.z ?? 0) - (ptB.z ?? 0);\n    }\n    ;\n    return Object.freeze(pt);\n}\n;\n","/**\n * An empty point of `{ x: 0, y: 0 }`.\n *\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty3d` to get an empty point with `z`.\n */\nexport const Empty = { x: 0, y: 0 };\n/**\n * Returns { x:1, y:1 }\n */\nexport const Unit = { x: 1, y: 1 };\n/**\n * An empty Point of `{ x: 0, y: 0, z: 0}`\n * Use `isEmpty` to check if a point is empty.\n * Use `Empty` to get an empty point without `z`.\n */\nexport const Empty3d = { x: 0, y: 0, z: 0 };\n/**\n * Returns { x:1,y:1,z:1 }\n */\nexport const Unit3d = { x: 1, y: 1, z: 1 };\n","import { guard, isPolarCoord } from \"./guard.js\";\nimport { subtract as subtractPoint } from \"../point/subtract.js\";\nimport { guard as guardPoint } from \"../point/guard.js\";\nimport { Empty as EmptyPoint } from '../point/empty.js';\nimport { isPoint } from \"../point/guard.js\";\nimport { radianToDegree } from \"../angles.js\";\n/**\n * Converts to Cartesian coordinate from polar.\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * const origin = { x: 50, y: 50}; // Polar origin\n * // Yields: { x, y }\n * const polar = Polar.toCartesian({ distance: 10, angleRadian: 0 }, origin);\n * ```\n *\n * Distance and angle can be provided as numbers intead:\n *\n * ```\n * // Yields: { x, y }\n * const polar = Polar.toCartesian(10, 0, origin);\n * ```\n *\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const toCartesian = (a, b, c) => {\n    if (isPolarCoord(a)) {\n        if (b === undefined)\n            b = EmptyPoint;\n        if (isPoint(b)) {\n            return polarToCartesian(a.distance, a.angleRadian, b);\n        }\n        throw new Error(`Expecting (Coord, Point). Second parameter is not a point`);\n    }\n    else if (typeof a === `object`) {\n        throw new TypeError(`First param is an object, but not a Coord: ${JSON.stringify(a)}`);\n    }\n    else {\n        if (typeof a === `number` && typeof b === `number`) {\n            if (c === undefined)\n                c = EmptyPoint;\n            if (!isPoint(c)) {\n                throw new Error(`Expecting (number, number, Point). Point param wrong type`);\n            }\n            return polarToCartesian(a, b, c);\n        }\n        else {\n            throw new TypeError(`Expecting parameters of (number, number). Got: (${typeof a}, ${typeof b}, ${typeof c}). a: ${JSON.stringify(a)}`);\n        }\n    }\n};\n/**\n * Converts a Cartesian coordinate to polar\n *\n * ```js\n * import { Polar } from 'https://unpkg.com/ixfx/dist/geometry.js';\n *\n * // Yields: { angleRadian, distance }\n * const polar = Polar.fromCartesian({x: 50, y: 50}, origin);\n * ```\n *\n * Any additional properties of `point` are copied to object.\n * @param point Point\n * @param origin Origin\n * @returns\n */\nexport const fromCartesian = (point, origin) => {\n    point = subtractPoint(point, origin);\n    const angle = Math.atan2(point.y, point.x);\n    return Object.freeze({\n        ...point,\n        angleRadian: angle,\n        distance: Math.hypot(point.x, point.y),\n    });\n};\n/**\n * Converts a polar coordinate to Cartesian\n * @param distance Distance\n * @param angleRadians Angle in radians\n * @param origin Origin, or 0,0 by default.\n * @returns\n */\nconst polarToCartesian = (distance, angleRadians, origin = EmptyPoint) => {\n    guardPoint(origin);\n    return Object.freeze({\n        x: origin.x + distance * Math.cos(angleRadians),\n        y: origin.y + distance * Math.sin(angleRadians),\n    });\n};\n/**\n * Returns a human-friendly string representation `(distance, angleDeg)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport const toString = (p, digits) => {\n    if (p === undefined)\n        return `(undefined)`;\n    if (p === null)\n        return `(null)`;\n    const angleDeg = radianToDegree(p.angleRadian);\n    const d = digits ? p.distance.toFixed(digits) : p.distance;\n    const a = digits ? angleDeg.toFixed(digits) : angleDeg;\n    return `(${d},${a})`;\n};\nexport const toPoint = (v, origin = EmptyPoint) => {\n    guard(v, `v`);\n    return Object.freeze({\n        x: origin.x + v.distance * Math.cos(v.angleRadian),\n        y: origin.y + v.distance * Math.sin(v.angleRadian),\n    });\n};\n","import { guard } from \"./guard.js\";\nimport { numberTest, resultThrow } from \"@ixfx/guards\";\nexport const normalise = (c) => {\n    //guard(v, `v`);\n    if (c.distance === 0)\n        throw new Error(`Cannot normalise vector of length 0`);\n    return Object.freeze({\n        ...c,\n        distance: 1,\n    });\n};\n/**\n * Clamps the magnitude of a vector\n * @param v\n * @param max\n * @param min\n * @returns\n */\nexport const clampMagnitude = (v, max = 1, min = 0) => {\n    let mag = v.distance;\n    if (mag > max)\n        mag = max;\n    if (mag < min)\n        mag = min;\n    return Object.freeze({\n        ...v,\n        distance: mag,\n    });\n};\n/**\n * Calculate dot product of two PolarCoords.\n *\n * Eg, power is the dot product of force and velocity\n *\n * Dot products are also useful for comparing similarity of\n *  angle between two unit PolarCoords.\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a, b) => {\n    guard(a, `a`);\n    guard(b, `b`);\n    return a.distance * b.distance * Math.cos(b.angleRadian - a.angleRadian);\n};\n/**\n * Multiplies the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport const multiply = (v, amt) => {\n    guard(v);\n    resultThrow(numberTest(amt, ``, `amt`));\n    return Object.freeze({\n        ...v,\n        distance: v.distance * amt,\n    });\n};\n/**\n * Divides the magnitude of a coord by `amt`.\n * Direction is unchanged.\n * @param v\n * @param amt\n * @returns\n */\nexport const divide = (v, amt) => {\n    guard(v);\n    resultThrow(numberTest(amt, ``, `amt`));\n    return Object.freeze({\n        ...v,\n        distance: v.distance / amt,\n    });\n};\n","/**\n * Placeholder point: `{ x: NaN, y: NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder3d` get a point with `z` property.\n */\n//eslint-disable-next-line @typescript-eslint/naming-convention\nexport const Placeholder = Object.freeze({ x: Number.NaN, y: Number.NaN });\n/**\n * Placeholder point: `{x: NaN, y:NaN, z:NaN }`\n * Use `isPlaceholder` to check if a point is a placeholder.\n * Use `Placeholder` to get a point without `z` property.\n */\nexport const Placeholder3d = Object.freeze({ x: Number.NaN, y: Number.NaN, z: Number.NaN });\n","import { piPi } from \"../pi.js\";\nimport { guard } from \"./guard.js\";\n/**\n * Returns the angle in radians between `a` and `b`.\n *\n * Eg if `a` is the origin, and `b` is another point,\n * in degrees one would get 0 to -180 when `b` was above `a`.\n *  -180 would be `b` in line with `a`.\n * Same for under `a`.\n *\n * Providing a third point `c` gives the interior angle, where `b` is the middle point.\n *\n * See also {@link angleRadianCircle} which returns coordinates on 0..Math.Pi*2\n * range. This avoids negative numbers.\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const angleRadian = (a, b, c) => {\n    guard(a, `a`);\n    if (b === undefined) {\n        return Math.atan2(a.y, a.x);\n    }\n    guard(b, `b`);\n    if (c === undefined) {\n        return Math.atan2(b.y - a.y, b.x - a.x);\n    }\n    guard(c, `c`);\n    return Math.atan2(b.y - a.y, b.x - a.x) - Math.atan2(c.y - a.y, c.x - a.x);\n};\n/**\n * Returns the angle between point(s) using a radian circle system.\n * ```\n *       90deg\n *       Pi/2\n *        |\n * Pi  ---+--- 0\n * 180    |\n *       3PI/2\n *       270deg\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport const angleRadianCircle = (a, b, c) => {\n    const angle = angleRadian(a, b, c);\n    if (angle < 0)\n        return angle + piPi;\n    return angle;\n};\n","import {} from \"../line/line-type.js\";\nimport {} from '../point/point-type.js';\nimport { distance } from '../point/distance.js';\nimport { angleRadian } from '../point/angle.js';\nimport {} from \"./types.js\";\nimport { toCartesian as polarToCartesian } from \"./conversions.js\";\n/**\n * Converts a ray to a Line in cartesian coordinates.\n *\n * @param ray\n * @param origin Override or provide origin point\n * @returns\n */\nexport const toCartesian = (ray, origin) => {\n    const o = getOrigin(ray, origin);\n    const a = polarToCartesian(ray.offset, ray.angleRadian, o);\n    const b = polarToCartesian(ray.offset + ray.length, ray.angleRadian, o);\n    return { a, b };\n};\nconst getOrigin = (ray, origin) => {\n    if (origin !== undefined)\n        return origin;\n    if (ray.origin !== undefined)\n        return ray.origin;\n    return { x: 0, y: 0 };\n};\n/**\n * Returns a copy of `ray` ensuring it has an origin.\n * If the `origin` parameter is provided, it will override the existing origin.\n * If no origin information is available, 0,0 is used.\n * @param ray\n * @param origin\n * @returns\n */\n// const withOrigin = (ray: PolarRay, origin?: Point): PolarRayWithOrigin => {\n//   if (origin) {\n//     return {\n//       ...ray,\n//       origin\n//     };\n//   }\n//   if (ray.origin !== undefined) return { ...ray } as PolarRayWithOrigin;\n//   return {\n//     ...ray,\n//     origin: { x: 0, y: 0 }\n//   }\n// }\n// function getAngle(a: Point, b: Point) {\n//   const angle = Math.atan2(b.y - a.y, b.x - a.x);// * (180 / Math.PI) + 90;\n//   return angle;//return (angle < 0) ? scale(angle, -90, 0, 0, piPi) : angle;\n// }\nexport const toString = (ray) => {\n    return `PolarRay(angle: ${ray.angleRadian} offset: ${ray.offset} len: ${ray.length})`;\n};\n/**\n * Returns a PolarRay based on a line and origin.\n * If `origin` is omitted, the origin is taken to be the 'a' point of the line.\n * @param line\n * @param origin\n * @returns\n */\nexport const fromLine = (line, origin) => {\n    const o = origin ?? line.a;\n    return {\n        angleRadian: angleRadian(line.b, o),\n        offset: distance(line.a, o),\n        length: distance(line.b, line.a),\n        origin: o\n    };\n};\n","/**\n * Produces an Archimedean spiral. It's a generator.\n *\n * ```js\n * const s = spiral(0.1, 1);\n * for (const coord of s) {\n *  // Use Polar coord...\n *  if (coord.step === 1000) break; // Stop after 1000 iterations\n * }\n * ```\n *\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n */\nexport function* spiral(smoothness, zoom) {\n    let step = 0;\n    while (true) {\n        const a = smoothness * step++;\n        yield {\n            distance: zoom * a,\n            angleRadian: a,\n            step: step,\n        };\n    }\n}\n/**\n * Produces an Archimedian spiral with manual stepping.\n * @param step Step number. Typically 0, 1, 2 ...\n * @param smoothness 0.1 pretty rounded, at around 5 it starts breaking down\n * @param zoom At smoothness 0.1, zoom starting at 1 is OK\n * @returns\n */\nexport const spiralRaw = (step, smoothness, zoom) => {\n    const a = smoothness * step;\n    return Object.freeze({\n        distance: zoom * a,\n        angleRadian: a,\n    });\n};\n","// import { degreeToRadian, radianToDegree } from '../Angles.js';\nexport * from './angles.js';\nexport * from './conversions.js';\nexport * from './guard.js';\nexport * from './math.js';\nexport * as Ray from './ray.js';\nexport * from './spiral.js';\n","import * as Polar from \"../polar/index.js\";\nimport { radianInvert } from \"../angles.js\";\n/**\n * Creates a line from an origin point.\n * ```js\n * // Line of length 0.2 with middle at 0.5,0.5\n * fromPivot({ x:0.5, y:0.5 }, 0.2);\n * // Same line, but on an angle\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45));\n *\n * // ...now with pivot point at 20%, rather than center\n * fromPivot({ x:0.5, y:0.5 }, 0.2, degreesToRadian(45), 0.2);\n * ```\n *\n * Examples:\n * * Angle of 0 (deg/rad) results in a horizontal line,\n * * Angle of 90deg in a vertical line.\n * * Angle of 45deg will be angled downwards.\n *\n * @param origin Origin to pivot around\n * @param length Total length of line\n * @param angleRadian Angle of line, in radians\n * @param balance Percentage of where origin ought to be on line. Default: 0.5, meaning the middle of line\n */\nexport const fromPivot = (origin = { x: 0.5, y: 0.5 }, length = 1, angleRadian = 0, balance = 0.5) => {\n    const left = length * balance;\n    const right = length * (1 - balance);\n    const a = Polar.toCartesian(left, radianInvert(angleRadian), origin);\n    const b = Polar.toCartesian(right, angleRadian, origin);\n    return Object.freeze({\n        a, b\n    });\n};\n","import { fromPoints } from \"./from-points.js\";\nimport { toPath } from \"./to-path.js\";\n/**\n * Returns a {@link LinePath} from two points\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const path = Lines.fromPointsToPath(ptA, ptB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const fromPointsToPath = (a, b) => toPath(fromPoints(a, b));\n","/**\n * Returns _true_ if the points have identical values\n *\n * ```js\n * const a = {x: 10, y: 10};\n * const b = {x: 10, y: 10;};\n * a === b        // False, because a and be are different objects\n * isEqual(a, b)   // True, because a and b are same value\n * ```\n * @param p Points\n * @returns _True_ if points are equal\n */\nexport const isEqual = (...p) => {\n    if (p === undefined)\n        throw new Error(`parameter 'p' is undefined`);\n    if (p.length < 2)\n        return true;\n    for (let index = 1; index < p.length; index++) {\n        if (p[index].x !== p[0].x)\n            return false;\n        if (p[index].y !== p[0].y)\n            return false;\n    }\n    return true;\n};\n","import { isEqual as PointsIsEqual } from '../point/is-equal.js';\n/**\n * Returns true if the lines have the same value. Note that only\n * the line start and end points are compared. So the lines might\n * be different in other properties, and `isEqual` will still return\n * true.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const a = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * const b = { a: {x:0,  y: 10 }, b: { x: 20, y: 20 }};\n * a === b; // false, because they are different objects\n * Lines.isEqual(a, b); // true, because they have the same value\n * ```\n * @param {Line} a\n * @param {Line} b\n * @returns {boolean}\n */\nexport const isEqual = (a, b) => PointsIsEqual(a.a, b.a) && PointsIsEqual(a.b, b.b);\n","import { isPoint, isPoint3d } from \"./guard.js\";\n/**\n * Returns a point with Math.abs applied to x,y and z if present.\n * ```js\n * Points.abs({ x:1,  y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:1  }); // { x: 1, y: 1 }\n * Points.abs({ x:-1, y:-1 }); // { x: 1, y: 1 }\n * ```\n * @param pt\n * @returns\n */\nexport function abs(pt) {\n    if (isPoint3d(pt)) {\n        return Object.freeze({\n            ...pt,\n            x: Math.abs(pt.x),\n            y: Math.abs(pt.y),\n            z: Math.abs(pt.z)\n        });\n    }\n    else if (isPoint(pt)) {\n        return Object.freeze({\n            ...pt,\n            x: Math.abs(pt.x),\n            y: Math.abs(pt.y)\n        });\n    }\n    else\n        throw new TypeError(`Param 'pt' is not a point`);\n}\n;\n","import { guard, isPoint3d } from \"./guard.js\";\n/**\n * Applies `fn` on x,y & z (if present) fields, returning all other fields as well\n * ```js\n * const p = {x:1.234, y:4.9};\n * const p2 = Points.apply(p, Math.round);\n * // Yields: {x:1, y:5}\n * ```\n *\n * The name of the field is provided as well. Here we only round the `x` field:\n *\n * ```js\n * const p = {x:1.234, y:4.9};\n * const p2 = Points.apply(p, (v, field) => {\n *  if (field === `x`) return Math.round(v);\n *  return v;\n * });\n * ```\n * @param pt\n * @param fn\n * @returns\n */\nexport function apply(pt, fn) {\n    guard(pt, `pt`);\n    if (isPoint3d(pt)) {\n        return Object.freeze({\n            ...pt,\n            x: fn(pt.x, `x`),\n            y: fn(pt.y, `y`),\n            z: fn(pt.z, `z`)\n        });\n    }\n    return Object.freeze({\n        ...pt,\n        x: fn(pt.x, `x`),\n        y: fn(pt.y, `y`),\n    });\n}\n","import { movingAverageLight as mal } from \"@ixfx/numbers\";\nimport { isPoint3d } from \"./guard.js\";\nexport function averager(kind, opts) {\n    let x;\n    let y;\n    let z;\n    switch (kind) {\n        case `moving-average-light`:\n            const scaling = opts.scaling ?? 3;\n            x = mal(scaling);\n            y = mal(scaling);\n            z = mal(scaling);\n            break;\n        default:\n            throw new Error(`Unknown averaging kind '${kind}'. Expected: 'moving-average-light'`);\n    }\n    return (point) => {\n        const ax = x(point.x);\n        const ay = y(point.y);\n        if (isPoint3d(point)) {\n            const az = z(point.z);\n            return Object.freeze({\n                x: ax,\n                y: ay,\n                z: az\n            });\n        }\n        else {\n            return Object.freeze({\n                x: ax,\n                y: ay\n            });\n        }\n    };\n}\n","import { isPoint } from \"./guard.js\";\n/**\n * Calculates the [centroid](https://en.wikipedia.org/wiki/Centroid#Of_a_finite_set_of_points) of a set of points\n * Undefined values are skipped over.\n *\n * ```js\n * // Find centroid of a list of points\n * const c1 = centroid(p1, p2, p3, ...);\n *\n * // Find centroid of an array of points\n * const c2 = centroid(...pointsArray);\n * ```\n * @param points\n * @returns A single point\n */\nexport const centroid = (...points) => {\n    if (!Array.isArray(points))\n        throw new Error(`Expected list of points`);\n    // eslint-disable-next-line unicorn/no-array-reduce\n    const sum = points.reduce((previous, p) => {\n        if (p === undefined)\n            return previous; // Ignore undefined\n        if (Array.isArray(p)) {\n            throw new TypeError(`'points' list contains an array. Did you mean: centroid(...myPoints)?`);\n        }\n        if (!isPoint(p)) {\n            throw new Error(`'points' contains something which is not a point: ${JSON.stringify(p)}`);\n        }\n        return {\n            x: previous.x + p.x,\n            y: previous.y + p.y,\n        };\n    }, { x: 0, y: 0 });\n    return Object.freeze({\n        x: sum.x / points.length,\n        y: sum.y / points.length,\n    });\n};\n","import { clamp as clampNumber } from '@ixfx/numbers';\nimport { isPoint3d } from \"./guard.js\";\n/**\n * Clamps a point to be between `min` and `max` (0 & 1 by default)\n * @param pt Point\n * @param min Minimum value (0 by default)\n * @param max Maximum value (1 by default)\n */\nexport function clamp(a, min = 0, max = 1) {\n    if (isPoint3d(a)) {\n        return Object.freeze({\n            x: clampNumber(a.x, min, max),\n            y: clampNumber(a.y, min, max),\n            z: clampNumber(a.z, min, max)\n        });\n    }\n    else {\n        return Object.freeze({\n            x: clampNumber(a.x, min, max),\n            y: clampNumber(a.y, min, max),\n        });\n    }\n}\n","/**\n * Returns -2 if both x & y of a is less than b\n * Returns -1 if either x/y of a is less than b\n *\n * Returns 2 if both x & y of a is greater than b\n * Returns 1 if either x/y of a is greater than b's x/y\n *\n * Returns 0 if x/y of a and b are equal\n * @param a\n * @param b\n * @returns\n */\nexport const compare = (a, b) => {\n    if (a.x < b.x && a.y < b.y)\n        return -2;\n    if (a.x > b.x && a.y > b.y)\n        return 2;\n    if (a.x < b.x || a.y < b.y)\n        return -1;\n    if (a.x > b.x || a.y > b.y)\n        return 1;\n    if (a.x === b.x && a.x === b.y)\n        return 0;\n    return Number.NaN;\n};\n/**\n * Compares points based on x value. Y value is ignored.\n *\n * Return values:\n * * 0: If a.x === b.x\n * * 1: a is to the right of b (ie. a.x > b.x)\n * * -1: a is to the left of b (ie. a.x < b.x)\n *\n * @example Sorting by x\n * ```js\n * arrayOfPoints.sort(Points.compareByX);\n * ```\n *\n * @param a\n * @param b\n * @returns\n */\nexport const compareByX = (a, b) => {\n    if (a.x === b.x)\n        return 0;\n    if (a.x < b.x)\n        return -1;\n    return 1;\n    // a.x - b.x || a.y - b.y;\n};\n/**\n * Compares points based on Y value. X value is ignored.\n * Returns values:\n * * 0: If a.y === b.y\n * * 1: A is below B (ie. a.y > b.y)\n * * -1: A is above B (ie. a.y < b.y)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByY);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByY = (a, b) => {\n    if (a.y === b.y)\n        return 0;\n    if (a.y < b.y)\n        return -1;\n    return 1;\n};\n/**\n * Compares points based on Z value. XY values are ignored.\n * Returns values:\n * * 0: If a.z === b.z\n * * 1: A is below B (ie. a.z > b.z)\n * * -1: A is above B (ie. a.z < b.z)\n *\n * @example Sorting by Y\n * ```js\n * arrayOfPoints.sort(Points.compareByZ);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareByZ = (a, b) => {\n    if (a.z === b.z)\n        return 0;\n    if (a.z < b.z)\n        return -1;\n    return 1;\n};\n","import { compareByX } from \"./compare.js\";\nimport { isEqual } from \"./is-equal.js\";\n/**\n * Simple convex hull impementation. Returns a set of points which\n * enclose `pts`.\n *\n * For more power, see something like [Hull.js](https://github.com/AndriiHeonia/hull)\n * @param pts\n * @returns\n */\nexport const convexHull = (...pts) => {\n    const sorted = [...pts].sort(compareByX);\n    if (sorted.length === 1)\n        return sorted;\n    const x = (points) => {\n        const v = [];\n        for (const p of points) {\n            while (v.length >= 2) {\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const q = v.at(-1);\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const r = v.at(-2);\n                if ((q.x - r.x) * (p.y - r.y) >= (q.y - r.y) * (p.x - r.x)) {\n                    //eslint-disable-next-line functional/immutable-data\n                    v.pop();\n                }\n                else\n                    break;\n            }\n            //eslint-disable-next-line functional/immutable-data\n            v.push(p);\n        }\n        //eslint-disable-next-line functional/immutable-data\n        v.pop();\n        return v;\n    };\n    const upper = x(sorted);\n    //eslint-disable-next-line functional/immutable-data\n    const lower = x(sorted.reverse());\n    if (upper.length === 1 && lower.length === 1 && isEqual(lower[0], upper[0])) {\n        return upper;\n    }\n    return [...upper, ...lower];\n};\n","import { guard as guardPoint } from '../point/guard.js';\n/**\n * Throws if radius is out of range. If x,y is present, these will be validated too.\n * @param circle\n * @param parameterName\n */\nexport const guard = (circle, parameterName = `circle`) => {\n    if (isCirclePositioned(circle)) {\n        guardPoint(circle, `circle`);\n    }\n    if (Number.isNaN(circle.radius))\n        throw new Error(`${parameterName}.radius is NaN`);\n    if (circle.radius <= 0)\n        throw new Error(`${parameterName}.radius must be greater than zero`);\n};\n/**\n * Throws if `circle` is not positioned or has dodgy fields\n * @param circle\n * @param parameterName\n * @returns\n */\nexport const guardPositioned = (circle, parameterName = `circle`) => {\n    if (!isCirclePositioned(circle))\n        throw new Error(`Expected a positioned circle with x,y`);\n    guard(circle, parameterName);\n};\n/***\n * Returns true if radius, x or y are NaN\n */\nexport const isNaN = (a) => {\n    if (Number.isNaN(a.radius))\n        return true;\n    if (isCirclePositioned(a)) {\n        if (Number.isNaN(a.x))\n            return true;\n        if (Number.isNaN(a.y))\n            return true;\n    }\n    return false;\n};\n/**\n * Returns true if parameter has x,y. Does not verify if parameter is a circle or not\n *\n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n *\n * const circleA = { radius: 5 };\n * Circles.isPositioned(circle); // false\n *\n * const circleB = { radius: 5, x: 10, y: 10 }\n * Circles.isPositioned(circle); // true\n * ```\n * @param p Circle\n * @returns\n */\nexport const isPositioned = (p) => p.x !== undefined && p.y !== undefined;\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isCircle = (p) => p.radius !== undefined;\n//eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isCirclePositioned = (p) => isCircle(p) && isPositioned(p);\n","import { distance as pointsDistance } from '../point/distance.js';\nimport { guardPositioned, isCirclePositioned } from \"./guard.js\";\n/**\n * Returns the distance between two circle centers.\n *\n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * Throws an error if either is lacking position.\n * @param a\n * @param b\n * @returns Distance\n */\nexport const distanceCenter = (a, b) => {\n    guardPositioned(a, `a`);\n    if (isCirclePositioned(b)) {\n        guardPositioned(b, `b`);\n    }\n    return pointsDistance(a, b);\n};\n","import { distanceCenter } from \"./distance-center.js\";\nimport { isPoint as PointsIsPoint } from \"../point/guard.js\";\nimport { distance as PointsDistance } from \"../point/distance.js\";\nimport { guardPositioned, isCirclePositioned } from \"./guard.js\";\n/**\n * Returns the distance between the exterior of two circles, or between the exterior of a circle and point.\n * If `b` overlaps or is enclosed by `a`, distance is 0.\n *\n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n * const circleA = { radius: 5, x: 5, y: 5 }\n * const circleB = { radius: 10, x: 20, y: 20 }\n * const distance = Circles.distanceCenter(circleA, circleB);\n * ```\n * @param a\n * @param b\n */\nexport const distanceFromExterior = (a, b) => {\n    guardPositioned(a, `a`);\n    if (isCirclePositioned(b)) {\n        return Math.max(0, distanceCenter(a, b) - a.radius - b.radius);\n    }\n    else if (PointsIsPoint(b)) {\n        const distribution = PointsDistance(a, b);\n        if (distribution < a.radius)\n            return 0;\n        return distribution;\n    }\n    else\n        throw new Error(`Second parameter invalid type`);\n};\n","import { isCirclePositioned } from \"./guard.js\";\n/**\n * Returns true if the two objects have the same values\n *\n * ```js\n * const circleA = { radius: 10, x: 5, y: 5 };\n * const circleB = { radius: 10, x: 5, y: 5 };\n *\n * circleA === circleB; // false, because identity of objects is different\n * Circles.isEqual(circleA, circleB); // true, because values are the same\n * ```\n *\n * Circles must both be positioned or not.\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a, b) => {\n    if (a.radius !== b.radius)\n        return false;\n    if (isCirclePositioned(a) && isCirclePositioned(b)) {\n        if (a.x !== b.x)\n            return false;\n        if (a.y !== b.y)\n            return false;\n        if (a.z !== b.z)\n            return false;\n        return true;\n    }\n    else if (!isCirclePositioned(a) && !isCirclePositioned(b)) {\n        // no-op\n    }\n    else\n        return false; // one is positioned one not\n    return false;\n};\n","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\n/**\n * Returns a Point with the x,y,z values of two points added.\n *\n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when adding a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * sum(ptA, ptB);\n * sum(x1, y1, x2, y2);\n * sum(ptA, x2, y2);\n * ```\n */\nexport function sum(a1, ab2, ab3, ab4, ab5, ab6) {\n    const [ptA, ptB] = getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6);\n    guard(ptA, `a`);\n    guard(ptB, `b`);\n    const pt = {\n        x: ptA.x + ptB.x,\n        y: ptA.y + ptB.y,\n    };\n    if (isPoint3d(ptA) || isPoint3d(ptB)) {\n        pt.z = (ptA.z ?? 0) + (ptB.z ?? 0);\n    }\n    ;\n    return Object.freeze(pt);\n}\n;\n","import { isEqual } from \"./is-equal.js\";\nimport { sum as PointsSum } from \"../point/sum.js\";\nimport { subtract as PointsSubtract } from \"../point/subtract.js\";\n/**\n * Returns the point(s) of intersection between a circle and line.\n *\n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n * const circle = { radius: 5, x: 5, y: 5 };\n * const line = { a: { x: 0, y: 0 }, b: { x: 10, y: 10 } };\n * const pts = Circles.intersectionLine(circle, line);\n * ```\n * @param circle\n * @param line\n * @returns Point(s) of intersection, or empty array\n */\nexport const intersectionLine = (circle, line) => {\n    const v1 = {\n        x: line.b.x - line.a.x,\n        y: line.b.y - line.a.y\n    };\n    const v2 = {\n        x: line.a.x - circle.x,\n        y: line.a.y - circle.y\n    };\n    const b = (v1.x * v2.x + v1.y * v2.y) * -2;\n    const c = 2 * (v1.x * v1.x + v1.y * v1.y);\n    const d = Math.sqrt(b * b - 2 * c * (v2.x * v2.x + v2.y * v2.y - circle.radius * circle.radius));\n    if (Number.isNaN(d))\n        return []; // no intercept\n    const u1 = (b - d) / c; // these represent the unit distance of point one and two on the line\n    const u2 = (b + d) / c;\n    const returnValue = [];\n    if (u1 <= 1 && u1 >= 0) { // add point if on the line segment\n        returnValue.push({\n            x: line.a.x + v1.x * u1,\n            y: line.a.y + v1.y * u1\n        });\n    }\n    if (u2 <= 1 && u2 >= 0) { // second add point if on the line segment\n        returnValue.push({\n            x: line.a.x + v1.x * u2,\n            y: line.a.y + v1.y * u2\n        });\n    }\n    return returnValue;\n};\n/**\n *\n * Returns the points of intersection betweeen `a` and `b`.\n *\n * Returns an empty array if circles are equal, one contains the other or if they don't touch at all.\n *\n * @param a Circle\n * @param b Circle\n * @returns Points of intersection, or an empty list if there are none\n */\nexport const intersections = (a, b) => {\n    const vector = PointsSubtract(b, a);\n    const centerD = Math.hypot((vector.y), (vector.x));\n    // Do not intersect\n    if (centerD > a.radius + b.radius)\n        return [];\n    // Circle contains another\n    if (centerD < Math.abs(a.radius - b.radius))\n        return [];\n    // Circles are the same\n    if (isEqual(a, b))\n        return [];\n    const centroidD = ((a.radius * a.radius) - (b.radius * b.radius) + (centerD * centerD)) / (2 * centerD);\n    const centroid = {\n        x: a.x + (vector.x * centroidD / centerD),\n        y: a.y + (vector.y * centroidD / centerD)\n    };\n    const centroidIntersectionD = Math.sqrt((a.radius * a.radius) - (centroidD * centroidD));\n    const intersection = {\n        x: -vector.y * (centroidIntersectionD / centerD),\n        y: vector.x * (centroidIntersectionD / centerD)\n    };\n    return [\n        PointsSum(centroid, intersection),\n        PointsSubtract(centroid, intersection)\n    ];\n};\n","import { intersections as circleIntersections } from \"./circle/intersections.js\";\nexport const circleRect = (a, b) => {\n    // https://yal.cc/rectangle-circle-intersection-test/\n    const deltaX = a.x - Math.max(b.x, Math.min(a.x, b.x + b.width));\n    const deltaY = a.y - Math.max(b.y, Math.min(a.y, b.y + b.height));\n    return (deltaX * deltaX + deltaY * deltaY) < (a.radius * a.radius);\n};\nexport const circleCircle = (a, b) => circleIntersections(a, b).length === 2;\n","import { guard } from \"./guard.js\";\nimport { isPositioned, isRectPositioned } from \"./guard.js\";\nimport { isCirclePositioned } from '../circle/guard.js';\nimport * as Intersects from '../intersects.js';\nimport { isPoint } from \"../point/guard.js\";\n/**\n * Returns true if point is within or on boundary of `rect`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * Rects.intersectsPoint(rect, { x: 100, y: 100});\n * Rects.intersectsPoint(rect, 100, 100);\n * ```\n * @param rect\n * @param a\n * @param b\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function intersectsPoint(rect, a, b) {\n    guard(rect, `rect`);\n    //eslint-disable-next-line functional/no-let\n    let x = 0;\n    //eslint-disable-next-line functional/no-let\n    let y = 0;\n    if (typeof a === `number`) {\n        if (b === undefined)\n            throw new Error(`x and y coordinate needed`);\n        x = a;\n        y = b;\n    }\n    else {\n        x = a.x;\n        y = a.y;\n    }\n    if (isPositioned(rect)) {\n        if (x - rect.x > rect.width || x < rect.x)\n            return false;\n        if (y - rect.y > rect.height || y < rect.y)\n            return false;\n    }\n    else {\n        // Assume 0,0\n        if (x > rect.width || x < 0)\n            return false;\n        if (y > rect.height || y < 0)\n            return false;\n    }\n    return true;\n}\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A rectangle can be checked for intersections with another RectPositioned, CirclePositioned or Point.\n *\n */\nexport const isIntersecting = (a, \n// eslint-disable-next-line @typescript-eslint/no-redundant-type-constituents\nb) => {\n    if (!isRectPositioned(a)) {\n        throw new Error(`a parameter should be RectPositioned`);\n    }\n    if (isCirclePositioned(b)) {\n        return Intersects.circleRect(b, a);\n    }\n    else if (isPoint(b)) {\n        return intersectsPoint(a, b);\n    }\n    throw new Error(`Unknown shape for b: ${JSON.stringify(b)}`);\n};\n","import { isPoint } from \"../point/guard.js\";\nimport { getRectPositioned, guard } from \"./guard.js\";\n/**\n * Returns the center of a rectangle as a {@link Geometry.Point}.\n *  If the rectangle lacks a position and `origin` parameter is not provided, 0,0 is used instead.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const p = Rects.center({x:10, y:20, width:100, height:50});\n * const p2 = Rects.center({width: 100, height: 50}); // Assumes 0,0 for rect x,y\n * ```\n * @param rect Rectangle\n * @param origin Optional origin. Overrides `rect` position if available. If no position is available 0,0 is used by default.\n * @returns\n */\nexport const center = (rect, origin) => {\n    guard(rect);\n    if (origin === undefined && isPoint(rect))\n        origin = rect;\n    else if (origin === undefined)\n        origin = { x: 0, y: 0 }; // throw new Error(`Unpositioned rect needs origin param`);\n    const r = getRectPositioned(rect, origin);\n    return Object.freeze({\n        x: origin.x + rect.width / 2,\n        y: origin.y + rect.height / 2,\n    });\n};\n","import { guardPositioned } from \"./guard.js\";\nimport { intersectsPoint } from \"./Intersects.js\";\nimport { center } from \"./center.js\";\nimport {} from '../point/point-type.js';\nimport { guard as PointsGuard } from '../point/guard.js';\nimport { distance as PointsDistance } from '../point/distance.js';\n/**\n * Returns the distance from the perimeter of `rect` to `pt`.\n * If the point is within the rectangle, 0 is returned.\n *\n * If `rect` does not have an x,y it's assumed to be 0,0\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromExterior(rect, { x: 20, y: 20 });\n * ```\n * @param rect Rectangle\n * @param pt Point\n * @returns Distance\n */\nexport const distanceFromExterior = (rect, pt) => {\n    guardPositioned(rect, `rect`);\n    PointsGuard(pt, `pt`);\n    if (intersectsPoint(rect, pt))\n        return 0;\n    const dx = Math.max(rect.x - pt.x, 0, pt.x - rect.x + rect.width);\n    const dy = Math.max(rect.y - pt.y, 0, pt.y - rect.y + rect.height);\n    return Math.hypot(dx, dy);\n};\n/**\n * Return the distance of `pt` to the center of `rect`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0 };\n * Rects.distanceFromCenter(rect, { x: 20, y: 20 });\n * ```\n * @param rect\n * @param pt\n * @returns\n */\nexport const distanceFromCenter = (rect, pt) => PointsDistance(center(rect), pt);\n","import { distanceFromExterior as circleDistanceFromExterior } from \"../circle/distance-from-exterior.js\";\nimport { distance } from \"./distance.js\";\nimport { isPoint } from \"./guard.js\";\nimport { distanceFromExterior as rectDistanceFromExterior } from \"../rect/distance.js\";\nimport { isCirclePositioned } from \"../circle/guard.js\";\nimport { isRectPositioned } from \"../rect/guard.js\";\n/**\n * Returns the distance from point `a` to the center of `shape`.\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport const distanceToCenter = (a, shape) => {\n    if (isRectPositioned(shape)) {\n        return rectDistanceFromExterior(shape, a);\n    }\n    if (isCirclePositioned(shape)) {\n        return circleDistanceFromExterior(shape, a);\n    }\n    if (isPoint(shape))\n        return distance(a, shape);\n    throw new Error(`Unknown shape`);\n};\n","import { distanceFromExterior as rectDistanceFromExterior } from \"../rect/distance.js\";\nimport { isCirclePositioned } from \"../circle/guard.js\";\nimport { isRectPositioned } from \"../rect/guard.js\";\nimport { isPoint } from \"./guard.js\";\nimport { distance } from \"./distance.js\";\nimport { distanceFromExterior as circleDistanceFromExterior } from \"../circle/distance-from-exterior.js\";\n/**\n * Returns the distance from point `a` to the exterior of `shape`.\n *\n * @example Distance from point to rectangle\n * ```\n * const distance = distanceToExterior(\n *  {x: 50, y: 50},\n *  {x: 100, y: 100, width: 20, height: 20}\n * );\n * ```\n *\n * @example Find closest shape to point\n * ```\n * import {minIndex} from '../data/arrays.js';\n * const shapes = [ some shapes... ]; // Shapes to compare against\n * const pt = { x: 10, y: 10 };       // Comparison point\n * const distances = shapes.map(v => distanceToExterior(pt, v));\n * const closest = shapes[minIndex(...distances)];\n * ```\n * @param a Point\n * @param shape Point, or a positioned Rect or Circle.\n * @returns\n */\nexport const distanceToExterior = (a, shape) => {\n    if (isRectPositioned(shape)) {\n        return rectDistanceFromExterior(shape, a);\n    }\n    if (isCirclePositioned(shape)) {\n        return circleDistanceFromExterior(shape, a);\n    }\n    if (isPoint(shape))\n        return distance(a, shape);\n    throw new Error(`Unknown shape`);\n};\n","/**\n * Returns point as an array in the form [x,y]. This can be useful for some libraries\n * that expect points in array form.\n *\n * ```\n * const p = {x: 10, y:5};\n * const p2 = toArray(p); // yields [10,5]\n * ```\n * @param p\n * @returns\n */\nexport const toArray = (p) => [p.x, p.y];\n","import { dotProduct as ArraysDotProduct } from '@ixfx/numbers';\nimport { toArray } from './to-array.js';\nexport const dotProduct = (...pts) => {\n    const a = pts.map(p => toArray(p));\n    return ArraysDotProduct(a);\n};\n","import { guard } from \"./guard.js\";\n/**\n * Returns a point from two or three coordinates or an array of [x,y] or [x,y,z].\n * @example\n * ```js\n * let p = from([10, 5]);    // yields {x:10, y:5}\n * let p = from([10, 5, 2]); // yields: {x:10, y:5, z:2}\n * let p = from(10, 5);      // yields {x:10, y:5}\n * let p = from(10, 5, 2);   // yields: {x:10, y:5, z:2}\n * ```\n * @param xOrArray\n * @param [y]\n * @returns Point\n */\nexport function from(xOrArray, y, z) {\n    if (Array.isArray(xOrArray)) {\n        if (xOrArray.length === 3) {\n            return Object.freeze({\n                x: xOrArray[0],\n                y: xOrArray[1],\n                z: xOrArray[2]\n            });\n        }\n        else if (xOrArray.length === 2) {\n            return Object.freeze({\n                x: xOrArray[0],\n                y: xOrArray[1],\n            });\n        }\n        else {\n            throw new Error(`Expected array of length two or three, got ${xOrArray.length}`);\n        }\n    }\n    else {\n        if (xOrArray === undefined)\n            throw new Error(`Requires an array of [x,y] or x,y parameters at least`);\n        else if (Number.isNaN(xOrArray))\n            throw new Error(`x is NaN`);\n        if (y === undefined)\n            throw new Error(`Param 'y' is missing`);\n        else if (Number.isNaN(y))\n            throw new Error(`y is NaN`);\n        if (z === undefined) {\n            return Object.freeze({ x: xOrArray, y: y });\n        }\n        else {\n            return Object.freeze({ x: xOrArray, y, z });\n        }\n    }\n}\n;\n/**\n * Parses a point as a string, in the form 'x,y' or 'x,y,z'.\n * eg '10,15' will be returned as `{ x: 10, y: 15 }`.\n *\n * Throws an error if `str` is not a string.\n *\n * ```js\n * Points.fromString(`10,15`);  // { x:10, y:15 }\n * Points.fromString(`a,10`);   // { x:NaN, y:10 }\n * ```\n *\n * Use {@link Points.isNaN} to check if returned point has NaN for either coordinate.\n * @param str\n */\nexport const fromString = (str) => {\n    if (typeof str !== `string`)\n        throw new TypeError(`Param 'str' ought to be a string. Got: ${typeof str}`);\n    const comma = str.indexOf(`,`);\n    const x = Number.parseFloat(str.substring(0, comma));\n    const nextComma = str.indexOf(',', comma + 1);\n    if (nextComma > 0) {\n        // z component\n        const y = Number.parseFloat(str.substring(comma + 1, nextComma - comma + 2));\n        const z = Number.parseFloat(str.substring(nextComma + 1));\n        return { x, y, z };\n    }\n    else {\n        const y = Number.parseFloat(str.substring(comma + 1));\n        return { x, y };\n    }\n};\n/**\n * Returns an array of points from an array of numbers.\n *\n * Array can be a continuous series of x, y values:\n * ```\n * [1,2,3,4] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n *\n * Or it can be an array of arrays:\n * ```\n * [[1,2], [3,4]] would yield: [{x:1, y:2}, {x:3, y:4}]\n * ```\n * @param coords\n * @returns\n */\nexport const fromNumbers = (...coords) => {\n    const pts = [];\n    if (Array.isArray(coords[0])) {\n        // [[x,y],[x,y]...]\n        for (const coord of coords) {\n            if (!(coord.length % 2 === 0)) {\n                throw new Error(`coords array should be even-numbered`);\n            }\n            //eslint-disable-next-line  functional/immutable-data\n            pts.push(Object.freeze({ x: coord[0], y: coord[1] }));\n        }\n    }\n    else {\n        // [x,y,x,y,x,y]\n        if (coords.length % 2 !== 0) {\n            throw new Error(`Expected even number of elements: [x,y,x,y...]`);\n        }\n        for (let index = 0; index < coords.length; index += 2) {\n            //eslint-disable-next-line  functional/immutable-data\n            pts.push(Object.freeze({ x: coords[index], y: coords[index + 1] }));\n        }\n    }\n    return pts;\n};\n","import { interpolate as lineInterpolate } from '../line/interpolate.js';\n/**\n * Returns a relative point between two points\n * ```js\n * interpolate(0.5, a, b); // Halfway point between a and b\n * ```\n *\n * Alias for Lines.interpolate(amount, a, b);\n *\n * @param amount Relative amount, 0-1\n * @param a\n * @param b\n * @param allowOverflow If true, length of line can be exceeded for `amount` of below 0 and above `1`.\n * @returns {@link Point}\n */\nexport const interpolate = (amount, a, b, allowOverflow = false) => lineInterpolate(amount, a, b, allowOverflow); //({x: (1-amt) * a.x + amt * b.x, y:(1-amt) * a.y + amt * b.y });\n","import { isPoint3d } from \"./guard.js\";\n/**\n * Inverts one or more axis of a point\n * ```js\n * invert({x:10, y:10}); // Yields: {x:-10, y:-10}\n * invert({x:10, y:10}, `x`); // Yields: {x:-10, y:10}\n * ```\n * @param pt Point to invert\n * @param what Which axis. If unspecified, both axies are inverted\n * @returns\n */\nexport const invert = (pt, what = `both`) => {\n    switch (what) {\n        case `both`: {\n            return isPoint3d(pt) ? Object.freeze({\n                ...pt,\n                x: pt.x * -1,\n                y: pt.y * -1,\n                z: pt.z * -1,\n            }) : Object.freeze({\n                ...pt,\n                x: pt.x * -1,\n                y: pt.y * -1,\n            });\n        }\n        case `x`: {\n            return Object.freeze({\n                ...pt,\n                x: pt.x * -1,\n            });\n        }\n        case `y`: {\n            return Object.freeze({\n                ...pt,\n                y: pt.y * -1,\n            });\n        }\n        case `z`: {\n            if (isPoint3d(pt)) {\n                return Object.freeze({\n                    ...pt,\n                    z: pt.z * -1,\n                });\n            }\n            else\n                throw new Error(`pt parameter is missing z`);\n        }\n        default: {\n            throw new Error(`Unknown what parameter. Expecting 'both', 'x' or 'y'`);\n        }\n    }\n};\n","import { getTwoPointParameters } from \"./get-point-parameter.js\";\nimport { guard, isPoint3d } from \"./guard.js\";\n/**\n * Returns a Point with the x,y,z values of two points multiply (a/b).\n *\n * `z` parameter is used, if present. Uses a default value of 0 for 'z' when multiplying a 2D point with a 3D one.\n *\n * Examples:\n *\n * ```js\n * multiply(ptA, ptB);\n * multiply(x1, y1, x2, y2);\n * multiply(ptA, x2, y2);\n * ```\n */\nexport function multiply(a1, ab2, ab3, ab4, ab5, ab6) {\n    const [ptA, ptB] = getTwoPointParameters(a1, ab2, ab3, ab4, ab5, ab6);\n    guard(ptA, `a`);\n    guard(ptB, `b`);\n    const pt = {\n        x: ptA.x * ptB.x,\n        y: ptA.y * ptB.y,\n    };\n    if (isPoint3d(ptA) || isPoint3d(ptB)) {\n        pt.z = (ptA.z ?? 0) * (ptB.z ?? 0);\n    }\n    ;\n    return Object.freeze(pt);\n}\n;\n/**\n * Multiplies all components by `v`.\n * Existing properties of `pt` are maintained.\n *\n * ```js\n * multiplyScalar({ x:2, y:4 }, 2);\n * // Yields: { x:4, y:8 }\n * ```\n * @param pt Point\n * @param v Value to multiply by\n * @returns\n */\nexport const multiplyScalar = (pt, v) => {\n    return isPoint3d(pt) ? Object.freeze({\n        ...pt,\n        x: pt.x * v,\n        y: pt.y * v,\n        z: pt.z * v,\n    }) : Object.freeze({\n        ...pt,\n        x: pt.x * v,\n        y: pt.y * v,\n    });\n};\n","import { distance } from \"./distance.js\";\nimport { multiply } from \"./multiply.js\";\n/**\n * Clamps the magnitude of a point.\n * This is useful when using a Point as a vector, to limit forces.\n * @param pt\n * @param max Maximum magnitude (1 by default)\n * @param min Minimum magnitude (0 by default)\n * @returns\n */\nexport const clampMagnitude = (pt, max = 1, min = 0) => {\n    const length = distance(pt);\n    let ratio = 1;\n    if (length > max) {\n        ratio = max / length;\n    }\n    else if (length < min) {\n        ratio = min / length;\n    }\n    return ratio === 1 ? pt : multiply(pt, ratio, ratio);\n};\n","import { findMinimum } from \"./find-minimum.js\";\n/**\n * Returns the left-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x <= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport const leftmost = (...points) => findMinimum((a, b) => (a.x <= b.x ? a : b), ...points);\n/**\n * Returns the right-most of the provided points.\n *\n * Same as:\n * ```js\n * findMinimum((a, b) => {\n *  if (a.x >= b.x) return a;\n *  return b;\n *}, ...points)\n * ```\n *\n * @param points\n * @returns\n */\nexport const rightmost = (...points) => findMinimum((a, b) => (a.x >= b.x ? a : b), ...points);\n","import { Empty } from \"./empty.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\nimport { isPoint } from \"./guard.js\";\nconst length = (ptOrX, y) => {\n    if (isPoint(ptOrX)) {\n        y = ptOrX.y;\n        ptOrX = ptOrX.x;\n    }\n    if (y === undefined)\n        throw new Error(`Expected y`);\n    return Math.hypot(ptOrX, y);\n};\n/**\n * Normalise point as a unit vector.\n *\n * ```js\n * normalise({x:10, y:20});\n * normalise(10, 20);\n * ```\n * @param ptOrX Point, or x value\n * @param y y value if first param is x\n * @returns\n */\nexport const normalise = (ptOrX, y) => {\n    const pt = getPointParameter(ptOrX, y);\n    const l = length(pt);\n    if (l === 0)\n        return Empty;\n    return Object.freeze({\n        ...pt,\n        x: pt.x / l,\n        y: pt.y / l,\n    });\n};\n","/**\n * Runs a sequential series of functions on `pt`. The output from one feeding into the next.\n * ```js\n * const p = Points.pipelineApply(somePoint, Points.normalise, Points.invert);\n * ```\n *\n * If you want to make a reusable pipeline of functions, consider {@link pipeline} instead.\n * @param point\n * @param pipelineFns\n * @returns\n */\nexport const pipelineApply = (point, ...pipelineFns) => pipeline(...pipelineFns)(point); // pipeline.reduce((prev, curr) => curr(prev), pt);\n/**\n * Returns a pipeline function that takes a point to be transformed through a series of functions\n * ```js\n * // Create pipeline\n * const p = Points.pipeline(Points.normalise, Points.invert);\n *\n * // Now run it on `somePoint`.\n * // First we normalised, and then invert\n * const changedPoint = p(somePoint);\n * ```\n *\n * If you don't want to create a pipeline, use {@link pipelineApply}.\n * @param pipeline Pipeline of functions\n * @returns\n */\nexport const pipeline = (...pipeline) => (pt) => \n// eslint-disable-next-line unicorn/no-array-reduce\npipeline.reduce((previous, current) => current(previous), pt);\n","import { guard } from \"./guard.js\";\n/**\n * Returns a point with rounded x,y coordinates. By default uses `Math.round` to round.\n * ```js\n * toIntegerValues({x:1.234, y:5.567}); // Yields: {x:1, y:6}\n * ```\n *\n * ```js\n * toIntegerValues(pt, Math.ceil); // Use Math.ceil to round x,y of `pt`.\n * ```\n * @param pt Point to round\n * @param rounder Rounding function, or Math.round by default\n * @returns\n */\nexport const toIntegerValues = (pt, rounder = Math.round) => {\n    guard(pt, `pt`);\n    return Object.freeze({\n        x: rounder(pt.x),\n        y: rounder(pt.y),\n    });\n};\n/**\n * Returns a copy of `pt` with `z` field omitted.\n * If it didn't have one to begin within, a copy is still returned.\n * @param pt\n * @returns\n */\nexport const to2d = (pt) => {\n    guard(pt, `pt`);\n    let copy = {\n        ...pt\n    };\n    delete copy.z;\n    return Object.freeze(copy);\n};\n/**\n * Returns a copy of `pt` with a `z` field set.\n * Defaults to a z value of 0.\n * @param pt Point\n * @param z Z-value, defaults to 0\n * @returns\n */\nexport const to3d = (pt, z = 0) => {\n    guard(pt, `pt`);\n    return Object.freeze({\n        ...pt,\n        z\n    });\n};\n/**\n * Returns a human-friendly string representation `(x, y)`.\n * If `precision` is supplied, this will be the number of significant digits.\n * @param p\n * @returns\n */\nexport function toString(p, digits) {\n    if (p === undefined)\n        return `(undefined)`;\n    if (p === null)\n        return `(null)`;\n    guard(p, `pt`);\n    const x = digits ? p.x.toFixed(digits) : p.x;\n    const y = digits ? p.y.toFixed(digits) : p.y;\n    if (p.z === undefined) {\n        return `(${x},${y})`;\n    }\n    else {\n        const z = digits ? p.z.toFixed(digits) : p.z;\n        return `(${x},${y},${z})`;\n    }\n}\n","import { normalise as PointsNormalise } from './point/normalise.js';\nimport { isPoint } from './point/guard.js';\nimport * as Polar from './polar/index.js';\nimport { divide as PointDivide } from './point/divider.js';\nimport { guard as LinesGuard } from './line/guard.js';\nimport { sum as PointsSum } from './point/sum.js';\nimport { subtract as PointsSubtract } from './point/index.js';\nimport { multiply as PointsMultiply } from './point/multiply.js';\nimport { dotProduct as PointsDotProduct } from './point/dot-product.js';\nimport { toString as PointsToString } from './point/To.js';\nimport { clampMagnitude as PointsClampMagnitude } from './point/magnitude.js';\nimport { distance as PointsDistance } from './point/distance.js';\nimport { Empty as PointEmpty } from './point/empty.js';\nconst EmptyCartesian = Object.freeze({ x: 0, y: 0 });\nconst piPi = Math.PI * 2;\nconst pi = Math.PI;\n// const Q1 = Math.PI / 2;\n// const Q2 = Math.PI;\n// const Q3 = Q1 + Q2;\n// const Q4 = Math.PI * 2;\nexport const fromRadians = (radians) => {\n    return Object.freeze({\n        x: Math.cos(radians),\n        y: Math.sin(radians)\n    });\n};\nexport const toRadians = (point) => {\n    return Math.atan2(point.y, point.x);\n};\n/**\n * Create a vector from a point\n *\n * If `unipolar` normalisation is used, direction will be fixed to 0..2π\n * if `bipolar` normalisation is used, direction will be fixed to -π...π\n * @param pt Point\n * @param angleNormalisation Technique to normalise angle\n * @param origin Origin to calculate vector from or 0,0 if left empty\n * @returns\n */\nexport const fromPointPolar = (pt, angleNormalisation = ``, origin = EmptyCartesian) => {\n    pt = PointsSubtract(pt, origin);\n    //eslint-disable-next-line functional/no-let\n    let direction = Math.atan2(pt.y, pt.x);\n    if (angleNormalisation === `unipolar` && direction < 0)\n        direction += piPi;\n    else if (angleNormalisation === `bipolar`) {\n        if (direction > pi)\n            direction -= piPi;\n        else if (direction <= -pi)\n            direction += piPi;\n    }\n    return Object.freeze({\n        distance: PointsDistance(pt),\n        angleRadian: direction,\n    });\n};\n/**\n * Returns a Cartesian-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLineCartesian = (line) => PointsSubtract(line.b, line.a);\n/**\n * Returns a polar-coordinate vector from a line a -> b\n * @param line\n * @returns\n */\nexport const fromLinePolar = (line) => {\n    LinesGuard(line, `line`);\n    const pt = PointsSubtract(line.b, line.a);\n    return fromPointPolar(pt);\n};\nconst isPolar = (v) => {\n    if (Polar.isPolarCoord(v))\n        return true;\n    return false;\n};\nconst isCartesian = (v) => {\n    if (isPoint(v))\n        return true;\n    return false;\n};\n/**\n * Returns the normalised vector (aka unit vector). This is where\n * direction is kept, but magnitude set to 1. This then just\n * suggests direction.\n * @param v\n * @returns\n */\nexport const normalise = (v) => {\n    if (isPolar(v)) {\n        return Polar.normalise(v);\n    }\n    else if (isCartesian(v)) {\n        return PointsNormalise(v);\n    }\n    throw new Error(`Expected polar/cartesian vector. Got: ${v}`);\n};\nexport const quadrantOffsetAngle = (p) => {\n    if (p.x >= 0 && p.y >= 0)\n        return 0; // Q1\n    if (p.x < 0 && p.y >= 0)\n        return pi; // Q2\n    if (p.x < 0 && p.y < 0)\n        return pi; // Q3\n    return piPi; // Q4\n};\n/**\n * Converts a vector to a polar coordinate. If the provided\n * value is already Polar, it is returned.\n * @param v\n * @param origin\n * @returns Polar vector\n */\nexport const toPolar = (v, origin = PointEmpty) => {\n    if (isPolar(v)) {\n        return v;\n    }\n    else if (isCartesian(v)) {\n        return Polar.fromCartesian(v, origin);\n    }\n    throw new Error(`Expected polar/cartesian vector. Got: ${v}`);\n};\n/**\n * Converts a Vector to a Cartesian coordinate. If the provided\n * value is already Cartesian, it is returned.\n * @param v\n * @returns Cartestian vector\n */\nexport const toCartesian = (v) => {\n    if (isPolar(v)) {\n        return Polar.toPoint(v);\n    }\n    else if (isCartesian(v)) {\n        return v;\n    }\n    throw new Error(`Expected polar/cartesian vector. Got: ${v}`);\n};\n/**\n * Return a human-friendly representation of vector\n * @param v\n * @param digits\n * @returns\n */\nexport const toString = (v, digits) => {\n    if (isPolar(v)) {\n        return Polar.toString(v, digits);\n    }\n    else if (isCartesian(v)) {\n        return PointsToString(v, digits);\n    }\n    throw new Error(`Expected polar/cartesian vector. Got: ${v}`);\n};\n/**\n * Calculate dot product of a vector\n * @param a\n * @param b\n * @returns\n */\nexport const dotProduct = (a, b) => {\n    if (isPolar(a) && isPolar(b)) {\n        return Polar.dotProduct(a, b);\n    }\n    else if (isCartesian(a) && isCartesian(b)) {\n        return PointsDotProduct(a, b);\n    }\n    throw new Error(`Expected two polar/Cartesian vectors.`);\n};\n/**\n * Clamps the magnitude of a vector\n * @param v Vector to clamp\n * @param max Maximum magnitude\n * @param min Minium magnitude\n * @returns\n */\nexport const clampMagnitude = (v, max = 1, min = 0) => {\n    if (isPolar(v)) {\n        return Polar.clampMagnitude(v, max, min);\n    }\n    else if (isCartesian(v)) {\n        return PointsClampMagnitude(v, max, min);\n    }\n    throw new Error(`Expected either polar or Cartesian vector`);\n};\n/**\n * Returns `a + b`.\n *\n * Vector is returned in the same type as `a`.\n * @param a\n * @param b\n * @returns\n */\nexport const sum = (a, b) => {\n    const polar = isPolar(a);\n    a = toCartesian(a);\n    b = toCartesian(b);\n    const c = PointsSum(a, b);\n    return polar ? toPolar(c) : c;\n};\n/**\n * Returns `a - b`.\n *\n * Vector is returned in the same type as `a`\n * @param a\n * @param b\n */\nexport const subtract = (a, b) => {\n    const polar = isPolar(a);\n    a = toCartesian(a);\n    b = toCartesian(b);\n    const c = PointsSubtract(a, b);\n    return polar ? toPolar(c) : c;\n};\n/**\n * Returns `a * b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const multiply = (a, b) => {\n    const polar = isPolar(a);\n    a = toCartesian(a);\n    b = toCartesian(b);\n    const c = PointsMultiply(a, b);\n    return polar ? toPolar(c) : c;\n};\n/**\n * Returns `a / b`.\n *\n * Vector is returned in the same type `a`.\n * @param a\n * @param b\n */\nexport const divide = (a, b) => {\n    const polar = isPolar(a);\n    a = toCartesian(a);\n    b = toCartesian(b);\n    const c = PointDivide(a, b);\n    return polar ? toPolar(c) : c;\n};\n","import { angleRadian } from \"./angle.js\";\nimport { centroid } from \"./centroid.js\";\nimport { distance } from \"./distance.js\";\nimport { getPointParameter } from \"./get-point-parameter.js\";\n/**\n * Tracks the relation between two points.\n *\n * 1. Call `Points.relation` with the initial reference point\n * 2. You get back a function\n * 3. Call the function with a new point to compute relational information.\n *\n * It computes angle, average, centroid, distance and speed.\n *\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Reference point: 50,50\n * const t = Points.relation({x:50,y:50}); // t is a function\n *\n * // Invoke the returned function with a point\n * const relation = t({ x:0, y:0 }); // Juicy relational data\n * ```\n *\n * Or with destructuring:\n *\n * ```js\n * const { angle, distanceFromStart, distanceFromLast, average, centroid, speed } = t({ x:0,y:0 });\n * ```\n *\n * x & y coordinates can also be used as parameters:\n * ```js\n * const t = Points.relation(50, 50);\n * const result = t(0, 0);\n * // result.speed, result.angle ...\n * ```\n *\n * Note that intermediate values are not stored. It keeps the initial\n * and most-recent point. If you want to compute something over a set\n * of prior points, you may want to use {@link Trackers.points}\n * @param a Initial point, or x value\n * @param b y value, if first option is a number.\n * @returns\n */\nexport const relation = (a, b) => {\n    const start = getPointParameter(a, b);\n    let totalX = 0;\n    let totalY = 0;\n    let count = 0;\n    let lastUpdate = performance.now();\n    let lastPoint = start;\n    const update = (aa, bb) => {\n        const p = getPointParameter(aa, bb);\n        totalX += p.x;\n        totalY += p.y;\n        count++;\n        const distanceFromStart = distance(p, start);\n        const distanceFromLast = distance(p, lastPoint);\n        // Track speed\n        const now = performance.now();\n        const speed = distanceFromLast / (now - lastUpdate);\n        lastUpdate = now;\n        lastPoint = p;\n        return Object.freeze({\n            angle: angleRadian(p, start),\n            distanceFromStart,\n            distanceFromLast,\n            speed,\n            centroid: centroid(p, start),\n            average: {\n                x: totalX / count,\n                y: totalY / count,\n            },\n        });\n    };\n    return update;\n};\n","import { TrackedValueMap, } from '@ixfx/core/trackers';\nimport { ObjectTracker } from '@ixfx/core/trackers';\nimport { length as LineLength } from '../line/length.js';\nimport * as Vectors from '../vector.js';\nimport { Empty as LinesEmpty } from '../line/index.js';\nimport { joinPointsToLines } from '../line/join-points-to-lines.js';\nimport { relation } from './relation.js';\nimport { distance } from './distance.js';\nimport { subtract } from './subtract.js';\nimport { angleRadian } from './angle.js';\nimport { Placeholder as PointsPlaceholder } from './point-type.js';\n/**\n * A tracked point. Mutable. Useful for monitoring how\n * it changes over time. Eg. when a pointerdown event happens, to record the start position and then\n * track the pointer as it moves until pointerup.\n *\n * See also\n * * [Playground](https://clinth.github.io/ixfx-play/data/point-tracker/index.html)\n * * {@link points}: Track several points, useful for multi-touch.\n * * [ixfx Guide to Point Tracker](https://ixfx.fun/geometry/tracking/)\n *\n * ```js\n * // Create a tracker on a pointerdown\n * const t = new PointTracker();\n *\n * // ...and later, tell it when a point is seen (eg. pointermove)\n * const nfo = t.seen({x: evt.x, y:evt.y});\n * // nfo gives us some details on the relation between the seen point, the start, and points inbetween\n * // nfo.angle, nfo.centroid, nfo.speed etc.\n * ```\n *\n * Compute based on last seen point\n * ```js\n * t.angleFromStart();\n * t.distanceFromStart();\n * t.x / t.y\n * t.length; // Total length of accumulated points\n * t.elapsed; // Total duration since start\n * t.lastResult; // The PointSeenInfo for last seen point\n * ```\n *\n * Housekeeping\n * ```js\n * t.reset(); // Reset tracker\n * ```\n *\n * By default, the tracker only keeps track of the initial point and\n * does not store intermediate 'seen' points. To use the tracker as a buffer,\n * set `storeIntermediate` option to _true_.\n *\n * ```js\n * // Keep only the last 10 points\n * const t = new PointTracker({\n *  sampleLimit: 10\n * });\n *\n * // Store all 'seen' points\n * const t = new PointTracker({\n *  storeIntermediate: true\n * });\n *\n * // In this case, the whole tracker is automatically\n * // reset after 10 samples\n * const t = new PointTracker({\n *  resetAfterSamples: 10\n * })\n * ```\n *\n * When using a buffer limited by `sampleLimit`, the 'initial' point will be the oldest in the\n * buffer, not actually the very first point seen.\n */\nexport class PointTracker extends ObjectTracker {\n    initialRelation;\n    markRelation;\n    lastResult;\n    constructor(opts = {}) {\n        super(opts);\n    }\n    /**\n     * Notification that buffer has been knocked down to `sampleLimit`.\n     *\n     * This will reset the `initialRelation`, which will use the new oldest value.\n     */\n    onTrimmed(_reason) {\n        // Force new relation calculations\n        this.initialRelation = undefined;\n    }\n    /**\n     * @ignore\n     */\n    onReset() {\n        super.onReset();\n        this.lastResult = undefined;\n        this.initialRelation = undefined;\n        this.markRelation = undefined;\n    }\n    /**\n     * Adds a PointerEvent along with its\n     * coalesced events, if available.\n     * @param p\n     * @returns\n     */\n    seenEvent(p) {\n        if (`getCoalescedEvents` in p) {\n            const events = p.getCoalescedEvents();\n            const asPoints = events.map(event => ({ x: event.clientX, y: event.clientY }));\n            return this.seen(...asPoints);\n        }\n        else {\n            return this.seen({ x: (p).clientX, y: (p).clientY });\n        }\n    }\n    /**\n     * Makes a 'mark' in the tracker, allowing you to compare values\n     * to this point.\n     */\n    mark() {\n        this.markRelation = relation(this.last);\n    }\n    /**\n     * Tracks a point, returning data on its relation to the\n     * initial point and the last received point.\n     *\n     * Use {@link seenEvent} to track a raw `PointerEvent`.\n     *\n     * @param _p Point\n     */\n    computeResults(_p) {\n        const currentLast = this.last;\n        const previousLast = this.values.at(-2);\n        if (this.initialRelation === undefined && this.initial) {\n            // Don't yet have an initial relation function\n            // Use the oldest point in the buffer (this.initial)\n            this.initialRelation = relation(this.initial);\n        }\n        else if (this.initialRelation === undefined) {\n            // Don't have an initial relation, but also don't have an initial point :()\n            throw new Error(`Bug: No initialRelation, and this.inital is undefined?`);\n        }\n        // Make a new relator based on previous point\n        const lastRelation = previousLast === undefined ? relation(currentLast) : relation(previousLast);\n        // Compute relation from initial point to latest\n        const initialRel = this.initialRelation(currentLast);\n        const markRel = (this.markRelation !== undefined) ? this.markRelation(currentLast) : undefined;\n        const speed = previousLast === undefined ? 0 : LineLength(previousLast, currentLast) / (currentLast.at - previousLast.at);\n        // Compute relation from current point to the previous\n        const lastRel = {\n            ...lastRelation(currentLast),\n            speed,\n        };\n        const r = {\n            fromInitial: initialRel,\n            fromLast: lastRel,\n            fromMark: markRel,\n            values: [...this.values],\n        };\n        this.lastResult = r;\n        return r;\n    }\n    /**\n     * Returns a polyline representation of stored points.\n     * Returns an empty array if points were not saved, or there's only one.\n     */\n    get line() {\n        if (this.values.length === 1)\n            return [];\n        return joinPointsToLines(...this.values);\n    }\n    /**\n     * Returns a vector of the initial/last points of the tracker.\n     * Returns as a polar coordinate\n     */\n    get vectorPolar() {\n        return Vectors.fromLinePolar(this.lineStartEnd);\n    }\n    /**\n     * Returns a vector of the initial/last points of the tracker.\n     * Returns as a Cartesian coordinate\n     */\n    get vectorCartesian() {\n        return Vectors.fromLineCartesian(this.lineStartEnd);\n    }\n    /**\n     * Returns a line from initial point to last point.\n     *\n     * If there are less than two points, Lines.Empty is returned\n     */\n    get lineStartEnd() {\n        const initial = this.initial;\n        if (this.values.length < 2 || !initial)\n            return LinesEmpty;\n        return {\n            a: initial,\n            b: this.last,\n        };\n    }\n    /**\n     * Returns distance from latest point to initial point.\n     * If there are less than two points, zero is returned.\n     *\n     * This is the direct distance from initial to last,\n     * not the accumulated length.\n     * @returns Distance\n     */\n    distanceFromStart() {\n        const initial = this.initial;\n        return this.values.length >= 2 && initial !== undefined ? distance(initial, this.last) : 0;\n    }\n    /**\n     * Difference between last point and the initial point, calculated\n     * as a simple subtraction of x,y & z.\n     *\n     * `Points.Placeholder` is returned if there's only one point so far.\n     */\n    difference() {\n        const initial = this.initial;\n        return this.values.length >= 2 && initial !== undefined ? subtract(this.last, initial) : PointsPlaceholder;\n    }\n    /**\n     * Returns angle (in radians) from latest point to the initial point\n     * If there are less than two points, undefined is return.\n     * @returns Angle in radians\n     */\n    angleFromStart() {\n        const initial = this.initial;\n        if (initial !== undefined && this.values.length > 2) {\n            return angleRadian(initial, this.last);\n        }\n    }\n    /**\n     * Returns the total length of accumulated points.\n     * Returns 0 if points were not saved, or there's only one\n     */\n    get length() {\n        if (this.values.length === 1)\n            return 0;\n        const l = this.line;\n        return LineLength(l);\n    }\n    /**\n   * Returns the last x coord\n   */\n    get x() {\n        return this.last.x;\n    }\n    /**\n     * Returns the last y coord\n     */\n    get y() {\n        return this.last.y;\n    }\n    /**\n     * Returns the last z coord (or _undefined_ if not available)\n     */\n    get z() {\n        return this.last.z;\n    }\n}\n/**\n * A {@link TrackedValueMap} for points. Uses {@link PointTracker} to\n * track added values.\n */\nexport class PointsTracker extends TrackedValueMap {\n    constructor(opts = {}) {\n        super((key, start) => {\n            if (start === undefined)\n                throw new Error(`Requires start point`);\n            const p = new PointTracker({\n                ...opts,\n                id: key,\n            });\n            p.seen(start);\n            return p;\n        });\n    }\n    /**\n     * Track a PointerEvent\n     * @param event\n     */\n    seenEvent(event) {\n        if (`getCoalescedEvents` in event) {\n            const events = event.getCoalescedEvents();\n            const seens = events.map(subEvent => super.seen(subEvent.pointerId.toString(), subEvent));\n            return Promise.all(seens);\n        }\n        else {\n            return Promise.all([super.seen(event.pointerId.toString(), event)]);\n        }\n    }\n}\n","import { isPoint3d } from \"./guard.js\";\nimport { subtract } from \"./subtract.js\";\n/**\n * Computes the progress between two waypoints, given `position`.\n *\n * [Source](https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09)\n * @param position Current position\n * @param waypointA Start\n * @param waypointB End\n * @returns\n */\nexport const progressBetween = (position, waypointA, waypointB) => {\n    // Via: https://www.habrador.com/tutorials/math/2-passed-waypoint/?s=09\n    // from -> current\n    const a = subtract(position, waypointA);\n    // from -> to\n    const b = subtract(waypointB, waypointA);\n    return isPoint3d(a) && isPoint3d(b) ? ((a.x * b.x + a.y * b.y + a.z * b.z) / (b.x * b.x + b.y * b.y + b.z * b.z)) : (a.x * b.x + a.y * b.y) / (b.x * b.x + b.y * b.y);\n};\n","/**\n * Project `origin` by `distance` and `angle` (radians).\n *\n * To figure out rotation, imagine a horizontal line running through `origin`.\n * * Rotation = 0 deg puts the point on the right of origin, on same y-axis\n * * Rotation = 90 deg/3:00 puts the point below origin, on the same x-axis\n * * Rotation = 180 deg/6:00 puts the point on the left of origin on the same y-axis\n * * Rotation = 270 deg/12:00 puts the point above the origin, on the same x-axis\n *\n * ```js\n * // Yields a point 100 units away from 10,20 with 10 degrees rotation (ie slightly down)\n * const a = Points.project({x:10, y:20}, 100, degreeToRadian(10));\n * ```\n * @param origin\n * @param distance\n * @param angle\n * @returns\n */\nexport const project = (origin, distance, angle) => {\n    const x = Math.cos(angle) * distance + origin.x;\n    const y = Math.sin(angle) * distance + origin.y;\n    return { x, y };\n};\n","import { quantiseEvery as quantiseEveryNumber } from '@ixfx/numbers';\nimport { guard, isPoint3d } from './guard.js';\n/**\n * Quantises a point.\n * @param pt\n * @param snap\n * @param middleRoundsUp\n * @returns\n */\nexport function quantiseEvery(pt, snap, middleRoundsUp = true) {\n    guard(pt, `pt`);\n    guard(snap, `snap`);\n    if (isPoint3d(pt)) {\n        if (!isPoint3d(snap))\n            throw new TypeError(`Param 'snap' is missing 'z' field`);\n        return Object.freeze({\n            x: quantiseEveryNumber(pt.x, snap.x, middleRoundsUp),\n            y: quantiseEveryNumber(pt.y, snap.y, middleRoundsUp),\n            z: quantiseEveryNumber(pt.z, snap.z, middleRoundsUp)\n        });\n    }\n    return Object.freeze({\n        x: quantiseEveryNumber(pt.x, snap.x, middleRoundsUp),\n        y: quantiseEveryNumber(pt.y, snap.y, middleRoundsUp),\n    });\n}\n","import {} from '@ixfx/random';\n/**\n * Returns a random 2D point on a 0..1 scale.\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * import { weightedSource } from \"https://unpkg.com/ixfx/dist/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random = (rando) => {\n    if (rando === undefined)\n        rando = Math.random;\n    return Object.freeze({\n        x: rando(),\n        y: rando(),\n    });\n};\n/**\n * Returns a random 3D point on a 0..1 scale.\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const pt = Points.random(); // eg {x: 0.2549012, y:0.859301}\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Points } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * import { weightedSource } from \"https://unpkg.com/ixfx/dist/random.js\"\n * const pt = Points.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random3d = (rando) => {\n    if (rando === undefined)\n        rando = Math.random;\n    return Object.freeze({\n        x: rando(),\n        y: rando(),\n        z: rando()\n    });\n};\n","/**\n * Reduces over points, treating _x_ and _y_ separately.\n *\n * ```\n * // Sum x and y values\n * const total = Points.reduce(points, (p, acc) => {\n *  return {x: p.x + acc.x, y: p.y + acc.y}\n * });\n * ```\n * @param pts Points to reduce\n * @param fn Reducer\n * @param initial Initial value, uses `{ x:0, y:0 }` by default\n * @returns\n */\nexport const reduce = (pts, fn, initial) => {\n    if (initial === undefined)\n        initial = { x: 0, y: 0 };\n    let accumulator = initial;\n    for (const p of pts) {\n        accumulator = fn(p, accumulator);\n    }\n    ;\n    return accumulator;\n};\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { guard } from \"./guard.js\";\nimport { fromCartesian as PolarFromCartesian } from \"../polar/index.js\";\nimport { rotate as PolarRotate, toCartesian as PolarToCartesian } from \"../polar/index.js\";\nexport function rotate(pt, amountRadian, origin) {\n    if (typeof origin === `undefined`)\n        origin = { x: 0, y: 0 };\n    guard(origin, `origin`);\n    resultThrow(numberTest(amountRadian, ``, `amountRadian`));\n    const arrayInput = Array.isArray(pt);\n    // no-op\n    if (amountRadian === 0)\n        return pt;\n    if (!arrayInput) {\n        pt = [pt];\n    }\n    const ptAr = pt;\n    for (const [index, p] of ptAr.entries())\n        guard(p, `pt[${index}]`);\n    const asPolar = ptAr.map((p) => PolarFromCartesian(p, origin));\n    const rotated = asPolar.map((p) => PolarRotate(p, amountRadian));\n    const asCartesisan = rotated.map((p) => PolarToCartesian(p, origin));\n    return arrayInput ? asCartesisan : asCartesisan[0];\n}\n","//eslint-disable-next-line functional/prefer-readonly-type\nexport const rotatePointArray = (v, amountRadian) => {\n    const mat = [\n        [Math.cos(amountRadian), -Math.sin(amountRadian)],\n        [Math.sin(amountRadian), Math.cos(amountRadian)],\n    ];\n    const result = [];\n    for (const [index, element] of v.entries()) {\n        result[index] = [\n            mat[0][0] * element[0] + mat[0][1] * element[1],\n            mat[1][0] * element[0] + mat[1][1] * element[1],\n        ];\n    }\n    return result;\n};\n","import { round as roundNumber } from '@ixfx/numbers';\nimport { getPointParameter } from './get-point-parameter.js';\n/**\n * Round the point's _x_ and _y_ to given number of digits\n * @param ptOrX\n * @param yOrDigits\n * @param digits\n * @returns\n */\nexport const round = (ptOrX, yOrDigits, digits) => {\n    const pt = getPointParameter(ptOrX, yOrDigits);\n    digits = digits ?? yOrDigits;\n    digits = digits ?? 2;\n    return Object.freeze({\n        ...pt,\n        x: roundNumber(digits, pt.x),\n        y: roundNumber(digits, pt.y)\n    });\n};\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { guard } from \"./guard.js\";\n/**\n * Returns true if two points are within a specified range on both axes.\n *\n * Provide a point for the range to set different x/y range, or pass a number\n * to use the same range for both axis.\n *\n * Note this simply compares x,y values it does not calcuate distance.\n *\n * @example\n * ```js\n * withinRange({x:100,y:100}, {x:101, y:101}, 1); // True\n * withinRange({x:100,y:100}, {x:105, y:101}, {x:5, y:1}); // True\n * withinRange({x:100,y:100}, {x:105, y:105}, {x:5, y:1}); // False - y axis too far\n * ```\n * @param a\n * @param b\n * @param maxRange\n * @returns\n */\nexport const withinRange = (a, b, maxRange) => {\n    guard(a, `a`);\n    guard(b, `b`);\n    if (typeof maxRange === `number`) {\n        resultThrow(numberTest(maxRange, `positive`, `maxRange`));\n        maxRange = { x: maxRange, y: maxRange };\n    }\n    else {\n        guard(maxRange, `maxRange`);\n    }\n    const x = Math.abs(b.x - a.x);\n    const y = Math.abs(b.y - a.y);\n    return x <= maxRange.x && y <= maxRange.y;\n};\n","import { wrap as wrapNumber } from '@ixfx/numbers';\nimport { guard } from './guard.js';\n/**\n * Wraps a point to be within `ptMin` and `ptMax`.\n * Note that max values are _exclusive_, meaning the return value will always be one less.\n *\n * Eg, if a view port is 100x100 pixels, wrapping the point 150,100 yields 50,99.\n *\n * ```js\n * // Wraps 150,100 to on 0,0 -100,100 range\n * wrap({x:150,y:100}, {x:100,y:100});\n * ```\n *\n * Wrap normalised point:\n * ```js\n * wrap({x:1.2, y:1.5}); // Yields: {x:0.2, y:0.5}\n * ```\n * @param pt Point to wrap\n * @param ptMax Maximum value, or `{ x:1, y:1 }` by default\n * @param ptMin Minimum value, or `{ x:0, y:0 }` by default\n * @returns Wrapped point\n */\nexport const wrap = (pt, ptMax, ptMin) => {\n    if (ptMax === undefined)\n        ptMax = { x: 1, y: 1 };\n    if (ptMin === undefined)\n        ptMin = { x: 0, y: 0 };\n    // ✔️ Unit tested\n    guard(pt, `pt`);\n    guard(ptMax, `ptMax`);\n    guard(ptMin, `ptMin`);\n    return Object.freeze({\n        x: wrapNumber(pt.x, ptMin.x, ptMax.x),\n        y: wrapNumber(pt.y, ptMin.y, ptMax.y),\n    });\n};\n","export * from './abs.js';\nexport * from './angle.js';\nexport * from './apply.js';\nexport * from './averager.js';\nexport * from './bbox.js';\nexport * from './centroid.js';\nexport * from './clamp.js';\nexport * from './compare.js';\nexport * from './convex-hull.js';\nexport * from './distance.js';\nexport * from './distance-to-center.js';\nexport * from './distance-to-exterior.js';\nexport * from './divider.js';\nexport * from './dot-product.js';\nexport * from './empty.js';\nexport * from './find-minimum.js';\nexport * from './from.js';\nexport * from './get-point-parameter.js';\nexport * from './guard.js';\nexport * from './interpolate.js';\nexport * from './invert.js';\nexport * from './is-equal.js';\nexport * from './magnitude.js';\nexport * from './most.js';\nexport * from './multiply.js';\nexport * from './normalise.js';\nexport * from './normalise-by-rect.js';\nexport * from './pipeline.js';\nexport * from './point-relation-types.js';\nexport * from './point-tracker.js';\nexport * from './point-type.js';\nexport * from './progress-between.js';\nexport * from './project.js';\nexport * from './quantise.js';\nexport * from './random.js';\nexport * from './reduce.js';\nexport * from './relation.js';\nexport * from './rotate.js';\nexport * from './rotate-point-array.js';\nexport * from './round.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './To.js';\nexport * from './to-array.js';\nexport * from './within-range.js';\nexport * from './wrap.js';\n","import { multiply as PointsMultiply } from \"../point/index.js\";\n/**\n * Multiplies start and end of line by point.x, point.y.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1, 1, 10, 10);\n * const ll = Lines.multiply(l, {x:2, y:3});\n * // Yields: 2,20 -> 3,30\n * ```\n * @param line\n * @param point\n * @returns\n */\nexport const multiply = (line, point) => (Object.freeze({\n    ...line,\n    a: PointsMultiply(line.a, point),\n    b: PointsMultiply(line.b, point)\n}));\n","import { length } from \"./length.js\";\nimport { distance as PointsDistance } from \"../point/distance.js\";\n/**\n * Returns the relative position of `pt` along `line`.\n * Warning: assumes `pt` is actually on `line`. Results may be bogus if not.\n * @param line\n * @param pt\n */\nexport const relativePosition = (line, pt) => {\n    const fromStart = PointsDistance(line.a, pt);\n    const total = length(line);\n    return fromStart / total;\n};\n","import { rotate as PointRotate } from '../point/index.js';\nimport { interpolate } from \"./interpolate.js\";\n/**\n * Returns a line that is rotated by `angleRad`. By default it rotates\n * around its center, but an arbitrary `origin` point can be provided.\n * If `origin` is a number, it's presumed to be a 0..1 percentage of the line.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n *\n * // Rotates line by 0.1 radians around point 10,10\n * const r = Lines.rotate(line, 0.1, {x:10,y:10});\n *\n * // Rotate line by 5 degrees around its center\n * const r = Lines.rotate(line, degreeToRadian(5));\n *\n * // Rotate line by 5 degres around its end point\n * const r = Lines.rotate(line, degreeToRadian(5), line.b);\n *\n * // Rotate by 90 degrees at the 80% position\n * const r = Lines.rotated = rotate(line, Math.PI / 2, 0.8);\n * ```\n * @param line Line to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of line will be used\n * @returns\n */\nexport const rotate = (line, amountRadian, origin) => {\n    if (amountRadian === undefined || amountRadian === 0)\n        return line;\n    if (origin === undefined)\n        origin = 0.5;\n    if (typeof origin === `number`) {\n        origin = interpolate(origin, line.a, line.b);\n    }\n    return Object.freeze({\n        ...line,\n        a: PointRotate(line.a, amountRadian, origin),\n        b: PointRotate(line.b, amountRadian, origin)\n    });\n};\n","import { subtract as PointsSubtract } from \"../point/subtract.js\";\n/**\n * Subtracts both start and end points by given x,y\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.subtract(l, {x:2, y:4});\n * // Yields: -1,-3 -> 8,6\n * ```\n * @param line\n * @param point\n * @returns\n */\nexport const subtract = (line, point) => Object.freeze({\n    ...line,\n    a: PointsSubtract(line.a, point),\n    b: PointsSubtract(line.b, point)\n});\n","import { sum as PointsSum } from '../point/sum.js';\n/**\n * Adds both start and end points by given x,y\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.sum(l, {x:2, y:4});\n * // Yields: 3,5 -> 12,14\n * ```\n * @param line\n * @param point\n * @returns\n */\nexport const sum = (line, point) => Object.freeze({\n    ...line,\n    a: PointsSum(line.a, point),\n    b: PointsSum(line.b, point)\n});\n","import { guard, isLine } from \"./guard.js\";\nimport { toString as PointsToString } from '../point/index.js';\n/**\n * Returns a string representation of a line or two points.\n * @param a\n * @param b\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function toString(a, b) {\n    if (isLine(a)) {\n        guard(a, `a`);\n        b = a.b;\n        a = a.a;\n    }\n    else if (b === undefined)\n        throw new Error(`Expect second point if first is a point`);\n    return PointsToString(a) + `-` + PointsToString(b);\n}\n","//import * as Points from '../point/index.js';\nimport { normaliseByRect as PointsNormaliseByRect } from '../point/normalise-by-rect.js';\nimport { minFast } from '@ixfx/numbers';\nimport { distanceSingleLine } from './distance-single-line.js';\nimport { isLine } from './guard.js';\nimport { length } from './length.js';\nimport { interpolate } from './interpolate.js';\nimport { isPoint, isEmpty as PointIsEmpty, isPlaceholder as PointIsPlaceholder } from '../point/guard.js';\nexport * from './angles.js';\nexport * from './bbox.js';\nexport * from './distance-single-line.js';\nexport * from './divide.js';\nexport * from './from-flat-array.js';\nexport * from './from-numbers.js';\nexport * from './from-points.js';\nexport * from './from-pivot.js';\nexport * from './from-points-to-path.js';\nexport * from './get-points-parameter.js';\nexport * from './guard.js';\nexport * from './interpolate.js';\nexport * from './is-equal.js';\nexport * from './join-points-to-lines.js';\nexport * from './length.js';\nexport * from './midpoint.js';\nexport * from './multiply.js';\nexport * from './nearest.js';\nexport * from './relative-position.js';\nexport * from './reverse.js';\nexport * from './rotate.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './to-path.js';\nexport * from './to-string.js';\nexport const Empty = Object.freeze({\n    a: Object.freeze({ x: 0, y: 0 }),\n    b: Object.freeze({ x: 0, y: 0 })\n});\nexport const Placeholder = Object.freeze({\n    a: Object.freeze({ x: Number.NaN, y: Number.NaN }),\n    b: Object.freeze({ x: Number.NaN, y: Number.NaN })\n});\n/**\n * Returns true if `l` is the same as Line.Empty, that is\n * the `a` and `b` points are Points.Empty.\n * @param l\n * @returns\n */\nexport const isEmpty = (l) => PointIsEmpty(l.a) && PointIsEmpty(l.b);\nexport const isPlaceholder = (l) => PointIsPlaceholder(l.a) && PointIsPlaceholder(l.b);\n/**\n * Applies `fn` to both start and end points.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Line 10,10 -> 20,20\n * const line = Lines.fromNumbers(10,10, 20,20);\n *\n * // Applies randomisation to both x and y.\n * const rand = (p) => ({\n *  x: p.x * Math.random(),\n *  y: p.y * Math.random()\n * });\n *\n * // Applies our randomisation function\n * const line2 = apply(line, rand);\n * ```\n * @param line Line\n * @param fn Function that takes a point and returns a point\n * @returns\n */\nexport const apply = (line, fn) => Object.freeze({\n    ...line,\n    a: fn(line.a),\n    b: fn(line.b)\n});\n/**\n * Returns the angle in radians of a line, or two points\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.angleRadian(line);\n * Lines.angleRadian(ptA, ptB);\n * ```\n * @param lineOrPoint\n * @param b\n * @returns\n */\nexport const angleRadian = (lineOrPoint, b) => {\n    let a;\n    if (isLine(lineOrPoint)) {\n        a = lineOrPoint.a;\n        b = lineOrPoint.b;\n    }\n    else {\n        a = lineOrPoint;\n        if (b === undefined)\n            throw new Error(`b point must be provided`);\n    }\n    return Math.atan2(b.y - a.y, b.x - a.x);\n};\n/**\n * Normalises start and end points by given width and height. Useful\n * for converting an absolutely-defined line to a relative one.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n *\n * // Line 1,1 -> 10,10\n * const l = Lines.fromNumbers(1,1,10,10);\n * const ll = Lines.normaliseByRect(l, 10, 10);\n * // Yields: 0.1,0.1 -> 1,1\n * ```\n * @param line\n * @param width\n * @param height\n * @returns\n */\nexport const normaliseByRect = (line, width, height) => Object.freeze({\n    ...line,\n    a: PointsNormaliseByRect(line.a, width, height),\n    b: PointsNormaliseByRect(line.b, width, height)\n});\n/**\n * Returns true if `point` is within `maxRange` of `line`.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = Lines.fromNumbers(0,20,20,20);\n * Lines.withinRange(line, {x:0,y:21}, 1); // True\n * ```\n * @param line\n * @param point\n * @param maxRange\n * @returns True if point is within range\n */\nexport const withinRange = (line, point, maxRange) => {\n    const calculatedDistance = distance(line, point);\n    return calculatedDistance <= maxRange;\n};\n/**\n * Calculates [slope](https://en.wikipedia.org/wiki/Slope) of line.\n *\n * @example\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.slope(line);\n * Lines.slope(ptA, ptB)\n * ```\n * @param lineOrPoint Line or point. If point is provided, second point must be given too\n * @param b Second point if needed\n * @returns\n */\nexport const slope = (lineOrPoint, b) => {\n    let a;\n    if (isLine(lineOrPoint)) {\n        a = lineOrPoint.a;\n        b = lineOrPoint.b;\n    }\n    else {\n        a = lineOrPoint;\n        if (b === undefined)\n            throw new Error(`b parameter required`);\n    }\n    if (b === undefined) {\n        throw new TypeError(`Second point missing`);\n    }\n    else {\n        return (b.y - a.y) / (b.x - a.x);\n    }\n};\n/**\n * Scales a line from its midpoint\n *\n * @example Shorten by 50%, anchored at the midpoint\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = {\n *  a: {x:50, y:50}, b: {x: 100, y: 90}\n * }\n * const l2 = Lines.scaleFromMidpoint(l, 0.5);\n * ```\n * @param line\n * @param factor\n */\nexport const scaleFromMidpoint = (line, factor) => {\n    const a = interpolate(factor / 2, line);\n    const b = interpolate(0.5 + factor / 2, line);\n    return { a, b };\n};\n/**\n * Calculates `y` where `line` intersects `x`.\n * @param line Line to extend\n * @param x Intersection of x-axis.\n */\nexport const pointAtX = (line, x) => {\n    const y = line.a.y + (x - line.a.x) * slope(line);\n    return Object.freeze({ x: x, y });\n};\n/**\n * Returns a line extended from its `a` point by a specified distance\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const line = {a: {x: 0, y:0}, b: {x:10, y:10} }\n * const extended = Lines.extendFromA(line, 2);\n * ```\n * @param line\n * @param distance\n * @return Newly extended line\n */\nexport const extendFromA = (line, distance) => {\n    const calculatedLength = length(line);\n    return Object.freeze({\n        ...line,\n        a: line.a,\n        b: Object.freeze({\n            x: line.b.x + (line.b.x - line.a.x) / calculatedLength * distance,\n            y: line.b.y + (line.b.y - line.a.y) / calculatedLength * distance,\n        })\n    });\n};\n/**\n * Yields every integer point along `line`.\n *\n * @example Basic usage\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const l = { a: {x: 0, y: 0}, b: {x: 100, y: 100} };\n * for (const p of Lines.pointsOf(l)) {\n *  // Do something with point `p`...\n * }\n * ```\n *\n * Some precision is lost as start and end\n * point is also returned as an integer.\n *\n * Uses [Bresenham's line algorithm](https://en.wikipedia.org/wiki/Bresenham%27s_line_algorithm)\n * @param line Line\n */\nexport function* pointsOf(line) {\n    // Via https://play.ertdfgcvb.xyz/#/src/demos/dyna\n    const { a, b } = line;\n    let x0 = Math.floor(a.x);\n    let y0 = Math.floor(a.y);\n    const x1 = Math.floor(b.x);\n    const y1 = Math.floor(b.y);\n    const dx = Math.abs(x1 - x0);\n    const dy = -Math.abs(y1 - y0);\n    const sx = x0 < x1 ? 1 : -1;\n    const sy = y0 < y1 ? 1 : -1;\n    // eslint-disable-next-line unicorn/prevent-abbreviations\n    let err = dx + dy;\n    while (true) {\n        yield { x: x0, y: y0 };\n        if (x0 === x1 && y0 === y1)\n            break;\n        // eslint-disable-next-line unicorn/prevent-abbreviations\n        const e2 = 2 * err;\n        if (e2 >= dy) {\n            err += dy;\n            x0 += sx;\n        }\n        if (e2 <= dx) {\n            err += dx;\n            y0 += sy;\n        }\n    }\n}\n/**\n * Returns the distance of `point` to the\n * nearest point on `line`.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const d = Lines.distance(line, {x:10,y:10});\n * ```\n *\n * If an array of lines is provided, the shortest distance is returned.\n * @param line Line (or array of lines)\n * @param point Point to check against\n * @returns Distance\n */\nexport const distance = (line, point) => {\n    if (Array.isArray(line)) {\n        const distances = line.map(l => distanceSingleLine(l, point));\n        return minFast(distances);\n    }\n    else {\n        return distanceSingleLine(line, point);\n    }\n};\n/**\n * Returns an array representation of line: [a.x, a.y, b.x, b.y]\n *\n * See {@link fromFlatArray} to create a line _from_ this representation.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * Lines.toFlatArray(line);\n * Lines.toFlatArray(pointA, pointB);\n * ```\n * @param {Point} a\n * @param {Point} b\n * @returns {number[]}\n */\nexport const toFlatArray = (a, b) => {\n    if (isLine(a)) {\n        return [a.a.x, a.a.y, a.b.x, a.b.y];\n    }\n    else if (isPoint(a) && isPoint(b)) {\n        return [a.x, a.y, b.x, b.y];\n    }\n    else {\n        throw new Error(`Expected single line parameter, or a and b points`);\n    }\n};\n/**\n * Yields all the points of all the lines.\n *\n * ```js\n * const lines = [ ..some array of lines.. ];\n * for (const pt of Lines.asPoints(lines)) {\n *  // Yields a and then b of each point sequentially\n * }\n * ```\n * @param lines\n */\nexport function* asPoints(lines) {\n    for (const l of lines) {\n        yield l.a;\n        yield l.b;\n    }\n}\n/**\n * Returns an SVG description of line\n * ```\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js';\n * Lines.toSvgString(ptA, ptB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const toSvgString = (a, b) => [`M${a.x} ${a.y} L ${b.x} ${b.y}`];\n","import { length } from \"./length.js\";\nimport { interpolate } from \"./interpolate.js\";\nimport { parallel, perpendicularPoint } from \"./angles.js\";\nimport { midpoint } from \"./midpoint.js\";\nimport { toFlatArray, toSvgString, slope, withinRange, apply } from \"./index.js\";\nimport { bbox } from \"./bbox.js\";\nimport { relativePosition } from \"./relative-position.js\";\nimport { sum } from \"./sum.js\";\nimport { divide } from \"./divide.js\";\nimport { rotate } from \"./rotate.js\";\nimport { nearest } from \"./nearest.js\";\nimport { distanceSingleLine } from './distance-single-line.js';\nimport { isEqual } from \"./is-equal.js\";\nimport { multiply } from \"./multiply.js\";\nimport { subtract } from \"./subtract.js\";\nimport { toString } from \"./to-string.js\";\n/**\n * Returns a path wrapper around a line instance. This is useful if there are a series\n * of operations you want to do with the same line because you don't have to pass it\n * in as an argument to each function.\n *\n * Note that the line is immutable, so a function like `sum` returns a new LinePath,\n * wrapping the result of `sum`.\n *\n * ```js\n * import { Lines } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * // Create a path\n * const l = Lines.toPath(fromNumbers(0,0,10,10));\n *\n * // Now we can use it...\n * l.length();\n *\n * // Mutate functions return a new path\n * const ll = l.sum({x:10,y:10});\n * ll.length();\n * ```\n * @param line\n * @returns\n */\nexport const toPath = (line) => {\n    const { a, b } = line;\n    return Object.freeze({\n        ...line,\n        length: () => length(a, b),\n        interpolate: (amount) => interpolate(amount, a, b),\n        relativePosition: (point) => relativePosition(line, point),\n        bbox: () => bbox(line),\n        toString: () => toString(a, b),\n        toFlatArray: () => toFlatArray(a, b),\n        toSvgString: () => toSvgString(a, b),\n        toPoints: () => [a, b],\n        rotate: (amountRadian, origin) => toPath(rotate(line, amountRadian, origin)),\n        nearest: (point) => nearest(line, point),\n        sum: (point) => toPath(sum(line, point)),\n        divide: (point) => toPath(divide(line, point)),\n        multiply: (point) => toPath(multiply(line, point)),\n        subtract: (point) => toPath(subtract(line, point)),\n        midpoint: () => midpoint(a, b),\n        distanceToPoint: (point) => distanceSingleLine(line, point),\n        parallel: (distance) => parallel(line, distance),\n        perpendicularPoint: (distance, amount) => perpendicularPoint(line, distance, amount),\n        slope: () => slope(line),\n        withinRange: (point, maxRange) => withinRange(line, point, maxRange),\n        isEqual: (otherLine) => isEqual(line, otherLine),\n        apply: (fn) => toPath(apply(line, fn)),\n        kind: `line`\n    });\n};\n","import { joinPointsToLines } from './line/join-points-to-lines.js';\nimport { toPath } from './line/to-path.js';\nimport { distance as PointsDistance } from \"./point/distance.js\";\nimport { sortByNumericProperty } from \"@ixfx/arrays\";\n/**\n * Create from set of points, connected in order starting at array position 0.\n * @param waypoints\n * @param opts\n * @returns\n */\nexport const fromPoints = (waypoints, opts = {}) => {\n    const lines = joinPointsToLines(...waypoints);\n    return init(lines.map((l) => toPath(l)), opts);\n};\n/**\n * Initialise\n *\n * Options:\n * * maxDistanceFromLine: Distances greater than this are not matched. Default 0.1\n * @param paths\n * @param opts\n * @returns\n */\nexport const init = (paths, opts = {}) => {\n    //const enforceOrder = opts.enforceOrder ?? true;\n    const maxDistanceFromLine = opts.maxDistanceFromLine ?? 0.1;\n    const checkUnordered = (pt) => {\n        const results = paths.map((p, index) => {\n            const nearest = p.nearest(pt);\n            const distance = PointsDistance(pt, nearest);\n            // Relative position of nearest point on this path segment\n            const positionRelative = p.relativePosition(nearest, maxDistanceFromLine);\n            ;\n            return { positionRelative, path: p, index, nearest, distance, rank: Number.MAX_SAFE_INTEGER };\n        });\n        const filtered = results.filter((v) => v.distance <= maxDistanceFromLine);\n        const sorted = sortByNumericProperty(filtered, `distance`);\n        // Assign ranks\n        for (let rank = 0; rank < sorted.length; rank++) {\n            sorted[rank].rank = rank;\n        }\n        return sorted;\n    };\n    // const checkUnordered = (p:Point) => {\n    //   // Calculate progress of pointer between all the waypoint lines\n    //   const progresses = lines.map((line, index) => (\n    //     {\n    //       index,\n    //       score: Points.progressBetween(p, line.a, line.b)\n    //     }));\n    //   // Sort by closest\n    //   const sorted = Arrays.sortByNumericProperty(progresses, `score`);\n    // };\n    return checkUnordered;\n};\n","import { project as PointsProject } from \"../point/project.js\";\n// import { guard as PointGuard } from \"../point/Guard.js\";\n// import { throwNumberTest } from \"@ixfx/guards\";\n// import { piPi } from \"../pi.js\";\n/**\n * A triangle consisting of three empty points (Points.Empty)\n */\nexport const Empty = Object.freeze({\n    a: { x: 0, y: 0 },\n    b: { x: 0, y: 0 },\n    c: { x: 0, y: 0 },\n});\n/**\n * A triangle consisting of three placeholder points (Points.Placeholder)\n */\nexport const Placeholder = Object.freeze({\n    a: { x: Number.NaN, y: Number.NaN },\n    b: { x: Number.NaN, y: Number.NaN },\n    c: { x: Number.NaN, y: Number.NaN },\n});\n/**\n * Returns a triangle anchored at `origin` with a given `length` and `angleRadian`.\n * The origin will be point `b` of the triangle, and the angle will be the angle for b.\n * @param origin Origin\n * @param length Length\n * @param angleRadian Angle\n * @returns\n */\nexport const equilateralFromVertex = (origin, length = 10, angleRadian = Math.PI / 2) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const a = PointsProject(origin, length, Math.PI - -angleRadian / 2);\n    const c = PointsProject(origin, length, Math.PI - angleRadian / 2);\n    return { a, b: origin, c };\n};\n","import {} from \"../point/point-type.js\";\nimport { getRectPositioned } from \"./guard.js\";\n/**\n * Returns the four corners of a rectangle as an array of Points.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 0, y: 0};\n * const pts = Rects.corners(rect);\n * ```\n *\n * If the rectangle is not positioned, is origin can be provided.\n * Order of corners: ne, nw, sw, se\n * @param rect\n * @param origin\n * @returns\n */\nexport const corners = (rect, origin) => {\n    const r = getRectPositioned(rect, origin);\n    return [\n        { x: r.x, y: r.y },\n        { x: r.x + r.width, y: r.y },\n        { x: r.x + r.width, y: r.y + r.height },\n        { x: r.x, y: r.y + r.height },\n    ];\n};\n","import { guardDim } from \"./guard.js\";\nimport { guard as PointsGuard } from '../point/guard.js';\n/**\n * Creates a rectangle from its top-left coordinate, a width and height.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Rectangle at 50,50 with width of 100, height of 200.\n * const rect = Rects.fromTopLeft({ x: 50, y:50 }, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromTopLeft = (origin, width, height) => {\n    guardDim(width, `width`);\n    guardDim(height, `height`);\n    PointsGuard(origin, `origin`);\n    return { x: origin.x, y: origin.y, width: width, height: height };\n};\n","import { equilateralFromVertex } from \"../triangle/create.js\";\nimport { corners as RectsCorners } from '../rect/corners.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/from-top-left.js';\nimport { rotate as PointsRotate } from \"../point/rotate.js\";\n/**\n * Returns the points forming an arrow.\n *\n * @example Create an arrow anchored by its tip at 100,100\n * ```js\n * const opts = {\n *  tailLength: 10,\n *  arrowSize: 20,\n *  tailThickness: 5,\n *  angleRadian: degreeToRadian(45)\n * }\n * const arrow = Shapes.arrow({x:100, y:100}, `tip`, opts); // Yields an array of points\n *\n * // Eg: draw points\n * Drawing.connectedPoints(ctx, arrow, {strokeStyle: `red`, loop: true});\n * ```\n *\n * @param origin Origin of arrow\n * @param from Does origin describe the tip, tail or middle?\n * @param opts Options for arrow\n * @returns\n */\nexport const arrow = (origin, from, opts = {}) => {\n    const tailLength = opts.tailLength ?? 10;\n    const tailThickness = opts.tailThickness ?? Math.max(tailLength / 5, 5);\n    const angleRadian = opts.angleRadian ?? 0;\n    const arrowSize = opts.arrowSize ?? Math.max(tailLength / 5, 15);\n    const triAngle = Math.PI / 2;\n    let tri;\n    let tailPoints;\n    if (from === `tip`) {\n        tri = equilateralFromVertex(origin, arrowSize, triAngle);\n        tailPoints = RectsCorners(RectsFromTopLeft({ x: tri.a.x - tailLength, y: origin.y - tailThickness / 2 }, tailLength, tailThickness));\n    }\n    else if (from === `middle`) {\n        const midX = tailLength + arrowSize / 2;\n        const midY = tailThickness / 2;\n        tri = equilateralFromVertex({\n            x: origin.x + arrowSize * 1.2,\n            y: origin.y,\n        }, arrowSize, triAngle);\n        tailPoints = RectsCorners(RectsFromTopLeft({ x: origin.x - midX, y: origin.y - midY }, tailLength + arrowSize, tailThickness));\n    }\n    else {\n        //const midY = origin.y - tailThickness/2;\n        tailPoints = RectsCorners(RectsFromTopLeft({ x: origin.x, y: origin.y - tailThickness / 2 }, tailLength, tailThickness));\n        tri = equilateralFromVertex({ x: origin.x + tailLength + arrowSize * 0.7, y: origin.y }, arrowSize, triAngle);\n    }\n    const arrow = PointsRotate([\n        tailPoints[0],\n        tailPoints[1],\n        tri.a,\n        tri.b,\n        tri.c,\n        tailPoints[2],\n        tailPoints[3],\n    ], angleRadian, origin);\n    return arrow;\n};\n","import { isCirclePositioned } from \"./guard.js\";\nimport { sum as PointsSum } from \"../point/sum.js\";\nimport { toCartesian as PolarToCartesian } from \"../polar/index.js\";\nconst piPi = Math.PI * 2;\n/**\n * Returns a random point within a circle.\n *\n * By default creates a uniform distribution.\n *\n * ```js\n * const pt = randomPoint({radius: 5});\n * const pt = randomPoint({radius: 5, x: 10, y: 20});\n * ```'\n *\n * Generate points with a gaussian distribution\n * ```js\n * const pt = randomPoint(circle, {\n *  randomSource: Random.gaussian\n * })\n * ```\n * @param within Circle to generate a point within\n * @param opts Options\n * @returns\n */\nexport const randomPoint = (within, opts = {}) => {\n    const offset = isCirclePositioned(within) ? within : { x: 0, y: 0 };\n    const strategy = opts.strategy ?? `uniform`;\n    const margin = opts.margin ?? 0;\n    const radius = within.radius - margin;\n    const rand = opts.randomSource ?? Math.random;\n    switch (strategy) {\n        case `naive`: {\n            return PointsSum(offset, PolarToCartesian(rand() * radius, rand() * piPi));\n        }\n        case `uniform`: {\n            return PointsSum(offset, PolarToCartesian(Math.sqrt(rand()) * radius, rand() * piPi));\n        }\n        default: {\n            throw new Error(`Unknown strategy '${strategy}'. Expects 'uniform' or 'naive'`);\n        }\n    }\n};\n","import {} from '@ixfx/random';\nimport { sum as PointsSum } from '../point/sum.js';\nimport { isPositioned } from './guard.js';\n/**\n * Returns a random positioned Rect on a 0..1 scale.\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r = Rects.random(); // eg {x: 0.2549012, y:0.859301, width: 0.5212, height: 0.1423 }\n * ```\n *\n * A custom source of randomness can be provided:\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * import { weightedSource } from \"https://unpkg.com/ixfx/dist/random.js\"\n * const r = Rects.random(weightedSource(`quadIn`));\n * ```\n * @param rando\n * @returns\n */\nexport const random = (rando) => {\n    if (rando === undefined)\n        rando = Math.random;\n    return Object.freeze({\n        x: rando(),\n        y: rando(),\n        width: rando(),\n        height: rando(),\n    });\n};\n/**\n * Returns a random point within a rectangle.\n *\n * By default creates a uniform distribution.\n *\n * ```js\n * const pt = randomPoint({width: 5, height: 10});\n * ```'\n * @param within Rectangle to generate a point within\n * @param options Options\n * @returns\n */\nexport const randomPoint = (within, options = {}) => {\n    // TODO: Does not implement uniform distribution\n    // See: https://math.stackexchange.com/questions/366474/find-coordinates-of-n-points-uniformly-distributed-in-a-rectangle\n    const rand = options.randomSource ?? Math.random;\n    const margin = options.margin ?? { x: 0, y: 0 };\n    const x = rand() * (within.width - margin.x - margin.x);\n    const y = rand() * (within.height - margin.y - margin.y);\n    const pos = { x: x + margin.x, y: y + margin.y };\n    return isPositioned(within) ? PointsSum(pos, within) : Object.freeze(pos);\n};\n","import { isCirclePositioned } from \"./guard.js\";\n/**\n * Returns the center of a circle\n *\n * If the circle has an x,y, that is the center.\n * If not, `radius` is used as the x and y.\n *\n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n * const circle = { radius: 5, x: 10, y: 10};\n *\n * // Yields: { x: 5, y: 10 }\n * Circles.center(circle);\n * ```\n *\n * It's a trivial function, but can make for more understandable code\n * @param circle\n * @returns Center of circle\n */\nexport const center = (circle) => {\n    return isCirclePositioned(circle) ? Object.freeze({ x: circle.x, y: circle.y }) : Object.freeze({ x: circle.radius, y: circle.radius });\n};\n","import { isPoint, guard as PointsGuard, isPlaceholder as PointsIsPlaceholder, isEmpty as PointsIsEmpty } from '../point/guard.js';\nimport { isEqual as PointsIsEqual } from \"../point/is-equal.js\";\n/**\n * Throws an exception if the triangle is invalid\n * @param t\n * @param name\n */\nexport const guard = (t, name = `t`) => {\n    if (t === undefined)\n        throw new Error(`{$name} undefined`);\n    PointsGuard(t.a, name + `.a`);\n    PointsGuard(t.b, name + `.b`);\n    PointsGuard(t.c, name + `.c`);\n};\n/**\n * Returns true if the parameter appears to be a valid triangle\n * @param p\n * @returns\n */\nexport const isTriangle = (p) => {\n    if (p === undefined)\n        return false;\n    const tri = p;\n    if (!isPoint(tri.a))\n        return false;\n    if (!isPoint(tri.b))\n        return false;\n    if (!isPoint(tri.c))\n        return false;\n    return true;\n};\n/**\n * Returns true if triangle is empty\n * @param t\n * @returns\n */\nexport const isEmpty = (t) => PointsIsEmpty(t.a) && PointsIsEmpty(t.b) && PointsIsEmpty(t.c);\n/**\n * Returns true if triangle is a placeholder\n * @param t\n * @returns\n */\nexport const isPlaceholder = (t) => PointsIsPlaceholder(t.a) &&\n    PointsIsPlaceholder(t.b) &&\n    PointsIsPlaceholder(t.c);\n/**\n * Returns true if the two parameters have equal values\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a, b) => PointsIsEqual(a.a, b.a) &&\n    PointsIsEqual(a.b, b.b) &&\n    PointsIsEqual(a.c, b.c);\n","import { guard } from \"./guard.js\";\nimport { reduce as PointsReduce } from '../point/index.js';\n/**\n * Returns simple centroid of triangle\n * @param t\n * @returns\n */\nexport const centroid = (t) => {\n    guard(t);\n    const total = PointsReduce([t.a, t.b, t.c], (p, accumulator) => ({\n        x: p.x + accumulator.x,\n        y: p.y + accumulator.y,\n    }));\n    const div = {\n        x: total.x / 3,\n        y: total.y / 3,\n    };\n    return div;\n};\n","import { isCircle, isCirclePositioned } from \"../circle/guard.js\";\nimport { isRect, isRectPositioned } from \"../rect/guard.js\";\nimport { randomPoint as circleRandomPoint } from '../circle/random.js';\nimport { randomPoint as rectRandomPoint } from '../rect/random.js';\nimport { center as circleCenter } from '../circle/center.js';\nimport { isTriangle } from \"../triangle/guard.js\";\nimport { centroid as triangleCentroid } from \"../triangle/centroid.js\";\nimport { center as rectCenter } from '../rect/center.js';\n/**\n * Returns a random point within a shape.\n * `shape` can be {@link CirclePositioned} or {@link RectPositioned}\n * @param shape\n * @param opts\n * @returns\n */\nexport const randomPoint = (shape, opts = {}) => {\n    if (isCirclePositioned(shape)) {\n        return circleRandomPoint(shape, opts);\n    }\n    else if (isRectPositioned(shape)) {\n        return rectRandomPoint(shape, opts);\n    }\n    throw new Error(`Unknown shape. Only CirclePositioned and RectPositioned are supported.`);\n};\n// export type Shape = {\n//   intersects(x:Point|Shape):ContainsResult\n//   readonly kind:`circular`\n// }\n/**\n * Returns the center of a shape\n * Shape can be: rectangle, triangle, circle\n * @param shape\n * @returns\n */\nexport const center = (shape) => {\n    if (shape === undefined) {\n        return Object.freeze({ x: 0.5, y: 0.5 });\n    }\n    else if (isRect(shape)) {\n        return rectCenter(shape);\n    }\n    else if (isTriangle(shape)) {\n        return triangleCentroid(shape);\n    }\n    else if (isCircle(shape)) {\n        return circleCenter(shape);\n    }\n    else {\n        throw new Error(`Unknown shape: ${JSON.stringify(shape)}`);\n    }\n};\n","import { isPoint } from \"../point/guard.js\";\nimport { distanceCenter } from \"./distance-center.js\";\nimport { isCircle } from \"./guard.js\";\n/**\n * Returns true if `b` is completely contained by `a`\n *\n * ```js\n * // Compare two points\n * isContainedBy(circleA, circleB);\n *\n * // Compare a circle with a point\n * isContainedBy(circleA, {x: 10, y: 20});\n *\n * // Define radius as third parameter\n * isContainedBy(circleA, {x: 10, y: 20}, 20);\n * ```\n * @param a Circle\n * @param b Circle or point to compare to\n * @param c Radius to accompany parameter b if it's a point\n * @returns\n */\nexport const isContainedBy = (a, b, c) => {\n    const d = distanceCenter(a, b);\n    if (isCircle(b)) {\n        return (d < Math.abs(a.radius - b.radius));\n    }\n    else if (isPoint(b)) {\n        // eslint-disable-next-line unicorn/prefer-ternary\n        if (c === undefined) {\n            return d <= a.radius;\n        }\n        else {\n            // Defining a circle\n            return (d < Math.abs(a.radius - c));\n        }\n    }\n    else\n        throw new Error(`b parameter is expected to be CirclePositioned or Point`);\n};\n","import * as Intersects from '../intersects.js';\nimport { isContainedBy } from \"./is-contained-by.js\";\nimport { isCircle } from \"./guard.js\";\nimport { isRectPositioned } from \"../rect/guard.js\";\nimport { isEqual as PointsIsEqual } from \"../point/is-equal.js\";\nimport { isPoint } from '../point/guard.js';\n/**\n * Returns true if `a` or `b` overlap, are equal, or `a` contains `b`.\n * A circle can be checked for intersections with another CirclePositioned, Point or RectPositioned.\n *\n * Use `intersections` to find the points of intersection.\n *\n * @param a Circle\n * @param b Circle or point to test\n * @returns True if circle overlap\n */\nexport const isIntersecting = (a, b, c) => {\n    if (PointsIsEqual(a, b))\n        return true;\n    if (isContainedBy(a, b, c))\n        return true;\n    if (isCircle(b)) {\n        return Intersects.circleCircle(a, b);\n    }\n    else if (isRectPositioned(b)) {\n        return Intersects.circleRect(a, b);\n    }\n    else if (isPoint(b) && c !== undefined) {\n        return Intersects.circleCircle(a, { ...b, radius: c });\n    }\n    return false;\n};\n","import { isCirclePositioned } from \"../circle/guard.js\";\nimport { isRectPositioned } from \"../rect/guard.js\";\nimport { isIntersecting as CirclesIsIntersecting } from '../circle/intersecting.js';\nimport { isIntersecting as RectsIsIntersecting } from '../rect/Intersects.js';\n/**\n * Returns the intersection result between a and b.\n * `a` can be a {@link CirclePositioned} or {@link RectPositioned}\n * `b` can be as above or a {@link Point}.\n * @param a\n * @param b\n */\nexport const isIntersecting = (a, b) => {\n    if (isCirclePositioned(a)) {\n        return CirclesIsIntersecting(a, b);\n    }\n    else if (isRectPositioned(a)) {\n        return RectsIsIntersecting(a, b);\n    }\n    throw new Error(`a or b are unknown shapes. a: ${JSON.stringify(a)} b: ${JSON.stringify(b)}`);\n};\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { toCartesian } from \"../polar/conversions.js\";\nimport { Empty as PointEmpty } from \"../point/empty.js\";\n/**\n * Generates a starburst shape, returning an array of points. By default, initial point is top and horizontally-centred.\n *\n * ```\n * // Generate a starburst with four spikes\n * const pts = starburst(4, 100, 200);\n * ```\n *\n * `points` of two produces a lozenge shape.\n * `points` of three produces a triangle shape.\n * `points` of five is the familiar 'star' shape.\n *\n * Note that the path will need to be closed back to the first point to enclose the shape.\n *\n * @example Create starburst and draw it. Note use of 'loop' flag to close the path\n * ```\n * const points = starburst(4, 100, 200);\n * Drawing.connectedPoints(ctx, pts, {loop: true, fillStyle: `orange`, strokeStyle: `red`});\n * ```\n *\n * Options:\n * * initialAngleRadian: angle offset to begin from. This overrides the `-Math.PI/2` default.\n *\n * @param points Number of points in the starburst. Defaults to five, which produces a typical star\n * @param innerRadius Inner radius. A proportionally smaller inner radius makes for sharper spikes. If unspecified, 50% of the outer radius is used.\n * @param outerRadius Outer radius. Maximum radius of a spike to origin\n * @param opts Options\n * @param origin Origin, or `{ x:0, y:0 }` by default.\n */\nexport const starburst = (outerRadius, points = 5, innerRadius, origin = PointEmpty, opts) => {\n    resultThrow(integerTest(points, `positive`, `points`));\n    const angle = (Math.PI * 2) / points;\n    const angleHalf = angle / 2;\n    const initialAngle = opts?.initialAngleRadian ?? -Math.PI / 2;\n    if (innerRadius === undefined)\n        innerRadius = outerRadius / 2;\n    let a = initialAngle;\n    const pts = [];\n    for (let index = 0; index < points; index++) {\n        const peak = toCartesian(outerRadius, a, origin);\n        const left = toCartesian(innerRadius, a - angleHalf, origin);\n        const right = toCartesian(innerRadius, a + angleHalf, origin);\n        pts.push(left, peak);\n        if (index + 1 < points)\n            pts.push(right);\n        a += angle;\n    }\n    return pts;\n};\n","export * from './arrow.js';\nexport * from './etc.js';\nexport * from './is-intersecting.js';\nexport * from './starburst.js';\n","import { sortByNumericProperty } from \"@ixfx/arrays\";\nimport { randomPoint as ShapesRandomPoint } from \"./shape/index.js\";\nimport { isIntersecting as CirclesIsIntersecting } from \"./circle/intersecting.js\";\n/**\n * Naive randomised circle packing.\n * [Algorithm by Taylor Hobbs](https://tylerxhobbs.com/essays/2016/a-randomized-approach-to-cicle-packing)\n */\nexport const random = (circles, container, opts = {}) => {\n    if (!Array.isArray(circles))\n        throw new Error(`Parameter 'circles' is not an array`);\n    const attempts = opts.attempts ?? 2000;\n    const sorted = sortByNumericProperty(circles, `radius`);\n    const positionedCircles = [];\n    const willHit = (b, radius) => positionedCircles.some(v => CirclesIsIntersecting(v, b, radius));\n    while (sorted.length > 0) {\n        //eslint-disable-next-line functional/immutable-data\n        const circle = sorted.pop();\n        if (!circle)\n            break;\n        const randomPointOpts = { ...opts, margin: { x: circle.radius, y: circle.radius } };\n        //eslint-disable-next-line functional/no-let\n        for (let index = 0; index < attempts; index++) {\n            const position = ShapesRandomPoint(container, randomPointOpts);\n            if (!willHit(position, circle.radius)) {\n                //eslint-disable-next-line functional/immutable-data\n                positionedCircles.push(Object.freeze({ ...circle, ...position }));\n                break;\n            }\n        }\n    }\n    return positionedCircles;\n};\n","export * as CirclePacking from './circle-packing.js';\n","import { guard } from \"./guard.js\";\n/**\n * Returns the area of `circle`.\n * @param circle\n * @returns\n */\nexport const area = (circle) => {\n    guard(circle);\n    return Math.PI * circle.radius * circle.radius;\n};\n","import {} from \"./rect-types.js\";\nimport { guard as PointsGuard } from '../point/guard.js';\nimport { guardDim } from \"./guard.js\";\n/**\n * Initialises a rectangle based on its center, a width and height\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * // Rectangle with center at 50,50, width 100 height 200\n * Rects.fromCenter({x: 50, y:50}, 100, 200);\n * ```\n * @param origin\n * @param width\n * @param height\n * @returns\n */\nexport const fromCenter = (origin, width, height) => {\n    PointsGuard(origin, `origin`);\n    guardDim(width, `width`);\n    guardDim(height, `height`);\n    const halfW = width / 2;\n    const halfH = height / 2;\n    return {\n        x: origin.x - halfW,\n        y: origin.y - halfH,\n        width: width,\n        height: height,\n    };\n};\n","import { isCirclePositioned } from \"./guard.js\";\nimport { fromCenter as RectsFromCenter } from '../rect/from-center.js';\n/**\n * Computes a bounding box that encloses circle\n * @param circle\n * @returns\n */\nexport const bbox = (circle) => {\n    return isCirclePositioned(circle) ?\n        RectsFromCenter(circle, circle.radius * 2, circle.radius * 2) :\n        { width: circle.radius * 2, height: circle.radius * 2, x: 0, y: 0 };\n};\n","/**\n * Yields the points making up the exterior (ie. circumference) of the circle.\n * Uses [Midpoint Circle Algorithm](http://en.wikipedia.org/wiki/Midpoint_circle_algorithm)\n *\n * @example Draw outline of circle\n * ```js\n * const circle = { x: 100, y: 100, radius: 50 }\n * for (const pt of Circles.exteriorIntegerPoints(circle)) {\n *  // Fill 1x1 pixel\n *  ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle\n */\nexport function* exteriorIntegerPoints(circle) {\n    const { x, y, radius } = circle;\n    let xx = radius;\n    let yy = 0;\n    let radiusError = 1 - x;\n    while (xx >= yy) {\n        yield { x: xx + x, y: yy + y };\n        yield { x: yy + x, y: xx + y };\n        yield { x: -xx + x, y: yy + y };\n        yield { x: -yy + x, y: xx + y };\n        yield { x: -xx + x, y: -yy + y };\n        yield { x: -yy + x, y: -xx + y };\n        yield { x: xx + x, y: -yy + y };\n        yield { x: yy + x, y: -xx + y };\n        yy++;\n        if (radiusError < 0) {\n            radiusError += 2 * yy + 1;\n        }\n        else {\n            xx--;\n            radiusError += 2 * (yy - xx + 1);\n        }\n    }\n}\n","import { distance } from \"../point/distance.js\";\n/**\n * Returns all integer points contained within `circle`.\n *\n * ```js\n * const c = { x:100, y:100, radius:100 };\n * for (const pt of Circles.interiorIntegerPoints(c)) {\n *   ctx.fillRect(pt.x, pt.y, 1, 1);\n * }\n * ```\n * @param circle\n */\nexport function* interiorIntegerPoints(circle) {\n    const xMin = circle.x - circle.radius;\n    const xMax = circle.x + circle.radius;\n    const yMin = circle.y - circle.radius;\n    const yMax = circle.y + circle.radius;\n    for (let x = xMin; x < xMax; x++) {\n        for (let y = yMin; y < yMax; y++) {\n            const r = Math.abs(distance(circle, x, y));\n            if (r <= circle.radius)\n                yield { x, y };\n        }\n    }\n}\n","import { guard, isCirclePositioned } from \"./guard.js\";\nimport { distance as PointsDistance } from \"../point/distance.js\";\nimport { minIndex } from \"@ixfx/numbers\";\nconst piPi = Math.PI * 2;\n/**\n * Returns the nearest point on `circle`'s perimeter closest to `point`.\n *\n * ```js\n * import { Circles } from 'https://unpkg.com/ixfx/dist/geometry.js'\n * const pt = Circles.nearest(circle, {x:10,y:10});\n * ```\n *\n * If an array of circles is provided, it will be the closest point amongst all the circles\n * @param circle Circle or array of circles\n * @param point\n * @returns Point `{ x, y }`\n */\nexport const nearest = (circle, point) => {\n    const n = (a) => {\n        const l = Math.sqrt(Math.pow(point.x - a.x, 2) + Math.pow(point.y - a.y, 2));\n        const x = a.x + (a.radius * ((point.x - a.x) / l));\n        const y = a.y + (a.radius * ((point.y - a.y) / l));\n        return { x, y };\n    };\n    if (Array.isArray(circle)) {\n        const pts = circle.map(l => n(l));\n        const dists = pts.map(p => PointsDistance(p, point));\n        return Object.freeze(pts[minIndex(...dists)]);\n    }\n    else {\n        return Object.freeze(n(circle));\n    }\n};\n/**\n * Returns a point on a circle's perimeter at a specified angle in radians\n *\n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n *\n * // Circle without position\n * const circleA = { radius: 5 };\n *\n * // Get point at angle Math.PI, passing in a origin coordinate\n * const ptA = Circles.pointOnPerimeter(circleA, Math.PI, {x: 10, y: 10 });\n *\n * // Point on circle with position\n * const circleB = { radius: 5, x: 10, y: 10};\n * const ptB = Circles.pointOnPerimeter(circleB, Math.PI);\n * ```\n * @param circle\n * @param angleRadian Angle in radians\n * @param origin or offset of calculated point. By default uses center of circle or 0,0 if undefined\n * @returns Point oo circle\n */\nexport const pointOnPerimeter = (circle, angleRadian, origin) => {\n    if (origin === undefined) {\n        origin = isCirclePositioned(circle) ? circle : { x: 0, y: 0 };\n    }\n    return {\n        x: (Math.cos(-angleRadian) * circle.radius) + origin.x,\n        y: (Math.sin(-angleRadian) * circle.radius) + origin.y\n    };\n};\n/**\n * Returns circumference of `circle` (alias of {@link length})\n * @param circle\n * @returns\n */\nexport const circumference = (circle) => {\n    guard(circle);\n    return piPi * circle.radius;\n};\n/**\n * Returns circumference of `circle` (alias of {@link circumference})\n * @param circle\n * @returns\n */\nexport const length = (circle) => circumference(circle);\n","import { pointOnPerimeter } from \"./perimeter.js\";\nconst piPi = Math.PI * 2;\n/**\n * Computes relative position along circle perimeter\n *\n * ```js\n * import { Circles } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n * const circle = { radius: 100, x: 100, y: 100 };\n *\n * // Get a point halfway around circle\n * // Yields { x, y }\n * const pt = Circles.interpolate(circle, 0.5);\n * ```\n * @param circle\n * @param t Position, 0-1\n * @returns\n */\nexport const interpolate = (circle, t) => pointOnPerimeter(circle, t * piPi);\n","import { isCirclePositioned } from \"./guard.js\";\nimport { multiplyScalar as PointsMultiplyScalar } from '../point/multiply.js';\n/**\n * Multiplies a circle's radius and position (if provided) by `value`.\n *\n * ```js\n * multiplyScalar({ radius: 5 }, 5);\n * // Yields: { radius: 25 }\n *\n * multiplyScalar({ radius: 5, x: 10, y: 20 }, 5);\n * // Yields: { radius: 25, x: 50, y: 100 }\n * ```\n */\nexport function multiplyScalar(a, value) {\n    if (isCirclePositioned(a)) {\n        const pt = PointsMultiplyScalar(a, value);\n        return Object.freeze({\n            ...a,\n            ...pt,\n            radius: a.radius * value\n        });\n    }\n    else {\n        return Object.freeze({\n            ...a,\n            radius: a.radius * value\n        });\n    }\n}\n","import { isCircle, isCirclePositioned } from \"./guard.js\";\n/**\n * Creates a SVG path segment.\n * @param a Circle or radius\n * @param sweep If true, path is 'outward'\n * @param origin Origin of path. Required if first parameter is just a radius or circle is non-positioned\n * @returns\n */\nexport const toSvg = (a, sweep, origin) => {\n    if (isCircle(a)) {\n        if (origin !== undefined) {\n            return toSvgFull(a.radius, origin, sweep);\n        }\n        if (isCirclePositioned(a)) {\n            return toSvgFull(a.radius, a, sweep);\n        }\n        else\n            throw new Error(`origin parameter needed for non-positioned circle`);\n    }\n    else {\n        if (origin === undefined) {\n            throw new Error(`origin parameter needed`);\n        }\n        else {\n            return toSvgFull(a, origin, sweep);\n        }\n    }\n};\nconst toSvgFull = (radius, origin, sweep) => {\n    // https://stackoverflow.com/questions/5737975/circle-drawing-with-svgs-arc-path\n    const { x, y } = origin;\n    const s = sweep ? `1` : `0`;\n    return `\n    M ${x}, ${y}\n    m -${radius}, 0\n    a ${radius},${radius} 0 1,${s} ${radius * 2},0\n    a ${radius},${radius} 0 1,${s} -${radius * 2},0\n  `.split(`\\n`);\n};\n","import { bbox } from \"./bbox.js\";\nimport { guard } from \"./guard.js\";\nimport { interpolate } from \"./interpolate.js\";\nimport { nearest } from \"./perimeter.js\";\nimport { toSvg } from \"./svg.js\";\nimport { circumference } from \"./perimeter.js\";\n/**\n * Returns a `CircularPath` representation of a circle\n *\n * @param {CirclePositioned} circle\n * @returns {CircularPath}\n */\nexport const toPath = (circle) => {\n    guard(circle);\n    return {\n        ...circle,\n        nearest: (point) => nearest(circle, point),\n        /**\n         * Returns a relative (0.0-1.0) point on a circle. 0=3 o'clock, 0.25=6 o'clock, 0.5=9 o'clock, 0.75=12 o'clock etc.\n         * @param {t} Relative (0.0-1.0) point\n         * @returns {Point} X,y\n         */\n        interpolate: (t) => interpolate(circle, t),\n        bbox: () => bbox(circle),\n        length: () => circumference(circle),\n        toSvgString: (sweep = true) => toSvg(circle, sweep),\n        relativePosition: (_point, _intersectionThreshold) => {\n            throw new Error(`Not implemented`);\n        },\n        distanceToPoint: (_point) => {\n            throw new Error(`Not implemented`);\n        },\n        kind: `circular`\n    };\n};\n","import { isCirclePositioned } from \"./guard.js\";\nimport { getPointParameter } from \"../point/get-point-parameter.js\";\n/**\n * Returns a positioned version of a circle.\n * If circle is already positioned, it is returned.\n * If no default position is supplied, 0,0 is used.\n * @param circle\n * @param defaultPositionOrX\n * @param y\n * @returns\n */\nexport const toPositioned = (circle, defaultPositionOrX, y) => {\n    if (isCirclePositioned(circle))\n        return circle;\n    // Returns 0,0 if params are undefined\n    const pt = getPointParameter(defaultPositionOrX, y);\n    return Object.freeze({\n        ...circle,\n        ...pt\n    });\n};\n","export * from './area.js';\nexport * from './bbox.js';\nexport * from './center.js';\nexport * from './circular-path.js';\nexport * from './distance-center.js';\nexport * from './distance-from-exterior.js';\nexport * from './exterior-points.js';\nexport * from './guard.js';\nexport * from './interior-points.js';\nexport * from './interpolate.js';\nexport * from './intersecting.js';\nexport * from './intersections.js';\nexport * from './is-contained-by.js';\nexport * from './is-equal.js';\nexport * from './multiply.js';\nexport * from './perimeter.js';\nexport * from './random.js';\nexport * from './svg.js';\nexport * from './to-path.js';\nexport * from './to-positioned.js';\n","import { guard } from \"./guard.js\";\n/**\n * Returns the area of `rect`\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.area(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const area = (rect) => {\n    guard(rect);\n    return rect.height * rect.width;\n};\n","import { guard } from \"./guard.js\";\nimport { isRect, isRectPositioned, isPositioned } from \"./guard.js\";\n/**\n * Applies an operation over each field of a rectangle.\n * ```js\n * // Convert x,y,width,height to integer values\n * applyFields(v => Number.floor(v), someRect);\n * ```\n * @param op\n * @param rectOrWidth\n * @param heightValue\n * @returns\n */\nexport function applyFields(op, rectOrWidth, heightValue) {\n    let width = (typeof rectOrWidth === `number`) ? rectOrWidth : rectOrWidth.width;\n    let height = (typeof rectOrWidth === `number`) ? heightValue : rectOrWidth.height;\n    if (width === undefined)\n        throw new Error(`Param 'width' undefined`);\n    if (height === undefined)\n        throw new Error(`Param 'height' undefined`);\n    width = op(width, `width`);\n    height = op(height, `height`);\n    if (typeof rectOrWidth === `object`) {\n        if (isPositioned(rectOrWidth)) {\n            const x = op(rectOrWidth.x, `x`);\n            const y = op(rectOrWidth.y, `y`);\n            return { ...rectOrWidth, width, height, x, y };\n        }\n        else {\n            return {\n                ...rectOrWidth, width, height\n            };\n        }\n    }\n    return { width, height };\n}\n/**\n * Applies an joint operation field-wise on two rectangles, returning a single rectangle. This is used to support operations like summing two rectangles.\n * ```js\n * // Eg make a new rectangle by summing each field of rectangle A & B.\n * apply((valueA,valueB) => valueA+valueB, rectA, rectB);\n * ```\n * @param op\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport function applyMerge(op, a, b, c) {\n    guard(a, `a`);\n    if (isRect(b)) {\n        // Math op by another rectangle\n        return isRectPositioned(a) ? Object.freeze({\n            ...a,\n            x: op(a.x, b.width),\n            y: op(a.y, b.height),\n            width: op(a.width, b.width),\n            height: op(a.height, b.height),\n        }) : Object.freeze({\n            ...a,\n            width: op(a.width, b.width),\n            height: op(a.height, b.height),\n        });\n    }\n    else {\n        // Math op with a series of values\n        if (typeof b !== `number`) {\n            throw new TypeError(`Expected second parameter of type Rect or number. Got ${JSON.stringify(b)}`);\n        }\n        if (typeof c !== `number`)\n            throw new Error(`Expected third param as height. Got ${JSON.stringify(c)}`);\n        return isRectPositioned(a) ? Object.freeze({\n            ...a,\n            x: op(a.x, b),\n            y: op(a.y, c),\n            width: op(a.width, b),\n            height: op(a.height, c),\n        }) : Object.freeze({\n            ...a,\n            width: op(a.width, b),\n            height: op(a.height, c),\n        });\n    }\n}\nexport function applyScalar(op, rect, parameter) {\n    return isPositioned(rect) ? Object.freeze({\n        ...rect,\n        x: op(rect.x, parameter),\n        y: op(rect.y, parameter),\n        width: op(rect.width, parameter),\n        height: op(rect.height, parameter),\n    }) : Object.freeze({\n        ...rect,\n        width: op(rect.width, parameter),\n        height: op(rect.height, parameter),\n    });\n}\n/**\n * Applies `op` with `param` to `rect`'s width and height.\n * @param op\n * @param rect\n * @param parameter\n * @returns\n */\nexport function applyDim(op, rect, parameter) {\n    return Object.freeze({\n        ...rect,\n        width: op(rect.width, parameter),\n        height: op(rect.height, parameter),\n    });\n}\n","/**\n * Returns a point on cardinal direction, or 'center' for the middle.\n *\n * ```js\n * cardinal({x: 10, y:10, width:100, height: 20}, 'center');\n * ```\n * @param rect Rectangle\n * @param card Cardinal direction or 'center'\n * @returns Point\n */\nexport const cardinal = (rect, card) => {\n    const { x, y, width, height } = rect;\n    switch (card) {\n        case `nw`: {\n            return Object.freeze({ x, y });\n        }\n        case `n`: {\n            return Object.freeze({\n                x: x + width / 2,\n                y,\n            });\n        }\n        case `ne`: {\n            return Object.freeze({\n                x: x + width,\n                y,\n            });\n        }\n        case `sw`: {\n            return Object.freeze({ x, y: y + height });\n        }\n        case `s`: {\n            return Object.freeze({\n                x: x + width / 2,\n                y: y + height,\n            });\n        }\n        case `se`: {\n            return Object.freeze({\n                x: x + width,\n                y: y + height,\n            });\n        }\n        case `w`: {\n            return Object.freeze({ x, y: y + height / 2 });\n        }\n        case `e`: {\n            return Object.freeze({ x: x + width, y: y + height / 2 });\n        }\n        case `center`: {\n            return Object.freeze({\n                x: x + width / 2,\n                y: y + height / 2,\n            });\n        }\n        default: {\n            // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n            throw new Error(`Unknown direction: ${card}`);\n        }\n    }\n};\n","import { applyMerge, applyDim, applyScalar } from \"./apply.js\";\nconst divideOp = (a, b) => a / b;\n/**\n * @internal\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport function divide(a, b, c) {\n    // @ts-ignore\n    return applyMerge(divideOp, a, b, c);\n}\n/**\n * Divides all components of `rect` by `amount`.\n * This includes x,y if present.\n *\n * ```js\n * divideScalar({ width:10, height:20 }, 2); // { width:5, height: 10 }\n * divideScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 0.5, y: 1, width:5, height: 10 }\n * ```\n * @param rect\n * @param amount\n */\nexport function divideScalar(rect, amount) {\n    return applyScalar(divideOp, rect, amount);\n}\nexport function divideDim(rect, amount) {\n    return applyDim(divideOp, rect, amount);\n}\n","import { isPoint } from \"../point/guard.js\";\nimport { guard } from \"./guard.js\";\nimport { joinPointsToLines as LinesJoinPointsToLines } from '../line/join-points-to-lines.js';\nimport { corners } from \"./corners.js\";\n/**\n * Returns four lines based on each corner.\n * Lines are given in order: top, right, bottom, left\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lines = Rects.lines(rect);\n * ```\n *\n * @param {(RectPositioned|Rect)} rect\n * @param {Points.Point} [origin]\n * @returns {Lines.Line[]}\n */\nexport const edges = (rect, origin) => {\n    const c = corners(rect, origin);\n    // Connect all the corners, back to first corner again\n    return LinesJoinPointsToLines(...c, c[0]);\n};\n/**\n * Returns a point on the edge of rectangle\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeX(r1, `right`);  // Yields: 110\n * Rects.getEdgeX(r1, `bottom`); // Yields: 10\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeX(r2, `right`);  // Yields: 100\n * Rects.getEdgeX(r2, `bottom`); // Yields: 0\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeX = (rect, edge) => {\n    guard(rect);\n    switch (edge) {\n        case `top`: {\n            return isPoint(rect) ? rect.x : 0;\n        }\n        case `bottom`: {\n            return isPoint(rect) ? rect.x : 0;\n        }\n        case `left`: {\n            return isPoint(rect) ? rect.y : 0;\n        }\n        case `right`: {\n            return isPoint(rect) ? rect.x + rect.width : rect.width;\n        }\n    }\n};\n/**\n * Returns a point on the edge of rectangle\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n *\n * const r1 = {x: 10, y: 10, width: 100, height: 50};\n * Rects.getEdgeY(r1, `right`);  // Yields: 10\n * Rects.getEdgeY(r1, `bottom`); // Yields: 60\n *\n * const r2 = {width: 100, height: 50};\n * Rects.getEdgeY(r2, `right`);  // Yields: 0\n * Rects.getEdgeY(r2, `bottom`); // Yields: 50\n * ```\n * @param rect\n * @param edge Which edge: right, left, bottom, top\n * @returns\n */\nexport const getEdgeY = (rect, edge) => {\n    guard(rect);\n    switch (edge) {\n        case `top`: {\n            return (isPoint(rect) ? rect.y : 0);\n        }\n        case `bottom`: {\n            return isPoint(rect) ? rect.y + rect.height : rect.height;\n        }\n        case `left`: {\n            return isPoint(rect) ? rect.y : 0;\n        }\n        case `right`: {\n            return isPoint(rect) ? rect.y : 0;\n        }\n    }\n};\n","export const Empty = Object.freeze({ width: 0, height: 0 });\nexport const EmptyPositioned = Object.freeze({\n    x: 0,\n    y: 0,\n    width: 0,\n    height: 0,\n});\n","/**\n * Returns a copy of `rect` with `rect` resized so it also encompasses `points`.\n * If provided point(s) are within bounds of `rect`, a copy of `rect` is returned.\n * @param rect\n * @param points\n * @returns\n */\nexport const encompass = (rect, ...points) => {\n    const x = points.map(p => p.x);\n    const y = points.map(p => p.y);\n    let minX = Math.min(...x, rect.x);\n    let minY = Math.min(...y, rect.y);\n    let maxX = Math.max(...x, rect.x + rect.width);\n    let maxY = Math.max(...y, rect.y + rect.height);\n    let rectW = Math.max(rect.width, maxX - minX);\n    let rectH = Math.max(rect.height, maxY - minY);\n    return Object.freeze({\n        ...rect,\n        x: minX,\n        y: minY,\n        width: rectW,\n        height: rectH\n    });\n};\n","/**\n * Initialise a rectangle based on the width and height of a HTML element.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\"\n * Rects.fromElement(document.querySelector(`body`));\n * ```\n * @param el\n * @returns\n */\nexport const fromElement = (el) => ({\n    width: el.clientWidth,\n    height: el.clientHeight,\n});\n","/**\n * Returns a rectangle from a series of numbers: x, y, width, height OR width, height\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r1 = Rects.fromNumbers(100, 200);\n * // {width: 100, height: 200}\n *\n * const r2 = Rects.fromNumbers(10, 20, 100, 200);\n * // {x: 10, y: 20, width: 100, height: 200}\n * ```\n * Use the spread operator (...) if the source is an array:\n *\n * ```js\n * const r3 = Rects.fromNumbers(...[10, 20, 100, 200]);\n * ```\n *\n * Use {@link toArray} for the opposite conversion.\n *\n * @see toArray\n * @param xOrWidth\n * @param yOrHeight\n * @param width\n * @param height\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function fromNumbers(xOrWidth, yOrHeight, width, height) {\n    if (width === undefined || height === undefined) {\n        if (typeof xOrWidth !== `number`)\n            throw new Error(`width is not an number`);\n        if (typeof yOrHeight !== `number`) {\n            throw new TypeError(`height is not an number`);\n        }\n        return Object.freeze({ width: xOrWidth, height: yOrHeight });\n    }\n    if (typeof xOrWidth !== `number`)\n        throw new Error(`x is not an number`);\n    if (typeof yOrHeight !== `number`)\n        throw new Error(`y is not an number`);\n    if (typeof width !== `number`)\n        throw new Error(`width is not an number`);\n    if (typeof height !== `number`)\n        throw new Error(`height is not an number`);\n    return Object.freeze({ x: xOrWidth, y: yOrHeight, width, height });\n}\n","import { isPoint } from \"../point/guard.js\";\nimport { isRect, isRectPositioned } from \"./guard.js\";\n/**\n * Accepts:\n * * x,y,w,h\n * * x,y,rect\n * * point,rect\n * * RectPositioned\n * * Rect, x,y\n * * Rect, Point\n * @param a\n * @param b\n * @param c\n * @param d\n * @returns\n */\nexport function getRectPositionedParameter(a, b, c, d) {\n    if (typeof a === `number`) {\n        if (typeof b === `number`) {\n            if (typeof c === `number` && typeof d === `number`) {\n                return { x: a, y: b, width: c, height: d };\n            }\n            else if (isRect(c)) {\n                return { x: a, y: b, width: c.width, height: c.height };\n            }\n            else {\n                throw new TypeError(`If params 'a' & 'b' are numbers, expect following parameters to be x,y or Rect`);\n            }\n        }\n        else {\n            throw new TypeError(`If parameter 'a' is a number, expect following parameters to be: y,w,h`);\n        }\n    }\n    else if (isRectPositioned(a)) {\n        return a;\n    }\n    else if (isRect(a)) {\n        if (typeof b === `number` && typeof c === `number`) {\n            return { width: a.width, height: a.height, x: b, y: c };\n        }\n        else if (isPoint(b)) {\n            return { width: a.width, height: a.height, x: b.x, y: b.y };\n        }\n        else {\n            throw new TypeError(`If param 'a' is a Rect, expects following parameters to be x,y`);\n        }\n    }\n    else if (isPoint(a)) {\n        if (typeof b === `number` && typeof c === `number`) {\n            return { x: a.x, y: a.y, width: b, height: c };\n        }\n        else if (isRect(b)) {\n            return { x: a.x, y: a.y, width: b.width, height: b.height };\n        }\n        else {\n            throw new TypeError(`If parameter 'a' is a Point, expect following params to be: Rect or width,height`);\n        }\n    }\n    throw new TypeError(`Expect a first parameter to be x,RectPositioned,Rect or Point`);\n}\n","import { isPositioned } from \"./guard.js\";\nimport { isEqual as PointsIsEqual } from '../point/is-equal.js';\n/**\n * Returns _true_ if the width & height of the two rectangles is the same.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqualSize = (a, b) => {\n    if (a === undefined)\n        throw new Error(`a undefined`);\n    if (b === undefined)\n        throw new Error(`b undefined`);\n    return a.width === b.width && a.height === b.height;\n};\n/**\n * Returns _true_ if two rectangles have identical values.\n * Both rectangles must be positioned or not.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 10, height: 10, x: 10, y: 10 };\n * const rectB = { width: 10, height: 10, x: 20, y: 20 };\n *\n * // False, because coordinates are different\n * Rects.isEqual(rectA, rectB)\n *\n * // True, even though x,y are different\n * Rects.isEqualSize(rectA, rectB);\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const isEqual = (a, b) => {\n    if (isPositioned(a) && isPositioned(b)) {\n        if (!PointsIsEqual(a, b))\n            return false;\n        return a.width === b.width && a.height === b.height;\n    }\n    else if (!isPositioned(a) && !isPositioned(b)) {\n        return a.width === b.width && a.height === b.height;\n    }\n    else {\n        // One param is positioned, the other is not\n        return false;\n    }\n};\n","import { length as LinesLength } from '../line/length.js';\nimport { edges } from './edges.js';\nimport { guardPositioned } from './guard.js';\n/**\n * Returns the length of each side of the rectangle (top, right, bottom, left)\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * // Yields: array of length four\n * const lengths = Rects.lengths(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const lengths = (rect) => {\n    guardPositioned(rect, `rect`);\n    return edges(rect).map((l) => LinesLength(l));\n};\n","import { applyMerge, applyDim, applyScalar } from \"./apply.js\";\nconst multiplyOp = (a, b) => a * b;\n/**\n * @internal\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport function multiply(a, b, c) {\n    // @ts-ignore\n    return applyMerge(multiplyOp, a, b, c);\n}\n/**\n * Multiplies all components of `rect` by `amount`.\n * This includes x,y if present.\n *\n * ```js\n * multiplyScalar({ width:10, height:20 }, 2); // { width:20, height: 40 }\n * multiplyScalar({ x: 1, y: 2, width:10, height:20 }, 2); // { x: 2, y: 4, width:20, height: 40 }\n * ```\n *\n * Use {@link multiplyDim} to only multiply width & height.\n * @param rect\n * @param amount\n */\nexport function multiplyScalar(rect, amount) {\n    return applyScalar(multiplyOp, rect, amount);\n    // return isPositioned(rect) ? Object.freeze({\n    //   ...rect,\n    //   x: rect.x * amount,\n    //   y: rect.y * amount,\n    //   width: rect.width * amount,\n    //   height: rect.height * amount,\n    // }) : Object.freeze({\n    //   ...rect,\n    //   width: rect.width * amount,\n    //   height: rect.height * amount,\n    // });\n}\n/**\n * Multiplies only the width/height of `rect`, leaving `x` and `y` as they are.\n * ```js\n * multiplyDim({ x:1,y:2,width:3,height:4 }, 2);\n * // Yields: { x:1, y:2, width:6, height: 8 }\n * ```\n *\n * In comparison, {@link multiply} will also include x & y.\n * @param rect Rectangle\n * @param amount Amount to multiply by\n * @returns\n */\nexport function multiplyDim(rect, amount) {\n    return applyDim(multiplyOp, rect, amount);\n    // return isPositioned(rect) ? Object.freeze({\n    //   ...rect,\n    //   x: rect.x * amount,\n    //   y: rect.y * amount,\n    //   width: rect.width * amount,\n    //   height: rect.height * amount,\n    // }) : Object.freeze({\n    //   ...rect,\n    //   width: rect.width * amount,\n    //   height: rect.height * amount,\n    // });\n}\n","/**\n * If `p` is inside of `rect`, a copy of `p` is returned.\n * If `p` is outside of `rect`, a point is returned closest to `p` on the edge\n * of the rectangle.\n * @param rect\n * @param p\n * @returns\n */\nexport const nearestInternal = (rect, p) => {\n    let { x, y } = p;\n    if (x < rect.x)\n        x = rect.x;\n    else if (x > rect.x + rect.width)\n        x = rect.x + rect.width;\n    if (y < rect.y)\n        y = rect.y;\n    else if (y > rect.y + rect.height)\n        y = rect.y + rect.height;\n    return Object.freeze({ ...p, x, y });\n};\n","export const Placeholder = Object.freeze({\n    width: Number.NaN,\n    height: Number.NaN,\n});\nexport const PlaceholderPositioned = Object.freeze({\n    x: Number.NaN,\n    y: Number.NaN,\n    width: Number.NaN,\n    height: Number.NaN,\n});\n","import { guard } from \"./guard.js\";\n/**\n * Returns the perimeter of `rect` (ie. sum of all edges)\n *  * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rect = { width: 100, height: 100, x: 100, y: 100 };\n * Rects.perimeter(rect);\n * ```\n * @param rect\n * @returns\n */\nexport const perimeter = (rect) => {\n    guard(rect);\n    return rect.height + rect.height + rect.width + rect.width;\n};\n","import { isPoint, isPoint3d } from \"../point/guard.js\";\n/**\n * Returns a function that divides numbers or points by the largest dimension of `rect`.\n * ```js\n * const d = dividerByLargestDimension({width:100,height:50});\n * d(50);                // 0.5 (50/100)\n * d({ x: 10, y: 20 }); // { x: 0.1, y: 0.2 }\n * ```\n * @param rect\n * @returns\n */\nexport const dividerByLargestDimension = (rect) => {\n    const largest = Math.max(rect.width, rect.height);\n    return (value) => {\n        if (typeof value === `number`) {\n            return value / largest;\n        }\n        else if (isPoint3d(value)) {\n            return Object.freeze({\n                ...value,\n                x: value.x / largest,\n                y: value.y / largest,\n                z: value.x / largest\n            });\n        }\n        else if (isPoint(value)) {\n            return Object.freeze({\n                ...value,\n                x: value.x / largest,\n                y: value.y / largest\n            });\n        }\n        else\n            throw new Error(`Param 'value' is neither number nor Point`);\n    };\n};\n","import { applyMerge } from \"./apply.js\";\nimport { isPositioned } from \"./guard.js\";\nconst subtractOp = (a, b) => a - b;\n/**\n * Subtracts width/height from `a`.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: -100, height: -100 }\n * Rects.subtract(rectA, rectB);\n * Rects.subtract(rectA, 200, 200);\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\nexport function subtract(a, b, c) {\n    // @ts-ignore\n    return applyMerge(subtractOp, a, b, c);\n}\nexport function subtractSize(a, b, c) {\n    const w = typeof b === `number` ? b : b.width;\n    const h = typeof b === `number` ? c : b.height;\n    if (h === undefined)\n        throw new Error(`Expected height as third parameter`);\n    const r = {\n        ...a,\n        width: a.width - w,\n        height: a.height - h\n    };\n    return r;\n}\n/**\n * Subtracts A-B. Applies to x, y, width & height\n * ```js\n * subtractOffset(\n *  { x:100, y:100, width:100, height:100 },\n *  { x:10, y:20,   width: 30, height: 40 }\n * );\n * // Yields: {x: 90, y: 80, width: 70, height: 60 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used.\n * @param a\n * @param b\n * @returns\n */\nexport function subtractOffset(a, b) {\n    let x = 0;\n    let y = 0;\n    if (isPositioned(a)) {\n        x = a.x;\n        y = a.y;\n    }\n    let xB = 0;\n    let yB = 0;\n    if (isPositioned(b)) {\n        xB = b.x;\n        yB = b.y;\n    }\n    return Object.freeze({\n        ...a,\n        x: x - xB,\n        y: y - yB,\n        width: a.width - b.width,\n        height: a.height - b.height\n    });\n}\n","import { applyMerge } from \"./apply.js\";\nimport { getRectPositioned, isPositioned } from \"./guard.js\";\nconst sumOp = (a, b) => a + b;\n/**\n * Sums width/height of `b` with `a` (ie: a + b), returning result.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const rectA = { width: 100, height: 100 };\n * const rectB = { width: 200, height: 200 };\n *\n * // Yields: { width: 300, height: 300 }\n * Rects.sum(rectA, rectB);\n * Rects.sum(rectA, 200, 200);\n * ```\n * @param a\n * @param b\n * @param c\n * @returns\n */\n//eslint-disable-next-line func-style\nexport function sum(a, b, c) {\n    // @ts-ignore\n    return applyMerge(sumOp, a, b, c);\n}\n/**\n * Sums x,y,width,height of a+b.\n * ```js\n * sumOffset({x:100,y:100,width:100,height:100}, {x:10, y:20, width: 30, height: 40});\n * // Yields: {x: 110, y: 120, width: 130, height: 140 }\n * ```\n * If either `a` or `b` are missing x & y, 0 is used\n * @param a\n * @param b\n * @returns\n */\nexport function sumOffset(a, b) {\n    let x = 0;\n    let y = 0;\n    if (isPositioned(a)) {\n        x = a.x;\n        y = a.y;\n    }\n    let xB = 0;\n    let yB = 0;\n    if (isPositioned(b)) {\n        xB = b.x;\n        yB = b.y;\n    }\n    return Object.freeze({\n        ...a,\n        x: x + xB,\n        y: y + yB,\n        width: a.width + b.width,\n        height: a.height + b.height\n    });\n}\n","import { isPositioned, isRect } from \"./guard.js\";\n/**\n * Converts a rectangle to an array of numbers. See {@link fromNumbers} for the opposite conversion.\n *\n * ```js\n * import { Rects } from \"https://unpkg.com/ixfx/dist/geometry.js\";\n * const r1 = Rects.toArray({ x: 10, y:20, width: 100, height: 200 });\n * // [10, 20, 100, 200]\n * const r2 = Rects.toArray({ width: 100, height: 200 });\n * // [100, 200]\n * ```\n * @param rect\n * @see fromNumbers\n */\n// eslint-disable-next-line func-style\nexport function toArray(rect) {\n    if (isPositioned(rect)) {\n        return [rect.x, rect.y, rect.width, rect.height];\n    }\n    else if (isRect(rect)) {\n        return [rect.width, rect.height];\n    }\n    else {\n        throw new Error(`Param 'rect' is not a rectangle. Got: ${JSON.stringify(rect)}`);\n    }\n}\n","export * from './area.js';\nexport * from './apply.js';\nexport * from './cardinal.js';\nexport * from './center.js';\nexport * from './corners.js';\nexport * from './distance.js';\nexport * from './divide.js';\nexport * from './edges.js';\nexport * from './empty.js';\nexport * from './encompass.js';\nexport * from './from-center.js';\nexport * from './from-element.js';\nexport * from './from-numbers.js';\nexport * from './from-top-left.js';\nexport * from './get-rect-positionedparameter.js';\nexport * from './guard.js';\nexport * from './Intersects.js';\nexport * from './is-equal.js';\nexport * from './lengths.js';\nexport * from './max.js';\nexport * from './multiply.js';\nexport * from './nearest.js';\nexport * from './placeholder.js';\nexport * from './perimeter.js';\nexport * from './normalise-by-rect.js';\nexport * from './random.js';\nexport * from './subtract.js';\nexport * from './sum.js';\nexport * from './to-array.js';\n","export const isQuadraticBezier = (path) => path.quadratic !== undefined;\nexport const isCubicBezier = (path) => path.cubic1 !== undefined && path.cubic2 !== undefined;\n","import { isQuadraticBezier } from \"../bezier/guard.js\";\nimport { isLine } from \"../line/guard.js\";\n/**\n * Return the start point of a path\n *\n * @param path\n * @return Point\n */\nexport const getStart = function (path) {\n    if (isQuadraticBezier(path))\n        return path.a;\n    else if (isLine(path))\n        return path.a;\n    else\n        throw new Error(`Unknown path type ${JSON.stringify(path)}`);\n};\n/**\n * Return the end point of a path\n *\n * @param path\n * @return Point\n */\nexport const getEnd = function (path) {\n    if (isQuadraticBezier(path))\n        return path.b;\n    else if (isLine(path))\n        return path.b;\n    else\n        throw new Error(`Unknown path type ${JSON.stringify(path)}`);\n};\n","import { bbox as PointsBbox } from '../point/bbox.js';\nimport { isEqual as PointsIsEqual } from '../point/is-equal.js';\nimport { corners as RectsCorners } from '../rect/corners.js';\nimport { sortByNumericProperty } from '@ixfx/arrays';\nimport { getEnd, getStart } from './start-end.js';\n/**\n * Returns a new compoundpath, replacing a path at a given index\n *\n * @param compoundPath Existing compoundpath\n * @param index Index to replace at\n * @param path Path to substitute in\n * @returns New compoundpath\n */\nexport const setSegment = (compoundPath, index, path) => {\n    const existing = [...compoundPath.segments];\n    //eslint-disable-next-line functional/prefer-readonly-type,functional/immutable-data\n    existing[index] = path;\n    return fromPaths(...existing);\n};\n/**\n * Computes x,y point at a relative position along compoundpath\n *\n * @param paths Combined paths (assumes contiguous)\n * @param t Position (given as a percentage from 0 to 1)\n * @param useWidth If true, widths are used for calulcating. If false, lengths are used\n * @param dimensions Precalculated dimensions of paths, will be computed if omitted\n * @returns\n */\nexport const interpolate = (paths, t, useWidth, dimensions) => {\n    if (dimensions === undefined) {\n        dimensions = computeDimensions(paths);\n    }\n    // Expected value to land on\n    const expected = t * (useWidth ? dimensions.totalWidth : dimensions.totalLength);\n    let soFar = 0;\n    // Use widths or lengths?\n    const l = useWidth ? dimensions.widths : dimensions.lengths;\n    for (const [index, element] of l.entries()) {\n        if (soFar + element >= expected) {\n            const relative = expected - soFar;\n            let amt = relative / element;\n            if (amt > 1)\n                amt = 1;\n            return paths[index].interpolate(amt);\n        }\n        else\n            soFar += element;\n    }\n    return { x: 0, y: 0 };\n};\n/**\n * Returns the shortest distance of `point` to any point on `paths`.\n * @param paths\n * @param point\n * @returns\n */\nexport const distanceToPoint = (paths, point) => {\n    if (paths.length === 0)\n        return 0;\n    let distances = paths.map((p, index) => ({ path: p, index, distance: p.distanceToPoint(point) }));\n    distances = sortByNumericProperty(distances, `distance`);\n    if (distances.length === 0)\n        throw new Error(`Could not look up distances`);\n    return distances[0].distance;\n};\n/**\n * Relative position\n * @param paths Paths\n * @param point Point\n * @param intersectionThreshold Threshold\n * @param dimensions Pre-computed dimensions\n * @returns\n */\nexport const relativePosition = (paths, point, intersectionThreshold, dimensions) => {\n    if (dimensions === undefined) {\n        dimensions = computeDimensions(paths);\n    }\n    let distances = paths.map((p, index) => ({ path: p, index, distance: p.distanceToPoint(point) }));\n    distances = sortByNumericProperty(distances, `distance`);\n    if (distances.length < 0)\n        throw new Error(`Point does not intersect with path`);\n    const d = distances[0];\n    if (d.distance > intersectionThreshold)\n        throw new Error(`Point does not intersect with path. Minimum distance: ${d.distance}, threshold: ${intersectionThreshold}`);\n    const relativePositionOnPath = d.path.relativePosition(point, intersectionThreshold);\n    // Add up distances\n    let accumulated = 0;\n    for (let index = 0; index < d.index; index++) {\n        // Add up length of paths before closest path segment\n        accumulated += dimensions.lengths[index];\n    }\n    // Add up partial amount of closest path\n    accumulated += dimensions.lengths[d.index] * relativePositionOnPath;\n    const accumulatedRel = accumulated / dimensions.totalLength;\n    console.log(`acc: ${accumulated} rel: ${accumulatedRel} on path: ${relativePositionOnPath} path: ${d.index}`);\n    return accumulatedRel;\n};\n/**\n * Computes the widths and lengths of all paths, adding them up as well\n *\n * @param paths\n * @returns\n */\nexport const computeDimensions = (paths) => {\n    const widths = paths.map(l => l.bbox().width);\n    const lengths = paths.map(l => l.length());\n    let totalLength = 0;\n    let totalWidth = 0;\n    for (const length of lengths) {\n        totalLength += length;\n    }\n    for (const width of widths) {\n        totalWidth += width;\n    }\n    return { totalLength, totalWidth, widths, lengths };\n};\n/**\n * Computes the bounding box that encloses entire compoundpath\n *\n * @param paths\n * @returns\n */\nexport const bbox = (paths) => {\n    const boxes = paths.map(p => p.bbox());\n    const corners = boxes.flatMap(b => RectsCorners(b));\n    return PointsBbox(...corners);\n};\n/**\n * Produce a human-friendly representation of paths\n *\n * @param paths\n * @returns\n */\nexport const toString = (paths) => paths.map(p => p.toString()).join(`, `);\n/**\n * Throws an error if paths are not connected together, in order\n *\n * @param paths\n */\nexport const guardContinuous = (paths) => {\n    let lastPos = getEnd(paths[0]);\n    for (let index = 1; index < paths.length; index++) {\n        const start = getStart(paths[index]);\n        if (!PointsIsEqual(start, lastPos))\n            throw new Error(`Path index ${index} does not start at prior path end. Start: ${start.x},${start.y} expected: ${lastPos.x},${lastPos.y}`);\n        lastPos = getEnd(paths[index]);\n    }\n};\nexport const toSvgString = (paths) => paths.flatMap(p => p.toSvgString());\n/**\n * Create a compoundpath from an array of paths.\n * All this does is verify they are connected, and precomputes dimensions\n *\n * @param paths\n * @returns\n */\nexport const fromPaths = (...paths) => {\n    guardContinuous(paths); // Throws an error if paths are not connected\n    const dims = computeDimensions(paths);\n    return Object.freeze({\n        segments: paths,\n        length: () => dims.totalLength,\n        nearest: (_) => { throw new Error(`not implemented`); },\n        interpolate: (t, useWidth = false) => interpolate(paths, t, useWidth, dims),\n        relativePosition: (point, intersectionThreshold) => relativePosition(paths, point, intersectionThreshold, dims),\n        distanceToPoint: (point) => distanceToPoint(paths, point),\n        bbox: () => bbox(paths),\n        toString: () => toString(paths),\n        toSvgString: () => toSvgString(paths),\n        kind: `compound`\n    });\n};\n","export * from './compound-path.js';\nexport * from './start-end.js';\n","/**\n * Returns _true_ if cell coordinates are above zero and within bounds of grid\n *\n * @param grid\n * @param cell\n * @return\n */\nexport const inside = (grid, cell) => {\n    if (cell.x < 0 || cell.y < 0)\n        return false;\n    if (cell.x >= grid.cols || cell.y >= grid.rows)\n        return false;\n    return true;\n};\n","import { inside } from \"./inside.js\";\n/**\n * Returns true if `cell` parameter is a cell with x,y fields.\n * Does not check validity of fields.\n *\n * @param cell\n * @return True if parameter is a cell\n */\nexport const isCell = (cell) => {\n    if (cell === undefined)\n        return false;\n    return `x` in cell && `y` in cell;\n};\n/**\n * Throws an exception if any of the cell's parameters are invalid\n * @private\n * @param cell\n * @param parameterName\n * @param grid\n */\nexport const guardCell = (cell, parameterName = `Param`, grid) => {\n    if (cell === undefined) {\n        throw new Error(parameterName + ` is undefined. Expecting {x,y}`);\n    }\n    if (cell.x === undefined)\n        throw new Error(parameterName + `.x is undefined`);\n    if (cell.y === undefined)\n        throw new Error(parameterName + `.y is undefined`);\n    if (Number.isNaN(cell.x))\n        throw new Error(parameterName + `.x is NaN`);\n    if (Number.isNaN(cell.y))\n        throw new Error(parameterName + `.y is NaN`);\n    if (!Number.isInteger(cell.x)) {\n        throw new TypeError(parameterName + `.x is non-integer`);\n    }\n    if (!Number.isInteger(cell.y)) {\n        throw new TypeError(parameterName + `.y is non-integer`);\n    }\n    if (grid !== undefined && !inside(grid, cell)) {\n        throw new Error(`${parameterName} is outside of grid. Cell: ${cell.x},${cell.y} Grid: ${grid.cols}, ${grid.rows}`);\n    }\n};\n/**\n * Throws an exception if any of the grid's parameters are invalid\n * @param grid\n * @param parameterName\n */\nexport const guardGrid = (grid, parameterName = `Param`) => {\n    if (grid === undefined) {\n        throw new Error(`${parameterName} is undefined. Expecting grid.`);\n    }\n    if (!(`rows` in grid))\n        throw new Error(`${parameterName}.rows is undefined`);\n    if (!(`cols` in grid))\n        throw new Error(`${parameterName}.cols is undefined`);\n    if (!Number.isInteger(grid.rows)) {\n        throw new TypeError(`${parameterName}.rows is not an integer`);\n    }\n    if (!Number.isInteger(grid.cols)) {\n        throw new TypeError(`${parameterName}.cols is not an integer`);\n    }\n};\n","import { clampIndex } from \"@ixfx/numbers\";\nimport { guardCell, guardGrid } from \"./guards.js\";\n/**\n * Calculates a legal position for a cell based on\n * `grid` size and `bounds` wrapping logic.\n * @param grid\n * @param cell\n * @param wrap\n * @returns\n */\nexport const applyBounds = function (grid, cell, wrap = `undefined`) {\n    guardGrid(grid, `grid`);\n    guardCell(cell, `cell`);\n    let x = cell.x;\n    let y = cell.y;\n    switch (wrap) {\n        case `wrap`: {\n            x = x % grid.cols;\n            y = y % grid.rows;\n            if (x < 0)\n                x = grid.cols + x;\n            else if (x >= grid.cols) {\n                x -= grid.cols;\n            }\n            if (y < 0)\n                y = grid.rows + y;\n            else if (y >= grid.rows) {\n                y -= grid.rows;\n            }\n            x = Math.abs(x);\n            y = Math.abs(y);\n            break;\n        }\n        case `stop`: {\n            x = clampIndex(x, grid.cols);\n            y = clampIndex(y, grid.rows);\n            break;\n        }\n        case `undefined`: {\n            if (x < 0 || y < 0)\n                return;\n            if (x >= grid.cols || y >= grid.rows)\n                return;\n            break;\n        }\n        case `unbounded`: {\n            break;\n        }\n        default: {\n            throw new Error(`Unknown BoundsLogic '${wrap}'. Expected: wrap, stop, undefined or unbounded`);\n        }\n    }\n    return Object.freeze({ x, y });\n};\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { indexFromCell } from \"./index.js\";\n/**\n * Returns a {@link GridCellAccessor} to get values from `array`\n * based on cell (`{x,y}`) coordinates.\n *\n * ```js\n * const arr = [\n *  1,2,3,\n *  4,5,6\n * ]\n * const a = access(arr, 3);\n * a({x:0,y:0});  // 1\n * a({x:2, y:2}); // 6\n * ```\n * @param array\n * @param cols\n * @returns\n */\nexport const access = (array, cols) => {\n    const grid = gridFromArrayDimensions(array, cols);\n    const fn = (cell, wrap = `undefined`) => accessWithGrid(grid, array, cell, wrap);\n    return fn;\n};\nconst accessWithGrid = (grid, array, cell, wrap) => {\n    const index = indexFromCell(grid, cell, wrap);\n    if (index === undefined)\n        return undefined;\n    return array[index];\n};\n/**\n * Returns a {@link GridCellSetter} that can mutate\n * array values based on cell {x,y} positions.\n * ```js\n * const arr = [\n *  1,2,3,\n *  4,5,6\n * ]\n * const a = setMutate(arr, 3);\n * a(10, {x:0,y:0});\n * a(20, {x:2, y:2});\n *\n * // Arr is now:\n * // [\n * //  10, 2, 3,\n * //  4, 5, 20\n * // ]\n * ```\n * @param array\n * @param cols\n * @returns\n */\nexport const setMutate = (array, cols) => {\n    const grid = gridFromArrayDimensions(array, cols);\n    return (value, cell, wrap = `undefined`) => setMutateWithGrid(grid, array, value, cell, wrap);\n};\nconst setMutateWithGrid = (grid, array, value, cell, wrap) => {\n    const index = indexFromCell(grid, cell, wrap);\n    if (index === undefined)\n        throw new RangeError(`Cell (${cell.x},${cell.y}) is out of range of grid cols: ${grid.cols} rows: ${grid.rows}`);\n    array[index] = value;\n    return array;\n};\nexport const set = (array, cols) => {\n    const grid = gridFromArrayDimensions(array, cols);\n    return (value, cell, wrap) => setWithGrid(grid, array, value, cell, wrap);\n};\nconst setWithGrid = (grid, array, value, cell, wrap) => {\n    const index = indexFromCell(grid, cell, wrap);\n    if (index === undefined)\n        throw new RangeError(`Cell (${cell.x},${cell.y}) is out of range of grid cols: ${grid.cols} rows: ${grid.rows}`);\n    const copy = [...array];\n    copy[index] = value;\n    array = copy;\n    return copy;\n};\n/**\n * Creates a {@link Grid} from the basis of an array and a given number of columns\n * @param array\n * @param cols\n * @returns\n */\nconst gridFromArrayDimensions = (array, cols) => {\n    const grid = { cols, rows: Math.ceil(array.length / cols) };\n    return grid;\n};\n/**\n * Wraps `array` for grid access.\n * Mutable, meaning that `array` gets modified if `set` function is used.\n *\n * ```js\n * const g = wrapMutable(myArray, 5); // 5 columns wide\n * g.get({x:1,y:2});     // Get value at cell position\n * g.set(10, {x:1,y:2}); // Set value at cell position\n * g.array;              // Get reference to original passed-in array\n * ```\n *\n * Use {@link wrap} for an immutable version.\n *\n * @param array Array to wrap\n * @param cols Width of grid\n * @returns\n */\nexport const wrapMutable = (array, cols) => {\n    const grid = gridFromArrayDimensions(array, cols);\n    return {\n        ...grid,\n        get: access(array, cols),\n        set: setMutate(array, cols),\n        get array() {\n            return array;\n        }\n    };\n};\n/**\n * Wraps `array` for grid access.\n * Immutable, such that underlying array is not modified and a\n * call to `set` returns a new `GridArray1d`.\n *\n * ```js\n * const myArray = [\n *    `a`, `b`, `c`,\n *    `d`, `e`, `f`\n * ];\n * let g = wrap(myArray, 3);  // 3 columns wide\n * g.get({ x:1, y:2 });          // Get value at cell position\n *\n * // Note that `set` returns a new instance\n * g = g.set(10, { x:1, y:2 });  // Set value at cell position\n * g.array;                      // Get reference to current array\n * ```\n *\n * Use {@link wrapMutable} to modify an array in-place\n * @param array Array to wrap\n * @param cols Width of grid\n * @returns\n */\nexport const wrap = (array, cols) => {\n    const grid = gridFromArrayDimensions(array, cols);\n    return {\n        ...grid,\n        get: (cell, boundsLogic = `undefined`) => accessWithGrid(grid, array, cell, boundsLogic),\n        set: (value, cell, boundsLogic = `undefined`) => {\n            array = setWithGrid(grid, array, value, cell, boundsLogic);\n            return wrap(array, cols);\n        },\n        get array() {\n            return array;\n        }\n    };\n};\n/**\n * Creates a 1-dimensional array to fit a grid of rows x cols.\n * Use {@link createArray} if you want to create this array and wrap it for grid access.\n *\n * ```js\n * // Creates an array filled with 0, sized for a grid 10 rows by 20 columns\n * const arr = createArray(0, 10, 20);\n *\n * // Alternatively, pass in a grid\n * const arr = createArray(0, { rows: 10, cols: 20 });\n * ```\n * @param rowsOrGrid Number of rows, or a grid to use the settings of\n * @param columns Columns\n */\nexport const createArray = (initialValue, rowsOrGrid, columns) => {\n    const rows = typeof rowsOrGrid === `number` ? rowsOrGrid : rowsOrGrid.rows;\n    const cols = typeof rowsOrGrid === `object` ? rowsOrGrid.cols : columns;\n    if (!cols)\n        throw new Error(`Parameter 'columns' missing`);\n    resultThrow(integerTest(rows, `aboveZero`, `rows`), integerTest(cols, `aboveZero`, `cols`));\n    const t = [];\n    const total = rows * cols;\n    for (let index = 0; index < total; index++) {\n        t[index] = initialValue;\n    }\n    return t;\n};\n/**\n * Creates a {@link GridArray1d} instance given the dimensions of the grid.\n * Use {@link createArray} if you just want to create an array sized for a grid.\n *\n * Behind the scenes, it runs:\n * ```js\n * const arr = createArray(initialValue, rows, cols);\n * return wrapMutable(arr, cols);\n * ```\n * @param initialValue\n * @param rowsOrGrid\n * @param columns\n * @returns\n */\nexport const createMutable = (initialValue, rowsOrGrid, columns) => {\n    const rows = typeof rowsOrGrid === `number` ? rowsOrGrid : rowsOrGrid.rows;\n    const cols = typeof rowsOrGrid === `object` ? rowsOrGrid.cols : columns;\n    if (!cols)\n        throw new Error(`Parameter 'columns' missing`);\n    const array = createArray(initialValue, rows, cols);\n    return wrapMutable(array, cols);\n};\n","import { applyBounds } from \"./apply-bounds.js\";\n/**\n * Create a grid from a 2-dimensional array.\n * ```js\n * const data = [\n *  [1,2,3],\n *  [4,5,6]\n * ]\n * const g = create(data);\n * // { rows: 2, cols: 3 }\n * ```\n * @param array\n * @returns\n */\nexport const create = (array) => {\n    let colLen = NaN;\n    for (const row of array) {\n        if (Number.isNaN(colLen)) {\n            colLen = row.length;\n        }\n        else {\n            if (colLen !== row.length)\n                throw new Error(`Array does not have uniform column length`);\n        }\n    }\n    return { rows: array.length, cols: colLen };\n};\nexport const setMutate = (array) => {\n    const grid = create(array);\n    return (value, cell, wrap = `undefined`) => setMutateWithGrid(grid, array, value, cell, wrap);\n};\n/**\n * Returns a function that updates a 2D array representation\n * of a grid. Array is mutated.\n *\n * ```js\n * const m = Grids.Array2d.setMutateWithGrid(grid, array);\n * m(someValue, { x:2, y:3 });\n * ```\n * @param grid\n * @param array\n * @returns\n */\nconst setMutateWithGrid = (grid, array, value, cell, bounds) => {\n    let boundCell = applyBounds(grid, cell, bounds);\n    if (boundCell === undefined)\n        throw new RangeError(`Cell (${cell.x},${cell.y}) is out of range of grid cols: ${grid.cols} rows: ${grid.rows}`);\n    array[boundCell.y][boundCell.x] = value;\n    return array;\n};\n// export const array2dUpdater = <V>(grid: GridVisual, array: Array<Array<V>>) => {\n//   const fn = (v: V, position: Cell) => {\n//     const pos = cellAtPoint(grid, position);\n//     if (pos === undefined) {\n//       throw new Error(\n//         `Position does not exist. Pos: ${ JSON.stringify(\n//           position\n//         ) } Grid: ${ JSON.stringify(grid) }`\n//       );\n//     }\n//     array[ pos.y ][ pos.x ] = v;\n//   };\n//   return fn;\n// };\nexport const access = (array) => {\n    const grid = create(array);\n    const fn = (cell, wrap = `undefined`) => accessWithGrid(grid, array, cell, wrap);\n    return fn;\n};\nconst accessWithGrid = (grid, array, cell, wrap) => {\n    let boundCell = applyBounds(grid, cell, wrap);\n    if (boundCell === undefined)\n        return undefined;\n    return array[boundCell.y][boundCell.x];\n};\nexport const wrapMutable = (array) => {\n    const grid = create(array);\n    return {\n        ...grid,\n        get: access(array),\n        set: setMutate(array),\n        get array() {\n            return array;\n        }\n    };\n};\nexport const set = (array) => {\n    const grid = create(array);\n    return (value, cell, wrap) => setWithGrid(grid, array, value, cell, wrap);\n};\nconst setWithGrid = (grid, array, value, cell, wrap) => {\n    let boundCell = applyBounds(grid, cell, wrap);\n    if (boundCell === undefined)\n        throw new RangeError(`Cell (${cell.x},${cell.y}) is out of range of grid cols: ${grid.cols} rows: ${grid.rows}`);\n    let copyWhole = [...array];\n    let copyRow = [...copyWhole[boundCell.y]];\n    copyRow[boundCell.x] = value;\n    copyWhole[boundCell.y] = copyRow;\n    array = copyWhole;\n    return copyWhole;\n};\n/**\n * Wraps `array` with two dimensions for grid access.\n * Immutable, such that underlying array is not modified and a\n * call to `set` returns a new `GridArray1d`.\n *\n * ```js\n * // Grid of rows: 2, cols: 3\n * const myArray = [\n *  [ `a`, `b`, `c` ],\n *  [ `d`, `e`, `f` ]\n * ]\n * let g = wrap(myArray);\n * g.get({x:1,y:2});          // Get value at cell position\n * g = g.set(10, {x:1,y:2}); // Set value at cell position\n * g.array;                  // Get reference to current array\n * ```\n *\n * Use {@link wrapMutable} to modify an array in-place\n * @param array Array to wrap\n * @returns\n */\nexport const wrap = (array) => {\n    const grid = create(array);\n    return {\n        ...grid,\n        get: (cell, boundsLogic = `undefined`) => accessWithGrid(grid, array, cell, boundsLogic),\n        set: (value, cell, boundsLogic = `undefined`) => {\n            array = setWithGrid(grid, array, value, cell, boundsLogic);\n            return wrap(array);\n        },\n        get array() {\n            return array;\n        }\n    };\n};\n","/**\n * Converts an 1D or 2D array of cell coordinates into values\n *\n * ```js\n * // 1D (ie an array of coordinates)\n * const cells = Grid.As.cells(grid);\n * for (const v of Grid.values(grid, cells)) {\n *\n * }\n * ```\n * ```js\n * // 2D (ie an array of rows)\n * const rows = Grid.As.rows(grid);\n * for (const v of Grid.values(grid, rows)) {\n * }\n * ```\n * @param grid\n * @param iter\n */\nexport function* values(grid, iter) {\n    for (const d of iter) {\n        if (Array.isArray(d)) {\n            yield d.map(v => grid.get(v, `undefined`));\n        }\n        else {\n            yield grid.get(d, `undefined`);\n        }\n    }\n}\n// export function visitValues<T>(readable: GridReadable<T>, visitor: Generator<Cell[]>, wrap?: BoundsLogic): Generator<T[]>\n// export function visitValues<T>(readable: GridReadable<T>, visitor: Generator<Cell>, wrap?: BoundsLogic): Generator<T>\n// /**\n//  * Visits the values of a readable grid\n//  * @param readable Readable grid\n//  * @param visitor Visitor\n//  * @param wrap Wrapping logic, defaultign to 'undefined'\n//  */\n// export function* visitValues<T>(readable: GridReadable<T>, visitor: Generator<Cell | Cell[]>, wrap: BoundsLogic = `undefined`) {\n//   for (const cellOrCells of visitor) {\n//     if (Array.isArray(cellOrCells)) {\n//       yield cellOrCells.map(cell => readable.accessor(cell, wrap));\n//     } else {\n//       yield readable.accessor(cellOrCells, wrap);\n//     }\n//   }\n// }\n","import { guardGrid, guardCell } from \"../guards.js\";\nimport { values } from \"../values.js\";\n/**\n * Enumerate all cell coordinates in an efficient manner.\n * Runs left-to-right, top-to-bottom.\n *\n * If end of grid is reached, behaviour depends on `wrap`:\n * * _true_ (default): iterator will wrap to ensure all are visited.\n * * _false_: iterator stops at end of grid\n *\n * ```js\n * import { Grids } from 'ixfx/geometry.js';\n *\n * // Enumerate each cell position, left-to-right, top-to-bottom\n * for (const cell of Grids.By.cells(grid)) {\n *  // cell will be { x, y }\n * }\n * ```\n *\n * See also:\n * * {@link cellValues}: Iterate over cell values\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid Grid to iterate over\n * @param start Starting cell position (default: {x:0,y:0})\n * @param wrap If true (default), iteration will wrap around through (0,0) when end of grid is reached.\n */\nexport function* cells(grid, start, wrap = true) {\n    if (!start)\n        start = { x: 0, y: 0 };\n    guardGrid(grid, `grid`);\n    guardCell(start, `start`, grid);\n    let { x, y } = start;\n    let canMove = true;\n    do {\n        yield { x, y };\n        x++;\n        if (x === grid.cols) {\n            y++;\n            x = 0;\n        }\n        if (y === grid.rows) {\n            if (wrap) {\n                y = 0;\n                x = 0;\n            }\n            else {\n                canMove = false;\n            }\n        }\n        if (x === start.x && y === start.y)\n            canMove = false; // Complete\n    } while (canMove);\n}\n;\n/**\n * Yield all the values of a grid, left-to-right, top-to-bottom.\n *\n * This is just a wrapper around Grids.values:\n * ```js\n * yield* values(grid, cells(grid, start, wrap));\n * ```\n *\n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellsAndValues}: Iterate over pairs of cell coordinates and cell values\n * @param grid\n * @param start\n * @param wrap\n */\nexport function* cellValues(grid, start, wrap = true) {\n    yield* values(grid, cells(grid, start, wrap));\n}\n/**\n * Yield all cell coordinates and values of a grid, left-to-right, top-to-bottom\n *\n * See also:\n * * {@link cells}: Iterate over cell coordinates\n * * {@link cellValues}: Iterate over cell values\n * @param grid\n * @param start\n * @param wrap\n */\nexport function* cellsAndValues(grid, start, wrap = true) {\n    for (const cell of cells(grid, start, wrap)) {\n        yield { cell, value: grid.get(cell) };\n    }\n}\n","import { cells } from \"./enumerators/cells.js\";\n/**\n * Enumerate rows of grid, returning all the cells in the row\n * as an array\n *\n * ```js\n * for (const row of Grid.As.rows(shape)) {\n *  // row is an array of Cells.\n *  // [ {x:0, y:0}, {x:1, y:0} ... ]\n * }\n * ```\n *\n * Use `Grid.values` to convert the returned iterator into values:\n * ```js\n * for (const v of Grid.values(Grid.rows(shape))) {\n * }\n * ```\n * @param grid\n * @param start\n */\nexport const rows = function* (grid, start) {\n    if (!start)\n        start = { x: 0, y: 0 };\n    let row = start.y;\n    let rowCells = [];\n    for (const c of cells(grid, start)) {\n        if (c.y === row) {\n            rowCells.push(c);\n        }\n        else {\n            yield rowCells;\n            rowCells = [c];\n            row = c.y;\n        }\n    }\n    if (rowCells.length > 0)\n        yield rowCells;\n};\n/**\n * Enumerate columns of grid, returning all the cells in the\n * same column as an array.\n *\n * ```js\n * for (const col of Grid.As.columns(grid)) {\n * }\n * ```\n *\n * Use `Grid.values` to convert into values\n * ```js\n * for (const value of Grid.values(Grid.As.columns(grid))) {\n * }\n * ```\n * @param grid\n * @param start\n */\nexport function* columns(grid, start) {\n    if (!start)\n        start = { x: 0, y: 0 };\n    for (let x = start.x; x < grid.cols; x++) {\n        let colCells = [];\n        for (let y = start.y; y < grid.rows; y++) {\n            colCells.push({ x, y });\n        }\n        yield colCells;\n    }\n}\n","//import { clampIndex } from '@ixfx/numbers';\nimport { applyBounds } from './apply-bounds.js';\n/**\n * Returns a coordinate offset from `start` by `vector` amount.\n *\n * Different behaviour can be specified for how to handle when coordinates exceed the bounds of the grid\n *\n * Note: x and y wrapping are calculated independently. A large wrapping of x, for example won't shift up/down a line.\n *\n * Use {@link Grids.applyBounds} if you need to calculate a wrapped coordinate without adding two together.\n * @param grid Grid to traverse\n * @param vector Offset in x/y\n * @param start Start point\n * @param bounds\n * @returns Cell\n */\nexport const offset = function (grid, start, vector, bounds = `undefined`) {\n    return applyBounds(grid, {\n        x: start.x + vector.x,\n        y: start.y + vector.y\n    }, bounds);\n    // guardCell(start, `start`, grid);\n    // guardCell(vector);\n    // guardGrid(grid, `grid`);\n    // // eslint-disable-next-line functional/no-let\n    // let x = start.x;\n    // // eslint-disable-next-line functional/no-let\n    // let y = start.y;\n    // switch (bounds) {\n    //   case `wrap`: {\n    //     x += vector.x % grid.cols;\n    //     y += vector.y % grid.rows;\n    //     if (x < 0) x = grid.cols + x;\n    //     else if (x >= grid.cols) {\n    //       x -= grid.cols;\n    //     }\n    //     if (y < 0) y = grid.rows + y;\n    //     else if (y >= grid.rows) {\n    //       y -= grid.rows;\n    //     }\n    //     break;\n    //   }\n    //   case `stop`: {\n    //     x += vector.x;\n    //     y += vector.y;\n    //     x = clampIndex(x, grid.cols);\n    //     y = clampIndex(y, grid.rows);\n    //     break;\n    //   }\n    //   case `undefined`: {\n    //     x += vector.x;\n    //     y += vector.y;\n    //     if (x < 0 || y < 0) return;\n    //     if (x >= grid.cols || y >= grid.rows) return;\n    //     break;\n    //   }\n    //   case `unbounded`: {\n    //     x += vector.x;\n    //     y += vector.y;\n    //     break;\n    //   }\n    //   default: {\n    //     // eslint-disable-next-line @typescript-eslint/restrict-template-expressions\n    //     throw new Error(`Unknown BoundsLogic case ${ bounds }`);\n    //   }\n    // }\n    // return Object.freeze({ x, y });\n};\n","import { zipKeyValue } from \"@ixfx/core/maps\";\nimport { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { guardCell, guardGrid } from \"./guards.js\";\nimport { offset } from \"./offset.js\";\n/**\n * Returns a list of all cardinal directions: n, ne, nw, e, s, se, sw, w\n */\nexport const allDirections = Object.freeze([\n    `n`,\n    `ne`,\n    `nw`,\n    `e`,\n    `s`,\n    `se`,\n    `sw`,\n    `w`,\n]);\n/**\n * Returns a list of + shaped directions: n, e, s, w\n */\nexport const crossDirections = Object.freeze([\n    `n`,\n    `e`,\n    `s`,\n    `w`,\n]);\n/**\n * Returns cells that correspond to the cardinal directions at a specified distance\n * i.e. it projects a line from `start` cell in all cardinal directions and returns the cells at `steps` distance.\n * @param grid Grid\n * @param steps Distance\n * @param start Start poiint\n * @param bounds Logic for if bounds of grid are exceeded\n * @returns Cells corresponding to cardinals\n */\nexport const offsetCardinals = (grid, start, steps, bounds = `stop`) => {\n    guardGrid(grid, `grid`);\n    guardCell(start, `start`);\n    resultThrow(integerTest(steps, `aboveZero`, `steps`));\n    const directions = allDirections;\n    const vectors = directions.map((d) => getVectorFromCardinal(d, steps));\n    const cells = directions.map((d, index) => offset(grid, start, vectors[index], bounds));\n    return zipKeyValue(directions, cells);\n};\n/**\n * Returns an `{ x, y }` signed vector corresponding to the provided cardinal direction.\n * ```js\n * const n = getVectorFromCardinal(`n`); // {x: 0, y: -1}\n * ```\n *\n * Optional `multiplier` can be applied to vector\n * ```js\n * const n = getVectorFromCardinal(`n`, 10); // {x: 0, y: -10}\n * ```\n *\n * Blank direction returns `{ x: 0, y: 0 }`\n * @param cardinal Direction\n * @param multiplier Multipler\n * @returns Signed vector in the form of `{ x, y }`\n */\nexport const getVectorFromCardinal = (cardinal, multiplier = 1) => {\n    let v;\n    switch (cardinal) {\n        case `n`: {\n            v = { x: 0, y: -1 * multiplier };\n            break;\n        }\n        case `ne`: {\n            v = { x: 1 * multiplier, y: -1 * multiplier };\n            break;\n        }\n        case `e`: {\n            v = { x: 1 * multiplier, y: 0 };\n            break;\n        }\n        case `se`: {\n            v = { x: 1 * multiplier, y: 1 * multiplier };\n            break;\n        }\n        case `s`: {\n            v = { x: 0, y: 1 * multiplier };\n            break;\n        }\n        case `sw`: {\n            v = { x: -1 * multiplier, y: 1 * multiplier };\n            break;\n        }\n        case `w`: {\n            v = { x: -1 * multiplier, y: 0 };\n            break;\n        }\n        case `nw`: {\n            v = { x: -1 * multiplier, y: -1 * multiplier };\n            break;\n        }\n        default: {\n            v = { x: 0, y: 0 };\n        }\n    }\n    return Object.freeze(v);\n};\n","//import type { Cell, GridReadable } from '../Types.js';\nexport * from './cells.js';\n// export function* withValues<T>(grid: GridReadable<T>, iter: IterableIterator<Cell>) {\n//   for (const cell of iter) {\n//     yield { cell, value: grid.get(cell, `undefined`) };\n//   }\n// }\n","import { guardCell } from \"./guards.js\";\n/**\n * Returns the cells on the line of `start` and `end`, inclusive\n *\n * ```js\n * // Get cells that connect 0,0 and 10,10\n * const cells = Grids.getLine({x:0,y:0}, {x:10,y:10});\n * ```\n *\n * This function does not handle wrapped coordinates.\n * @param start Starting cell\n * @param end End cell\n * @returns\n */\nexport const getLine = (start, end) => {\n    // https://stackoverflow.com/a/4672319\n    guardCell(start);\n    guardCell(end);\n    let startX = start.x;\n    let startY = start.y;\n    const dx = Math.abs(end.x - startX);\n    const dy = Math.abs(end.y - startY);\n    const sx = startX < end.x ? 1 : -1;\n    const sy = startY < end.y ? 1 : -1;\n    let error = dx - dy;\n    const cells = [];\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n        cells.push(Object.freeze({ x: startX, y: startY }));\n        if (startX === end.x && startY === end.y)\n            break;\n        const error2 = 2 * error;\n        if (error2 > -dy) {\n            error -= dy;\n            startX += sx;\n        }\n        if (error2 < dx) {\n            error += dx;\n            startY += sy;\n        }\n    }\n    return cells;\n};\n/**\n * Returns a list of cells from `start` to `end`.\n *\n * Throws an error if start and end are not on same row or column.\n *\n * @param start Start cell\n * @param end end clel\n * @param endInclusive\n * @return Array of cells\n */\nexport const simpleLine = function (start, end, endInclusive = false) {\n    const cells = [];\n    if (start.x === end.x) {\n        // Vertical\n        const lastY = endInclusive ? end.y + 1 : end.y;\n        for (let y = start.y; y < lastY; y++) {\n            cells.push({ x: start.x, y: y });\n        }\n    }\n    else if (start.y === end.y) {\n        // Horizontal\n        const lastX = endInclusive ? end.x + 1 : end.x;\n        for (let x = start.x; x < lastX; x++) {\n            cells.push({ x: x, y: start.y });\n        }\n    }\n    else {\n        throw new Error(`Only does vertical and horizontal: ${start.x},${start.y} - ${end.x},${end.y}`);\n    }\n    return cells;\n};\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { guardGrid } from \"./guards.js\";\nimport { offset } from \"./offset.js\";\n/**\n * Returns the index for a given cell.\n * This is useful if a grid is stored in an array.\n *\n * ```js\n * const data = [\n *  1, 2,\n *  3, 4,\n *  5, 6 ];\n * const cols = 2; // Grid of 2 columns wide\n * const index = indexFromCell(cols, {x: 1, y: 1});\n * // Yields an index of 3\n * console.log(data[index]); // Yields 4\n * ```\n *\n * Bounds logic is applied to cell.x/y separately. Wrapping\n * only ever happens in same col/row.\n * @see cellFromIndex\n * @param grid Grid\n * @param cell Cell to get index for\n * @param wrap Logic for if we hit bounds of grid\n * @returns\n */\nexport const indexFromCell = (grid, cell, wrap) => {\n    guardGrid(grid, `grid`);\n    if (cell.x < 0) {\n        switch (wrap) {\n            case `stop`: {\n                cell = { ...cell, x: 0 };\n                break;\n            }\n            case `unbounded`: {\n                throw new Error(`unbounded not supported`);\n            }\n            case `undefined`: {\n                return undefined;\n            }\n            case `wrap`: {\n                //cell = { ...cell, x: grid.cols + cell.x };\n                cell = offset(grid, { x: 0, y: cell.y }, { x: cell.x, y: 0 }, `wrap`);\n                break;\n            }\n        }\n    }\n    if (cell.y < 0) {\n        switch (wrap) {\n            case `stop`: {\n                cell = { ...cell, y: 0 };\n                break;\n            }\n            case `unbounded`: {\n                throw new Error(`unbounded not supported`);\n            }\n            case `undefined`: {\n                return undefined;\n            }\n            case `wrap`: {\n                cell = { ...cell, y: grid.rows + cell.y };\n                break;\n            }\n        }\n    }\n    if (cell.x >= grid.cols) {\n        switch (wrap) {\n            case `stop`: {\n                cell = { ...cell, x: grid.cols - 1 };\n                break;\n            }\n            case `unbounded`: {\n                throw new Error(`unbounded not supported`);\n            }\n            case `undefined`: {\n                return undefined;\n            }\n            case `wrap`: {\n                cell = { ...cell, x: cell.x % grid.cols };\n                break;\n            }\n        }\n    }\n    if (cell.y >= grid.rows) {\n        switch (wrap) {\n            case `stop`: {\n                cell = { ...cell, y: grid.rows - 1 };\n                break;\n            }\n            case `unbounded`: {\n                throw new Error(`unbounded not supported`);\n            }\n            case `undefined`: {\n                return undefined;\n            }\n            case `wrap`: {\n                cell = { ...cell, y: cell.y % grid.rows };\n                break;\n            }\n        }\n    }\n    const index = cell.y * grid.cols + cell.x;\n    return index;\n};\n/**\n * Returns x,y from an array index.\n *\n * ```js\n *  const data = [\n *   1, 2,\n *   3, 4,\n *   5, 6 ];\n *\n * // Cols of 2, index 2 (ie. data[2] == 3)\n * const cell = cellFromIndex(2, 2);\n * // Yields: {x: 0, y: 1}\n * ```\n * @see indexFromCell\n * @param colsOrGrid\n * @param index\n * @returns\n */\nexport const cellFromIndex = (colsOrGrid, index) => {\n    let cols = 0;\n    cols = typeof colsOrGrid === `number` ? colsOrGrid : colsOrGrid.cols;\n    resultThrow(integerTest(cols, `aboveZero`, `colsOrGrid`));\n    return {\n        x: index % cols,\n        y: Math.floor(index / cols),\n    };\n};\n","/**\n * Returns _true_ if grids `a` and `b` are equal in value.\n * Returns _false_ if either parameter is undefined.\n *\n * @param a\n * @param b\n * @return\n */\nexport const isEqual = (a, b) => {\n    if (b === undefined)\n        return false;\n    if (a === undefined)\n        return false;\n    if (`rows` in a && `cols` in a) {\n        if (`rows` in b && `cols` in b) {\n            if (a.rows !== b.rows || a.cols !== b.cols)\n                return false;\n        }\n        else\n            return false;\n    }\n    if (`size` in a) {\n        if (`size` in b) {\n            if (a.size !== b.size)\n                return false;\n        }\n        else\n            return false;\n    }\n    return true;\n};\n/**\n * Returns _true_ if two cells equal.\n * Returns _false_ if either cell are undefined\n *\n * @param a\n * @param b\n * @returns\n */\nexport const cellEquals = (a, b) => {\n    if (b === undefined)\n        return false;\n    if (a === undefined)\n        return false;\n    return a.x === b.x && a.y === b.y;\n};\n","import { zipKeyValue } from \"@ixfx/core/maps\";\nimport { allDirections, getVectorFromCardinal } from \"./directions.js\";\nimport { randomElement } from \"@ixfx/random\";\nimport { offset } from \"./offset.js\";\nexport const randomNeighbour = (nbos) => randomElement(nbos); // .filter(isNeighbour));\n/**\n * Returns _true_ if `n` is a Neighbour type, eliminating NeighbourMaybe possibility\n *\n * @param n\n * @return\n */\nconst isNeighbour = (n) => {\n    if (n === undefined)\n        return false;\n    if (n[1] === undefined)\n        return false;\n    return true;\n};\n/**\n * Gets a list of neighbours for `cell` (using {@link neighbours}), filtering\n * results to only those that are valid neighbours (using {@link isNeighbour})\n *\n * ```js\n * // Get all eight surrounding cells\n * const n = Grids.neighbourList(grid, cell, Grids.allDirections);\n *\n * // Get north, east, south, west cells\n * const n = Grids.neighbourList(grid, cell, Grids.crossDirections);\n * ```\n * @param grid Grid\n * @param cell Cell\n * @param directions Directions\n * @param bounds Bounds\n * @returns\n */\nexport const neighbourList = (grid, cell, directions, bounds) => {\n    // Get neighbours for cell\n    const cellNeighbours = neighbours(grid, cell, bounds, directions);\n    // Filter out undefined cells\n    const entries = Object.entries(cellNeighbours);\n    return entries.filter(n => isNeighbour(n));\n};\n/**\n * Returns neighbours for a cell. If no `directions` are provided, it defaults to {@link allDirections}.\n *\n * ```js\n * const grid = { rows: 5, cols: 5 };\n * const cell = { x:2, y:2 };\n *\n * // Get n,ne,nw,e,s,se,sw and w neighbours\n * const n = Grids.neighbours(grid, cell, `wrap`);\n *\n * Yields:\n * {\n *  n: {x: 2, y: 1}\n *  s: {x: 2, y: 3}\n *  ....\n * }\n * ```\n *\n * Returns neighbours without diagonals (ie: n, e, s, w):\n * ```js\n * const n = Grids.neighbours(grid, cell, `stop`, Grids.crossDirections);\n * ```\n * @returns Returns a map of cells, keyed by cardinal direction\n * @param grid Grid\n * @param cell Cell\n * @param bounds How to handle edges of grid\n * @param directions Directions to return\n */\nexport const neighbours = (grid, cell, bounds = `undefined`, directions) => {\n    const directories = directions ?? allDirections;\n    const points = directories.map((c) => offset(grid, cell, getVectorFromCardinal(c), bounds));\n    return zipKeyValue(directories, points);\n};\n","/**\n * Returns a two-dimensional array according to `grid`\n * size.\n *\n * ```js\n * const a = Grids.toArray({ rows: 3, cols: 2 });\n * Yields:\n * [ [_,_] ]\n * [ [_,_] ]\n * [ [_,_] ]\n * ```\n *\n * `initialValue` can be provided to set the value\n * for all cells.\n * @param grid Grid\n * @param initialValue Initial value\n * @returns\n */\nexport const toArray2d = (grid, initialValue) => {\n    const returnValue = [];\n    for (let row = 0; row < grid.rows; row++) {\n        returnValue[row] = Array.from({ length: grid.cols });\n        if (initialValue) {\n            for (let col = 0; col < grid.cols; col++) {\n                returnValue[row][col] = initialValue;\n            }\n        }\n    }\n    return returnValue;\n};\n","/**\n * Returns a key string for a cell instance\n * A key string allows comparison of instances by value rather than reference\n *\n * ```js\n * cellKeyString({x:10,y:20});\n * // Yields: \"Cell{10,20}\";\n * ```\n * @param v\n * @returns\n */\nexport const cellKeyString = (v) => `Cell{${v.x},${v.y}}`;\n","import { guardCell } from \"./guards.js\";\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/from-top-left.js';\nimport { integerTest, numberTest, resultThrow } from '@ixfx/guards';\nimport { cells } from \"./enumerators/cells.js\";\n/**\n * Generator that returns rectangles for each cell in a grid\n *\n * @example Draw rectangles\n * ```js\n * import { Drawing } from 'visuals.js'\n * const rects = [...Grids.asRectangles(grid)];\n * Drawing.rect(ctx, rects, { strokeStyle: `silver`});\n * ```\n * @param grid\n */\nexport function* asRectangles(grid) {\n    for (const c of cells(grid)) {\n        yield rectangleForCell(grid, c);\n    }\n}\n/**\n * Returns the cell at a specified visual coordinate\n * or _undefined_ if the position is outside of the grid.\n *\n * `position` must be in same coordinate/scale as the grid.\n *\n * @param position Position, eg in pixels\n * @param grid Grid\n * @return Cell at position or undefined if outside of the grid\n */\nexport const cellAtPoint = (grid, position) => {\n    const size = grid.size;\n    resultThrow(numberTest(size, `positive`, `grid.size`));\n    if (position.x < 0 || position.y < 0)\n        return;\n    const x = Math.floor(position.x / size);\n    const y = Math.floor(position.y / size);\n    if (x >= grid.cols)\n        return;\n    if (y >= grid.rows)\n        return;\n    return { x, y };\n};\n/**\n * Returns a visual rectangle of the cell, positioned from the top-left corner\n *\n * ```js\n * const cell = { x: 1, y: 0 };\n *\n * // 5x5 grid, each cell 5px in size\n * const grid = { rows: 5, cols: 5, size: 5 }\n *\n * const r = rectangleForCell(grid, cell,);\n *\n * // Yields: { x: 5, y: 0, width: 5, height: 5 }\n * ```\n * @param cell\n * @param grid\n * @return\n */\nexport const rectangleForCell = (grid, cell) => {\n    guardCell(cell);\n    const size = grid.size;\n    const x = cell.x * size;\n    const y = cell.y * size;\n    const r = RectsFromTopLeft({ x: x, y: y }, size, size);\n    return r;\n};\n/**\n * Returns the visual midpoint of a cell (eg. pixel coordinate)\n *\n * @param cell\n * @param grid\n * @return\n */\nexport const cellMiddle = (grid, cell) => {\n    guardCell(cell);\n    const size = grid.size;\n    const x = cell.x * size; // + (grid.spacing ? cell.x * grid.spacing : 0);\n    const y = cell.y * size; // + (grid.spacing ? cell.y * grid.spacing : 0);\n    return Object.freeze({ x: x + size / 2, y: y + size / 2 });\n};\n","//import { visitor } from \"./Visitor.js\";\n// export const visitorBreadth = (\n//   grid: Grid,\n//   start: Cell,\n//   opts: VisitorOpts = {}\n// ) =>\n//   visitor(\n//     {\n//       select: (nbos) => nbos[ 0 ],\n//     },\n//     grid,\n//     start,\n//     opts\n//   );\nexport const breadthLogic = () => {\n    return {\n        select: (nbos) => nbos[0],\n    };\n};\n","import { allDirections } from \"../directions.js\";\nimport { neighbourList } from \"../neighbour.js\";\n// export function* cellNeigbours(\n//   grid: Grid,\n//   cell: Cell,\n//   bounds: BoundsLogic = `undefined`,\n//   directions?: ReadonlyArray<CardinalDirection>\n// ) {\n//   const dirs = directions ?? allDirections;\n//   const points = dirs.map((c) =>\n//     offset(grid, cell, getVectorFromCardinal(c), bounds)\n//   );\n//   for (const pt of points) {\n//     if (pt !== undefined) yield pt;\n//   }\n// }\nexport const neighboursLogic = () => {\n    return {\n        select: (neighbours) => {\n            return neighbours.at(0);\n        },\n        getNeighbours: (grid, cell) => {\n            return neighbourList(grid, cell, allDirections, `undefined`);\n        }\n    };\n};\n","/**\n * Visits cells running down columns, left-to-right.\n * @param opts Options\n * @returns Visitor generator\n */\nexport const columnLogic = (opts = {}) => {\n    const reversed = opts.reversed ?? false;\n    return {\n        select: (nbos) => nbos.find((n) => n[0] === (reversed ? `n` : `s`)),\n        getNeighbours: (grid, cell) => {\n            if (reversed) {\n                // WALK UP COLUMN, RIGHT-TO-LEFT\n                if (cell.y > 0) {\n                    // Easy case\n                    cell = { x: cell.x, y: cell.y - 1 };\n                }\n                else {\n                    // Top of column\n                    if (cell.x === 0) {\n                        // Top-left corner, need to wrap\n                        cell = { x: grid.cols - 1, y: grid.rows - 1 };\n                    }\n                    else {\n                        cell = { x: cell.x - 1, y: grid.rows - 1 };\n                    }\n                }\n            }\n            else {\n                // WALK DOWN COLUMNS, LEFT-TO-RIGHT\n                if (cell.y < grid.rows - 1) {\n                    // Easy case, move down by one\n                    cell = { x: cell.x, y: cell.y + 1 };\n                }\n                else {\n                    // End of column\n                    if (cell.x < grid.cols - 1) {\n                        // Move to next column and start at top\n                        cell = { x: cell.x + 1, y: 0 };\n                    }\n                    else {\n                        // Move to start of grid\n                        cell = { x: 0, y: 0 };\n                    }\n                }\n            }\n            return [[reversed ? `n` : `s`, cell]];\n        }\n    };\n};\n","// export const visitorDepth = (grid: Grid, start: Cell, opts: VisitorOpts = {}) =>\n//   visitor(\n//     {\n//       select: (nbos) => nbos.at(-1),\n//     },\n//     grid,\n//     start,\n//     opts\n//   );\nexport const depthLogic = () => {\n    return {\n        select: (nbos) => nbos.at(-1)\n    };\n};\n","import { randomNeighbour } from \"../neighbour.js\";\nimport { cells } from \"../enumerators/cells.js\";\n// export const visitorRandom = (\n//   grid: Grid,\n//   start: Cell,\n//   opts: VisitorOpts = {}\n// ) =>\n//   visitor(\n//     ,\n//     grid,\n//     start,\n//     opts\n//   );\nexport const randomLogic = () => {\n    return {\n        getNeighbours: (grid, cell) => {\n            const t = [];\n            for (const c of cells(grid, cell)) {\n                t.push([`n`, c]);\n            }\n            return t;\n        },\n        select: randomNeighbour,\n    };\n};\n","import { randomNeighbour } from \"../neighbour.js\";\n// export const visitorRandomContiguous = (\n//   grid: Grid,\n//   start: Cell,\n//   opts: VisitorOpts = {}\n// ) =>\n//   visitor(\n//     ,\n//     grid,\n//     start,\n//     opts\n//   );\nexport const randomContiguousLogic = () => {\n    return {\n        select: randomNeighbour,\n    };\n};\n","/**\n* Visit by following rows. Normal order is left-to-right, top-to-bottom.\n* @param opts Options\n* @returns\n*/\nexport const rowLogic = (opts = {}) => {\n    const reversed = opts.reversed ?? false;\n    return {\n        select: (nbos) => nbos.find((n) => n[0] === (reversed ? `w` : `e`)),\n        getNeighbours: (grid, cell) => {\n            if (reversed) {\n                // WALKING BACKWARD ALONG ROW\n                if (cell.x > 0) {\n                    // All fine, step to the left\n                    cell = { x: cell.x - 1, y: cell.y };\n                }\n                else {\n                    // At the beginning of a row\n                    if (cell.y > 0) {\n                        // Wrap to next row up\n                        cell = { x: grid.cols - 1, y: cell.y - 1 };\n                    }\n                    else {\n                        // Wrap to end of grid\n                        cell = { x: grid.cols - 1, y: grid.rows - 1 };\n                    }\n                }\n            }\n            else {\n                /*\n                 * WALKING FORWARD ALONG ROWS\n                 */\n                if (cell.x < grid.rows - 1) {\n                    // All fine, step to the right\n                    cell = { x: cell.x + 1, y: cell.y };\n                }\n                else {\n                    // At the end of a row\n                    // eslint-disable-next-line unicorn/prefer-ternary\n                    if (cell.y < grid.rows - 1) {\n                        // More rows available, wrap to next row down\n                        cell = { x: 0, y: cell.y + 1 };\n                    }\n                    else {\n                        // No more rows available, wrap to start of the grid\n                        cell = { x: 0, y: 0 };\n                    }\n                }\n            }\n            return [[reversed ? `w` : `e`, cell]];\n        }\n    };\n};\n","import { mutable } from '@ixfx/collections/set';\nimport { crossDirections } from \"../directions.js\";\nimport { guardGrid, guardCell, isCell } from \"../guards.js\";\nimport { cellEquals } from \"../is-equal.js\";\nimport { neighbourList } from '../neighbour.js';\nimport { cellKeyString } from \"../to-string.js\";\n/**\n * Visits every cell in grid using supplied selection function\n * In-built functions to use: visitorDepth, visitorBreadth, visitorRandom,\n * visitorColumn, visitorRow.\n *\n * Usage example:\n * ```js\n *  let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell);\n *  for (let cell of visitor) {\n *   // do something with cell\n *  }\n * ```\n *\n * If you want to keep tabs on the visitor, pass in a {@link Collections.Sets.ISetMutable} instance. This gets\n * updated as cells are visited to make sure we don't visit the same one twice. If a set is not passed\n * in, one will be created internally.\n * ```js\n * let visited = new SetStringMutable<Grids.Cell>(c => Grids.cellKeyString(c));\n * let visitor = Grids.visitor(Grids.visitorRandom, grid, startCell, visited);\n * ```\n *\n * To visit with some delay, try this pattern\n * ```js\n *  const delayMs = 100;\n *  const run = () => {\n *   let cell = visitor.next().value;\n *   if (cell === undefined) return;\n *   // Do something with cell\n *   setTimeout(run, delayMs);\n *  }\n *  setTimeout(run, delayMs);\n * ```\n * @param logic Logic for selecting next cell\n * @param grid Grid to visitl\n * @param opts Options\n * @returns Cells\n */\nexport function* visitByNeighbours(logic, grid, opts = {}) {\n    guardGrid(grid, `grid`);\n    const start = opts.start ?? { x: 0, y: 0 };\n    guardCell(start, `opts.start`, grid);\n    const v = opts.visited ?? mutable(cellKeyString);\n    const possibleNeighbours = logic.getNeighbours ?? ((g, c) => neighbourList(g, c, crossDirections, `undefined`));\n    let cellQueue = [start];\n    let moveQueue = [];\n    let current = undefined;\n    while (cellQueue.length > 0) {\n        if (current === undefined) {\n            const nv = cellQueue.pop();\n            if (nv === undefined) {\n                break;\n            }\n            current = nv;\n        }\n        if (!v.has(current)) {\n            v.add(current);\n            yield current;\n            const nextSteps = possibleNeighbours(grid, current).filter((step) => {\n                if (step[1] === undefined)\n                    return false;\n                return !v.has(step[1]);\n            });\n            if (nextSteps.length === 0) {\n                // No more moves for this cell\n                if (current !== undefined) {\n                    cellQueue = cellQueue.filter((cq) => cellEquals(cq, current));\n                }\n            }\n            else {\n                for (const n of nextSteps) {\n                    if (n === undefined)\n                        continue;\n                    if (n[1] === undefined)\n                        continue;\n                    moveQueue.push(n);\n                }\n            }\n        }\n        // Remove steps already made\n        moveQueue = moveQueue.filter((step) => !v.has(step[1]));\n        if (moveQueue.length === 0) {\n            current = undefined;\n        }\n        else {\n            // Pick move\n            const potential = logic.select(moveQueue);\n            if (potential !== undefined) {\n                cellQueue.push(potential[1]);\n                current = potential[1];\n            }\n        }\n    }\n}\n;\n","import { integerTest, resultThrow } from \"@ixfx/guards\";\nimport { guardCell, guardGrid } from \"../guards.js\";\n/**\n * Runs the provided `visitor` for `steps`, returning the cell we end at\n * ```js\n * // Create visitor & stepper\n * const visitor = Grids.Visit.create(`row`);\n * const stepper = Grids.Visit.stepper(grid, visitor);\n *\n * // Step by 10\n * stepper(10); // GridCell {x,y}\n *\n * // Step by another 2\n * stepper(2);\n * ```\n * @param grid Grid to traverse\n * @param start Start point\n * @param createVisitor Visitor function\n * @returns\n */\nexport const stepper = (grid, createVisitor, start = { x: 0, y: 0 }, resolution = 1) => {\n    guardGrid(grid, `grid`);\n    guardCell(start, `start`);\n    resultThrow(integerTest(resolution, ``, `resolution`));\n    // Create a list of steps\n    const steps = [];\n    let count = 0;\n    let position = 0;\n    for (const c of createVisitor(grid, { start, boundsWrap: `undefined` })) {\n        count++;\n        if ((count % resolution) !== 0)\n            continue;\n        steps.push(c);\n    }\n    return (step, fromStart = false) => {\n        resultThrow(integerTest(step, ``, `step`));\n        if (fromStart)\n            position = step;\n        else\n            position += step;\n        //position = position % steps.length;\n        return steps.at(position % steps.length);\n    };\n};\n// export const step = (\n//   grid: Grid,\n//   start: Cell,\n//   steps: number,\n//   createVisitor: CreateVisitor\n// ): Cell => {\n//   throwIntegerTest(steps, ``, `steps`);\n//   const opts: Partial<VisitorOpts> = {\n//     reversed: steps < 0,\n//     start\n//   };\n//   steps = Math.abs(steps);\n//   let c = start;\n//   let v = createVisitor(grid, opts);\n//   v.next(); // Burn up starting cell\n//   let stepsMade = 0;\n//   while (stepsMade < steps) {\n//     stepsMade++;\n//     const { value } = v.next();\n//     if (value) {\n//       c = value;\n//       if (opts.debug) {\n//         console.log(\n//           `stepsMade: ${ stepsMade } cell: ${ c.x }, ${ c.y } reverse: ${ opts.reversed }`\n//         );\n//       }\n//     } else {\n//       if (steps >= grid.cols * grid.rows) {\n//         steps -= grid.cols * grid.rows;\n//         stepsMade = 0;\n//         v = createVisitor(grid, opts);\n//         v.next();\n//         c = start;\n//         if (opts.debug) console.log(`resetting visitor to ${ steps }`);\n//       } else throw new Error(`Value not received by visitor`);\n//     }\n//   }\n//   return c;\n// };\n","import { breadthLogic } from './breadth.js';\nimport { neighboursLogic } from './cell-neighbours.js';\nimport { columnLogic } from './columns.js';\nimport { depthLogic } from './depth.js';\nimport { randomLogic } from './random.js';\nimport { randomContiguousLogic } from './random-contiguous.js';\nimport { rowLogic } from './rows.js';\nimport { visitByNeighbours } from './visitor.js';\nexport * from './breadth.js';\nexport * from './cell-neighbours.js';\nexport * from './columns.js';\nexport * from './depth.js';\nexport * from './step.js';\nexport * from './random.js';\nexport * from './random-contiguous.js';\nexport * from './rows.js';\nexport * from './visitor.js';\n/**\n * Logic types:\n * * 'row': left-to-right, top-to-bottom\n * * 'column': top-to-bottom, left-to-right\n * * 'neighbours': neighbours surrounding cell (eight)\n * * 'breadth`: breadth-first\n * * 'depth': depth-first\n * * 'random': any random cell in grid\n * * 'random-contiguous': any random cell neighbouring an already visited cell\n * @param type\n * @param opts\n * @returns\n */\nexport const create = (type, opts = {}) => {\n    switch (type) {\n        case `random-contiguous`:\n            return withLogic(randomContiguousLogic(), opts);\n        case `random`:\n            return withLogic(randomLogic(), opts);\n        case `depth`:\n            return withLogic(depthLogic(), opts);\n        case `breadth`:\n            return withLogic(breadthLogic(), opts);\n        case `neighbours`:\n            return withLogic(neighboursLogic(), opts);\n        case `row`:\n            return withLogic(rowLogic(opts), opts);\n        case `column`:\n            return withLogic(columnLogic(opts), opts);\n        default:\n            throw new TypeError(`Param 'type' unknown. Value: ${type}`);\n    }\n};\nexport const withLogic = (logic, options = {}) => {\n    return (grid, optionsOverride = {}) => {\n        return visitByNeighbours(logic, grid, { ...options, ...optionsOverride });\n    };\n};\nfunction isIterator(v) {\n    if (typeof v !== `object`)\n        return false;\n    if (!(`next` in v))\n        return false;\n    if (!(`throw` in v))\n        return false;\n    if (!(`return` in v))\n        return false;\n    return true;\n}\n// export function* withValues<T>(createOrIter: CreateVisitor | Generator<Cell>, grid: GridReadable<T>, opts: Partial<VisitorOpts>) {\n//   const iter = isIterator(createOrIter) ? createOrIter : createOrIter(grid, opts)();\n//   for (const cell of iter) {\n//     yield { cell, value: grid.accessor(cell, `undefined`) }\n//   }\n// }\n// export const byCells = (grid: Grid, options: Partial<VisitorOpts> = {}) => {\n//   return (logic: NeighbourSelectionLogic, optionsOverride: Partial<VisitorOpts> = {}) => {\n//     return visitByNeighbours(logic, grid, { ...options, ...optionsOverride });\n//   }\n// }\n// export const byCellsLeftToRightTopToBottom = ():CreateVisitor => {\n//   return (grid) => {\n//     return cells(grid)\n//   }\n// }\n","export * from './apply-bounds.js';\nexport * as Array1d from './array-1d.js';\nexport * as Array2d from './array-2d.js';\n/**\n * Iterates over slices of the grid (eg a whole row, a whole column)\n */\nexport * as As from './as.js';\nexport * from './directions.js';\nexport * as By from './enumerators/index.js';\nexport * from './geometry.js';\nexport * from './guards.js';\nexport * from './indexing.js';\nexport * from './inside.js';\nexport * from './is-equal.js';\nexport * from './neighbour.js';\nexport * from './offset.js';\nexport * from './to-array.js';\nexport * from './to-string.js';\nexport * from './visual.js';\nexport * from './values.js';\nexport * as Visit from './visitors/index.js';\n","import { Bezier as BezierLibrary } from 'bezier-js';\nimport { interpolate as LinesInterpolate } from '../line/interpolate.js';\nimport { fromTopLeft as RectsFromTopLeft } from '../rect/from-top-left.js';\nimport { isCubicBezier, isQuadraticBezier } from './guard.js';\nimport { to2d } from '../point/To.js';\nexport * from './bezier-type.js';\nexport * from './guard.js';\n/**\n * Returns a new quadratic bezier with specified bend amount\n *\n * @param {QuadraticBezier} b Curve\n * @param {number} [bend=0] Bend amount, from -1 to 1\n * @returns {QuadraticBezier}\n */\n// export const quadraticBend = (a: Point, b: Point, bend = 0): QuadraticBezier => quadraticSimple(a, b, bend);\n/**\n * Creates a simple quadratic bezier with a specified amount of 'bend'.\n * Bend of -1 will pull curve down, 1 will pull curve up. 0 is no curve.\n *\n * Use {@link interpolator} to calculate a point along the curve.\n * @param {Point} start Start of curve\n * @param {Point} end End of curve\n * @param {number} [bend=0] Bend amount, -1 to 1\n * @returns {QuadraticBezier}\n */\nexport const quadraticSimple = (start, end, bend = 0) => {\n    if (Number.isNaN(bend))\n        throw new Error(`bend is NaN`);\n    if (bend < -1 || bend > 1)\n        throw new Error(`Expects bend range of -1 to 1`);\n    const middle = LinesInterpolate(0.5, start, end);\n    let target = middle;\n    if (end.y < start.y) {\n        // Upward slope\n        target = bend > 0 ? { x: Math.min(start.x, end.x), y: Math.min(start.y, end.y) } :\n            { x: Math.max(start.x, end.x), y: Math.max(start.y, end.y) };\n    }\n    else {\n        // Downward slope\n        target = bend > 0 ? { x: Math.max(start.x, end.x), y: Math.min(start.y, end.y) } :\n            { x: Math.min(start.x, end.x), y: Math.max(start.y, end.y) };\n    }\n    const handle = LinesInterpolate(Math.abs(bend), middle, target);\n    return quadratic(start, end, handle);\n};\n/**\n * Returns a relative point on a simple quadratic\n * @param start Start\n * @param end  End\n * @param bend Bend (-1 to 1)\n * @param amt Amount\n * @returns Point\n */\n// export const computeQuadraticSimple = (start: Point, end: Point, bend: number, amt: number): Point => {\n//   const q = quadraticSimple(start, end, bend);\n//   const bzr = new BezierLibrary(q.a, q.quadratic, q.b);\n//   return bzr.compute(amt);\n// };\n/**\n * Interpolate cubic or quadratic bezier\n * ```js\n * const i = interpolator(myBezier);\n *\n * // Get point at 50%\n * i(0.5); // { x, y }\n * ```\n * @param q\n * @returns\n */\nexport const interpolator = (q) => {\n    //console.log(q);\n    //if (isCubicBezier(q)) console.log(`is cubic`);\n    //const bzr = isCubicBezier(q) ? new BezierLibrary(to2d(q.a), to2d(q.cubic1), to2d(q.cubic2), to2d(q.b)) : new BezierLibrary(q.a, q.quadratic, q.b);\n    const bzr = isCubicBezier(q) ?\n        new BezierLibrary(q.a.x, q.a.y, q.cubic1.x, q.cubic1.y, q.cubic2.x, q.cubic2.y, q.b.x, q.b.y) :\n        new BezierLibrary(q.a, q.quadratic, q.b);\n    return (amount) => bzr.compute(amount);\n};\n//https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\nexport const quadraticToSvgString = (start, end, handle) => [`M ${start.x} ${start.y} Q ${handle.x} ${handle.y} ${end.x} ${end.y}`];\nexport const toPath = (cubicOrQuadratic) => {\n    if (isCubicBezier(cubicOrQuadratic)) {\n        return cubicToPath(cubicOrQuadratic);\n    }\n    else if (isQuadraticBezier(cubicOrQuadratic)) {\n        return quadratictoPath(cubicOrQuadratic);\n    }\n    else {\n        throw new Error(`Unknown bezier type`);\n    }\n};\nexport const cubic = (start, end, cubic1, cubic2) => ({\n    a: Object.freeze(start),\n    b: Object.freeze(end),\n    cubic1: Object.freeze(cubic1),\n    cubic2: Object.freeze(cubic2)\n});\nconst cubicToPath = (cubic) => {\n    const { a, cubic1, cubic2, b } = cubic;\n    const bzr = new BezierLibrary(a, cubic1, cubic2, b);\n    return Object.freeze({\n        ...cubic,\n        length: () => bzr.length(),\n        interpolate: (t) => bzr.compute(t),\n        nearest: (_) => { throw new Error(`not implemented`); },\n        bbox: () => {\n            const { x, y } = bzr.bbox();\n            const xSize = x.size;\n            const ySize = y.size;\n            if (xSize === undefined)\n                throw new Error(`x.size not present on calculated bbox`);\n            if (ySize === undefined)\n                throw new Error(`x.size not present on calculated bbox`);\n            return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n        },\n        relativePosition: (_point, _intersectionThreshold) => {\n            throw new Error(`Not implemented`);\n        },\n        distanceToPoint: (_point) => {\n            throw new Error(`Not implemented`);\n        },\n        toSvgString: () => [`brrup`],\n        kind: `bezier/cubic`\n    });\n};\nexport const quadratic = (start, end, handle) => ({\n    a: Object.freeze(start),\n    b: Object.freeze(end),\n    quadratic: Object.freeze(handle)\n});\nconst quadratictoPath = (quadraticBezier) => {\n    const { a, b, quadratic } = quadraticBezier;\n    const bzr = new BezierLibrary(a, quadratic, b);\n    return Object.freeze({\n        ...quadraticBezier,\n        length: () => bzr.length(),\n        interpolate: (t) => bzr.compute(t),\n        nearest: (_) => { throw new Error(`not implemented`); },\n        bbox: () => {\n            const { x, y } = bzr.bbox();\n            const xSize = x.size;\n            const ySize = y.size;\n            if (xSize === undefined)\n                throw new Error(`x.size not present on calculated bbox`);\n            if (ySize === undefined)\n                throw new Error(`x.size not present on calculated bbox`);\n            return RectsFromTopLeft({ x: x.min, y: y.min }, xSize, ySize);\n        },\n        distanceToPoint: (_point) => {\n            throw new Error(`Not implemented`);\n        },\n        relativePosition: (_point, _intersectionThreshold) => {\n            throw new Error(`Not implemented`);\n        },\n        toString: () => bzr.toString(),\n        toSvgString: () => quadraticToSvgString(a, b, quadratic),\n        kind: `bezier/quadratic`\n    });\n};\n","import { degreeToRadian } from './angles.js';\nexport const fromDegrees = (radiusX, radiusY, rotationDeg = 0, startAngleDeg = 0, endAngleDeg = 360) => ({\n    radiusX, radiusY,\n    rotation: degreeToRadian(rotationDeg),\n    startAngle: degreeToRadian(startAngleDeg),\n    endAngle: degreeToRadian(endAngleDeg)\n});\n","import { distance } from \"./point/distance.js\";\n/**\n * Simplifies a curve by dropping points based on shortest distance.\n *\n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n *\n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n *\n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n *\n * @param points\n * @param epsilon\n * @returns\n */\nexport const rdpShortestDistance = (points, epsilon = 0.1) => {\n    const firstPoint = points[0];\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const lastPoint = points.at(-1);\n    if (points.length < 3) {\n        return points;\n    }\n    let index = -1;\n    let distribution = 0;\n    for (let index_ = 1; index_ < points.length - 1; index_++) {\n        const cDistribution = distanceFromPointToLine(points[index_], firstPoint, lastPoint);\n        if (cDistribution > distribution) {\n            distribution = cDistribution;\n            index = index_;\n        }\n    }\n    if (distribution > epsilon) {\n        // iterate\n        const l1 = points.slice(0, index + 1);\n        const l2 = points.slice(index);\n        const r1 = rdpShortestDistance(l1, epsilon);\n        const r2 = rdpShortestDistance(l2, epsilon);\n        // concat r2 to r1 minus the end/startpoint that will be the same\n        const rs = [...r1.slice(0, -1), ...r2]; //concat(r2);\n        return rs;\n    }\n    else {\n        return [firstPoint, lastPoint];\n    }\n};\n/**\n * Simplifies a curve by dropping points based on perpendicular distance\n *\n * Values of `epsilon` approaching zero keep more of the original points.\n * Making `epsilon` larger will filter out more points, making the curve more lossy and jagged.\n *\n * ```js\n * // Source set of points that define the curve\n * const pts = [ {x:100,y:200}, {x:10, y:20}, ... ];\n *\n * const simplified = rdpShortestDistance(pts, 3); // Yields an array of points\n * ```\n * It is an implementation of the [Ramer Douglas Peucker algorithm](https://en.wikipedia.org/wiki/Ramer%E2%80%93Douglas%E2%80%93Peucker_algorithm)\n * by Marius Karthaus. Try the online playground: https://karthaus.nl/rdp/\n *\n * @param points\n * @param epsilon\n * @returns\n */\nexport const rdpPerpendicularDistance = (points, epsilon = 0.1) => {\n    const firstPoint = points[0];\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const lastPoint = points.at(-1);\n    if (points.length < 3) {\n        return points;\n    }\n    let index = -1;\n    let distribution = 0;\n    for (let index_ = 1; index_ < points.length - 1; index_++) {\n        const cDistribution = findPerpendicularDistance(points[index_], firstPoint, lastPoint);\n        if (cDistribution > distribution) {\n            distribution = cDistribution;\n            index = index_;\n        }\n    }\n    if (distribution > epsilon) {\n        // iterate\n        const l1 = points.slice(0, index + 1);\n        const l2 = points.slice(index);\n        const r1 = rdpPerpendicularDistance(l1, epsilon);\n        const r2 = rdpPerpendicularDistance(l2, epsilon);\n        // concat r2 to r1 minus the end/startpoint that will be the same\n        const rs = [...r1.slice(0, -1), ...r2];\n        return rs;\n    }\n    else {\n        return [firstPoint, lastPoint];\n    }\n};\nfunction findPerpendicularDistance(p, p1, p2) {\n    // if start and end point are on the same x the distance is the difference in X.\n    let result;\n    let slope;\n    let intercept;\n    if (p1.x == p2.x) {\n        result = Math.abs(p.x - p1.x);\n    }\n    else {\n        slope = (p2.y - p1.y) / (p2.x - p1.x);\n        intercept = p1.y - (slope * p1.x);\n        result = Math.abs(slope * p.x - p.y + intercept) / Math.sqrt(Math.pow(slope, 2) + 1);\n    }\n    return result;\n}\nconst distanceFromPointToLine = (p, index, index_) => {\n    const lineLength = distance(index, index_); //First, we need the length of the line segment.\n    if (lineLength == 0) { //if it's 0, the line is actually just a point.\n        return distance(p, index);\n    }\n    const t = ((p.x - index.x) * (index_.x - index.x) + (p.y - index.y) * (index_.y - index.y)) / lineLength;\n    //t is very important. t is a number that essentially compares the individual coordinates\n    //distances between the point and each point on the line.\n    if (t < 0) { //if t is less than 0, the point is behind i, and closest to i.\n        return distance(p, index);\n    } //if greater than 1, it's closest to j.\n    if (t > 1) {\n        return distance(p, index_);\n    }\n    return distance(p, { x: index.x + t * (index_.x - index.x), y: index.y + t * (index_.y - index.y) });\n};\n","import {} from '@ixfx/collections';\nimport * as Shapes from './shape/index.js';\nimport { fromTopLeft as RectsFromTopLeft } from './rect/from-top-left.js';\nimport { intersectsPoint as RectsIntersectsPoint } from './rect/Intersects.js';\nimport { fromNumbers as PointsFromNumbers } from './point/from.js';\n/**\n * Direction\n */\nexport var Direction;\n(function (Direction) {\n    Direction[Direction[\"Nw\"] = 0] = \"Nw\";\n    Direction[Direction[\"Ne\"] = 1] = \"Ne\";\n    Direction[Direction[\"Sw\"] = 2] = \"Sw\";\n    Direction[Direction[\"Se\"] = 3] = \"Se\";\n})(Direction || (Direction = {}));\n/**\n * Creates a QuadTreeNode\n * @param bounds Bounds of region\n * @param initialData Initial items to place in quad tree\n * @param opts Options\n * @returns New quad tree\n */\nexport const quadTree = (bounds, initialData = [], opts = {}) => {\n    const o = {\n        maxItems: opts.maxItems ?? 4,\n        maxLevels: opts.maxLevels ?? 4\n    };\n    const n = new QuadTreeNode(undefined, bounds, 0, o);\n    for (const d of initialData) {\n        n.add(d);\n    }\n    return n;\n};\n/**\n * QuadTreeNode. The values of the node is an array of {@link QuadTreeItem}.\n *\n * To create, you probably want the {@link quadTree} function.\n *\n */\nexport class QuadTreeNode {\n    boundary;\n    level;\n    opts;\n    #items = [];\n    #children = [];\n    #parent;\n    /**\n     * Constructor\n     * @param boundary\n     * @param level\n     * @param opts\n     */\n    constructor(parent, boundary, level, opts) {\n        this.boundary = boundary;\n        this.level = level;\n        this.opts = opts;\n        this.#parent = parent;\n    }\n    getLengthChildren() {\n        return this.#children.length;\n    }\n    *parents() {\n        //eslint-disable-next-line functional/no-let,@typescript-eslint/no-this-alias\n        let n = this;\n        while (n.#parent !== undefined) {\n            yield n.#parent;\n            n = n.#parent;\n        }\n    }\n    getParent() {\n        return this.#parent;\n    }\n    /**\n     * Iterates over immediate children\n     */\n    *children() {\n        for (const c of this.#children) {\n            yield c;\n        }\n    }\n    /**\n     * Array of QuadTreeItem\n     * @returns\n     */\n    getValue() {\n        return this.#items;\n    }\n    getIdentity() {\n        return this;\n    }\n    /**\n     * Get a descendant node in a given direction\n     * @param d\n     * @returns\n     */\n    direction(d) {\n        return this.#children[d];\n    }\n    /**\n     * Add an item to the quadtree\n     * @param p\n     * @returns False if item is outside of boundary, True if item was added\n     */\n    add(p) {\n        if (!Shapes.isIntersecting(this.boundary, p))\n            return false;\n        if (this.#children.length > 0) {\n            for (const d of this.#children)\n                (d).add(p);\n            return true;\n        }\n        this.#items.push(p);\n        if (this.#items.length > this.opts.maxItems &&\n            this.level < this.opts.maxLevels) {\n            if (this.#children.length === 0) {\n                this.#subdivide();\n            }\n            // Add to child\n            for (const item of this.#items) {\n                for (const d of this.#children)\n                    (d).add(item);\n            }\n            //this.descendants.forEach(d => (d as QuadTreeNode).add(p));\n            this.#items = [];\n        }\n        return true;\n    }\n    /**\n     * Returns true if point is inside node's boundary\n     * @param p\n     * @returns\n     */\n    couldHold(p) {\n        return RectsIntersectsPoint(this.boundary, p);\n    }\n    #subdivide() {\n        const w = this.boundary.width / 2;\n        const h = this.boundary.height / 2;\n        const x = this.boundary.x;\n        const y = this.boundary.y;\n        // top-left corners of each of the four new sections\n        const coords = PointsFromNumbers(x + w, y, x, y, x, y + h, x + w, y + h);\n        const rects = coords.map((p) => RectsFromTopLeft(p, w, h));\n        // rects.forEach((r, index) => {\n        //   this.descendants[index] = new QuadTreeNode(r, this.level + 1, this.opts);\n        // });\n        this.#children = rects.map((r) => new QuadTreeNode(this, r, this.level + 1, this.opts));\n    }\n}\n","import { isPoint } from './point/index.js';\nimport { isRect } from './rect/guard.js';\nimport { Placeholder as PlaceholderRect } from './rect/placeholder.js';\n/**\n * Returns a set of scaler functions, to convert to and from ranges.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`, {width:window.innerWidth, height:window.innerHeight});\n * // Assuming screen of 800x400...\n * scaler.abs(400,200);          // Yields { x:0.5, y:0.5 }\n * scaler.abs({ x:400, y:200 }); // Yields { x:0.5, y:0.5 }\n *\n * scaler.rel(0.5, 0.5);         // Yields: { x:400, y:200 }\n * scaler.rel({ x:0.5, y:0.5 }); // Yields: { x:400, y:200 }\n * ```\n *\n * If no default range is provided, it must be given each time the scale function is used.\n *\n * ```js\n * const scaler = Scaler.scaler(`both`);\n *\n * scaler.abs(400, 200, 800, 400);\n * scaler.abs(400, 200, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, { width: 800, height: 400 });\n * scaler.abs({ x:400, y: 200}, 800, 400);\n * // All are the same, yielding { x:0.5, y:0.5 }\n *\n * scaler.abs(400, 200); // Throws an exception because there is no scale\n * ```\n * @param scaleBy Dimension to scale by\n * @param defaultRect Default range\n * @returns\n */\nexport const scaler = (scaleBy = `both`, defaultRect) => {\n    const defaultBounds = defaultRect ?? PlaceholderRect;\n    let sw = 1;\n    let sh = 1;\n    let s = { x: 1, y: 1 };\n    const computeScale = () => {\n        switch (scaleBy) {\n            case `height`: {\n                return { x: sh, y: sh };\n            }\n            case `width`: {\n                return { x: sw, y: sw };\n            }\n            case `min`: {\n                return { x: Math.min(sw, sh), y: Math.min(sw, sh) };\n            }\n            case `max`: {\n                return { x: Math.max(sw, sh), y: Math.max(sw, sh) };\n            }\n            default: {\n                return { x: sw, y: sh };\n            }\n        }\n    };\n    const normalise = (a, b, c, d) => {\n        let inX = Number.NaN;\n        let inY = Number.NaN;\n        let outW = defaultBounds.width;\n        let outH = defaultBounds.height;\n        if (typeof a === `number`) {\n            inX = a;\n            if (typeof b === `number`) {\n                inY = b;\n                if (c === undefined)\n                    return [inX, inY, outW, outH];\n                if (isRect(c)) {\n                    outW = c.width;\n                    outH = c.height;\n                }\n                else if (typeof c === `number`) {\n                    outW = c;\n                    if (typeof d === `number`) {\n                        outH = d;\n                    }\n                    else {\n                        throw new TypeError(`Missing final height value`);\n                    }\n                }\n                else\n                    throw new Error(`Missing valid output range`);\n            }\n            else if (isRect(b)) {\n                outW = b.width;\n                outH = b.height;\n            }\n            else {\n                throw new Error(`Expected input y or output Rect to follow first number parameter`);\n            }\n        }\n        else if (isPoint(a)) {\n            inX = a.x;\n            inY = a.y;\n            if (b === undefined)\n                return [inX, inY, outW, outH];\n            if (isRect(b)) {\n                outW = b.width;\n                outH = b.height;\n            }\n            else if (typeof b === `number`) {\n                outW = b;\n                if (typeof c === `number`) {\n                    outH = c;\n                }\n                else {\n                    throw new TypeError(`Expected height as third parameter after Point and output width`);\n                }\n            }\n            else {\n                throw new TypeError(`Expected Rect or width as second parameter when first parameter is a Point`);\n            }\n        }\n        else {\n            throw new Error(`Expected input Point or x value as first parameter`);\n        }\n        return [inX, inY, outW, outH];\n    };\n    const scaleAbs = (a, b, c, d) => {\n        const n = normalise(a, b, c, d);\n        return scaleNormalised(true, ...n);\n    };\n    const scaleRel = (a, b, c, d) => {\n        const n = normalise(a, b, c, d);\n        return scaleNormalised(false, ...n);\n    };\n    const scaleNormalised = (abs, x, y, w, h) => {\n        if (Number.isNaN(w))\n            throw new Error(`Output width range missing`);\n        if (Number.isNaN(h))\n            throw new Error(`Output height range missing`);\n        // If output dimensions has changed since last, create a new scale\n        if (w !== sw || h !== sh) {\n            sw = w;\n            sh = h;\n            s = computeScale();\n        }\n        return abs ? {\n            x: x * s.x,\n            y: y * s.y,\n        } : {\n            x: x / s.x,\n            y: y / s.y,\n        };\n    };\n    return {\n        computeScale,\n        rel: scaleRel,\n        abs: scaleAbs,\n        width: defaultBounds.width,\n        height: defaultBounds.height\n    };\n};\n// export const scalerReactive = (scaleBy: ScaleBy = `both`,\n//   defaultRect?: ReactiveInitial<Rect>) => {\n//   const resolve = (a: Point | Rect | RectPositioned | number, b: Rect | number, c: number, d: number) => {\n//     if (typeof a === `number`) {\n//       if (typeof b === `number`) {\n//         return { x: a, y: b, width: undefined, height: undefined }\n//       } else {\n//         throw new TypeError(`Expected 'b' parameter to be the y value?`);\n//       }\n//     } else if (isPoint(a)) {\n//       if (isRect(b)) {\n//         // Positioned rect\n//         return {\n//           x: \n//       }\n//       }\n//     }\n//   }\n","import { degreeToRadian, radianArc, radiansSum } from '../angles.js';\nimport { guard as guardPoint, isPoint } from '../point/guard.js';\nimport { distance as pointsDistance } from '../point/distance.js';\nimport { bbox as pointsBbox } from '../point/bbox.js';\nimport { toCartesian } from '../polar/index.js';\nimport { fromPoints as LinesFromPoints } from '../line/from-points.js';\nimport { piPi } from '../pi.js';\n/**\n * Returns true if parameter is an arc\n * @param p Arc or number\n * @returns\n */\nexport const isArc = (p) => typeof p.startRadian !== `undefined` && typeof p.endRadian !== `undefined` && typeof p.clockwise !== `undefined`;\n/**\n * Returns true if parameter has a positioned (x,y)\n * @param p Point, Arc or ArcPositiond\n * @returns\n */\nexport const isPositioned = (p) => typeof p.x !== `undefined` && typeof p.y !== `undefined`;\n/**\n * Returns an arc from degrees, rather than radians\n * @param radius Radius of arc\n * @param startDegrees Start angle in degrees\n * @param endDegrees End angle in degrees\n * @param origin Optional center of arc\n * @param clockwise Whether arc moves in clockwise direction\n * @returns Arc\n */\nexport function fromDegrees(radius, startDegrees, endDegrees, clockwise, origin) {\n    const a = {\n        radius,\n        startRadian: degreeToRadian(startDegrees),\n        endRadian: degreeToRadian(endDegrees),\n        clockwise\n    };\n    if (isPoint(origin)) {\n        guardPoint(origin);\n        const ap = {\n            ...a,\n            x: origin.x,\n            y: origin.y\n        };\n        return Object.freeze(ap);\n    }\n    else {\n        return Object.freeze(a);\n    }\n}\n/**\n * Returns a {@link Geometry.Line} linking the start and end points of an {@link ArcPositioned}.\n *\n * @param arc\n * @returns Line from start to end of arc\n */\nexport const toLine = (arc) => LinesFromPoints(point(arc, arc.startRadian), point(arc, arc.endRadian));\n/**\n * Return start and end points of `arc`.\n * `origin` will override arc's origin, if defined.\n *\n * See also:\n * * {@link point} - get point on arc by angle\n * * {@link interpolate} - get point on arc by interpolation percentage\n * @param arc\n * @param origin\n * @returns\n */\nexport const getStartEnd = (arc, origin) => {\n    guard(arc);\n    const start = point(arc, arc.startRadian, origin);\n    const end = point(arc, arc.endRadian, origin);\n    return [start, end];\n};\n/**\n * Calculates a coordinate on an arc, based on an angle.\n * `origin` will override arc's origin, if defined.\n *\n * See also:\n * * {@link getStartEnd} - get start and end of arc\n * * {@link interpolate} - get point on arc by interpolation percentage\n * @param arc Arc\n * @param angleRadian Angle of desired coordinate\n * @param origin Origin of arc (0,0 used by default)\n * @returns Coordinate\n */\nexport const point = (arc, angleRadian, origin) => {\n    if (typeof origin === `undefined`) {\n        origin = isPositioned(arc) ? arc : { x: 0, y: 0 };\n    }\n    return {\n        x: (Math.cos(angleRadian) * arc.radius) + origin.x,\n        y: (Math.sin(angleRadian) * arc.radius) + origin.y\n    };\n};\n/**\n * Throws an error if arc instance is invalid\n * @param arc\n */\nexport const guard = (arc) => {\n    if (typeof arc === `undefined`)\n        throw new TypeError(`Arc is undefined`);\n    if (isPositioned(arc)) {\n        guardPoint(arc, `arc`);\n    }\n    if (typeof arc.radius === `undefined`)\n        throw new TypeError(`Arc radius is undefined (${JSON.stringify(arc)})`);\n    if (typeof arc.radius !== `number`)\n        throw new TypeError(`Radius must be a number`);\n    if (Number.isNaN(arc.radius))\n        throw new TypeError(`Radius is NaN`);\n    if (arc.radius <= 0)\n        throw new TypeError(`Radius must be greater than zero`);\n    if (typeof arc.startRadian === `undefined`)\n        throw new TypeError(`Arc is missing 'startRadian' field`);\n    if (typeof arc.endRadian === `undefined`)\n        throw new TypeError(`Arc is missing 'startRadian' field`);\n    if (Number.isNaN(arc.endRadian))\n        throw new TypeError(`Arc endRadian is NaN`);\n    if (Number.isNaN(arc.startRadian))\n        throw new TypeError(`Arc endRadian is NaN`);\n    if (typeof arc.clockwise === `undefined`)\n        throw new TypeError(`Arc is missing 'clockwise field`);\n    if (arc.startRadian >= arc.endRadian)\n        throw new TypeError(`startRadian is expected to be les than endRadian`);\n};\n/**\n * Compute relative position on arc.\n *\n * See also:\n * * {@link getStartEnd} - get start and end of arc\n * * {@link point} - get point on arc by angle\n * @param arc Arc\n * @param amount Relative position 0-1\n * @param origin If arc is not positioned, pass in an origin\n * @param allowOverflow If _true_ allows point to overflow arc dimensions (default: _false_)\n * @returns\n */\nexport const interpolate = (amount, arc, allowOverflow, origin) => {\n    guard(arc);\n    const overflowOk = allowOverflow ?? false;\n    if (!overflowOk) {\n        if (amount < 0)\n            throw new Error(`Param 'amount' is under zero, and overflow is not allowed`);\n        if (amount > 1)\n            throw new Error(`Param 'amount' is above 1 and overflow is not allowed`);\n    }\n    const span = angularSize(arc); // angular size\n    const rel = span * amount;\n    const angle = radiansSum(arc.startRadian, rel, arc.clockwise);\n    //console.log(`interpolate span: ${ span.toFixed(2) } rel: ${ rel.toFixed(2) } angle: ${ angle.toFixed(2) } amt: ${ amount.toFixed(2) } cw: ${ arc.clockwise } start: ${ arc.startRadian }`);\n    return point(arc, angle, origin);\n    //return point(arc, arc.startRadian + ((arc.endRadian - arc.startRadian) * amount), origin);\n};\n/**\n * Returns the angular size of arc.\n * Eg if arc runs from 45-315deg in clockwise direction, size will be 90deg.\n * @param arc\n */\nexport const angularSize = (arc) => radianArc(arc.startRadian, arc.endRadian, arc.clockwise);\n/**\n * Creates a {@link Geometry.Path} instance from the arc. This wraps up some functions for convienence.\n * @param arc\n * @returns Path\n */\nexport const toPath = (arc) => {\n    guard(arc);\n    return Object.freeze({\n        ...arc,\n        nearest: (_point) => { throw new Error(`not implemented`); },\n        interpolate: (amount) => interpolate(amount, arc),\n        bbox: () => bbox(arc),\n        length: () => length(arc),\n        toSvgString: () => toSvg(arc),\n        relativePosition: (_point, _intersectionThreshold) => {\n            throw new Error(`Not implemented`);\n        },\n        distanceToPoint: (_point) => {\n            throw new Error(`Not implemented`);\n        },\n        kind: `arc`\n    });\n};\n/**\n * Returns an arc based on a circle using start and end angles.\n * If you don't have the end angle, but rather the size of the arc, use {@link fromCircleAmount}\n * @param circle Circle\n * @param startRadian Start radian\n * @param endRadian End radian\n * @param clockwise Whether arc goes in a clockwise direction (default: true)\n * @returns\n */\nexport const fromCircle = (circle, startRadian, endRadian, clockwise = true) => {\n    const a = Object.freeze({\n        ...circle,\n        endRadian,\n        startRadian,\n        clockwise\n    });\n    return a;\n};\n/**\n * Returns an arc based on a circle, a start angle, and the size of the arc.\n * See {@link fromCircle} if you already have start and end angles.\n * @param circle Circle to base off\n * @param startRadian Starting angle\n * @param sizeRadian Size of arc\n * @param clockwise Whether arc moves in clockwise direction (default: true)\n * @returns\n */\nexport const fromCircleAmount = (circle, startRadian, sizeRadian, clockwise = true) => {\n    const endRadian = radiansSum(startRadian, sizeRadian, clockwise);\n    return fromCircle(circle, startRadian, endRadian);\n};\n/**\n * Calculates the length of the arc\n * @param arc\n * @returns Length\n */\nexport const length = (arc) => piPi * arc.radius * ((arc.startRadian - arc.endRadian) / piPi);\n/**\n * Calculates a {@link Geometry.Rect | Rect} bounding box for arc.\n * @param arc\n * @returns Rectangle encompassing arc.\n */\nexport const bbox = (arc) => {\n    if (isPositioned(arc)) {\n        const middle = interpolate(0.5, arc);\n        const asLine = toLine(arc);\n        return pointsBbox(middle, asLine.a, asLine.b);\n    }\n    else {\n        return {\n            width: arc.radius * 2,\n            height: arc.radius * 2\n        };\n    }\n};\n/**\n * Creates an SV path snippet for arc\n * @returns\n */\n// eslint-disable-next-line unicorn/prevent-abbreviations\nexport const toSvg = (a, b, c, d, e) => {\n    if (isArc(a)) {\n        if (isPositioned(a)) {\n            if (isPoint(b)) {\n                // Passing in a origin override\n                return toSvgFull(b, a.radius, a.startRadian, a.endRadian, c);\n            }\n            else {\n                // Using origin in arc\n                return toSvgFull(a, a.radius, a.startRadian, a.endRadian, b);\n            }\n        }\n        else {\n            return isPoint(b) ? toSvgFull(b, a.radius, a.startRadian, a.endRadian, c) : toSvgFull({ x: 0, y: 0 }, a.radius, a.startRadian, a.endRadian);\n        }\n    }\n    else {\n        if (c === undefined)\n            throw new Error(`startAngle undefined`);\n        if (d === undefined)\n            throw new Error(`endAngle undefined`);\n        if (isPoint(a)) {\n            if (typeof b === `number` && typeof c === `number` && typeof d === `number`) {\n                return toSvgFull(a, b, c, d, e);\n            }\n            else {\n                throw new TypeError(`Expected (point, number, number, number). Missing a number param.`);\n            }\n        }\n        else {\n            throw new Error(`Expected (point, number, number, number). Missing first point.`);\n        }\n    }\n};\nconst toSvgFull = (origin, radius, startRadian, endRadian, opts) => {\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Tutorial/Paths\n    // A rx ry x-axis-rotation large-arc-flag sweep-flag x y\n    // a rx ry x-axis-rotation large-arc-flag sweep-flag dx dy\n    if (opts === undefined || typeof opts !== `object`)\n        opts = {};\n    const isFullCircle = endRadian - startRadian === 360;\n    const start = toCartesian(radius, endRadian - 0.01, origin);\n    const end = toCartesian(radius, startRadian, origin);\n    const { largeArc = false, sweep = false } = opts;\n    const d = [`\n    M ${start.x} ${start.y}\n    A ${radius} ${radius} 0 ${largeArc ? `1` : `0`} ${sweep ? `1` : `0`} ${end.x} ${end.y},\n  `];\n    if (isFullCircle)\n        d.push(`z`);\n    return d;\n};\n/**\n * Calculates the distance between the centers of two arcs\n * @param a\n * @param b\n * @returns Distance\n */\nexport const distanceCenter = (a, b) => pointsDistance(a, b);\n/**\n * Returns true if the two arcs have the same values\n *\n * ```js\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * const arcA = { radius: 5, endRadian: 0, startRadian: 1 };\n * arcA === arcB; // false, because object identities are different\n * Arcs.isEqual(arcA, arcB); // true, because values are identical\n * ```\n * @param a\n * @param b\n * @returns {boolean}\n */\nexport const isEqual = (a, b) => {\n    if (a.radius !== b.radius)\n        return false;\n    if (a.endRadian !== b.endRadian)\n        return false;\n    if (a.startRadian !== b.startRadian)\n        return false;\n    if (a.clockwise !== b.clockwise)\n        return false;\n    if (isPositioned(a) && isPositioned(b)) {\n        if (a.x !== b.x)\n            return false;\n        if (a.y !== b.y)\n            return false;\n        if (a.z !== b.z)\n            return false;\n    }\n    else if (!isPositioned(a) && !isPositioned(b)) {\n        // no-op\n    }\n    else\n        return false; // one is positioned one not\n    return true;\n};\n","import { toPositioned as circleToPositioned } from './circle/to-positioned.js';\nimport { scale, linearSpace } from '@ixfx/numbers';\nconst cos = Math.cos;\nconst sin = Math.sin;\nconst asin = Math.asin;\nconst sqrt = Math.sqrt;\nconst pow = Math.pow;\nconst pi = Math.PI;\nconst piPi = Math.PI * 2;\nconst goldenAngle = pi * (3 - sqrt(5));\nconst goldenSection = (1 + sqrt(5)) / 2;\n/**\n * Generates points on a Vogel spiral - a sunflower-like arrangement of points.\n *\n * @example With no arguments, assumes a unit circle\n * ```js\n * for (const pt of circleVogelSpiral()) {\n *  // Generate points on a unit circle, with 95% density\n * }\n * ```\n *\n *\n * @example Specifying a circle and options\n * ```js\n * const circle = { radius: 100, x: 100, y: 100 };\n * const opts = {\n *  maxPoints: 50,\n *  density: 0.99\n * };\n * for (const pt of circleVogelSpiral(circle, opts)) {\n *  // Do something with point...\n * }\n * ```\n *\n * @example Array format\n * ```js\n * const ptsArray = [...circleVogelSpiral(circle, opts)];\n * ```\n * @param circle\n * @param opts\n */\nexport function* circleVogelSpiral(circle, opts = {}) {\n    const maxPoints = opts.maxPoints ?? 5000;\n    const density = opts.density ?? 0.95;\n    const rotationOffset = opts.rotation ?? 0;\n    const c = circleToPositioned(circle ?? { radius: 1, x: 0, y: 0 });\n    const max = c.radius;\n    //eslint-disable-next-line functional/no-let\n    let spacing = c.radius * scale(density, 0, 1, 0.3, 0.01);\n    if (opts.spacing)\n        spacing = opts.spacing;\n    //eslint-disable-next-line functional/no-let\n    let radius = 0;\n    //eslint-disable-next-line functional/no-let\n    let count = 0;\n    //eslint-disable-next-line functional/no-let\n    let angle = 0;\n    while (count < maxPoints && radius < max) {\n        radius = spacing * count ** 0.5;\n        angle = rotationOffset + (count * 2 * pi) / goldenSection;\n        yield Object.freeze({\n            x: c.x + radius * cos(angle),\n            y: c.y + radius * sin(angle),\n        });\n        count++;\n    }\n}\n/**\n * Generates points spaced out on the given number of rings.\n *\n * Get points as array\n * ```js\n * const circle = { radius: 5, x: 100, y: 100 };\n * const opts = { rings: 5 };\n * const points = [...circleRings(circle, rings)];\n * ```\n *\n * Or iterate over them\n * ```js\n * for (const point of circleRings(circle, opts)) {\n * }\n * ```\n * Source: http://www.holoborodko.com/pavel/2015/07/23/generating-equidistant-points-on-unit-disk/#more-3453\n * @param circle\n */\nexport function* circleRings(circle, opts = {}) {\n    const rings = opts.rings ?? 5;\n    const c = circleToPositioned(circle ?? { radius: 1, x: 0, y: 0 });\n    const ringR = 1 / rings;\n    const rotationOffset = opts.rotation ?? 0;\n    //eslint-disable-next-line functional/no-let\n    let ringCount = 1;\n    // Origin\n    yield Object.freeze({ x: c.x, y: c.y });\n    //eslint-disable-next-line functional/no-let\n    for (let r = ringR; r <= 1; r += ringR) {\n        const n = Math.round(pi / asin(1 / (2 * ringCount)));\n        for (const theta of linearSpace(0, piPi, n + 1)) {\n            yield Object.freeze({\n                x: c.x + r * cos(theta + rotationOffset) * c.radius,\n                y: c.y + r * sin(theta + rotationOffset) * c.radius,\n            });\n        }\n        ringCount++;\n    }\n}\n/**\n * Fibonacci sphere algorithm. Generates points\n * distributed on a sphere.\n *\n * @example Generate points of a unit sphere\n * ```js\n * for (const pt of sphereFibonacci(100)) {\n *  // pt.x, pt.y, pt.z\n * }\n * ```\n *\n * @example Generate points into an array\n * ```js\n * const sphere = { radius: 10, x: 10, y: 200 }\n * const pts = [...sphereFibonacci(100, 0, sphere)];\n * ```\n *\n * Source: https://codepen.io/elchininet/pen/vXeRyL\n *\n * @param samples\n * @returns\n */\nexport function* sphereFibonacci(samples = 100, rotationRadians = 0, sphere) {\n    const offset = 2 / samples;\n    const s = sphere ?? { x: 0, y: 0, z: 0, radius: 1 };\n    for (let index = 0; index < samples; index++) {\n        const y = index * offset - 1 + offset / 2;\n        const r = sqrt(1 - pow(y, 2));\n        const a = ((index + 1) % samples) * goldenAngle + rotationRadians;\n        const x = cos(a) * r;\n        const z = sin(a) * r;\n        //eslint-disable-next-line functional/immutable-data\n        yield Object.freeze({\n            x: s.x + x * s.radius,\n            y: s.y + y * s.radius,\n            z: s.z + z * s.radius,\n        });\n    }\n}\n","import { angleRadian as PointsAngleRadian } from '../point/angle.js';\nimport { guard } from \"./guard.js\";\nimport { radianToDegree } from \"../angles.js\";\n/**\n * Return the three interior angles of the triangle, in radians.\n * @param t\n * @returns\n */\nexport const angles = (t) => {\n    guard(t);\n    return [\n        PointsAngleRadian(t.a, t.b),\n        PointsAngleRadian(t.b, t.c),\n        PointsAngleRadian(t.c, t.a),\n    ];\n};\n/**\n * Returns the three interior angles of the triangle, in degrees\n * @param t\n * @returns\n */\nexport const anglesDegrees = (t) => {\n    guard(t);\n    return radianToDegree(angles(t));\n};\n","import { joinPointsToLines } from \"../line/join-points-to-lines.js\";\nimport { guard } from \"./guard.js\";\n/**\n * Returns the edges (ie sides) of the triangle as an array of lines\n * @param t\n * @returns Array of length three\n */\nexport const edges = (t) => {\n    guard(t);\n    return joinPointsToLines(t.a, t.b, t.c, t.a);\n};\n","import { guard } from \"./guard.js\";\nimport { length as LinesLength } from '../line/length.js';\nimport { edges } from \"./edges.js\";\n/**\n * Calculates the area of a triangle\n * @param t\n * @returns\n */\nexport const area = (t) => {\n    guard(t, `t`);\n    // Get length of edges\n    const lengths = edges(t).map((l) => LinesLength(l));\n    // Add up length of edges, halve\n    const p = (lengths[0] + lengths[1] + lengths[2]) / 2;\n    return Math.sqrt(p * (p - lengths[0]) * (p - lengths[1]) * (p - lengths[2]));\n};\n","import { getPointParameter } from \"../point/get-point-parameter.js\";\nimport { guard } from \"./guard.js\";\n/**\n * Returns the [Barycentric coordinate](https://en.wikipedia.org/wiki/Barycentric_coordinate_system) of a point within a triangle\n *\n * @param t\n * @param a\n * @param b\n * @returns\n */\nexport const barycentricCoord = (t, a, b) => {\n    const pt = getPointParameter(a, b);\n    const ab = (x, y, pa, pb) => (pa.y - pb.y) * x + (pb.x - pa.x) * y + pa.x * pb.y - pb.x * pa.y;\n    const alpha = ab(pt.x, pt.y, t.b, t.c) / ab(t.a.x, t.a.y, t.b, t.c);\n    const theta = ab(pt.x, pt.y, t.c, t.a) / ab(t.b.x, t.b.y, t.c, t.a);\n    const gamma = ab(pt.x, pt.y, t.a, t.b) / ab(t.c.x, t.c.y, t.a, t.b);\n    return {\n        a: alpha,\n        b: theta,\n        c: gamma,\n    };\n};\n/**\n * Convert Barycentric coordinate to Cartesian\n * @param t\n * @param bc\n * @returns\n */\nexport const barycentricToCartestian = (t, bc) => {\n    guard(t);\n    const { a, b, c } = t;\n    const x = a.x * bc.a + b.x * bc.b + c.x * bc.c;\n    const y = a.y * bc.a + b.y * bc.b + c.y * bc.c;\n    if (a.z && b.z && c.z) {\n        const z = a.z * bc.a + b.z * bc.b + c.z * bc.c;\n        return Object.freeze({ x, y, z });\n    }\n    else {\n        return Object.freeze({ x, y });\n    }\n};\n","/**\n * Returns the bounding box that encloses the triangle.\n * @param t\n * @param inflation If specified, box will be inflated by this much. Default: 0.\n * @returns\n */\nexport const bbox = (t, inflation = 0) => {\n    const { a, b, c } = t;\n    const xMin = Math.min(a.x, b.x, c.x) - inflation;\n    const xMax = Math.max(a.x, b.x, c.x) + inflation;\n    const yMin = Math.min(a.y, b.y, c.y) - inflation;\n    const yMax = Math.max(a.y, b.y, c.y) + inflation;\n    const r = {\n        x: xMin,\n        y: yMin,\n        width: xMax - xMin,\n        height: yMax - yMin,\n    };\n    return r;\n};\n","import { guard } from \"./guard.js\";\n/**\n * Returns the corners (vertices) of the triangle as an array of points\n * @param t\n * @returns Array of length three\n */\nexport const corners = (t) => {\n    guard(t);\n    return [t.a, t.b, t.c];\n};\n","import { numberTest, resultThrow } from \"@ixfx/guards\";\nimport { fromNumbers as PointsFromNumbers } from \"../point/from.js\";\nimport { guard as PointGuard } from \"../point/guard.js\";\nimport { piPi } from \"../pi.js\";\nimport { toCartesian as PolarToCartesian } from \"../polar/conversions.js\";\n/**\n * Returns an equilateral triangle centered at the origin.\n *\n * ```js\n * // Create a triangle at 100,100 with radius of 60\n * const tri = fromRadius({x:100,y:100}, 60);\n *\n * // Triangle with point A upwards, B to the right, C to the left\n * constr tri2 = fromRadius({x:100,y:100}, 60, {initialAngleRadian: -Math.PI / 2});\n * ```\n *\n *\n * @param origin Origin\n * @param radius Radius of triangle\n * @param opts Options\n */\nexport const fromRadius = (origin, radius, opts = {}) => {\n    resultThrow(numberTest(radius, `positive`, `radius`));\n    PointGuard(origin, `origin`);\n    const initialAngleRadian = opts.initialAngleRadian ?? 0;\n    const angles = [\n        initialAngleRadian,\n        initialAngleRadian + (piPi * 1) / 3,\n        initialAngleRadian + (piPi * 2) / 3,\n    ];\n    const points = angles.map((a) => PolarToCartesian(radius, a, origin));\n    return fromPoints(points);\n};\n/**\n * Returns a triangle from a set of coordinates in a flat array form:\n * [xA, yA, xB, yB, xC, yC]\n * @param coords\n * @returns\n */\nexport const fromFlatArray = (coords) => {\n    if (!Array.isArray(coords))\n        throw new Error(`coords expected as array`);\n    if (coords.length !== 6) {\n        throw new Error(`coords array expected with 6 elements. Got ${coords.length}`);\n    }\n    return fromPoints(PointsFromNumbers(...coords));\n};\n/**\n * Returns a triangle from an array of three points\n * @param points\n * @returns\n */\nexport const fromPoints = (points) => {\n    if (!Array.isArray(points))\n        throw new Error(`points expected as array`);\n    if (points.length !== 3) {\n        throw new Error(`points array expected with 3 elements. Got ${points.length}`);\n    }\n    const t = {\n        a: points[0],\n        b: points[1],\n        c: points[2],\n    };\n    return t;\n};\n","import { guard } from \"./guard.js\";\nimport { distance } from \"../point/distance.js\";\n/**\n * Returns the lengths of the triangle sides\n * @param t\n * @returns Array of length three\n */\nexport const lengths = (t) => {\n    guard(t);\n    return [\n        distance(t.a, t.b),\n        distance(t.b, t.c),\n        distance(t.c, t.a),\n    ];\n};\n","import { angles } from \"./angles.js\";\nimport { guard } from \"./guard.js\";\nimport { lengths } from \"./lengths.js\";\n/**\n * Returns true if it is an equilateral triangle\n * @param t\n * @returns\n */\nexport const isEquilateral = (t) => {\n    guard(t);\n    const [a, b, c] = lengths(t);\n    return a === b && b === c;\n};\n/**\n * Returns true if it is an isosceles triangle\n * @param t\n * @returns\n */\nexport const isIsosceles = (t) => {\n    const [a, b, c] = lengths(t);\n    if (a === b)\n        return true;\n    if (b === c)\n        return true;\n    if (c === a)\n        return true;\n    return false;\n};\n/**\n * Returns true if at least one interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport const isRightAngle = (t) => angles(t).includes(Math.PI / 2);\n/**\n * Returns true if triangle is oblique: No interior angle is 90 degrees\n * @param t\n * @returns\n */\nexport const isOblique = (t) => !isRightAngle(t);\n/**\n * Returns true if triangle is actue: all interior angles less than 90 degrees\n * @param t\n * @returns\n */\nexport const isAcute = (t) => !angles(t).some((v) => v >= Math.PI / 2);\n/**\n * Returns true if triangle is obtuse: at least one interior angle is greater than 90 degrees\n * @param t\n * @returns\n */\nexport const isObtuse = (t) => angles(t).some((v) => v > Math.PI / 2);\n","import { guard } from \"./guard.js\";\nimport { length as LinesLength } from '../line/length.js';\nimport { edges } from \"./edges.js\";\n/**\n * Calculates perimeter of a triangle\n * @param t\n * @returns\n */\nexport const perimeter = (t) => {\n    guard(t);\n    return edges(t).reduce((accumulator, v) => accumulator + LinesLength(v), 0);\n};\n","import { area } from \"./area.js\";\nimport { centroid } from \"./centroid.js\";\nimport { perimeter } from \"./perimeter.js\";\n/**\n * Returns the largest circle enclosed by triangle `t`.\n * @param t\n */\nexport const innerCircle = (t) => {\n    const c = centroid(t);\n    const p = perimeter(t) / 2;\n    const a = area(t);\n    const radius = a / p;\n    return { radius, ...c };\n};\n","import { length as LinesLength } from '../line/length.js';\nimport { edges } from \"./edges.js\";\nimport { centroid } from './centroid.js';\n/**\n * Returns the largest circle touching the corners of triangle `t`.\n * @param t\n * @returns\n */\nexport const outerCircle = (t) => {\n    const [a, b, c] = edges(t).map((l) => LinesLength(l));\n    const cent = centroid(t);\n    const radius = (a * b * c) /\n        Math.sqrt((a + b + c) * (-a + b + c) * (a - b + c) * (a + b - c));\n    return {\n        radius,\n        ...cent,\n    };\n};\n","import { centroid } from \"./centroid.js\";\nimport { rotate as PointsRotate } from \"../point/index.js\";\n/**\n * Returns a triangle that is rotated by `angleRad`. By default it rotates\n * around its center but an arbitrary `origin` point can be provided.\n *\n * ```js\n * let triangle = Triangles.fromPoints([a, b, c]);\n *\n * // Rotate triangle by 5 degrees\n * triangle = Triangles.rotate(triangle, degreeToRadian(5));\n *\n * // Rotate by 90 degrees\n * triangle = Triangles.rotate(triangle, Math.PI / 2);\n * ```\n * @param triangle Triangle to rotate\n * @param amountRadian Angle in radians to rotate by\n * @param origin Point to rotate around. If undefined, middle of triangle will be used\n * @returns A new triangle\n */\nexport const rotate = (triangle, amountRadian, origin) => {\n    if (amountRadian === undefined || amountRadian === 0)\n        return triangle;\n    if (origin === undefined)\n        origin = centroid(triangle);\n    return Object.freeze({\n        ...triangle,\n        a: PointsRotate(triangle.a, amountRadian, origin),\n        b: PointsRotate(triangle.b, amountRadian, origin),\n        c: PointsRotate(triangle.c, amountRadian, origin),\n    });\n};\n/**\n * Rotates the vertices of the triangle around one point (by default, `b`), returning\n * as a new object.\n *\n * ```js\n * let triangle = Triangles.fromPoints([a, b, c]);\n * triangle = Triangles.rotateByVertex(triangle, Math.Pi, `a`);\n * ```\n * @param triangle Triangle\n * @param amountRadian Angle to rotate by\n * @param vertex Name of vertex: a, b or c.\n * @returns A new triangle\n */\nexport const rotateByVertex = (triangle, amountRadian, vertex = `b`) => {\n    const origin = vertex === `a` ? triangle.a : (vertex === `b` ? triangle.b : triangle.c);\n    return Object.freeze({\n        a: PointsRotate(triangle.a, amountRadian, origin),\n        b: PointsRotate(triangle.b, amountRadian, origin),\n        c: PointsRotate(triangle.c, amountRadian, origin),\n    });\n};\n","const pi4over3 = (Math.PI * 4) / 3;\nconst pi2over3 = (Math.PI * 2) / 3;\nconst resolveLength = (t) => {\n    if (typeof t === `number`)\n        return t;\n    return t.length;\n};\n/**\n * Returns a positioned `Triangle` from an equilateral triangle definition.\n * By default the rotation is such that point `a` and `c` are lying on the horizontal,\n * and `b` is the upward-facing tip.\n *\n * Default is a triangle pointing upwards with b at the top, c to the left and b to right on the baseline.\n *\n * Example rotation values in radians:\n * * ▶️ 0: a and c on vertical, b at the tip\n * * ◀️ Math.PI: `c`and `a` are on vertical, with `b` at the tip.\n * * 🔽 Math.PI/2: `c` and `a` are on horizontal, `c` to the left. `b` at the bottom.\n * * 🔼 Math.PI*1.5: `c` and `a` are on horizontal, `c` to the right. `b` at the top. (default)\n * @param t\n * @param origin\n * @param rotationRad\n * @returns\n */\nexport const fromCenter = (t, origin, rotationRad) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const r = resolveLength(t) / Math.sqrt(3);\n    const rot = rotationRad ?? Math.PI * 1.5;\n    const b = {\n        x: r * Math.cos(rot) + origin.x,\n        y: r * Math.sin(rot) + origin.y,\n    };\n    const a = {\n        x: r * Math.cos(rot + pi4over3) + origin.x,\n        y: r * Math.sin(rot + pi4over3) + origin.y,\n    };\n    const c = {\n        x: r * Math.cos(rot + pi2over3) + origin.x,\n        y: r * Math.sin(rot + pi2over3) + origin.y,\n    };\n    return Object.freeze({ a, b, c });\n};\n/**\n * Calculate center from the given point A\n * @param t\n * @param ptA\n * @returns\n */\nexport const centerFromA = (t, ptA) => {\n    if (!ptA)\n        ptA = Object.freeze({ x: 0, y: 0 });\n    const r = resolveLength(t);\n    const { radius } = incircle(t);\n    return {\n        x: ptA.x + r / 2,\n        y: ptA.y - radius,\n    };\n};\n/**\n * Calculate center from the given point B\n * @param t\n * @param ptB\n * @returns\n */\nexport const centerFromB = (t, ptB) => {\n    if (!ptB)\n        ptB = Object.freeze({ x: 0, y: 0 });\n    const { radius } = incircle(t);\n    return {\n        x: ptB.x,\n        y: ptB.y + radius * 2,\n    };\n};\n/**\n * Calculate center from the given point C\n * @param t\n * @param ptC\n * @returns\n */\nexport const centerFromC = (t, ptC) => {\n    if (!ptC)\n        ptC = Object.freeze({ x: 0, y: 0 });\n    const r = resolveLength(t);\n    const { radius } = incircle(t);\n    return {\n        x: ptC.x - r / 2,\n        y: ptC.y - radius,\n    };\n};\n/**\n * Returns the height (or rise) of an equilateral triangle.\n * Ie. from one vertex to the perpendicular edge.\n * (line marked x in the diagram below)\n *\n * ```\n *      .\n *     .x .\n *    . x  .\n *   .  x   .\n *  ..........\n * ```\n * @param t\n */\nexport const height = (t) => (Math.sqrt(3) / 2) * resolveLength(t);\nexport const perimeter = (t) => resolveLength(t) * 3;\nexport const area = (t) => (Math.pow(resolveLength(t), 2) * Math.sqrt(3)) / 4;\n/**\n * Circle that encompasses all points of triangle\n * @param t\n */\nexport const circumcircle = (t) => ({\n    radius: (Math.sqrt(3) / 3) * resolveLength(t),\n});\n/**\n * Circle that is inside the edges of the triangle\n * @param t\n * @returns\n */\nexport const incircle = (t) => ({\n    radius: (Math.sqrt(3) / 6) * resolveLength(t),\n});\n","/**\n * Returns a positioned triangle from a point for A.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromA = (t, origin) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const tt = resolveLengths(t);\n    const seg = hypotenuseSegments(t);\n    const h = height(t);\n    const a = { x: origin.x, y: origin.y };\n    const b = { x: origin.x + tt.hypotenuse, y: origin.y };\n    const c = { x: origin.x + seg[1], y: origin.y - h };\n    return { a, b, c };\n};\n/**\n * Returns a positioned triangle from a point for B.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromB = (t, origin) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const tt = resolveLengths(t);\n    const seg = hypotenuseSegments(t);\n    const h = height(t);\n    const b = { x: origin.x, y: origin.y };\n    const a = { x: origin.x - tt.hypotenuse, y: origin.y };\n    const c = { x: origin.x - seg[0], y: origin.y - h };\n    return { a, b, c };\n};\n/**\n * Returns a positioned triangle from a point for C.\n *\n * ```\n *             c (90 deg)\n *             .\n *          .   .\n *       .       .\n *    .           .\n * a .............. b\n * ```\n *\n *\n * ```js\n * // Triangle pointing up to 0,0 with sides of 15\n * Triangles.Right.fromC({ adjacent: 15, opposite:15 }, { x: 0, y: 0 });\n * ```\n * @param t\n * @param origin\n * @returns\n */\nexport const fromC = (t, origin) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const seg = hypotenuseSegments(t);\n    const h = height(t);\n    const c = { x: origin.x, y: origin.y };\n    const a = { x: origin.x - seg[1], y: origin.y + h };\n    const b = { x: origin.x + seg[0], y: origin.y + h };\n    return { a, b, c };\n};\n/**\n * Returns a right triangle with all lengths defined.\n * At least two lengths must already exist\n * @param t\n * @returns\n */\nexport const resolveLengths = (t) => {\n    const a = t.adjacent;\n    const o = t.opposite;\n    const h = t.hypotenuse;\n    if (a !== undefined && o !== undefined) {\n        return {\n            ...t,\n            adjacent: a,\n            opposite: o,\n            hypotenuse: Math.hypot(a, o),\n        };\n    }\n    else if (a && h) {\n        return {\n            ...t,\n            adjacent: a,\n            hypotenuse: h,\n            opposite: h * h - a * a,\n        };\n    }\n    else if (o && h) {\n        return {\n            ...t,\n            hypotenuse: h,\n            opposite: o,\n            adjacent: h * h - o * o,\n        };\n    }\n    else if (t.opposite && t.hypotenuse && t.adjacent) {\n        return t;\n    }\n    throw new Error(`Missing at least two edges`);\n};\n/**\n * Height of right-triangle\n * @param t\n * @returns\n */\nexport const height = (t) => {\n    const tt = resolveLengths(t);\n    const p = (tt.opposite * tt.opposite) / tt.hypotenuse;\n    const q = (tt.adjacent * tt.adjacent) / tt.hypotenuse;\n    return Math.sqrt(p * q);\n};\n/**\n * Returns the lengths of the hypotenuse split into p and q segments.\n * In other words, if one makes a line from the right-angle vertex down to hypotenuse.\n *\n * [See here](https://rechneronline.de/pi/right-triangle.php)\n * @param t\n * @returns\n */\nexport const hypotenuseSegments = (t) => {\n    const tt = resolveLengths(t);\n    const p = (tt.opposite * tt.opposite) / tt.hypotenuse;\n    const q = (tt.adjacent * tt.adjacent) / tt.hypotenuse;\n    return [p, q];\n};\nexport const perimeter = (t) => {\n    const tt = resolveLengths(t);\n    return tt.adjacent + tt.hypotenuse + tt.opposite;\n};\nexport const area = (t) => {\n    const tt = resolveLengths(t);\n    return (tt.opposite * tt.adjacent) / 2;\n};\n/**\n * Angle (in radians) between hypotenuse and adjacent edge\n * @param t\n * @returns\n */\nexport const angleAtPointA = (t) => {\n    const tt = resolveLengths(t);\n    return Math.acos((tt.adjacent * tt.adjacent +\n        tt.hypotenuse * tt.hypotenuse -\n        tt.opposite * tt.opposite) /\n        (2 * tt.adjacent * tt.hypotenuse));\n};\n/**\n * Angle (in radians) between opposite edge and hypotenuse\n * @param t\n * @returns\n */\nexport const angleAtPointB = (t) => {\n    const tt = resolveLengths(t);\n    return Math.acos((tt.opposite * tt.opposite +\n        tt.hypotenuse * tt.hypotenuse -\n        tt.adjacent * tt.adjacent) /\n        (2 * tt.opposite * tt.hypotenuse));\n};\n/**\n * Returns the median line lengths a, b and c in an array.\n *\n * The median lines are the lines from each vertex to the center.\n *\n * @param t\n * @returns\n */\nexport const medians = (t) => {\n    const tt = resolveLengths(t);\n    const b = tt.adjacent * tt.adjacent;\n    const c = tt.hypotenuse * tt.hypotenuse;\n    const a = tt.opposite * tt.opposite;\n    return [\n        Math.sqrt(2 * (b + c) - a) / 2,\n        Math.sqrt(2 * (c + a) - b) / 2,\n        Math.sqrt(2 * (a + b) - c) / 2,\n    ];\n};\n/**\n * The circle which passes through the points of the triangle\n * @param t\n * @returns\n */\nexport const circumcircle = (t) => {\n    const tt = resolveLengths(t);\n    return { radius: tt.hypotenuse / 2 };\n};\n/**\n * Circle enclosed by triangle\n * @param t\n * @returns\n */\nexport const incircle = (t) => {\n    const tt = resolveLengths(t);\n    return {\n        radius: (tt.adjacent + tt.opposite - tt.hypotenuse) / 2,\n    };\n};\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param adjacent\n * @returns\n */\nexport const oppositeFromAdjacent = (angleRad, adjacent) => Math.tan(angleRad) * adjacent;\n/**\n * Returns the opposite length of a right-angle triangle,\n * marked here\n *\n * ```\n *    .  <\n *   ..  <\n * ....  <\n * ```\n *\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRad\n * @param hypotenuse\n * @returns\n */\nexport const oppositeFromHypotenuse = (angleRad, hypotenuse) => Math.sin(angleRad) * hypotenuse;\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param hypotenuse\n * @returns\n */\nexport const adjacentFromHypotenuse = (angleRadian, hypotenuse) => Math.cos(angleRadian) * hypotenuse;\n/**\n * Returns the adjecent length of a right-angle triangle,\n * marked here\n * ```\n *    .\n *   ..  o\n * ....\n * ^^^^\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport const adjacentFromOpposite = (angleRadian, opposite) => opposite / Math.tan(angleRadian);\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param opposite\n * @returns\n */\nexport const hypotenuseFromOpposite = (angleRadian, opposite) => opposite / Math.sin(angleRadian);\n/**\n * Returns the hypotenuse length of a right-angle triangle,\n * marked here\n * ```\n *      .\n * >   ..\n * >  ...\n * > ....  opp\n *  .....\n *   adj\n * ```\n * This is just:\n * ```js\n * opposite = Math.tan(angle) * adjacent\n * ```\n * @param angleRadian\n * @param adjacent\n * @returns\n */\nexport const hypotenuseFromAdjacent = (angleRadian, adjacent) => adjacent / Math.cos(angleRadian);\n","export const baseAngle = (t) => Math.acos(t.base / (2 * t.legs));\nexport const apexAngle = (t) => {\n    const aa = t.legs * t.legs;\n    const cc = t.base * t.base;\n    return Math.acos((2 * aa - cc) / (2 * aa));\n};\nexport const height = (t) => {\n    const aa = t.legs * t.legs;\n    const cc = t.base * t.base;\n    return Math.sqrt((4 * aa - cc) / 4);\n};\nexport const legHeights = (t) => {\n    const b = baseAngle(t);\n    return t.base * Math.sin(b);\n};\nexport const perimeter = (t) => 2 * t.legs + t.base;\nexport const area = (t) => {\n    const h = height(t);\n    return (h * t.base) / 2;\n};\nexport const circumcircle = (t) => {\n    const h = height(t);\n    const hh = h * h;\n    const cc = t.base * t.base;\n    return { radius: (4 * hh + cc) / (8 * h) };\n};\nexport const incircle = (t) => {\n    const h = height(t);\n    return { radius: (t.base * h) / (2 * t.legs + t.base) };\n};\nexport const medians = (t) => {\n    const aa = t.legs * t.legs;\n    const cc = t.base * t.base;\n    const medianAB = Math.sqrt(aa + 2 * cc) / 2;\n    const medianC = Math.sqrt(4 * aa - cc) / 2;\n    return [medianAB, medianAB, medianC];\n};\n/**\n * Returns a positioned `Triangle` based on a center origin.\n * Center is determined by the intesecting of the medians.\n *\n * See: https://rechneronline.de/pi/isosceles-triangle.php\n * @param t\n * @param origin\n * @returns\n */\nexport const fromCenter = (t, origin) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const h = height(t);\n    const incircleR = incircle(t).radius;\n    const verticalToApex = h - incircleR;\n    const a = { x: origin.x - t.base / 2, y: origin.y + incircleR };\n    const b = { x: origin.x + t.base / 2, y: origin.y + incircleR };\n    const c = { x: origin.x, y: origin.y - verticalToApex };\n    return { a, b, c };\n};\nexport const fromA = (t, origin) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const h = height(t);\n    const a = { x: origin.x, y: origin.y };\n    const b = { x: origin.x + t.base, y: origin.y };\n    const c = { x: origin.x + t.base / 2, y: origin.y - h };\n    return { a, b, c };\n};\nexport const fromB = (t, origin) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const h = height(t);\n    const b = { x: origin.x, y: origin.y };\n    const a = { x: origin.x - t.base, y: origin.y };\n    const c = { x: origin.x - t.base / 2, y: origin.y - h };\n    return { a, b, c };\n};\nexport const fromC = (t, origin) => {\n    if (!origin)\n        origin = Object.freeze({ x: 0, y: 0 });\n    const h = height(t);\n    const c = { x: origin.x, y: origin.y };\n    const a = { x: origin.x - t.base / 2, y: origin.y + h };\n    const b = { x: origin.x + t.base / 2, y: origin.y + h };\n    return { a, b, c };\n};\n","export * from './angles.js';\nexport * from './area.js';\nexport * from './barycentric.js';\nexport * from './bbox.js';\nexport * from './centroid.js';\nexport * from './corners.js';\nexport * from './create.js';\nexport * from './edges.js';\nexport * from './from.js';\nexport * from './kinds.js';\nexport * from './inner-circle.js';\nexport * from './guard.js';\nexport * from './outer-circle.js';\nexport * from './perimeter.js';\nexport * from './rotate.js';\n/**\n * Functions for working with equilateral triangles, defined by length\n */\nexport * as Equilateral from './equilateral.js';\n/**\n * Functions for working with right-angled triangles, defined by two of three edges\n */\nexport * as Right from './right.js';\nexport * as Isosceles from './isosceles.js';\n/**\n* Triangle.\n*\n* Helpers for creating:\n*  - {@link Triangles.fromFlatArray}: Create from [x1, y1, x2, y2, x3, y3]\n*  - {@link Triangles.fromPoints}: Create from three `{x,y}` sets\n*  - {@link Triangles.fromRadius}: Equilateral triangle of a given radius and center\n*/\n","export * from '@ixfx/geometry';"],"mappings":"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"}