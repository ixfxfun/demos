{"version":3,"file":"records-ButNOjS_.js","names":[],"sources":["../packages/core/dist/src/records/map-object-keys.js","../packages/core/dist/src/records/compare.js","../packages/core/dist/src/records/clone-from-fields.js","../packages/core/dist/src/records/map-object.js","../packages/core/dist/src/records/traverse.js","../packages/core/dist/src/records/merge.js","../packages/core/dist/src/records/keys-to-numbers.js","../packages/core/dist/src/records/index.js"],"sourcesContent":["/**\n * Maps the keys of an object, returning a transformed object.\n * ```js\n * const input = {\n *  hello: `there`,\n *  chap: `chappie`\n * }\n *\n * mapObjectKeys(input, key => key.toUppercase());\n *\n * // Yields: { HELLO: `there`, CHAP: `chappie` }\n * ```\n * @param object\n * @param mapFunction\n * @returns\n */\nexport const mapObjectKeys = (object, mapFunction) => {\n    const destinationObject = {};\n    for (const entries of Object.entries(object)) {\n        const key = mapFunction(entries[0]);\n        destinationObject[key] = entries[1];\n    }\n    return destinationObject;\n};\n","import { compareIterableValuesShallow, isEqualDefault } from '@ixfx/core';\nimport { mapObjectKeys } from './map-object-keys.js';\n/**\n * Compares the keys of two objects, returning a set of those in\n * common, and those in either A or B exclusively.\n * ```js\n * const a = { colour: `red`, intensity: 5 };\n * const b = { colour: `pink`, size: 10 };\n * const c = compareObjectKeys(a, b);\n * // c.shared = [ `colour` ]\n * // c.a = [ `intensity` ]\n * // c.b = [ `size`  ]\n * ```\n * @param a\n * @param b\n * @returns\n */\nexport const compareObjectKeys = (a, b) => {\n    const c = compareIterableValuesShallow(Object.keys(a), Object.keys(b));\n    return c;\n};\n/**\n * Returns the changed fields from A -> B. It's assumed that A and B have the same shape.\n * ie. returns an object that only consists of fields which have changed in B compared to A.\n *\n * ```js\n * const a = { msg: `hi`, v: 10 };\n *\n * changedObjectDataFields(a, { msg: `hi`,   v: 10 }); // {}\n * changedObjectDataFields(a, { msg: `hi!!`, v: 10 }); // { msg: `hi!!` }\n * changedObjectDataFields(a, { msg: `hi!!` });       // { msg: `hi!!`, v: undefined }\n * ```\n *\n * If B has additional or removed fields, this is considered an error.\n *\n * If a field is an array, the whole array is returned, rather than a diff.\n * @param a\n * @param b\n */\nexport const changedObjectDataFields = (a, b) => {\n    const r = compareObjectData(a, b, true);\n    if (Object.entries(r.added).length > 0)\n        throw new Error(`Shape of data has changed`);\n    if (Object.entries(r.removed).length > 0)\n        throw new Error(`Shape of data has changed`);\n    const output = compareResultToObject(r, b);\n    return output;\n};\nconst compareResultToObject = (r, b) => {\n    const output = {};\n    if (r.isArray) {\n        return b;\n    }\n    for (const entry of Object.entries(r.changed)) {\n        output[entry[0]] = entry[1];\n    }\n    for (const entry of Object.entries(r.added)) {\n        output[entry[0]] = entry[1];\n    }\n    for (const childEntry of Object.entries(r.children)) {\n        const childResult = childEntry[1];\n        if (childResult.hasChanged) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-argument\n            output[childEntry[0]] = compareResultToObject(childResult, b[childEntry[0]]);\n        }\n    }\n    return output;\n};\n/**\n * Produces a {@link CompareChangeSet} between two arrays.\n *\n * @param a Earlier array to compare\n * @param b Later array to compare\n * @param eq Equality comparison for values\n * @returns Change set.\n */\nexport const compareArrays = (a, b, eq = (isEqualDefault)) => {\n    if (!Array.isArray(a))\n        throw new Error(`Param 'a' is not an array`);\n    if (!Array.isArray(b))\n        throw new Error(`Param 'b' is not an array`);\n    const c = compareObjectData(a, b, false, eq);\n    if (!c.isArray)\n        throw new Error(`Change set does not have arrays as parameters`);\n    const convert = (key) => {\n        if (key.startsWith(`_`)) {\n            return Number.parseInt(key.slice(1));\n        }\n        else\n            throw new Error(`Unexpected key '${key}'`);\n    };\n    const cc = {\n        ...c,\n        added: mapObjectKeys(c.added, convert),\n        changed: mapObjectKeys(c.changed, convert),\n        removed: c.removed.map(v => convert(v)),\n        summary: c.summary.map(value => {\n            return [value[0], convert(value[1]), value[2]];\n        })\n    };\n    return cc;\n};\n/**\n * Compares A to B. Assumes they are simple objects, essentially key-value pairs, where the\n * values are primitive values or other simple objects. It also works with arrays.\n *\n * Uses === equality semantics by default.\n * @param a\n * @param b\n */\nexport const compareObjectData = (a, b, assumeSameShape = false, eq = isEqualDefault) => {\n    a ??= {};\n    b ??= {};\n    const entriesA = Object.entries(a);\n    const entriesB = Object.entries(b);\n    const scannedKeys = new Set();\n    const changed = {};\n    const added = {};\n    const children = {};\n    const removed = [];\n    const isArray = Array.isArray(a);\n    const summary = new Array();\n    let hasChanged = false;\n    // Look for existing entries of A that are modified\n    for (const entry of entriesA) {\n        const outputKey = isArray ? `_${entry[0]}` : entry[0];\n        const aValue = entry[1];\n        const bValue = b[entry[0]];\n        scannedKeys.add(entry[0]);\n        if (bValue === undefined) {\n            // B does not have a key from A\n            hasChanged = true;\n            if (assumeSameShape && !isArray) {\n                // If we're assuming it's the same shape, then _undefined_ is actually the value\n                changed[outputKey] = bValue;\n                summary.push([`mutate`, outputKey, bValue]);\n            }\n            else {\n                // Key removed\n                removed.push(outputKey);\n                summary.push([`del`, outputKey, aValue]);\n            }\n            continue;\n        }\n        if (typeof aValue === `object`) {\n            const r = compareObjectData(aValue, bValue, assumeSameShape, eq);\n            if (r.hasChanged)\n                hasChanged = true;\n            children[outputKey] = r;\n            const childSummary = r.summary.map(sum => { return [sum[0], outputKey + `.` + sum[1], sum[2]]; });\n            summary.push(...childSummary);\n        }\n        else {\n            if (!eq(aValue, bValue)) {\n                changed[outputKey] = bValue;\n                hasChanged = true;\n                summary.push([`mutate`, outputKey, bValue]);\n            }\n        }\n    }\n    // Look for entries in B that weren't in A\n    if (!assumeSameShape || isArray) {\n        for (const entry of entriesB) {\n            const key = isArray ? `_${entry[0]}` : entry[0];\n            if (scannedKeys.has(entry[0]))\n                continue;\n            added[key] = entry[1];\n            hasChanged = true;\n            summary.push([`add`, key, entry[1]]);\n        }\n    }\n    return {\n        changed, added, removed, children, hasChanged, isArray, summary\n    };\n};\n","import { testPlainObjectOrPrimitive } from \"@ixfx/guards\";\nexport const cloneFromFields = (source) => {\n    const entries = [];\n    for (const field in source) {\n        const value = (source)[field];\n        if (testPlainObjectOrPrimitive(value)) {\n            entries.push([field, value]);\n        }\n    }\n    return Object.fromEntries(entries);\n};\n","/**\n * Maps the top-level properties of an object through a map function.\n * That is, run each of the values of an object through a function,\n * setting the result onto the same key structure as original.\n *\n * It is NOT recursive.\n *\n * The mapping function gets a single args object, consisting of `{ value, field, index }`,\n * where 'value' is the value of the field, 'field' the name, and 'index' a numeric count.\n * @example Double the value of all fields\n * ```js\n * const rect = { width: 100, height: 250 };\n * const doubled = mapObjectShallow(rect, args => {\n *  return args.value*2;\n * });\n * // Yields: { width: 200, height: 500 }\n * ```\n *\n * Since the map callback gets the name of the property, it can do context-dependent things.\n * ```js\n * const rect = { width: 100, height: 250, colour: 'red' }\n * const doubled = mapObjectShallow(rect, args => {\n *  if (args.field === 'width') return args.value*3;\n *  else if (typeof args.value === 'number') return args.value*2;\n *  return args.value;\n * });\n * // Yields: { width: 300, height: 500, colour: 'red' }\n * ```\n * In addition to bulk processing, it allows remapping of property types.\n *\n * In terms of type-safety, the mapped properties are assumed to have the\n * same type.\n *\n * ```js\n * const o = {\n *  x: 10,\n *  y: 20,\n *  width: 200,\n *  height: 200\n * }\n *\n * // Make each property use an averager instead\n * const oAvg = mapObjectShallow(o, args => {\n *  return movingAverage(10);\n * });\n *\n * // Instead of { x:number, y:number... }, we now have { x:movingAverage(), y:movingAverage()... }\n * // Add a value to the averager\n * oAvg.x.add(20);\n * ```\n */\nexport const mapObjectShallow = (object, mapFunction) => {\n    const entries = Object.entries(object);\n    const mapped = entries.map(([sourceField, sourceFieldValue], index) => [\n        sourceField,\n        mapFunction({ value: sourceFieldValue, field: sourceField, index, path: sourceField }),\n    ]);\n    return Object.fromEntries(mapped);\n};\n/**\n * Maps the contents of `data` using `mapper` as a structured set of map functions.\n * ```js\n * const a = {\n *  person: {\n *    size: 20\n *  }\n *  hello: `there`\n * }\n * mapObjectByObject(a, {\n *  person: {\n *    size: (value, context) => {\n *      return value * 2\n *    }\n *  }\n * });\n * // Yields: { person: { size: 40 }, hello: `there` }\n * ```\n * @param data\n * @param mapper\n * @returns\n */\nexport function mapObjectByObject(data, mapper) {\n    const entries = Object.entries(data);\n    for (const entry of entries) {\n        if (entry[0] in mapper) {\n            const m = mapper[entry[0]];\n            entry[1] = (typeof m === `object`) ?\n                mapObjectByObject(entry[1], m) :\n                m(entry[1], data);\n        }\n    }\n    return Object.fromEntries(entries);\n}\n","import { resultThrow, nullUndefTest } from '@ixfx/guards';\nimport { isPrimitive } from '../is-primitive.js';\n/**\n * Helper function to get a 'friendly' string representation of an array of {@link RecordEntry}.\n * @param entries\n * @returns\n */\nexport function prettyPrintEntries(entries) {\n    if (entries.length === 0)\n        return `(empty)`;\n    let t = ``;\n    for (const [index, entry] of entries.entries()) {\n        t += `  `.repeat(index);\n        t += entry.name + ` = ` + JSON.stringify(entry.nodeValue) + `\\n`;\n    }\n    return t;\n}\n/**\n * Returns a human-friendly debug string for a tree-like structure\n * ```js\n * console.log(Trees.prettyPrint(obj));\n * ```\n * @param indent\n * @param node\n * @param options\n * @returns\n */\nexport const recordEntryPrettyPrint = (node, indent = 0, options = {}) => {\n    resultThrow(nullUndefTest(node, `node`));\n    const defaultName = options.name ?? `node`;\n    const entry = getNamedRecordEntry(node, defaultName);\n    const t = `${`  `.repeat(indent)} + name: ${entry.name} value: ${JSON.stringify(entry.nodeValue)}`;\n    const childrenAsArray = [...recordChildren(node, options)];\n    return childrenAsArray.length > 0 ? (t +\n        `\\n` +\n        childrenAsArray.map((d) => recordEntryPrettyPrint(d.nodeValue, indent + 1, { ...options, name: d.name })).join(`\\n`)) : t;\n};\n/**\n * Returns the direct children of a tree-like object as a pairing\n * of node name and value. Supports basic objects, Maps and arrays.\n *\n * Sub-children are included as an object blob.\n *\n * @example Simple object\n * ```js\n * const o = {\n *  colour: {\n *    r: 0.5, g: 0.5, b: 0.5\n *  }\n * };\n *\n * const children = [ ...Trees.children(o) ];\n * // Children:\n * // [\n * //  { name: \"colour\", value: { b: 0.5, g: 0.5, r: 0.5 } }\n * // ]\n * const subChildren = [ ...Trees.children(o.colour) ];\n * // [ { name: \"r\", value: 0.5 }, { name: \"g\", value: 0.5 }, { name: \"b\", value: 0.5 } ]\n * ```\n *\n * Arrays are assigned a name based on index.\n * @example Arrays\n * ```js\n * const colours = [ { r: 1, g: 0, b: 0 }, { r: 0, g: 1, b: 0 }, { r: 0, g: 0, b: 1 } ];\n * // Children:\n * // [\n * //  { name: \"array[0]\", value: {r:1,g:0,b:0} },\n * //  { name: \"array[1]\", value: {r:0,g:1,b:0} },\n * //  { name: \"array[2]\", value: {r:0,g:0,b:1} },\n * // ]\n * ```\n *\n * Pass in `options.name` (eg 'colours') to have names generated as 'colours[0]', etc.\n * Options can also be used to filter children. By default all direct children are returned.\n * @param node\n * @param options\n */\nexport function* recordChildren(node, options = {}) {\n    resultThrow(nullUndefTest(node, `node`));\n    const filter = options.filter ?? `none`;\n    const filterByValue = (v) => {\n        if (filter === `none`)\n            return [true, isPrimitive(v)];\n        else if (filter === `leaves` && isPrimitive(v))\n            return [true, true];\n        else if (filter === `branches` && !isPrimitive(v))\n            return [true, false];\n        return [false, isPrimitive(v)];\n    };\n    if (Array.isArray(node)) {\n        //if (options.name === undefined) defaultName = `array`;\n        for (const [index, element] of node.entries()) {\n            const f = filterByValue(element);\n            if (f[0]) {\n                yield { name: index.toString(), sourceValue: element, nodeValue: f[1] ? element : undefined };\n                //yield { name: defaultName + `[` + index.toString() + `]`, sourceValue: element, nodeValue: f[ 1 ] ? element : undefined };\n            }\n        }\n    }\n    else if (typeof node === `object`) {\n        const entriesIter = (`entries` in node) ? node.entries() : Object.entries(node);\n        for (const [name, value] of entriesIter) {\n            //onsole.log(`children name: ${ name } type: ${ typeof value } isPrim: ${ isPrimitive(value) } filter: ${ filter }`);\n            const f = filterByValue(value);\n            if (f[0]) {\n                yield { name: name, sourceValue: value, nodeValue: f[1] ? value : undefined };\n            }\n        }\n    }\n}\nexport function* recordEntriesDepthFirst(node, options = {}, ancestors = []) {\n    for (const c of recordChildren(node, options)) {\n        //onsole.log(`depthFirst name: ${ c.name } nodeValue: ${ toStringAbbreviate(c.nodeValue) }`)\n        yield { ...c, ancestors: [...ancestors] };\n        yield* recordEntriesDepthFirst(c.sourceValue, options, [...ancestors, c.name]);\n    }\n}\n/**\n * Finds a given direct child by name\n * @param name\n * @param node\n * @returns\n */\nfunction recordEntryChildByName(name, node) {\n    for (const d of recordChildren(node)) {\n        if (d.name === name)\n            return d;\n    }\n}\n/**\n * Returns the closest matching entry, tracing `path` in an array, Map or simple object.\n * Returns an entry with _undefined_ value at the point where tracing stopped.\n * Use {@link traceRecordEntryByPath} to step through all the segments.\n *\n * ```js\n  * const people = {\n    *  jane: {\n *   address: {\n *    postcode: 1000,\n    *    street: 'West St',\n    *    city: 'Blahville'\n *   },\n * colour: 'red'\n  *  }\n * }\n * Trees.getByPath('jane.address.postcode', people); // '.' default separator\n * // ['postcode', 1000]\n * Trees.getByPath('jane.address.country.state', people);\n * // ['country', undefined] - since full path could not be resolved.\n * ```\n * @param path Path, eg `jane.address.postcode`\n * @param node Node to look within\n * @param options Options for parsing path. By default '.' is used as a separator\n * @returns\n */\nexport function getRecordEntryByPath(path, node, options = {}) {\n    const paths = [...traceRecordEntryByPath(path, node, options)];\n    if (paths.length === 0)\n        throw new Error(`Could not trace path: ${path} `);\n    return paths.at(-1);\n}\n/**\n * Enumerates over children of `node` towards the node named in `path`.\n * This is useful if you want to get the interim steps to the target node.\n *\n * Use {@link getRecordEntryByPath} if you don't care about interim steps.\n *\n * ```js\n * const people = {\n *  jane: {\n *   address: {\n *    postcode: 1000,\n *    street: 'West St',\n *    city: 'Blahville'\n *   },\n * colour: 'red'\n *  }\n * }\n * for (const p of Trees.traceByPath('jane.address.street', people)) {\n * // { name: \"jane\", value: { address: { postcode: 1000,street: 'West St', city: 'Blahville' }, colour: 'red'} },\n * // { name: \"address\", value: { postcode: 1000, street: 'West St', city: 'Blahville' } },\n * // { name: \"street\", value: \"West St\" } }\n * }\n * ```\n *\n * Results stop when the path can't be followed any further.\n * The last entry will have a name of the last sought path segment, and _undefined_ as its value.\n *\n * @param path Path to traverse\n * @param node Starting node\n * @param options Options for path traversal logic\n * @returns\n */\nexport function* traceRecordEntryByPath(path, node, options = {}) {\n    resultThrow(nullUndefTest(path, `path`), nullUndefTest(node, `node`));\n    const separator = options.separator ?? `.`;\n    const pathSplit = path.split(separator);\n    const ancestors = [];\n    for (const p of pathSplit) {\n        const entry = recordEntryChildByName(p, node);\n        if (!entry) {\n            yield { name: p, sourceValue: undefined, nodeValue: undefined, ancestors };\n            return;\n        }\n        node = entry.sourceValue;\n        yield { ...entry, ancestors: [...ancestors] };\n        ancestors.push(p);\n    }\n}\n/**\n * Generates a name for a node.\n * Uses the 'name' property if it exists, otherwise uses `defaultName`\n * @param node\n * @param defaultName\n * @returns\n */\nfunction getNamedRecordEntry(node, defaultName = ``) {\n    if (`name` in node && `nodeValue` in node && `sourceValue` in node)\n        return node;\n    if (`name` in node) {\n        return { name: node.name, nodeValue: node, sourceValue: node };\n    }\n    return { name: defaultName, nodeValue: node, sourceValue: node };\n}\n","// Source: https://stackoverflow.com/questions/49682569/typescript-merge-object-types\n// jcalz 2021-09-09\nexport function mergeObjects(...a) {\n    return Object.assign({}, ...a);\n}\n","/**\n * Returns a copy of `object` with integer numbers as keys instead of whatever it has.\n * ```js\n * keysToNumbers({ '1': true }); // Yields: { 1: true }\n * ```\n *\n * The `onInvalidKey` sets how to handle keys that cannot be converted to integers.\n * * 'throw' (default): throws an exception\n * * 'ignore': that key & value is ignored\n * * 'keep': uses the string key instead\n *\n *\n * ```js\n * keysToNumber({ hello: 'there' }, `ignore`); // Yields: {  }\n * keysToNumber({ hello: 'there' }, `throw`);  // Exception\n * keysToNumber({ hello: 'there' }, `keep`);   // Yields: { hello: 'there' }\n * ```\n *\n * Floating-point numbers will be converted to integer by rounding.\n * ```js\n * keysToNumbers({ '2.4': 'hello' }); // Yields: { 2: 'hello' }\n * ```\n * @param object\n * @param onInvalidKey\n * @returns\n */\nexport const keysToNumbers = (object, onInvalidKey = `throw`) => {\n    const returnObject = {};\n    for (const entry of Object.entries(object)) {\n        const asNumber = Number.parseInt(entry[0]);\n        if (Number.isNaN(asNumber)) {\n            switch (onInvalidKey) {\n                case `throw`: {\n                    throw new TypeError(`Cannot convert key '${entry[0]}' to an integer`);\n                }\n                case `ignore`: {\n                    continue;\n                }\n                case `keep`: {\n                    // eslint-disable-next-line @typescript-eslint/no-explicit-any, @typescript-eslint/no-unsafe-member-access\n                    returnObject[entry[0]] = entry[1];\n                    continue;\n                }\n                default: {\n                    throw new Error(`Param 'onInvalidKey' should be: 'throw', 'ignore' or 'keep'.`);\n                }\n            }\n        }\n        returnObject[asNumber] = entry[1];\n    }\n    return returnObject;\n};\n","export * from './compare.js';\nexport * from './clone-from-fields.js';\nexport * from './map-object.js';\nexport * from './map-object-keys.js';\nexport * from './traverse.js';\nexport * from './merge.js';\nexport * from './keys-to-numbers.js';\n"],"mappings":"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"}